function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self1 = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self1, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_apply_descriptor_set(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _class_extract_field_descriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _class_private_field_get(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
    return _class_apply_descriptor_get(receiver, descriptor);
}
function _class_private_field_init(obj, privateMap, value) {
    _check_private_redeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _class_private_field_set(receiver, privateMap, value) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
    _class_apply_descriptor_set(receiver, descriptor, value);
    return value;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _object_without_properties(source, excluded) {
    if (source == null) return {};
    var target = _object_without_properties_loose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _object_without_properties_loose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
var _fields, _inFormListFields, _defaultValues, _values, _errors, _events;
import { Button, Canvas, Form, Image as Image2, Input, ScrollView, Switch, Text, Textarea, View } from "./chunk-T47QXRPA.js";
import { require_react_dom } from "./chunk-46SKMPFG.js";
import { require_react } from "./chunk-ZEZLQ4G4.js";
import { Events, _extends, createSelectorQuery, getCurrentInstance, getCurrentPages, getEnv, getSystemInfo, getWindowInfo, nextTick, offWindowResize, onWindowResize, pageScrollTo, pxTransform } from "./chunk-XVM4PJ6V.js";
import { usePageScroll } from "./chunk-UA4GZOHK.js";
import { FormElement, capitalize, document$1, ensure, internalComponents, isBoolean, isFunction, isNumber, isObject, isString, isUndefined, noop, toCamelCase } from "./chunk-6QIIT3JC.js";
import { __commonJS, __toESM } from "./chunk-UG6XUGBP.js";
// node_modules/classnames/index.js
var require_classnames = __commonJS({
    "node_modules/classnames/index.js" (exports, module) {
        (function() {
            "use strict";
            var hasOwn = {}.hasOwnProperty;
            function classNames153() {
                var classes = "";
                for(var i = 0; i < arguments.length; i++){
                    var arg = arguments[i];
                    if (arg) {
                        classes = appendClass(classes, parseValue(arg));
                    }
                }
                return classes;
            }
            function parseValue(arg) {
                if (typeof arg === "string" || typeof arg === "number") {
                    return arg;
                }
                if (typeof arg !== "object") {
                    return "";
                }
                if (Array.isArray(arg)) {
                    return classNames153.apply(null, arg);
                }
                if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
                    return arg.toString();
                }
                var classes = "";
                for(var key in arg){
                    if (hasOwn.call(arg, key) && arg[key]) {
                        classes = appendClass(classes, key);
                    }
                }
                return classes;
            }
            function appendClass(value, newClass) {
                if (!newClass) {
                    return value;
                }
                if (value) {
                    return value + " " + newClass;
                }
                return value + newClass;
            }
            if (typeof module !== "undefined" && module.exports) {
                classNames153.default = classNames153;
                module.exports = classNames153;
            } else if (false) {
                (false)("classnames", [], function() {
                    return classNames153;
                });
            } else {
                window.classNames = classNames153;
            }
        })();
    }
});
// node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
    "node_modules/lodash/_baseHasIn.js" (exports, module) {
        function baseHasIn(object, key) {
            return object != null && key in Object(object);
        }
        module.exports = baseHasIn;
    }
});
// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
    "node_modules/lodash/isArray.js" (exports, module) {
        var isArray = Array.isArray;
        module.exports = isArray;
    }
});
// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
    "node_modules/lodash/_freeGlobal.js" (exports, module) {
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        module.exports = freeGlobal;
    }
});
// node_modules/lodash/_root.js
var require_root = __commonJS({
    "node_modules/lodash/_root.js" (exports, module) {
        var freeGlobal = require_freeGlobal();
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        module.exports = root;
    }
});
// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
    "node_modules/lodash/_Symbol.js" (exports, module) {
        var root = require_root();
        var Symbol2 = root.Symbol;
        module.exports = Symbol2;
    }
});
// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
    "node_modules/lodash/_getRawTag.js" (exports, module) {
        var Symbol2 = require_Symbol();
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var nativeObjectToString = objectProto.toString;
        var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
        function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
                value[symToStringTag] = void 0;
                var unmasked = true;
            } catch (e) {}
            var result = nativeObjectToString.call(value);
            if (unmasked) {
                if (isOwn) {
                    value[symToStringTag] = tag;
                } else {
                    delete value[symToStringTag];
                }
            }
            return result;
        }
        module.exports = getRawTag;
    }
});
// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
    "node_modules/lodash/_objectToString.js" (exports, module) {
        var objectProto = Object.prototype;
        var nativeObjectToString = objectProto.toString;
        function objectToString(value) {
            return nativeObjectToString.call(value);
        }
        module.exports = objectToString;
    }
});
// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
    "node_modules/lodash/_baseGetTag.js" (exports, module) {
        var Symbol2 = require_Symbol();
        var getRawTag = require_getRawTag();
        var objectToString = require_objectToString();
        var nullTag = "[object Null]";
        var undefinedTag = "[object Undefined]";
        var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
        function baseGetTag(value) {
            if (value == null) {
                return value === void 0 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
        }
        module.exports = baseGetTag;
    }
});
// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
    "node_modules/lodash/isObjectLike.js" (exports, module) {
        function isObjectLike(value) {
            return value != null && typeof value == "object";
        }
        module.exports = isObjectLike;
    }
});
// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
    "node_modules/lodash/isSymbol.js" (exports, module) {
        var baseGetTag = require_baseGetTag();
        var isObjectLike = require_isObjectLike();
        var symbolTag = "[object Symbol]";
        function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        module.exports = isSymbol;
    }
});
// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
    "node_modules/lodash/_isKey.js" (exports, module) {
        var isArray = require_isArray();
        var isSymbol = require_isSymbol();
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
        var reIsPlainProp = /^\w*$/;
        function isKey(value, object) {
            if (isArray(value)) {
                return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
                return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
        }
        module.exports = isKey;
    }
});
// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
    "node_modules/lodash/isObject.js" (exports, module) {
        function isObject2(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
        }
        module.exports = isObject2;
    }
});
// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
    "node_modules/lodash/isFunction.js" (exports, module) {
        var baseGetTag = require_baseGetTag();
        var isObject2 = require_isObject();
        var asyncTag = "[object AsyncFunction]";
        var funcTag = "[object Function]";
        var genTag = "[object GeneratorFunction]";
        var proxyTag = "[object Proxy]";
        function isFunction5(value) {
            if (!isObject2(value)) {
                return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        module.exports = isFunction5;
    }
});
// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
    "node_modules/lodash/_coreJsData.js" (exports, module) {
        var root = require_root();
        var coreJsData = root["__core-js_shared__"];
        module.exports = coreJsData;
    }
});
// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
    "node_modules/lodash/_isMasked.js" (exports, module) {
        var coreJsData = require_coreJsData();
        var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
        }();
        function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
        }
        module.exports = isMasked;
    }
});
// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
    "node_modules/lodash/_toSource.js" (exports, module) {
        var funcProto = Function.prototype;
        var funcToString = funcProto.toString;
        function toSource(func) {
            if (func != null) {
                try {
                    return funcToString.call(func);
                } catch (e) {}
                try {
                    return func + "";
                } catch (e) {}
            }
            return "";
        }
        module.exports = toSource;
    }
});
// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
    "node_modules/lodash/_baseIsNative.js" (exports, module) {
        var isFunction5 = require_isFunction();
        var isMasked = require_isMasked();
        var isObject2 = require_isObject();
        var toSource = require_toSource();
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var funcProto = Function.prototype;
        var objectProto = Object.prototype;
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        function baseIsNative(value) {
            if (!isObject2(value) || isMasked(value)) {
                return false;
            }
            var pattern = isFunction5(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
        }
        module.exports = baseIsNative;
    }
});
// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
    "node_modules/lodash/_getValue.js" (exports, module) {
        function getValue(object, key) {
            return object == null ? void 0 : object[key];
        }
        module.exports = getValue;
    }
});
// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
    "node_modules/lodash/_getNative.js" (exports, module) {
        var baseIsNative = require_baseIsNative();
        var getValue = require_getValue();
        function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : void 0;
        }
        module.exports = getNative;
    }
});
// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
    "node_modules/lodash/_nativeCreate.js" (exports, module) {
        var getNative = require_getNative();
        var nativeCreate = getNative(Object, "create");
        module.exports = nativeCreate;
    }
});
// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
    "node_modules/lodash/_hashClear.js" (exports, module) {
        var nativeCreate = require_nativeCreate();
        function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
        }
        module.exports = hashClear;
    }
});
// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
    "node_modules/lodash/_hashDelete.js" (exports, module) {
        function hashDelete(key) {
            var result = this.has(key) && delete this.__data__[key];
            this.size -= result ? 1 : 0;
            return result;
        }
        module.exports = hashDelete;
    }
});
// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
    "node_modules/lodash/_hashGet.js" (exports, module) {
        var nativeCreate = require_nativeCreate();
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
                var result = data[key];
                return result === HASH_UNDEFINED ? void 0 : result;
            }
            return hasOwnProperty.call(data, key) ? data[key] : void 0;
        }
        module.exports = hashGet;
    }
});
// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
    "node_modules/lodash/_hashHas.js" (exports, module) {
        var nativeCreate = require_nativeCreate();
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
        }
        module.exports = hashHas;
    }
});
// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
    "node_modules/lodash/_hashSet.js" (exports, module) {
        var nativeCreate = require_nativeCreate();
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
            return this;
        }
        module.exports = hashSet;
    }
});
// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
    "node_modules/lodash/_Hash.js" (exports, module) {
        var hashClear = require_hashClear();
        var hashDelete = require_hashDelete();
        var hashGet = require_hashGet();
        var hashHas = require_hashHas();
        var hashSet = require_hashSet();
        function Hash(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while(++index < length){
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        module.exports = Hash;
    }
});
// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
    "node_modules/lodash/_listCacheClear.js" (exports, module) {
        function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
        }
        module.exports = listCacheClear;
    }
});
// node_modules/lodash/eq.js
var require_eq = __commonJS({
    "node_modules/lodash/eq.js" (exports, module) {
        function eq(value, other) {
            return value === other || value !== value && other !== other;
        }
        module.exports = eq;
    }
});
// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
    "node_modules/lodash/_assocIndexOf.js" (exports, module) {
        var eq = require_eq();
        function assocIndexOf(array, key) {
            var length = array.length;
            while(length--){
                if (eq(array[length][0], key)) {
                    return length;
                }
            }
            return -1;
        }
        module.exports = assocIndexOf;
    }
});
// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
    "node_modules/lodash/_listCacheDelete.js" (exports, module) {
        var assocIndexOf = require_assocIndexOf();
        var arrayProto = Array.prototype;
        var splice = arrayProto.splice;
        function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
                return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
                data.pop();
            } else {
                splice.call(data, index, 1);
            }
            --this.size;
            return true;
        }
        module.exports = listCacheDelete;
    }
});
// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
    "node_modules/lodash/_listCacheGet.js" (exports, module) {
        var assocIndexOf = require_assocIndexOf();
        function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? void 0 : data[index][1];
        }
        module.exports = listCacheGet;
    }
});
// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
    "node_modules/lodash/_listCacheHas.js" (exports, module) {
        var assocIndexOf = require_assocIndexOf();
        function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
        }
        module.exports = listCacheHas;
    }
});
// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
    "node_modules/lodash/_listCacheSet.js" (exports, module) {
        var assocIndexOf = require_assocIndexOf();
        function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
                ++this.size;
                data.push([
                    key,
                    value
                ]);
            } else {
                data[index][1] = value;
            }
            return this;
        }
        module.exports = listCacheSet;
    }
});
// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
    "node_modules/lodash/_ListCache.js" (exports, module) {
        var listCacheClear = require_listCacheClear();
        var listCacheDelete = require_listCacheDelete();
        var listCacheGet = require_listCacheGet();
        var listCacheHas = require_listCacheHas();
        var listCacheSet = require_listCacheSet();
        function ListCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while(++index < length){
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        module.exports = ListCache;
    }
});
// node_modules/lodash/_Map.js
var require_Map = __commonJS({
    "node_modules/lodash/_Map.js" (exports, module) {
        var getNative = require_getNative();
        var root = require_root();
        var Map2 = getNative(root, "Map");
        module.exports = Map2;
    }
});
// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
    "node_modules/lodash/_mapCacheClear.js" (exports, module) {
        var Hash = require_Hash();
        var ListCache = require_ListCache();
        var Map2 = require_Map();
        function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
                "hash": new Hash(),
                "map": new (Map2 || ListCache)(),
                "string": new Hash()
            };
        }
        module.exports = mapCacheClear;
    }
});
// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
    "node_modules/lodash/_isKeyable.js" (exports, module) {
        function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        module.exports = isKeyable;
    }
});
// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
    "node_modules/lodash/_getMapData.js" (exports, module) {
        var isKeyable = require_isKeyable();
        function getMapData(map2, key) {
            var data = map2.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        module.exports = getMapData;
    }
});
// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
    "node_modules/lodash/_mapCacheDelete.js" (exports, module) {
        var getMapData = require_getMapData();
        function mapCacheDelete(key) {
            var result = getMapData(this, key)["delete"](key);
            this.size -= result ? 1 : 0;
            return result;
        }
        module.exports = mapCacheDelete;
    }
});
// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
    "node_modules/lodash/_mapCacheGet.js" (exports, module) {
        var getMapData = require_getMapData();
        function mapCacheGet(key) {
            return getMapData(this, key).get(key);
        }
        module.exports = mapCacheGet;
    }
});
// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
    "node_modules/lodash/_mapCacheHas.js" (exports, module) {
        var getMapData = require_getMapData();
        function mapCacheHas(key) {
            return getMapData(this, key).has(key);
        }
        module.exports = mapCacheHas;
    }
});
// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
    "node_modules/lodash/_mapCacheSet.js" (exports, module) {
        var getMapData = require_getMapData();
        function mapCacheSet(key, value) {
            var data = getMapData(this, key), size = data.size;
            data.set(key, value);
            this.size += data.size == size ? 0 : 1;
            return this;
        }
        module.exports = mapCacheSet;
    }
});
// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
    "node_modules/lodash/_MapCache.js" (exports, module) {
        var mapCacheClear = require_mapCacheClear();
        var mapCacheDelete = require_mapCacheDelete();
        var mapCacheGet = require_mapCacheGet();
        var mapCacheHas = require_mapCacheHas();
        var mapCacheSet = require_mapCacheSet();
        function MapCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while(++index < length){
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        module.exports = MapCache;
    }
});
// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
    "node_modules/lodash/memoize.js" (exports, module) {
        var MapCache = require_MapCache();
        var FUNC_ERROR_TEXT = "Expected a function";
        function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
                var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                if (cache.has(key)) {
                    return cache.get(key);
                }
                var result = func.apply(this, args);
                memoized.cache = cache.set(key, result) || cache;
                return result;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
        }
        memoize.Cache = MapCache;
        module.exports = memoize;
    }
});
// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
    "node_modules/lodash/_memoizeCapped.js" (exports, module) {
        var memoize = require_memoize();
        var MAX_MEMOIZE_SIZE = 500;
        function memoizeCapped(func) {
            var result = memoize(func, function(key) {
                if (cache.size === MAX_MEMOIZE_SIZE) {
                    cache.clear();
                }
                return key;
            });
            var cache = result.cache;
            return result;
        }
        module.exports = memoizeCapped;
    }
});
// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
    "node_modules/lodash/_stringToPath.js" (exports, module) {
        var memoizeCapped = require_memoizeCapped();
        var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reEscapeChar = /\\(\\)?/g;
        var stringToPath = memoizeCapped(function(string) {
            var result = [];
            if (string.charCodeAt(0) === 46) {
                result.push("");
            }
            string.replace(rePropName, function(match, number, quote, subString) {
                result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
            });
            return result;
        });
        module.exports = stringToPath;
    }
});
// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
    "node_modules/lodash/_arrayMap.js" (exports, module) {
        function arrayMap(array, iteratee) {
            var index = -1, length = array == null ? 0 : array.length, result = Array(length);
            while(++index < length){
                result[index] = iteratee(array[index], index, array);
            }
            return result;
        }
        module.exports = arrayMap;
    }
});
// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
    "node_modules/lodash/_baseToString.js" (exports, module) {
        var Symbol2 = require_Symbol();
        var arrayMap = require_arrayMap();
        var isArray = require_isArray();
        var isSymbol = require_isSymbol();
        var INFINITY = 1 / 0;
        var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
        var symbolToString = symbolProto ? symbolProto.toString : void 0;
        function baseToString(value) {
            if (typeof value == "string") {
                return value;
            }
            if (isArray(value)) {
                return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
                return symbolToString ? symbolToString.call(value) : "";
            }
            var result = value + "";
            return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }
        module.exports = baseToString;
    }
});
// node_modules/lodash/toString.js
var require_toString = __commonJS({
    "node_modules/lodash/toString.js" (exports, module) {
        var baseToString = require_baseToString();
        function toString2(value) {
            return value == null ? "" : baseToString(value);
        }
        module.exports = toString2;
    }
});
// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
    "node_modules/lodash/_castPath.js" (exports, module) {
        var isArray = require_isArray();
        var isKey = require_isKey();
        var stringToPath = require_stringToPath();
        var toString2 = require_toString();
        function castPath(value, object) {
            if (isArray(value)) {
                return value;
            }
            return isKey(value, object) ? [
                value
            ] : stringToPath(toString2(value));
        }
        module.exports = castPath;
    }
});
// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
    "node_modules/lodash/_baseIsArguments.js" (exports, module) {
        var baseGetTag = require_baseGetTag();
        var isObjectLike = require_isObjectLike();
        var argsTag = "[object Arguments]";
        function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        module.exports = baseIsArguments;
    }
});
// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
    "node_modules/lodash/isArguments.js" (exports, module) {
        var baseIsArguments = require_baseIsArguments();
        var isObjectLike = require_isObjectLike();
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var propertyIsEnumerable = objectProto.propertyIsEnumerable;
        var isArguments = baseIsArguments(/* @__PURE__ */ function() {
            return arguments;
        }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        module.exports = isArguments;
    }
});
// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
    "node_modules/lodash/_isIndex.js" (exports, module) {
        var MAX_SAFE_INTEGER = 9007199254740991;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
        }
        module.exports = isIndex;
    }
});
// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
    "node_modules/lodash/isLength.js" (exports, module) {
        var MAX_SAFE_INTEGER = 9007199254740991;
        function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        module.exports = isLength;
    }
});
// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
    "node_modules/lodash/_toKey.js" (exports, module) {
        var isSymbol = require_isSymbol();
        var INFINITY = 1 / 0;
        function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
                return value;
            }
            var result = value + "";
            return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }
        module.exports = toKey;
    }
});
// node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
    "node_modules/lodash/_hasPath.js" (exports, module) {
        var castPath = require_castPath();
        var isArguments = require_isArguments();
        var isArray = require_isArray();
        var isIndex = require_isIndex();
        var isLength = require_isLength();
        var toKey = require_toKey();
        function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1, length = path.length, result = false;
            while(++index < length){
                var key = toKey(path[index]);
                if (!(result = object != null && hasFunc(object, key))) {
                    break;
                }
                object = object[key];
            }
            if (result || ++index != length) {
                return result;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        module.exports = hasPath;
    }
});
// node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
    "node_modules/lodash/hasIn.js" (exports, module) {
        var baseHasIn = require_baseHasIn();
        var hasPath = require_hasPath();
        function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
        }
        module.exports = hasIn;
    }
});
// node_modules/lodash/isBoolean.js
var require_isBoolean = __commonJS({
    "node_modules/lodash/isBoolean.js" (exports, module) {
        var baseGetTag = require_baseGetTag();
        var isObjectLike = require_isObjectLike();
        var boolTag = "[object Boolean]";
        function isBoolean2(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        module.exports = isBoolean2;
    }
});
// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
    "node_modules/lodash/_isPrototype.js" (exports, module) {
        var objectProto = Object.prototype;
        function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
        }
        module.exports = isPrototype;
    }
});
// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
    "node_modules/lodash/_overArg.js" (exports, module) {
        function overArg(func, transform) {
            return function(arg) {
                return func(transform(arg));
            };
        }
        module.exports = overArg;
    }
});
// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
    "node_modules/lodash/_nativeKeys.js" (exports, module) {
        var overArg = require_overArg();
        var nativeKeys = overArg(Object.keys, Object);
        module.exports = nativeKeys;
    }
});
// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
    "node_modules/lodash/_baseKeys.js" (exports, module) {
        var isPrototype = require_isPrototype();
        var nativeKeys = require_nativeKeys();
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        function baseKeys(object) {
            if (!isPrototype(object)) {
                return nativeKeys(object);
            }
            var result = [];
            for(var key in Object(object)){
                if (hasOwnProperty.call(object, key) && key != "constructor") {
                    result.push(key);
                }
            }
            return result;
        }
        module.exports = baseKeys;
    }
});
// node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
    "node_modules/lodash/_DataView.js" (exports, module) {
        var getNative = require_getNative();
        var root = require_root();
        var DataView = getNative(root, "DataView");
        module.exports = DataView;
    }
});
// node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
    "node_modules/lodash/_Promise.js" (exports, module) {
        var getNative = require_getNative();
        var root = require_root();
        var Promise2 = getNative(root, "Promise");
        module.exports = Promise2;
    }
});
// node_modules/lodash/_Set.js
var require_Set = __commonJS({
    "node_modules/lodash/_Set.js" (exports, module) {
        var getNative = require_getNative();
        var root = require_root();
        var Set2 = getNative(root, "Set");
        module.exports = Set2;
    }
});
// node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
    "node_modules/lodash/_WeakMap.js" (exports, module) {
        var getNative = require_getNative();
        var root = require_root();
        var WeakMap2 = getNative(root, "WeakMap");
        module.exports = WeakMap2;
    }
});
// node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
    "node_modules/lodash/_getTag.js" (exports, module) {
        var DataView = require_DataView();
        var Map2 = require_Map();
        var Promise2 = require_Promise();
        var Set2 = require_Set();
        var WeakMap2 = require_WeakMap();
        var baseGetTag = require_baseGetTag();
        var toSource = require_toSource();
        var mapTag = "[object Map]";
        var objectTag = "[object Object]";
        var promiseTag = "[object Promise]";
        var setTag = "[object Set]";
        var weakMapTag = "[object WeakMap]";
        var dataViewTag = "[object DataView]";
        var dataViewCtorString = toSource(DataView);
        var mapCtorString = toSource(Map2);
        var promiseCtorString = toSource(Promise2);
        var setCtorString = toSource(Set2);
        var weakMapCtorString = toSource(WeakMap2);
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
            getTag = function(value) {
                var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
                if (ctorString) {
                    switch(ctorString){
                        case dataViewCtorString:
                            return dataViewTag;
                        case mapCtorString:
                            return mapTag;
                        case promiseCtorString:
                            return promiseTag;
                        case setCtorString:
                            return setTag;
                        case weakMapCtorString:
                            return weakMapTag;
                    }
                }
                return result;
            };
        }
        module.exports = getTag;
    }
});
// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
    "node_modules/lodash/isArrayLike.js" (exports, module) {
        var isFunction5 = require_isFunction();
        var isLength = require_isLength();
        function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction5(value);
        }
        module.exports = isArrayLike;
    }
});
// node_modules/lodash/isString.js
var require_isString = __commonJS({
    "node_modules/lodash/isString.js" (exports, module) {
        var baseGetTag = require_baseGetTag();
        var isArray = require_isArray();
        var isObjectLike = require_isObjectLike();
        var stringTag = "[object String]";
        function isString2(value) {
            return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        module.exports = isString2;
    }
});
// node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
    "node_modules/lodash/_baseProperty.js" (exports, module) {
        function baseProperty(key) {
            return function(object) {
                return object == null ? void 0 : object[key];
            };
        }
        module.exports = baseProperty;
    }
});
// node_modules/lodash/_asciiSize.js
var require_asciiSize = __commonJS({
    "node_modules/lodash/_asciiSize.js" (exports, module) {
        var baseProperty = require_baseProperty();
        var asciiSize = baseProperty("length");
        module.exports = asciiSize;
    }
});
// node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
    "node_modules/lodash/_hasUnicode.js" (exports, module) {
        var rsAstralRange = "\\ud800-\\udfff";
        var rsComboMarksRange = "\\u0300-\\u036f";
        var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
        var rsComboSymbolsRange = "\\u20d0-\\u20ff";
        var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
        var rsVarRange = "\\ufe0e\\ufe0f";
        var rsZWJ = "\\u200d";
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        function hasUnicode(string) {
            return reHasUnicode.test(string);
        }
        module.exports = hasUnicode;
    }
});
// node_modules/lodash/_unicodeSize.js
var require_unicodeSize = __commonJS({
    "node_modules/lodash/_unicodeSize.js" (exports, module) {
        var rsAstralRange = "\\ud800-\\udfff";
        var rsComboMarksRange = "\\u0300-\\u036f";
        var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
        var rsComboSymbolsRange = "\\u20d0-\\u20ff";
        var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
        var rsVarRange = "\\ufe0e\\ufe0f";
        var rsAstral = "[" + rsAstralRange + "]";
        var rsCombo = "[" + rsComboRange + "]";
        var rsFitz = "\\ud83c[\\udffb-\\udfff]";
        var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
        var rsNonAstral = "[^" + rsAstralRange + "]";
        var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
        var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
        var rsZWJ = "\\u200d";
        var reOptMod = rsModifier + "?";
        var rsOptVar = "[" + rsVarRange + "]?";
        var rsOptJoin = "(?:" + rsZWJ + "(?:" + [
            rsNonAstral,
            rsRegional,
            rsSurrPair
        ].join("|") + ")" + rsOptVar + reOptMod + ")*";
        var rsSeq = rsOptVar + reOptMod + rsOptJoin;
        var rsSymbol = "(?:" + [
            rsNonAstral + rsCombo + "?",
            rsCombo,
            rsRegional,
            rsSurrPair,
            rsAstral
        ].join("|") + ")";
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        function unicodeSize(string) {
            var result = reUnicode.lastIndex = 0;
            while(reUnicode.test(string)){
                ++result;
            }
            return result;
        }
        module.exports = unicodeSize;
    }
});
// node_modules/lodash/_stringSize.js
var require_stringSize = __commonJS({
    "node_modules/lodash/_stringSize.js" (exports, module) {
        var asciiSize = require_asciiSize();
        var hasUnicode = require_hasUnicode();
        var unicodeSize = require_unicodeSize();
        function stringSize(string) {
            return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        module.exports = stringSize;
    }
});
// node_modules/lodash/size.js
var require_size = __commonJS({
    "node_modules/lodash/size.js" (exports, module) {
        var baseKeys = require_baseKeys();
        var getTag = require_getTag();
        var isArrayLike = require_isArrayLike();
        var isString2 = require_isString();
        var stringSize = require_stringSize();
        var mapTag = "[object Map]";
        var setTag = "[object Set]";
        function size(collection) {
            if (collection == null) {
                return 0;
            }
            if (isArrayLike(collection)) {
                return isString2(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
                return collection.size;
            }
            return baseKeys(collection).length;
        }
        module.exports = size;
    }
});
// node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
    "node_modules/lodash/_stackClear.js" (exports, module) {
        var ListCache = require_ListCache();
        function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
        }
        module.exports = stackClear;
    }
});
// node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
    "node_modules/lodash/_stackDelete.js" (exports, module) {
        function stackDelete(key) {
            var data = this.__data__, result = data["delete"](key);
            this.size = data.size;
            return result;
        }
        module.exports = stackDelete;
    }
});
// node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
    "node_modules/lodash/_stackGet.js" (exports, module) {
        function stackGet(key) {
            return this.__data__.get(key);
        }
        module.exports = stackGet;
    }
});
// node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
    "node_modules/lodash/_stackHas.js" (exports, module) {
        function stackHas(key) {
            return this.__data__.has(key);
        }
        module.exports = stackHas;
    }
});
// node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
    "node_modules/lodash/_stackSet.js" (exports, module) {
        var ListCache = require_ListCache();
        var Map2 = require_Map();
        var MapCache = require_MapCache();
        var LARGE_ARRAY_SIZE = 200;
        function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
                var pairs = data.__data__;
                if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                    pairs.push([
                        key,
                        value
                    ]);
                    this.size = ++data.size;
                    return this;
                }
                data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
        }
        module.exports = stackSet;
    }
});
// node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
    "node_modules/lodash/_Stack.js" (exports, module) {
        var ListCache = require_ListCache();
        var stackClear = require_stackClear();
        var stackDelete = require_stackDelete();
        var stackGet = require_stackGet();
        var stackHas = require_stackHas();
        var stackSet = require_stackSet();
        function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        module.exports = Stack;
    }
});
// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
    "node_modules/lodash/_setCacheAdd.js" (exports, module) {
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
        }
        module.exports = setCacheAdd;
    }
});
// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
    "node_modules/lodash/_setCacheHas.js" (exports, module) {
        function setCacheHas(value) {
            return this.__data__.has(value);
        }
        module.exports = setCacheHas;
    }
});
// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
    "node_modules/lodash/_SetCache.js" (exports, module) {
        var MapCache = require_MapCache();
        var setCacheAdd = require_setCacheAdd();
        var setCacheHas = require_setCacheHas();
        function SetCache(values2) {
            var index = -1, length = values2 == null ? 0 : values2.length;
            this.__data__ = new MapCache();
            while(++index < length){
                this.add(values2[index]);
            }
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        module.exports = SetCache;
    }
});
// node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
    "node_modules/lodash/_arraySome.js" (exports, module) {
        function arraySome(array, predicate) {
            var index = -1, length = array == null ? 0 : array.length;
            while(++index < length){
                if (predicate(array[index], index, array)) {
                    return true;
                }
            }
            return false;
        }
        module.exports = arraySome;
    }
});
// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
    "node_modules/lodash/_cacheHas.js" (exports, module) {
        function cacheHas(cache, key) {
            return cache.has(key);
        }
        module.exports = cacheHas;
    }
});
// node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
    "node_modules/lodash/_equalArrays.js" (exports, module) {
        var SetCache = require_SetCache();
        var arraySome = require_arraySome();
        var cacheHas = require_cacheHas();
        var COMPARE_PARTIAL_FLAG = 1;
        var COMPARE_UNORDERED_FLAG = 2;
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                return false;
            }
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
                return arrStacked == other && othStacked == array;
            }
            var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
            stack.set(array, other);
            stack.set(other, array);
            while(++index < arrLength){
                var arrValue = array[index], othValue = other[index];
                if (customizer) {
                    var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                }
                if (compared !== void 0) {
                    if (compared) {
                        continue;
                    }
                    result = false;
                    break;
                }
                if (seen) {
                    if (!arraySome(other, function(othValue2, othIndex) {
                        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                            return seen.push(othIndex);
                        }
                    })) {
                        result = false;
                        break;
                    }
                } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                    result = false;
                    break;
                }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result;
        }
        module.exports = equalArrays;
    }
});
// node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
    "node_modules/lodash/_Uint8Array.js" (exports, module) {
        var root = require_root();
        var Uint8Array = root.Uint8Array;
        module.exports = Uint8Array;
    }
});
// node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
    "node_modules/lodash/_mapToArray.js" (exports, module) {
        function mapToArray(map2) {
            var index = -1, result = Array(map2.size);
            map2.forEach(function(value, key) {
                result[++index] = [
                    key,
                    value
                ];
            });
            return result;
        }
        module.exports = mapToArray;
    }
});
// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
    "node_modules/lodash/_setToArray.js" (exports, module) {
        function setToArray(set) {
            var index = -1, result = Array(set.size);
            set.forEach(function(value) {
                result[++index] = value;
            });
            return result;
        }
        module.exports = setToArray;
    }
});
// node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
    "node_modules/lodash/_equalByTag.js" (exports, module) {
        var Symbol2 = require_Symbol();
        var Uint8Array = require_Uint8Array();
        var eq = require_eq();
        var equalArrays = require_equalArrays();
        var mapToArray = require_mapToArray();
        var setToArray = require_setToArray();
        var COMPARE_PARTIAL_FLAG = 1;
        var COMPARE_UNORDERED_FLAG = 2;
        var boolTag = "[object Boolean]";
        var dateTag = "[object Date]";
        var errorTag = "[object Error]";
        var mapTag = "[object Map]";
        var numberTag = "[object Number]";
        var regexpTag = "[object RegExp]";
        var setTag = "[object Set]";
        var stringTag = "[object String]";
        var symbolTag = "[object Symbol]";
        var arrayBufferTag = "[object ArrayBuffer]";
        var dataViewTag = "[object DataView]";
        var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
        var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch(tag){
                case dataViewTag:
                    if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                        return false;
                    }
                    object = object.buffer;
                    other = other.buffer;
                case arrayBufferTag:
                    if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                        return false;
                    }
                    return true;
                case boolTag:
                case dateTag:
                case numberTag:
                    return eq(+object, +other);
                case errorTag:
                    return object.name == other.name && object.message == other.message;
                case regexpTag:
                case stringTag:
                    return object == other + "";
                case mapTag:
                    var convert = mapToArray;
                case setTag:
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                    convert || (convert = setToArray);
                    if (object.size != other.size && !isPartial) {
                        return false;
                    }
                    var stacked = stack.get(object);
                    if (stacked) {
                        return stacked == other;
                    }
                    bitmask |= COMPARE_UNORDERED_FLAG;
                    stack.set(object, other);
                    var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                    stack["delete"](object);
                    return result;
                case symbolTag:
                    if (symbolValueOf) {
                        return symbolValueOf.call(object) == symbolValueOf.call(other);
                    }
            }
            return false;
        }
        module.exports = equalByTag;
    }
});
// node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
    "node_modules/lodash/_arrayPush.js" (exports, module) {
        function arrayPush(array, values2) {
            var index = -1, length = values2.length, offset = array.length;
            while(++index < length){
                array[offset + index] = values2[index];
            }
            return array;
        }
        module.exports = arrayPush;
    }
});
// node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
    "node_modules/lodash/_baseGetAllKeys.js" (exports, module) {
        var arrayPush = require_arrayPush();
        var isArray = require_isArray();
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
        }
        module.exports = baseGetAllKeys;
    }
});
// node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
    "node_modules/lodash/_arrayFilter.js" (exports, module) {
        function arrayFilter(array, predicate) {
            var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
            while(++index < length){
                var value = array[index];
                if (predicate(value, index, array)) {
                    result[resIndex++] = value;
                }
            }
            return result;
        }
        module.exports = arrayFilter;
    }
});
// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
    "node_modules/lodash/stubArray.js" (exports, module) {
        function stubArray() {
            return [];
        }
        module.exports = stubArray;
    }
});
// node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
    "node_modules/lodash/_getSymbols.js" (exports, module) {
        var arrayFilter = require_arrayFilter();
        var stubArray = require_stubArray();
        var objectProto = Object.prototype;
        var propertyIsEnumerable = objectProto.propertyIsEnumerable;
        var nativeGetSymbols = Object.getOwnPropertySymbols;
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
                return [];
            }
            object = Object(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
                return propertyIsEnumerable.call(object, symbol);
            });
        };
        module.exports = getSymbols;
    }
});
// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
    "node_modules/lodash/_baseTimes.js" (exports, module) {
        function baseTimes(n, iteratee) {
            var index = -1, result = Array(n);
            while(++index < n){
                result[index] = iteratee(index);
            }
            return result;
        }
        module.exports = baseTimes;
    }
});
// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
    "node_modules/lodash/stubFalse.js" (exports, module) {
        function stubFalse() {
            return false;
        }
        module.exports = stubFalse;
    }
});
// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
    "node_modules/lodash/isBuffer.js" (exports, module) {
        var root = require_root();
        var stubFalse = require_stubFalse();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var Buffer = moduleExports ? root.Buffer : void 0;
        var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
        var isBuffer = nativeIsBuffer || stubFalse;
        module.exports = isBuffer;
    }
});
// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
    "node_modules/lodash/_baseIsTypedArray.js" (exports, module) {
        var baseGetTag = require_baseGetTag();
        var isLength = require_isLength();
        var isObjectLike = require_isObjectLike();
        var argsTag = "[object Arguments]";
        var arrayTag = "[object Array]";
        var boolTag = "[object Boolean]";
        var dateTag = "[object Date]";
        var errorTag = "[object Error]";
        var funcTag = "[object Function]";
        var mapTag = "[object Map]";
        var numberTag = "[object Number]";
        var objectTag = "[object Object]";
        var regexpTag = "[object RegExp]";
        var setTag = "[object Set]";
        var stringTag = "[object String]";
        var weakMapTag = "[object WeakMap]";
        var arrayBufferTag = "[object ArrayBuffer]";
        var dataViewTag = "[object DataView]";
        var float32Tag = "[object Float32Array]";
        var float64Tag = "[object Float64Array]";
        var int8Tag = "[object Int8Array]";
        var int16Tag = "[object Int16Array]";
        var int32Tag = "[object Int32Array]";
        var uint8Tag = "[object Uint8Array]";
        var uint8ClampedTag = "[object Uint8ClampedArray]";
        var uint16Tag = "[object Uint16Array]";
        var uint32Tag = "[object Uint32Array]";
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        module.exports = baseIsTypedArray;
    }
});
// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
    "node_modules/lodash/_baseUnary.js" (exports, module) {
        function baseUnary(func) {
            return function(value) {
                return func(value);
            };
        }
        module.exports = baseUnary;
    }
});
// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
    "node_modules/lodash/_nodeUtil.js" (exports, module) {
        var freeGlobal = require_freeGlobal();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
            try {
                var types = freeModule && freeModule.require && freeModule.require("util").types;
                if (types) {
                    return types;
                }
                return freeProcess && freeProcess.binding && freeProcess.binding("util");
            } catch (e) {}
        }();
        module.exports = nodeUtil;
    }
});
// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
    "node_modules/lodash/isTypedArray.js" (exports, module) {
        var baseIsTypedArray = require_baseIsTypedArray();
        var baseUnary = require_baseUnary();
        var nodeUtil = require_nodeUtil();
        var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        module.exports = isTypedArray;
    }
});
// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
    "node_modules/lodash/_arrayLikeKeys.js" (exports, module) {
        var baseTimes = require_baseTimes();
        var isArguments = require_isArguments();
        var isArray = require_isArray();
        var isBuffer = require_isBuffer();
        var isIndex = require_isIndex();
        var isTypedArray = require_isTypedArray();
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
            for(var key in value){
                if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
                (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
                isIndex(key, length)))) {
                    result.push(key);
                }
            }
            return result;
        }
        module.exports = arrayLikeKeys;
    }
});
// node_modules/lodash/keys.js
var require_keys = __commonJS({
    "node_modules/lodash/keys.js" (exports, module) {
        var arrayLikeKeys = require_arrayLikeKeys();
        var baseKeys = require_baseKeys();
        var isArrayLike = require_isArrayLike();
        function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        module.exports = keys;
    }
});
// node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
    "node_modules/lodash/_getAllKeys.js" (exports, module) {
        var baseGetAllKeys = require_baseGetAllKeys();
        var getSymbols = require_getSymbols();
        var keys = require_keys();
        function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
        }
        module.exports = getAllKeys;
    }
});
// node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
    "node_modules/lodash/_equalObjects.js" (exports, module) {
        var getAllKeys = require_getAllKeys();
        var COMPARE_PARTIAL_FLAG = 1;
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
                return false;
            }
            var index = objLength;
            while(index--){
                var key = objProps[index];
                if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                    return false;
                }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
                return objStacked == other && othStacked == object;
            }
            var result = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while(++index < objLength){
                key = objProps[index];
                var objValue = object[key], othValue = other[key];
                if (customizer) {
                    var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                }
                if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                    result = false;
                    break;
                }
                skipCtor || (skipCtor = key == "constructor");
            }
            if (result && !skipCtor) {
                var objCtor = object.constructor, othCtor = other.constructor;
                if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                    result = false;
                }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result;
        }
        module.exports = equalObjects;
    }
});
// node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
    "node_modules/lodash/_baseIsEqualDeep.js" (exports, module) {
        var Stack = require_Stack();
        var equalArrays = require_equalArrays();
        var equalByTag = require_equalByTag();
        var equalObjects = require_equalObjects();
        var getTag = require_getTag();
        var isArray = require_isArray();
        var isBuffer = require_isBuffer();
        var isTypedArray = require_isTypedArray();
        var COMPARE_PARTIAL_FLAG = 1;
        var argsTag = "[object Arguments]";
        var arrayTag = "[object Array]";
        var objectTag = "[object Object]";
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
                if (!isBuffer(other)) {
                    return false;
                }
                objIsArr = true;
                objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
                stack || (stack = new Stack());
                return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                if (objIsWrapped || othIsWrapped) {
                    var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                    stack || (stack = new Stack());
                    return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                }
            }
            if (!isSameTag) {
                return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        module.exports = baseIsEqualDeep;
    }
});
// node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
    "node_modules/lodash/_baseIsEqual.js" (exports, module) {
        var baseIsEqualDeep = require_baseIsEqualDeep();
        var isObjectLike = require_isObjectLike();
        function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
                return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
                return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        module.exports = baseIsEqual;
    }
});
// node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
    "node_modules/lodash/_baseIsMatch.js" (exports, module) {
        var Stack = require_Stack();
        var baseIsEqual = require_baseIsEqual();
        var COMPARE_PARTIAL_FLAG = 1;
        var COMPARE_UNORDERED_FLAG = 2;
        function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer;
            if (object == null) {
                return !length;
            }
            object = Object(object);
            while(index--){
                var data = matchData[index];
                if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                    return false;
                }
            }
            while(++index < length){
                data = matchData[index];
                var key = data[0], objValue = object[key], srcValue = data[1];
                if (noCustomizer && data[2]) {
                    if (objValue === void 0 && !(key in object)) {
                        return false;
                    }
                } else {
                    var stack = new Stack();
                    if (customizer) {
                        var result = customizer(objValue, srcValue, key, object, source, stack);
                    }
                    if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
                        return false;
                    }
                }
            }
            return true;
        }
        module.exports = baseIsMatch;
    }
});
// node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
    "node_modules/lodash/_isStrictComparable.js" (exports, module) {
        var isObject2 = require_isObject();
        function isStrictComparable(value) {
            return value === value && !isObject2(value);
        }
        module.exports = isStrictComparable;
    }
});
// node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
    "node_modules/lodash/_getMatchData.js" (exports, module) {
        var isStrictComparable = require_isStrictComparable();
        var keys = require_keys();
        function getMatchData(object) {
            var result = keys(object), length = result.length;
            while(length--){
                var key = result[length], value = object[key];
                result[length] = [
                    key,
                    value,
                    isStrictComparable(value)
                ];
            }
            return result;
        }
        module.exports = getMatchData;
    }
});
// node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
    "node_modules/lodash/_matchesStrictComparable.js" (exports, module) {
        function matchesStrictComparable(key, srcValue) {
            return function(object) {
                if (object == null) {
                    return false;
                }
                return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
            };
        }
        module.exports = matchesStrictComparable;
    }
});
// node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
    "node_modules/lodash/_baseMatches.js" (exports, module) {
        var baseIsMatch = require_baseIsMatch();
        var getMatchData = require_getMatchData();
        var matchesStrictComparable = require_matchesStrictComparable();
        function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
                return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
                return object === source || baseIsMatch(object, source, matchData);
            };
        }
        module.exports = baseMatches;
    }
});
// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
    "node_modules/lodash/_baseGet.js" (exports, module) {
        var castPath = require_castPath();
        var toKey = require_toKey();
        function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0, length = path.length;
            while(object != null && index < length){
                object = object[toKey(path[index++])];
            }
            return index && index == length ? object : void 0;
        }
        module.exports = baseGet;
    }
});
// node_modules/lodash/get.js
var require_get = __commonJS({
    "node_modules/lodash/get.js" (exports, module) {
        var baseGet = require_baseGet();
        function get(object, path, defaultValue) {
            var result = object == null ? void 0 : baseGet(object, path);
            return result === void 0 ? defaultValue : result;
        }
        module.exports = get;
    }
});
// node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
    "node_modules/lodash/_baseMatchesProperty.js" (exports, module) {
        var baseIsEqual = require_baseIsEqual();
        var get = require_get();
        var hasIn = require_hasIn();
        var isKey = require_isKey();
        var isStrictComparable = require_isStrictComparable();
        var matchesStrictComparable = require_matchesStrictComparable();
        var toKey = require_toKey();
        var COMPARE_PARTIAL_FLAG = 1;
        var COMPARE_UNORDERED_FLAG = 2;
        function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
                return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object) {
                var objValue = get(object, path);
                return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
        }
        module.exports = baseMatchesProperty;
    }
});
// node_modules/lodash/identity.js
var require_identity = __commonJS({
    "node_modules/lodash/identity.js" (exports, module) {
        function identity(value) {
            return value;
        }
        module.exports = identity;
    }
});
// node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
    "node_modules/lodash/_basePropertyDeep.js" (exports, module) {
        var baseGet = require_baseGet();
        function basePropertyDeep(path) {
            return function(object) {
                return baseGet(object, path);
            };
        }
        module.exports = basePropertyDeep;
    }
});
// node_modules/lodash/property.js
var require_property = __commonJS({
    "node_modules/lodash/property.js" (exports, module) {
        var baseProperty = require_baseProperty();
        var basePropertyDeep = require_basePropertyDeep();
        var isKey = require_isKey();
        var toKey = require_toKey();
        function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        module.exports = property;
    }
});
// node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
    "node_modules/lodash/_baseIteratee.js" (exports, module) {
        var baseMatches = require_baseMatches();
        var baseMatchesProperty = require_baseMatchesProperty();
        var identity = require_identity();
        var isArray = require_isArray();
        var property = require_property();
        function baseIteratee(value) {
            if (typeof value == "function") {
                return value;
            }
            if (value == null) {
                return identity;
            }
            if (typeof value == "object") {
                return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
        }
        module.exports = baseIteratee;
    }
});
// node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
    "node_modules/lodash/_createBaseFor.js" (exports, module) {
        function createBaseFor(fromRight) {
            return function(object, iteratee, keysFunc) {
                var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
                while(length--){
                    var key = props[fromRight ? length : ++index];
                    if (iteratee(iterable[key], key, iterable) === false) {
                        break;
                    }
                }
                return object;
            };
        }
        module.exports = createBaseFor;
    }
});
// node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
    "node_modules/lodash/_baseFor.js" (exports, module) {
        var createBaseFor = require_createBaseFor();
        var baseFor = createBaseFor();
        module.exports = baseFor;
    }
});
// node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
    "node_modules/lodash/_baseForOwn.js" (exports, module) {
        var baseFor = require_baseFor();
        var keys = require_keys();
        function baseForOwn(object, iteratee) {
            return object && baseFor(object, iteratee, keys);
        }
        module.exports = baseForOwn;
    }
});
// node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
    "node_modules/lodash/_createBaseEach.js" (exports, module) {
        var isArrayLike = require_isArrayLike();
        function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee) {
                if (collection == null) {
                    return collection;
                }
                if (!isArrayLike(collection)) {
                    return eachFunc(collection, iteratee);
                }
                var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
                while(fromRight ? index-- : ++index < length){
                    if (iteratee(iterable[index], index, iterable) === false) {
                        break;
                    }
                }
                return collection;
            };
        }
        module.exports = createBaseEach;
    }
});
// node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
    "node_modules/lodash/_baseEach.js" (exports, module) {
        var baseForOwn = require_baseForOwn();
        var createBaseEach = require_createBaseEach();
        var baseEach = createBaseEach(baseForOwn);
        module.exports = baseEach;
    }
});
// node_modules/lodash/_baseMap.js
var require_baseMap = __commonJS({
    "node_modules/lodash/_baseMap.js" (exports, module) {
        var baseEach = require_baseEach();
        var isArrayLike = require_isArrayLike();
        function baseMap(collection, iteratee) {
            var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
                result[++index] = iteratee(value, key, collection2);
            });
            return result;
        }
        module.exports = baseMap;
    }
});
// node_modules/lodash/map.js
var require_map = __commonJS({
    "node_modules/lodash/map.js" (exports, module) {
        var arrayMap = require_arrayMap();
        var baseIteratee = require_baseIteratee();
        var baseMap = require_baseMap();
        var isArray = require_isArray();
        function map2(collection, iteratee) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, baseIteratee(iteratee, 3));
        }
        module.exports = map2;
    }
});
// node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
    "node_modules/lodash/_getPrototype.js" (exports, module) {
        var overArg = require_overArg();
        var getPrototype = overArg(Object.getPrototypeOf, Object);
        module.exports = getPrototype;
    }
});
// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
    "node_modules/lodash/isPlainObject.js" (exports, module) {
        var baseGetTag = require_baseGetTag();
        var getPrototype = require_getPrototype();
        var isObjectLike = require_isObjectLike();
        var objectTag = "[object Object]";
        var funcProto = Function.prototype;
        var objectProto = Object.prototype;
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var objectCtorString = funcToString.call(Object);
        function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
                return true;
            }
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        module.exports = isPlainObject;
    }
});
// node_modules/lodash/_baseRange.js
var require_baseRange = __commonJS({
    "node_modules/lodash/_baseRange.js" (exports, module) {
        var nativeCeil = Math.ceil;
        var nativeMax = Math.max;
        function baseRange(start, end, step, fromRight) {
            var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
            while(length--){
                result[fromRight ? length : ++index] = start;
                start += step;
            }
            return result;
        }
        module.exports = baseRange;
    }
});
// node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
    "node_modules/lodash/_isIterateeCall.js" (exports, module) {
        var eq = require_eq();
        var isArrayLike = require_isArrayLike();
        var isIndex = require_isIndex();
        var isObject2 = require_isObject();
        function isIterateeCall(value, index, object) {
            if (!isObject2(object)) {
                return false;
            }
            var type = typeof index;
            if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
                return eq(object[index], value);
            }
            return false;
        }
        module.exports = isIterateeCall;
    }
});
// node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
    "node_modules/lodash/_trimmedEndIndex.js" (exports, module) {
        var reWhitespace = /\s/;
        function trimmedEndIndex(string) {
            var index = string.length;
            while(index-- && reWhitespace.test(string.charAt(index))){}
            return index;
        }
        module.exports = trimmedEndIndex;
    }
});
// node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
    "node_modules/lodash/_baseTrim.js" (exports, module) {
        var trimmedEndIndex = require_trimmedEndIndex();
        var reTrimStart = /^\s+/;
        function baseTrim(string) {
            return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        module.exports = baseTrim;
    }
});
// node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
    "node_modules/lodash/toNumber.js" (exports, module) {
        var baseTrim = require_baseTrim();
        var isObject2 = require_isObject();
        var isSymbol = require_isSymbol();
        var NAN = 0 / 0;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsOctal = /^0o[0-7]+$/i;
        var freeParseInt = parseInt;
        function toNumber(value) {
            if (typeof value == "number") {
                return value;
            }
            if (isSymbol(value)) {
                return NAN;
            }
            if (isObject2(value)) {
                var other = typeof value.valueOf == "function" ? value.valueOf() : value;
                value = isObject2(other) ? other + "" : other;
            }
            if (typeof value != "string") {
                return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        module.exports = toNumber;
    }
});
// node_modules/lodash/toFinite.js
var require_toFinite = __commonJS({
    "node_modules/lodash/toFinite.js" (exports, module) {
        var toNumber = require_toNumber();
        var INFINITY = 1 / 0;
        var MAX_INTEGER = 17976931348623157e292;
        function toFinite(value) {
            if (!value) {
                return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
                var sign = value < 0 ? -1 : 1;
                return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
        }
        module.exports = toFinite;
    }
});
// node_modules/lodash/_createRange.js
var require_createRange = __commonJS({
    "node_modules/lodash/_createRange.js" (exports, module) {
        var baseRange = require_baseRange();
        var isIterateeCall = require_isIterateeCall();
        var toFinite = require_toFinite();
        function createRange(fromRight) {
            return function(start, end, step) {
                if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                    end = step = void 0;
                }
                start = toFinite(start);
                if (end === void 0) {
                    end = start;
                    start = 0;
                } else {
                    end = toFinite(end);
                }
                step = step === void 0 ? start < end ? 1 : -1 : toFinite(step);
                return baseRange(start, end, step, fromRight);
            };
        }
        module.exports = createRange;
    }
});
// node_modules/lodash/range.js
var require_range = __commonJS({
    "node_modules/lodash/range.js" (exports, module) {
        var createRange = require_createRange();
        var range = createRange();
        module.exports = range;
    }
});
// node_modules/lodash/isNumber.js
var require_isNumber = __commonJS({
    "node_modules/lodash/isNumber.js" (exports, module) {
        var baseGetTag = require_baseGetTag();
        var isObjectLike = require_isObjectLike();
        var numberTag = "[object Number]";
        function isNumber2(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        module.exports = isNumber2;
    }
});
// node_modules/lodash/head.js
var require_head = __commonJS({
    "node_modules/lodash/head.js" (exports, module) {
        function head(array) {
            return array && array.length ? array[0] : void 0;
        }
        module.exports = head;
    }
});
// node_modules/lodash/first.js
var require_first = __commonJS({
    "node_modules/lodash/first.js" (exports, module) {
        module.exports = require_head();
    }
});
// node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
    "node_modules/lodash/_arrayEach.js" (exports, module) {
        function arrayEach(array, iteratee) {
            var index = -1, length = array == null ? 0 : array.length;
            while(++index < length){
                if (iteratee(array[index], index, array) === false) {
                    break;
                }
            }
            return array;
        }
        module.exports = arrayEach;
    }
});
// node_modules/lodash/_castFunction.js
var require_castFunction = __commonJS({
    "node_modules/lodash/_castFunction.js" (exports, module) {
        var identity = require_identity();
        function castFunction(value) {
            return typeof value == "function" ? value : identity;
        }
        module.exports = castFunction;
    }
});
// node_modules/lodash/forEach.js
var require_forEach = __commonJS({
    "node_modules/lodash/forEach.js" (exports, module) {
        var arrayEach = require_arrayEach();
        var baseEach = require_baseEach();
        var castFunction = require_castFunction();
        var isArray = require_isArray();
        function forEach(collection, iteratee) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, castFunction(iteratee));
        }
        module.exports = forEach;
    }
});
// node_modules/lodash/isUndefined.js
var require_isUndefined = __commonJS({
    "node_modules/lodash/isUndefined.js" (exports, module) {
        function isUndefined2(value) {
            return value === void 0;
        }
        module.exports = isUndefined2;
    }
});
// node_modules/lodash/isNull.js
var require_isNull = __commonJS({
    "node_modules/lodash/isNull.js" (exports, module) {
        function isNull(value) {
            return value === null;
        }
        module.exports = isNull;
    }
});
// node_modules/lodash/isEmpty.js
var require_isEmpty = __commonJS({
    "node_modules/lodash/isEmpty.js" (exports, module) {
        var baseKeys = require_baseKeys();
        var getTag = require_getTag();
        var isArguments = require_isArguments();
        var isArray = require_isArray();
        var isArrayLike = require_isArrayLike();
        var isBuffer = require_isBuffer();
        var isPrototype = require_isPrototype();
        var isTypedArray = require_isTypedArray();
        var mapTag = "[object Map]";
        var setTag = "[object Set]";
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        function isEmpty(value) {
            if (value == null) {
                return true;
            }
            if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
                return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
                return !value.size;
            }
            if (isPrototype(value)) {
                return !baseKeys(value).length;
            }
            for(var key in value){
                if (hasOwnProperty.call(value, key)) {
                    return false;
                }
            }
            return true;
        }
        module.exports = isEmpty;
    }
});
// node_modules/lodash/_baseClamp.js
var require_baseClamp = __commonJS({
    "node_modules/lodash/_baseClamp.js" (exports, module) {
        function baseClamp(number, lower, upper) {
            if (number === number) {
                if (upper !== void 0) {
                    number = number <= upper ? number : upper;
                }
                if (lower !== void 0) {
                    number = number >= lower ? number : lower;
                }
            }
            return number;
        }
        module.exports = baseClamp;
    }
});
// node_modules/lodash/toInteger.js
var require_toInteger = __commonJS({
    "node_modules/lodash/toInteger.js" (exports, module) {
        var toFinite = require_toFinite();
        function toInteger(value) {
            var result = toFinite(value), remainder = result % 1;
            return result === result ? remainder ? result - remainder : result : 0;
        }
        module.exports = toInteger;
    }
});
// node_modules/lodash/endsWith.js
var require_endsWith = __commonJS({
    "node_modules/lodash/endsWith.js" (exports, module) {
        var baseClamp = require_baseClamp();
        var baseToString = require_baseToString();
        var toInteger = require_toInteger();
        var toString2 = require_toString();
        function endsWith(string, target, position) {
            string = toString2(string);
            target = baseToString(target);
            var length = string.length;
            position = position === void 0 ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
        }
        module.exports = endsWith;
    }
});
// node_modules/lodash/_arrayReduce.js
var require_arrayReduce = __commonJS({
    "node_modules/lodash/_arrayReduce.js" (exports, module) {
        function arrayReduce(array, iteratee, accumulator, initAccum) {
            var index = -1, length = array == null ? 0 : array.length;
            if (initAccum && length) {
                accumulator = array[++index];
            }
            while(++index < length){
                accumulator = iteratee(accumulator, array[index], index, array);
            }
            return accumulator;
        }
        module.exports = arrayReduce;
    }
});
// node_modules/lodash/_basePropertyOf.js
var require_basePropertyOf = __commonJS({
    "node_modules/lodash/_basePropertyOf.js" (exports, module) {
        function basePropertyOf(object) {
            return function(key) {
                return object == null ? void 0 : object[key];
            };
        }
        module.exports = basePropertyOf;
    }
});
// node_modules/lodash/_deburrLetter.js
var require_deburrLetter = __commonJS({
    "node_modules/lodash/_deburrLetter.js" (exports, module) {
        var basePropertyOf = require_basePropertyOf();
        var deburredLetters = {
            // Latin-1 Supplement block.
            "\xC0": "A",
            "\xC1": "A",
            "\xC2": "A",
            "\xC3": "A",
            "\xC4": "A",
            "\xC5": "A",
            "\xE0": "a",
            "\xE1": "a",
            "\xE2": "a",
            "\xE3": "a",
            "\xE4": "a",
            "\xE5": "a",
            "\xC7": "C",
            "\xE7": "c",
            "\xD0": "D",
            "\xF0": "d",
            "\xC8": "E",
            "\xC9": "E",
            "\xCA": "E",
            "\xCB": "E",
            "\xE8": "e",
            "\xE9": "e",
            "\xEA": "e",
            "\xEB": "e",
            "\xCC": "I",
            "\xCD": "I",
            "\xCE": "I",
            "\xCF": "I",
            "\xEC": "i",
            "\xED": "i",
            "\xEE": "i",
            "\xEF": "i",
            "\xD1": "N",
            "\xF1": "n",
            "\xD2": "O",
            "\xD3": "O",
            "\xD4": "O",
            "\xD5": "O",
            "\xD6": "O",
            "\xD8": "O",
            "\xF2": "o",
            "\xF3": "o",
            "\xF4": "o",
            "\xF5": "o",
            "\xF6": "o",
            "\xF8": "o",
            "\xD9": "U",
            "\xDA": "U",
            "\xDB": "U",
            "\xDC": "U",
            "\xF9": "u",
            "\xFA": "u",
            "\xFB": "u",
            "\xFC": "u",
            "\xDD": "Y",
            "\xFD": "y",
            "\xFF": "y",
            "\xC6": "Ae",
            "\xE6": "ae",
            "\xDE": "Th",
            "\xFE": "th",
            "\xDF": "ss",
            // Latin Extended-A block.
            "\u0100": "A",
            "\u0102": "A",
            "\u0104": "A",
            "\u0101": "a",
            "\u0103": "a",
            "\u0105": "a",
            "\u0106": "C",
            "\u0108": "C",
            "\u010A": "C",
            "\u010C": "C",
            "\u0107": "c",
            "\u0109": "c",
            "\u010B": "c",
            "\u010D": "c",
            "\u010E": "D",
            "\u0110": "D",
            "\u010F": "d",
            "\u0111": "d",
            "\u0112": "E",
            "\u0114": "E",
            "\u0116": "E",
            "\u0118": "E",
            "\u011A": "E",
            "\u0113": "e",
            "\u0115": "e",
            "\u0117": "e",
            "\u0119": "e",
            "\u011B": "e",
            "\u011C": "G",
            "\u011E": "G",
            "\u0120": "G",
            "\u0122": "G",
            "\u011D": "g",
            "\u011F": "g",
            "\u0121": "g",
            "\u0123": "g",
            "\u0124": "H",
            "\u0126": "H",
            "\u0125": "h",
            "\u0127": "h",
            "\u0128": "I",
            "\u012A": "I",
            "\u012C": "I",
            "\u012E": "I",
            "\u0130": "I",
            "\u0129": "i",
            "\u012B": "i",
            "\u012D": "i",
            "\u012F": "i",
            "\u0131": "i",
            "\u0134": "J",
            "\u0135": "j",
            "\u0136": "K",
            "\u0137": "k",
            "\u0138": "k",
            "\u0139": "L",
            "\u013B": "L",
            "\u013D": "L",
            "\u013F": "L",
            "\u0141": "L",
            "\u013A": "l",
            "\u013C": "l",
            "\u013E": "l",
            "\u0140": "l",
            "\u0142": "l",
            "\u0143": "N",
            "\u0145": "N",
            "\u0147": "N",
            "\u014A": "N",
            "\u0144": "n",
            "\u0146": "n",
            "\u0148": "n",
            "\u014B": "n",
            "\u014C": "O",
            "\u014E": "O",
            "\u0150": "O",
            "\u014D": "o",
            "\u014F": "o",
            "\u0151": "o",
            "\u0154": "R",
            "\u0156": "R",
            "\u0158": "R",
            "\u0155": "r",
            "\u0157": "r",
            "\u0159": "r",
            "\u015A": "S",
            "\u015C": "S",
            "\u015E": "S",
            "\u0160": "S",
            "\u015B": "s",
            "\u015D": "s",
            "\u015F": "s",
            "\u0161": "s",
            "\u0162": "T",
            "\u0164": "T",
            "\u0166": "T",
            "\u0163": "t",
            "\u0165": "t",
            "\u0167": "t",
            "\u0168": "U",
            "\u016A": "U",
            "\u016C": "U",
            "\u016E": "U",
            "\u0170": "U",
            "\u0172": "U",
            "\u0169": "u",
            "\u016B": "u",
            "\u016D": "u",
            "\u016F": "u",
            "\u0171": "u",
            "\u0173": "u",
            "\u0174": "W",
            "\u0175": "w",
            "\u0176": "Y",
            "\u0177": "y",
            "\u0178": "Y",
            "\u0179": "Z",
            "\u017B": "Z",
            "\u017D": "Z",
            "\u017A": "z",
            "\u017C": "z",
            "\u017E": "z",
            "\u0132": "IJ",
            "\u0133": "ij",
            "\u0152": "Oe",
            "\u0153": "oe",
            "\u0149": "'n",
            "\u017F": "s"
        };
        var deburrLetter = basePropertyOf(deburredLetters);
        module.exports = deburrLetter;
    }
});
// node_modules/lodash/deburr.js
var require_deburr = __commonJS({
    "node_modules/lodash/deburr.js" (exports, module) {
        var deburrLetter = require_deburrLetter();
        var toString2 = require_toString();
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var rsComboMarksRange = "\\u0300-\\u036f";
        var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
        var rsComboSymbolsRange = "\\u20d0-\\u20ff";
        var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
        var rsCombo = "[" + rsComboRange + "]";
        var reComboMark = RegExp(rsCombo, "g");
        function deburr(string) {
            string = toString2(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        module.exports = deburr;
    }
});
// node_modules/lodash/_asciiWords.js
var require_asciiWords = __commonJS({
    "node_modules/lodash/_asciiWords.js" (exports, module) {
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        function asciiWords(string) {
            return string.match(reAsciiWord) || [];
        }
        module.exports = asciiWords;
    }
});
// node_modules/lodash/_hasUnicodeWord.js
var require_hasUnicodeWord = __commonJS({
    "node_modules/lodash/_hasUnicodeWord.js" (exports, module) {
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        function hasUnicodeWord(string) {
            return reHasUnicodeWord.test(string);
        }
        module.exports = hasUnicodeWord;
    }
});
// node_modules/lodash/_unicodeWords.js
var require_unicodeWords = __commonJS({
    "node_modules/lodash/_unicodeWords.js" (exports, module) {
        var rsAstralRange = "\\ud800-\\udfff";
        var rsComboMarksRange = "\\u0300-\\u036f";
        var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
        var rsComboSymbolsRange = "\\u20d0-\\u20ff";
        var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
        var rsDingbatRange = "\\u2700-\\u27bf";
        var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
        var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
        var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
        var rsPunctuationRange = "\\u2000-\\u206f";
        var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
        var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
        var rsVarRange = "\\ufe0e\\ufe0f";
        var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]";
        var rsBreak = "[" + rsBreakRange + "]";
        var rsCombo = "[" + rsComboRange + "]";
        var rsDigits = "\\d+";
        var rsDingbat = "[" + rsDingbatRange + "]";
        var rsLower = "[" + rsLowerRange + "]";
        var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
        var rsFitz = "\\ud83c[\\udffb-\\udfff]";
        var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
        var rsNonAstral = "[^" + rsAstralRange + "]";
        var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
        var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
        var rsUpper = "[" + rsUpperRange + "]";
        var rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
        var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
        var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
        var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
        var reOptMod = rsModifier + "?";
        var rsOptVar = "[" + rsVarRange + "]?";
        var rsOptJoin = "(?:" + rsZWJ + "(?:" + [
            rsNonAstral,
            rsRegional,
            rsSurrPair
        ].join("|") + ")" + rsOptVar + reOptMod + ")*";
        var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
        var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
        var rsSeq = rsOptVar + reOptMod + rsOptJoin;
        var rsEmoji = "(?:" + [
            rsDingbat,
            rsRegional,
            rsSurrPair
        ].join("|") + ")" + rsSeq;
        var reUnicodeWord = RegExp([
            rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [
                rsBreak,
                rsUpper,
                "$"
            ].join("|") + ")",
            rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [
                rsBreak,
                rsUpper + rsMiscLower,
                "$"
            ].join("|") + ")",
            rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
            rsUpper + "+" + rsOptContrUpper,
            rsOrdUpper,
            rsOrdLower,
            rsDigits,
            rsEmoji
        ].join("|"), "g");
        function unicodeWords(string) {
            return string.match(reUnicodeWord) || [];
        }
        module.exports = unicodeWords;
    }
});
// node_modules/lodash/words.js
var require_words = __commonJS({
    "node_modules/lodash/words.js" (exports, module) {
        var asciiWords = require_asciiWords();
        var hasUnicodeWord = require_hasUnicodeWord();
        var toString2 = require_toString();
        var unicodeWords = require_unicodeWords();
        function words(string, pattern, guard) {
            string = toString2(string);
            pattern = guard ? void 0 : pattern;
            if (pattern === void 0) {
                return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
        }
        module.exports = words;
    }
});
// node_modules/lodash/_createCompounder.js
var require_createCompounder = __commonJS({
    "node_modules/lodash/_createCompounder.js" (exports, module) {
        var arrayReduce = require_arrayReduce();
        var deburr = require_deburr();
        var words = require_words();
        var rsApos = "['\u2019]";
        var reApos = RegExp(rsApos, "g");
        function createCompounder(callback) {
            return function(string) {
                return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
        }
        module.exports = createCompounder;
    }
});
// node_modules/lodash/kebabCase.js
var require_kebabCase = __commonJS({
    "node_modules/lodash/kebabCase.js" (exports, module) {
        var createCompounder = require_createCompounder();
        var kebabCase = createCompounder(function(result, word, index) {
            return result + (index ? "-" : "") + word.toLowerCase();
        });
        module.exports = kebabCase;
    }
});
// node_modules/asap/browser-raw.js
var require_browser_raw = __commonJS({
    "node_modules/asap/browser-raw.js" (exports, module) {
        "use strict";
        module.exports = rawAsap;
        function rawAsap(task) {
            if (!queue.length) {
                requestFlush();
                flushing = true;
            }
            queue[queue.length] = task;
        }
        var queue = [];
        var flushing = false;
        var requestFlush;
        var index = 0;
        var capacity = 1024;
        function flush() {
            while(index < queue.length){
                var currentIndex = index;
                index = index + 1;
                queue[currentIndex].call();
                if (index > capacity) {
                    for(var scan = 0, newLength = queue.length - index; scan < newLength; scan++){
                        queue[scan] = queue[scan + index];
                    }
                    queue.length -= index;
                    index = 0;
                }
            }
            queue.length = 0;
            index = 0;
            flushing = false;
        }
        var scope = typeof global !== "undefined" ? global : self;
        var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
        if (typeof BrowserMutationObserver === "function") {
            requestFlush = makeRequestCallFromMutationObserver(flush);
        } else {
            requestFlush = makeRequestCallFromTimer(flush);
        }
        rawAsap.requestFlush = requestFlush;
        function makeRequestCallFromMutationObserver(callback) {
            var toggle = 1;
            var observer = new BrowserMutationObserver(callback);
            var node = document.createTextNode("");
            observer.observe(node, {
                characterData: true
            });
            return function requestCall() {
                toggle = -toggle;
                node.data = toggle;
            };
        }
        function makeRequestCallFromTimer(callback) {
            return function requestCall() {
                var timeoutHandle = setTimeout(handleTimer, 0);
                var intervalHandle = setInterval(handleTimer, 50);
                function handleTimer() {
                    clearTimeout(timeoutHandle);
                    clearInterval(intervalHandle);
                    callback();
                }
            };
        }
        rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;
    }
});
// node_modules/promise/lib/core.js
var require_core = __commonJS({
    "node_modules/promise/lib/core.js" (exports, module) {
        "use strict";
        var asap = require_browser_raw();
        function noop3() {}
        var LAST_ERROR = null;
        var IS_ERROR = {};
        function getThen(obj) {
            try {
                return obj.then;
            } catch (ex) {
                LAST_ERROR = ex;
                return IS_ERROR;
            }
        }
        function tryCallOne(fn, a) {
            try {
                return fn(a);
            } catch (ex) {
                LAST_ERROR = ex;
                return IS_ERROR;
            }
        }
        function tryCallTwo(fn, a, b) {
            try {
                fn(a, b);
            } catch (ex) {
                LAST_ERROR = ex;
                return IS_ERROR;
            }
        }
        module.exports = Promise2;
        function Promise2(fn) {
            if (typeof this !== "object") {
                throw new TypeError("Promises must be constructed via new");
            }
            if (typeof fn !== "function") {
                throw new TypeError("Promise constructor's argument is not a function");
            }
            this._x = 0;
            this._y = 0;
            this._z = null;
            this._A = null;
            if (fn === noop3) return;
            doResolve(fn, this);
        }
        Promise2._B = null;
        Promise2._C = null;
        Promise2._D = noop3;
        Promise2.prototype.then = function(onFulfilled, onRejected) {
            if (this.constructor !== Promise2) {
                return safeThen(this, onFulfilled, onRejected);
            }
            var res = new Promise2(noop3);
            handle(this, new Handler(onFulfilled, onRejected, res));
            return res;
        };
        function safeThen(self2, onFulfilled, onRejected) {
            return new self2.constructor(function(resolve2, reject2) {
                var res = new Promise2(noop3);
                res.then(resolve2, reject2);
                handle(self2, new Handler(onFulfilled, onRejected, res));
            });
        }
        function handle(self2, deferred) {
            while(self2._y === 3){
                self2 = self2._z;
            }
            if (Promise2._B) {
                Promise2._B(self2);
            }
            if (self2._y === 0) {
                if (self2._x === 0) {
                    self2._x = 1;
                    self2._A = deferred;
                    return;
                }
                if (self2._x === 1) {
                    self2._x = 2;
                    self2._A = [
                        self2._A,
                        deferred
                    ];
                    return;
                }
                self2._A.push(deferred);
                return;
            }
            handleResolved(self2, deferred);
        }
        function handleResolved(self2, deferred) {
            asap(function() {
                var cb = self2._y === 1 ? deferred.onFulfilled : deferred.onRejected;
                if (cb === null) {
                    if (self2._y === 1) {
                        resolve(deferred.promise, self2._z);
                    } else {
                        reject(deferred.promise, self2._z);
                    }
                    return;
                }
                var ret = tryCallOne(cb, self2._z);
                if (ret === IS_ERROR) {
                    reject(deferred.promise, LAST_ERROR);
                } else {
                    resolve(deferred.promise, ret);
                }
            });
        }
        function resolve(self2, newValue) {
            if (newValue === self2) {
                return reject(self2, new TypeError("A promise cannot be resolved with itself."));
            }
            if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
                var then = getThen(newValue);
                if (then === IS_ERROR) {
                    return reject(self2, LAST_ERROR);
                }
                if (then === self2.then && newValue instanceof Promise2) {
                    self2._y = 3;
                    self2._z = newValue;
                    finale(self2);
                    return;
                } else if (typeof then === "function") {
                    doResolve(then.bind(newValue), self2);
                    return;
                }
            }
            self2._y = 1;
            self2._z = newValue;
            finale(self2);
        }
        function reject(self2, newValue) {
            self2._y = 2;
            self2._z = newValue;
            if (Promise2._C) {
                Promise2._C(self2, newValue);
            }
            finale(self2);
        }
        function finale(self2) {
            if (self2._x === 1) {
                handle(self2, self2._A);
                self2._A = null;
            }
            if (self2._x === 2) {
                for(var i = 0; i < self2._A.length; i++){
                    handle(self2, self2._A[i]);
                }
                self2._A = null;
            }
        }
        function Handler(onFulfilled, onRejected, promise) {
            this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
            this.onRejected = typeof onRejected === "function" ? onRejected : null;
            this.promise = promise;
        }
        function doResolve(fn, promise) {
            var done = false;
            var res = tryCallTwo(fn, function(value) {
                if (done) return;
                done = true;
                resolve(promise, value);
            }, function(reason) {
                if (done) return;
                done = true;
                reject(promise, reason);
            });
            if (!done && res === IS_ERROR) {
                done = true;
                reject(promise, LAST_ERROR);
            }
        }
    }
});
// node_modules/promise/lib/done.js
var require_done = __commonJS({
    "node_modules/promise/lib/done.js" (exports, module) {
        "use strict";
        var Promise2 = require_core();
        module.exports = Promise2;
        Promise2.prototype.done = function(onFulfilled, onRejected) {
            var self2 = arguments.length ? this.then.apply(this, arguments) : this;
            self2.then(null, function(err) {
                setTimeout(function() {
                    throw err;
                }, 0);
            });
        };
    }
});
// node_modules/promise/lib/finally.js
var require_finally = __commonJS({
    "node_modules/promise/lib/finally.js" (exports, module) {
        "use strict";
        var Promise2 = require_core();
        module.exports = Promise2;
        Promise2.prototype.finally = function(f) {
            return this.then(function(value) {
                return Promise2.resolve(f()).then(function() {
                    return value;
                });
            }, function(err) {
                return Promise2.resolve(f()).then(function() {
                    throw err;
                });
            });
        };
    }
});
// node_modules/promise/lib/es6-extensions.js
var require_es6_extensions = __commonJS({
    "node_modules/promise/lib/es6-extensions.js" (exports, module) {
        "use strict";
        var Promise2 = require_core();
        module.exports = Promise2;
        var TRUE = valuePromise(true);
        var FALSE = valuePromise(false);
        var NULL = valuePromise(null);
        var UNDEFINED = valuePromise(void 0);
        var ZERO = valuePromise(0);
        var EMPTYSTRING = valuePromise("");
        function valuePromise(value) {
            var p = new Promise2(Promise2._D);
            p._y = 1;
            p._z = value;
            return p;
        }
        Promise2.resolve = function(value) {
            if (value instanceof Promise2) return value;
            if (value === null) return NULL;
            if (value === void 0) return UNDEFINED;
            if (value === true) return TRUE;
            if (value === false) return FALSE;
            if (value === 0) return ZERO;
            if (value === "") return EMPTYSTRING;
            if (typeof value === "object" || typeof value === "function") {
                try {
                    var then = value.then;
                    if (typeof then === "function") {
                        return new Promise2(then.bind(value));
                    }
                } catch (ex) {
                    return new Promise2(function(resolve, reject) {
                        reject(ex);
                    });
                }
            }
            return valuePromise(value);
        };
        var iterableToArray = function(iterable) {
            if (typeof Array.from === "function") {
                iterableToArray = Array.from;
                return Array.from(iterable);
            }
            iterableToArray = function(x) {
                return Array.prototype.slice.call(x);
            };
            return Array.prototype.slice.call(iterable);
        };
        Promise2.all = function(arr) {
            var args = iterableToArray(arr);
            return new Promise2(function(resolve, reject) {
                if (args.length === 0) return resolve([]);
                var remaining = args.length;
                function res(i2, val) {
                    if (val && (typeof val === "object" || typeof val === "function")) {
                        if (val instanceof Promise2 && val.then === Promise2.prototype.then) {
                            while(val._y === 3){
                                val = val._z;
                            }
                            if (val._y === 1) return res(i2, val._z);
                            if (val._y === 2) reject(val._z);
                            val.then(function(val2) {
                                res(i2, val2);
                            }, reject);
                            return;
                        } else {
                            var then = val.then;
                            if (typeof then === "function") {
                                var p = new Promise2(then.bind(val));
                                p.then(function(val2) {
                                    res(i2, val2);
                                }, reject);
                                return;
                            }
                        }
                    }
                    args[i2] = val;
                    if (--remaining === 0) {
                        resolve(args);
                    }
                }
                for(var i = 0; i < args.length; i++){
                    res(i, args[i]);
                }
            });
        };
        function onSettledFulfill(value) {
            return {
                status: "fulfilled",
                value
            };
        }
        function onSettledReject(reason) {
            return {
                status: "rejected",
                reason
            };
        }
        function mapAllSettled(item) {
            if (item && (typeof item === "object" || typeof item === "function")) {
                if (item instanceof Promise2 && item.then === Promise2.prototype.then) {
                    return item.then(onSettledFulfill, onSettledReject);
                }
                var then = item.then;
                if (typeof then === "function") {
                    return new Promise2(then.bind(item)).then(onSettledFulfill, onSettledReject);
                }
            }
            return onSettledFulfill(item);
        }
        Promise2.allSettled = function(iterable) {
            return Promise2.all(iterableToArray(iterable).map(mapAllSettled));
        };
        Promise2.reject = function(value) {
            return new Promise2(function(resolve, reject) {
                reject(value);
            });
        };
        Promise2.race = function(values2) {
            return new Promise2(function(resolve, reject) {
                iterableToArray(values2).forEach(function(value) {
                    Promise2.resolve(value).then(resolve, reject);
                });
            });
        };
        Promise2.prototype["catch"] = function(onRejected) {
            return this.then(null, onRejected);
        };
        function getAggregateError(errors) {
            if (typeof AggregateError === "function") {
                return new AggregateError(errors, "All promises were rejected");
            }
            var error = new Error("All promises were rejected");
            error.name = "AggregateError";
            error.errors = errors;
            return error;
        }
        Promise2.any = function promiseAny(values2) {
            return new Promise2(function(resolve, reject) {
                var promises = iterableToArray(values2);
                var hasResolved = false;
                var rejectionReasons = [];
                function resolveOnce(value) {
                    if (!hasResolved) {
                        hasResolved = true;
                        resolve(value);
                    }
                }
                function rejectionCheck(reason) {
                    rejectionReasons.push(reason);
                    if (rejectionReasons.length === promises.length) {
                        reject(getAggregateError(rejectionReasons));
                    }
                }
                if (promises.length === 0) {
                    reject(getAggregateError(rejectionReasons));
                } else {
                    promises.forEach(function(value) {
                        Promise2.resolve(value).then(resolveOnce, rejectionCheck);
                    });
                }
            });
        };
    }
});
// node_modules/asap/browser-asap.js
var require_browser_asap = __commonJS({
    "node_modules/asap/browser-asap.js" (exports, module) {
        "use strict";
        var rawAsap = require_browser_raw();
        var freeTasks = [];
        var pendingErrors = [];
        var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);
        function throwFirstError() {
            if (pendingErrors.length) {
                throw pendingErrors.shift();
            }
        }
        module.exports = asap;
        function asap(task) {
            var rawTask;
            if (freeTasks.length) {
                rawTask = freeTasks.pop();
            } else {
                rawTask = new RawTask();
            }
            rawTask.task = task;
            rawAsap(rawTask);
        }
        function RawTask() {
            this.task = null;
        }
        RawTask.prototype.call = function() {
            try {
                this.task.call();
            } catch (error) {
                if (asap.onerror) {
                    asap.onerror(error);
                } else {
                    pendingErrors.push(error);
                    requestErrorThrow();
                }
            } finally{
                this.task = null;
                freeTasks[freeTasks.length] = this;
            }
        };
    }
});
// node_modules/promise/lib/node-extensions.js
var require_node_extensions = __commonJS({
    "node_modules/promise/lib/node-extensions.js" (exports, module) {
        "use strict";
        var Promise2 = require_core();
        var asap = require_browser_asap();
        module.exports = Promise2;
        Promise2.denodeify = function(fn, argumentCount) {
            if (typeof argumentCount === "number" && argumentCount !== Infinity) {
                return denodeifyWithCount(fn, argumentCount);
            } else {
                return denodeifyWithoutCount(fn);
            }
        };
        var callbackFn = "function (err, res) {if (err) { rj(err); } else { rs(res); }}";
        function denodeifyWithCount(fn, argumentCount) {
            var args = [];
            for(var i = 0; i < argumentCount; i++){
                args.push("a" + i);
            }
            var body = [
                "return function (" + args.join(",") + ") {",
                "var self = this;",
                "return new Promise(function (rs, rj) {",
                "var res = fn.call(",
                [
                    "self"
                ].concat(args).concat([
                    callbackFn
                ]).join(","),
                ");",
                "if (res &&",
                '(typeof res === "object" || typeof res === "function") &&',
                'typeof res.then === "function"',
                ") {rs(res);}",
                "});",
                "};"
            ].join("");
            return Function([
                "Promise",
                "fn"
            ], body)(Promise2, fn);
        }
        function denodeifyWithoutCount(fn) {
            var fnLength = Math.max(fn.length - 1, 3);
            var args = [];
            for(var i = 0; i < fnLength; i++){
                args.push("a" + i);
            }
            var body = [
                "return function (" + args.join(",") + ") {",
                "var self = this;",
                "var args;",
                "var argLength = arguments.length;",
                "if (arguments.length > " + fnLength + ") {",
                "args = new Array(arguments.length + 1);",
                "for (var i = 0; i < arguments.length; i++) {",
                "args[i] = arguments[i];",
                "}",
                "}",
                "return new Promise(function (rs, rj) {",
                "var cb = " + callbackFn + ";",
                "var res;",
                "switch (argLength) {",
                args.concat([
                    "extra"
                ]).map(function(_, index) {
                    return "case " + index + ":res = fn.call(" + [
                        "self"
                    ].concat(args.slice(0, index)).concat("cb").join(",") + ");break;";
                }).join(""),
                "default:",
                "args[argLength] = cb;",
                "res = fn.apply(self, args);",
                "}",
                "if (res &&",
                '(typeof res === "object" || typeof res === "function") &&',
                'typeof res.then === "function"',
                ") {rs(res);}",
                "});",
                "};"
            ].join("");
            return Function([
                "Promise",
                "fn"
            ], body)(Promise2, fn);
        }
        Promise2.nodeify = function(fn) {
            return function() {
                var args = Array.prototype.slice.call(arguments);
                var callback = typeof args[args.length - 1] === "function" ? args.pop() : null;
                var ctx = this;
                try {
                    return fn.apply(this, arguments).nodeify(callback, ctx);
                } catch (ex) {
                    if (callback === null || typeof callback == "undefined") {
                        return new Promise2(function(resolve, reject) {
                            reject(ex);
                        });
                    } else {
                        asap(function() {
                            callback.call(ctx, ex);
                        });
                    }
                }
            };
        };
        Promise2.prototype.nodeify = function(callback, ctx) {
            if (typeof callback != "function") return this;
            this.then(function(value) {
                asap(function() {
                    callback.call(ctx, null, value);
                });
            }, function(err) {
                asap(function() {
                    callback.call(ctx, err);
                });
            });
        };
    }
});
// node_modules/promise/lib/synchronous.js
var require_synchronous = __commonJS({
    "node_modules/promise/lib/synchronous.js" (exports, module) {
        "use strict";
        var Promise2 = require_core();
        module.exports = Promise2;
        Promise2.enableSynchronous = function() {
            Promise2.prototype.isPending = function() {
                return this.getState() == 0;
            };
            Promise2.prototype.isFulfilled = function() {
                return this.getState() == 1;
            };
            Promise2.prototype.isRejected = function() {
                return this.getState() == 2;
            };
            Promise2.prototype.getValue = function() {
                if (this._y === 3) {
                    return this._z.getValue();
                }
                if (!this.isFulfilled()) {
                    throw new Error("Cannot get a value of an unfulfilled promise.");
                }
                return this._z;
            };
            Promise2.prototype.getReason = function() {
                if (this._y === 3) {
                    return this._z.getReason();
                }
                if (!this.isRejected()) {
                    throw new Error("Cannot get a rejection reason of a non-rejected promise.");
                }
                return this._z;
            };
            Promise2.prototype.getState = function() {
                if (this._y === 3) {
                    return this._z.getState();
                }
                if (this._y === -1 || this._y === -2) {
                    return 0;
                }
                return this._y;
            };
        };
        Promise2.disableSynchronous = function() {
            Promise2.prototype.isPending = void 0;
            Promise2.prototype.isFulfilled = void 0;
            Promise2.prototype.isRejected = void 0;
            Promise2.prototype.getValue = void 0;
            Promise2.prototype.getReason = void 0;
            Promise2.prototype.getState = void 0;
        };
    }
});
// node_modules/promise/lib/index.js
var require_lib = __commonJS({
    "node_modules/promise/lib/index.js" (exports, module) {
        "use strict";
        module.exports = require_core();
        require_done();
        require_finally();
        require_es6_extensions();
        require_node_extensions();
        require_synchronous();
    }
});
// node_modules/promise/index.js
var require_promise = __commonJS({
    "node_modules/promise/index.js" (exports, module) {
        "use strict";
        module.exports = require_lib();
    }
});
// node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
    "node_modules/lodash/_baseSlice.js" (exports, module) {
        function baseSlice(array, start, end) {
            var index = -1, length = array.length;
            if (start < 0) {
                start = -start > length ? 0 : length + start;
            }
            end = end > length ? length : end;
            if (end < 0) {
                end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result = Array(length);
            while(++index < length){
                result[index] = array[index + start];
            }
            return result;
        }
        module.exports = baseSlice;
    }
});
// node_modules/lodash/_castSlice.js
var require_castSlice = __commonJS({
    "node_modules/lodash/_castSlice.js" (exports, module) {
        var baseSlice = require_baseSlice();
        function castSlice(array, start, end) {
            var length = array.length;
            end = end === void 0 ? length : end;
            return !start && end >= length ? array : baseSlice(array, start, end);
        }
        module.exports = castSlice;
    }
});
// node_modules/lodash/_baseIsRegExp.js
var require_baseIsRegExp = __commonJS({
    "node_modules/lodash/_baseIsRegExp.js" (exports, module) {
        var baseGetTag = require_baseGetTag();
        var isObjectLike = require_isObjectLike();
        var regexpTag = "[object RegExp]";
        function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        module.exports = baseIsRegExp;
    }
});
// node_modules/lodash/isRegExp.js
var require_isRegExp = __commonJS({
    "node_modules/lodash/isRegExp.js" (exports, module) {
        var baseIsRegExp = require_baseIsRegExp();
        var baseUnary = require_baseUnary();
        var nodeUtil = require_nodeUtil();
        var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        module.exports = isRegExp;
    }
});
// node_modules/lodash/_asciiToArray.js
var require_asciiToArray = __commonJS({
    "node_modules/lodash/_asciiToArray.js" (exports, module) {
        function asciiToArray(string) {
            return string.split("");
        }
        module.exports = asciiToArray;
    }
});
// node_modules/lodash/_unicodeToArray.js
var require_unicodeToArray = __commonJS({
    "node_modules/lodash/_unicodeToArray.js" (exports, module) {
        var rsAstralRange = "\\ud800-\\udfff";
        var rsComboMarksRange = "\\u0300-\\u036f";
        var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
        var rsComboSymbolsRange = "\\u20d0-\\u20ff";
        var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
        var rsVarRange = "\\ufe0e\\ufe0f";
        var rsAstral = "[" + rsAstralRange + "]";
        var rsCombo = "[" + rsComboRange + "]";
        var rsFitz = "\\ud83c[\\udffb-\\udfff]";
        var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
        var rsNonAstral = "[^" + rsAstralRange + "]";
        var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
        var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
        var rsZWJ = "\\u200d";
        var reOptMod = rsModifier + "?";
        var rsOptVar = "[" + rsVarRange + "]?";
        var rsOptJoin = "(?:" + rsZWJ + "(?:" + [
            rsNonAstral,
            rsRegional,
            rsSurrPair
        ].join("|") + ")" + rsOptVar + reOptMod + ")*";
        var rsSeq = rsOptVar + reOptMod + rsOptJoin;
        var rsSymbol = "(?:" + [
            rsNonAstral + rsCombo + "?",
            rsCombo,
            rsRegional,
            rsSurrPair,
            rsAstral
        ].join("|") + ")";
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        function unicodeToArray(string) {
            return string.match(reUnicode) || [];
        }
        module.exports = unicodeToArray;
    }
});
// node_modules/lodash/_stringToArray.js
var require_stringToArray = __commonJS({
    "node_modules/lodash/_stringToArray.js" (exports, module) {
        var asciiToArray = require_asciiToArray();
        var hasUnicode = require_hasUnicode();
        var unicodeToArray = require_unicodeToArray();
        function stringToArray(string) {
            return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        module.exports = stringToArray;
    }
});
// node_modules/lodash/split.js
var require_split = __commonJS({
    "node_modules/lodash/split.js" (exports, module) {
        var baseToString = require_baseToString();
        var castSlice = require_castSlice();
        var hasUnicode = require_hasUnicode();
        var isIterateeCall = require_isIterateeCall();
        var isRegExp = require_isRegExp();
        var stringToArray = require_stringToArray();
        var toString2 = require_toString();
        var MAX_ARRAY_LENGTH = 4294967295;
        function split(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
                separator = limit = void 0;
            }
            limit = limit === void 0 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
                return [];
            }
            string = toString2(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
                separator = baseToString(separator);
                if (!separator && hasUnicode(string)) {
                    return castSlice(stringToArray(string), 0, limit);
                }
            }
            return string.split(separator, limit);
        }
        module.exports = split;
    }
});
// node_modules/lodash/uniqueId.js
var require_uniqueId = __commonJS({
    "node_modules/lodash/uniqueId.js" (exports, module) {
        var toString2 = require_toString();
        var idCounter = 0;
        function uniqueId(prefix) {
            var id = ++idCounter;
            return toString2(prefix) + id;
        }
        module.exports = uniqueId;
    }
});
// node_modules/lodash/isEqual.js
var require_isEqual = __commonJS({
    "node_modules/lodash/isEqual.js" (exports, module) {
        var baseIsEqual = require_baseIsEqual();
        function isEqual2(value, other) {
            return baseIsEqual(value, other);
        }
        module.exports = isEqual2;
    }
});
// node_modules/lodash/_baseRepeat.js
var require_baseRepeat = __commonJS({
    "node_modules/lodash/_baseRepeat.js" (exports, module) {
        var MAX_SAFE_INTEGER = 9007199254740991;
        var nativeFloor = Math.floor;
        function baseRepeat(string, n) {
            var result = "";
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                return result;
            }
            do {
                if (n % 2) {
                    result += string;
                }
                n = nativeFloor(n / 2);
                if (n) {
                    string += string;
                }
            }while (n)
            return result;
        }
        module.exports = baseRepeat;
    }
});
// node_modules/lodash/_createPadding.js
var require_createPadding = __commonJS({
    "node_modules/lodash/_createPadding.js" (exports, module) {
        var baseRepeat = require_baseRepeat();
        var baseToString = require_baseToString();
        var castSlice = require_castSlice();
        var hasUnicode = require_hasUnicode();
        var stringSize = require_stringSize();
        var stringToArray = require_stringToArray();
        var nativeCeil = Math.ceil;
        function createPadding(length, chars) {
            chars = chars === void 0 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
                return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join("") : result.slice(0, length);
        }
        module.exports = createPadding;
    }
});
// node_modules/lodash/padEnd.js
var require_padEnd = __commonJS({
    "node_modules/lodash/padEnd.js" (exports, module) {
        var createPadding = require_createPadding();
        var stringSize = require_stringSize();
        var toInteger = require_toInteger();
        var toString2 = require_toString();
        function padEnd(string, length, chars) {
            string = toString2(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        module.exports = padEnd;
    }
});
// node_modules/lodash/startsWith.js
var require_startsWith = __commonJS({
    "node_modules/lodash/startsWith.js" (exports, module) {
        var baseClamp = require_baseClamp();
        var baseToString = require_baseToString();
        var toInteger = require_toInteger();
        var toString2 = require_toString();
        function startsWith(string, target, position) {
            string = toString2(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
        }
        module.exports = startsWith;
    }
});
// node_modules/lodash/_createFind.js
var require_createFind = __commonJS({
    "node_modules/lodash/_createFind.js" (exports, module) {
        var baseIteratee = require_baseIteratee();
        var isArrayLike = require_isArrayLike();
        var keys = require_keys();
        function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
                var iterable = Object(collection);
                if (!isArrayLike(collection)) {
                    var iteratee = baseIteratee(predicate, 3);
                    collection = keys(collection);
                    predicate = function(key) {
                        return iteratee(iterable[key], key, iterable);
                    };
                }
                var index = findIndexFunc(collection, predicate, fromIndex);
                return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
            };
        }
        module.exports = createFind;
    }
});
// node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
    "node_modules/lodash/_baseFindIndex.js" (exports, module) {
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
            var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
            while(fromRight ? index-- : ++index < length){
                if (predicate(array[index], index, array)) {
                    return index;
                }
            }
            return -1;
        }
        module.exports = baseFindIndex;
    }
});
// node_modules/lodash/findIndex.js
var require_findIndex = __commonJS({
    "node_modules/lodash/findIndex.js" (exports, module) {
        var baseFindIndex = require_baseFindIndex();
        var baseIteratee = require_baseIteratee();
        var toInteger = require_toInteger();
        var nativeMax = Math.max;
        function findIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
                return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
                index = nativeMax(length + index, 0);
            }
            return baseFindIndex(array, baseIteratee(predicate, 3), index);
        }
        module.exports = findIndex;
    }
});
// node_modules/lodash/find.js
var require_find = __commonJS({
    "node_modules/lodash/find.js" (exports, module) {
        var createFind = require_createFind();
        var findIndex = require_findIndex();
        var find = createFind(findIndex);
        module.exports = find;
    }
});
// node_modules/lodash/clamp.js
var require_clamp = __commonJS({
    "node_modules/lodash/clamp.js" (exports, module) {
        var baseClamp = require_baseClamp();
        var toNumber = require_toNumber();
        function clamp(number, lower, upper) {
            if (upper === void 0) {
                upper = lower;
                lower = void 0;
            }
            if (upper !== void 0) {
                upper = toNumber(upper);
                upper = upper === upper ? upper : 0;
            }
            if (lower !== void 0) {
                lower = toNumber(lower);
                lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number), lower, upper);
        }
        module.exports = clamp;
    }
});
// node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
    "node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js" (exports) {
        "use strict";
        if (true) {
            (function() {
                "use strict";
                var hasSymbol = typeof Symbol === "function" && Symbol.for;
                var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
                var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
                var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
                var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
                var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
                var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
                var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
                var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
                var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
                var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
                var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
                var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
                var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
                var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
                var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
                var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
                var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
                var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
                function isValidElementType(type) {
                    return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
                    type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
                }
                function typeOf(object) {
                    if (typeof object === "object" && object !== null) {
                        var $$typeof = object.$$typeof;
                        switch($$typeof){
                            case REACT_ELEMENT_TYPE:
                                var type = object.type;
                                switch(type){
                                    case REACT_ASYNC_MODE_TYPE:
                                    case REACT_CONCURRENT_MODE_TYPE:
                                    case REACT_FRAGMENT_TYPE:
                                    case REACT_PROFILER_TYPE:
                                    case REACT_STRICT_MODE_TYPE:
                                    case REACT_SUSPENSE_TYPE:
                                        return type;
                                    default:
                                        var $$typeofType = type && type.$$typeof;
                                        switch($$typeofType){
                                            case REACT_CONTEXT_TYPE:
                                            case REACT_FORWARD_REF_TYPE:
                                            case REACT_LAZY_TYPE:
                                            case REACT_MEMO_TYPE:
                                            case REACT_PROVIDER_TYPE:
                                                return $$typeofType;
                                            default:
                                                return $$typeof;
                                        }
                                }
                            case REACT_PORTAL_TYPE:
                                return $$typeof;
                        }
                    }
                    return void 0;
                }
                var AsyncMode = REACT_ASYNC_MODE_TYPE;
                var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
                var ContextConsumer = REACT_CONTEXT_TYPE;
                var ContextProvider = REACT_PROVIDER_TYPE;
                var Element2 = REACT_ELEMENT_TYPE;
                var ForwardRef = REACT_FORWARD_REF_TYPE;
                var Fragment20 = REACT_FRAGMENT_TYPE;
                var Lazy = REACT_LAZY_TYPE;
                var Memo = REACT_MEMO_TYPE;
                var Portal = REACT_PORTAL_TYPE;
                var Profiler = REACT_PROFILER_TYPE;
                var StrictMode = REACT_STRICT_MODE_TYPE;
                var Suspense = REACT_SUSPENSE_TYPE;
                var hasWarnedAboutDeprecatedIsAsyncMode = false;
                function isAsyncMode(object) {
                    {
                        if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                            hasWarnedAboutDeprecatedIsAsyncMode = true;
                            console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
                        }
                    }
                    return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
                }
                function isConcurrentMode(object) {
                    return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
                }
                function isContextConsumer(object) {
                    return typeOf(object) === REACT_CONTEXT_TYPE;
                }
                function isContextProvider(object) {
                    return typeOf(object) === REACT_PROVIDER_TYPE;
                }
                function isElement(object) {
                    return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
                }
                function isForwardRef(object) {
                    return typeOf(object) === REACT_FORWARD_REF_TYPE;
                }
                function isFragment2(object) {
                    return typeOf(object) === REACT_FRAGMENT_TYPE;
                }
                function isLazy(object) {
                    return typeOf(object) === REACT_LAZY_TYPE;
                }
                function isMemo(object) {
                    return typeOf(object) === REACT_MEMO_TYPE;
                }
                function isPortal(object) {
                    return typeOf(object) === REACT_PORTAL_TYPE;
                }
                function isProfiler(object) {
                    return typeOf(object) === REACT_PROFILER_TYPE;
                }
                function isStrictMode(object) {
                    return typeOf(object) === REACT_STRICT_MODE_TYPE;
                }
                function isSuspense(object) {
                    return typeOf(object) === REACT_SUSPENSE_TYPE;
                }
                exports.AsyncMode = AsyncMode;
                exports.ConcurrentMode = ConcurrentMode;
                exports.ContextConsumer = ContextConsumer;
                exports.ContextProvider = ContextProvider;
                exports.Element = Element2;
                exports.ForwardRef = ForwardRef;
                exports.Fragment = Fragment20;
                exports.Lazy = Lazy;
                exports.Memo = Memo;
                exports.Portal = Portal;
                exports.Profiler = Profiler;
                exports.StrictMode = StrictMode;
                exports.Suspense = Suspense;
                exports.isAsyncMode = isAsyncMode;
                exports.isConcurrentMode = isConcurrentMode;
                exports.isContextConsumer = isContextConsumer;
                exports.isContextProvider = isContextProvider;
                exports.isElement = isElement;
                exports.isForwardRef = isForwardRef;
                exports.isFragment = isFragment2;
                exports.isLazy = isLazy;
                exports.isMemo = isMemo;
                exports.isPortal = isPortal;
                exports.isProfiler = isProfiler;
                exports.isStrictMode = isStrictMode;
                exports.isSuspense = isSuspense;
                exports.isValidElementType = isValidElementType;
                exports.typeOf = typeOf;
            })();
        }
    }
});
// node_modules/prop-types/node_modules/react-is/index.js
var require_react_is = __commonJS({
    "node_modules/prop-types/node_modules/react-is/index.js" (exports, module) {
        "use strict";
        if (false) {
            module.exports = null;
        } else {
            module.exports = require_react_is_development();
        }
    }
});
// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
    "node_modules/object-assign/index.js" (exports, module) {
        "use strict";
        var getOwnPropertySymbols = Object.getOwnPropertySymbols;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var propIsEnumerable = Object.prototype.propertyIsEnumerable;
        function toObject(val) {
            if (val === null || val === void 0) {
                throw new TypeError("Object.assign cannot be called with null or undefined");
            }
            return Object(val);
        }
        function shouldUseNative() {
            try {
                if (!Object.assign) {
                    return false;
                }
                var test1 = new String("abc");
                test1[5] = "de";
                if (Object.getOwnPropertyNames(test1)[0] === "5") {
                    return false;
                }
                var test2 = {};
                for(var i = 0; i < 10; i++){
                    test2["_" + String.fromCharCode(i)] = i;
                }
                var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
                    return test2[n];
                });
                if (order2.join("") !== "0123456789") {
                    return false;
                }
                var test3 = {};
                "abcdefghijklmnopqrst".split("").forEach(function(letter) {
                    test3[letter] = letter;
                });
                if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
                    return false;
                }
                return true;
            } catch (err) {
                return false;
            }
        }
        module.exports = shouldUseNative() ? Object.assign : function(target, source) {
            var from;
            var to = toObject(target);
            var symbols;
            for(var s = 1; s < arguments.length; s++){
                from = Object(arguments[s]);
                for(var key in from){
                    if (hasOwnProperty.call(from, key)) {
                        to[key] = from[key];
                    }
                }
                if (getOwnPropertySymbols) {
                    symbols = getOwnPropertySymbols(from);
                    for(var i = 0; i < symbols.length; i++){
                        if (propIsEnumerable.call(from, symbols[i])) {
                            to[symbols[i]] = from[symbols[i]];
                        }
                    }
                }
            }
            return to;
        };
    }
});
// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
    "node_modules/prop-types/lib/ReactPropTypesSecret.js" (exports, module) {
        "use strict";
        var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
        module.exports = ReactPropTypesSecret;
    }
});
// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
    "node_modules/prop-types/lib/has.js" (exports, module) {
        module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
    }
});
// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
    "node_modules/prop-types/checkPropTypes.js" (exports, module) {
        "use strict";
        var printWarning = function() {};
        if (true) {
            ReactPropTypesSecret = require_ReactPropTypesSecret();
            loggedTypeFailures = {};
            has = require_has();
            printWarning = function(text) {
                var message = "Warning: " + text;
                if (typeof console !== "undefined") {
                    console.error(message);
                }
                try {
                    throw new Error(message);
                } catch (x) {}
            };
        }
        var ReactPropTypesSecret;
        var loggedTypeFailures;
        var has;
        function checkPropTypes(typeSpecs, values2, location, componentName, getStack) {
            if (true) {
                for(var typeSpecName in typeSpecs){
                    if (has(typeSpecs, typeSpecName)) {
                        var error;
                        try {
                            if (typeof typeSpecs[typeSpecName] !== "function") {
                                var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                                err.name = "Invariant Violation";
                                throw err;
                            }
                            error = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, ReactPropTypesSecret);
                        } catch (ex) {
                            error = ex;
                        }
                        if (error && !(error instanceof Error)) {
                            printWarning((componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).");
                        }
                        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                            loggedTypeFailures[error.message] = true;
                            var stack = getStack ? getStack() : "";
                            printWarning("Failed " + location + " type: " + error.message + (stack != null ? stack : ""));
                        }
                    }
                }
            }
        }
        checkPropTypes.resetWarningCache = function() {
            if (true) {
                loggedTypeFailures = {};
            }
        };
        module.exports = checkPropTypes;
    }
});
// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
    "node_modules/prop-types/factoryWithTypeCheckers.js" (exports, module) {
        "use strict";
        var ReactIs = require_react_is();
        var assign = require_object_assign();
        var ReactPropTypesSecret = require_ReactPropTypesSecret();
        var has = require_has();
        var checkPropTypes = require_checkPropTypes();
        var printWarning = function() {};
        if (true) {
            printWarning = function(text) {
                var message = "Warning: " + text;
                if (typeof console !== "undefined") {
                    console.error(message);
                }
                try {
                    throw new Error(message);
                } catch (x) {}
            };
        }
        function emptyFunctionThatReturnsNull() {
            return null;
        }
        module.exports = function(isValidElement54, throwOnDirectAccess) {
            var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
            var FAUX_ITERATOR_SYMBOL = "@@iterator";
            function getIteratorFn(maybeIterable) {
                var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
                if (typeof iteratorFn === "function") {
                    return iteratorFn;
                }
            }
            var ANONYMOUS = "<<anonymous>>";
            var ReactPropTypes = {
                array: createPrimitiveTypeChecker("array"),
                bigint: createPrimitiveTypeChecker("bigint"),
                bool: createPrimitiveTypeChecker("boolean"),
                func: createPrimitiveTypeChecker("function"),
                number: createPrimitiveTypeChecker("number"),
                object: createPrimitiveTypeChecker("object"),
                string: createPrimitiveTypeChecker("string"),
                symbol: createPrimitiveTypeChecker("symbol"),
                any: createAnyTypeChecker(),
                arrayOf: createArrayOfTypeChecker,
                element: createElementTypeChecker(),
                elementType: createElementTypeTypeChecker(),
                instanceOf: createInstanceTypeChecker,
                node: createNodeChecker(),
                objectOf: createObjectOfTypeChecker,
                oneOf: createEnumTypeChecker,
                oneOfType: createUnionTypeChecker,
                shape: createShapeTypeChecker,
                exact: createStrictShapeTypeChecker
            };
            function is(x, y) {
                if (x === y) {
                    return x !== 0 || 1 / x === 1 / y;
                } else {
                    return x !== x && y !== y;
                }
            }
            function PropTypeError(message, data) {
                this.message = message;
                this.data = data && typeof data === "object" ? data : {};
                this.stack = "";
            }
            PropTypeError.prototype = Error.prototype;
            function createChainableTypeChecker(validate) {
                if (true) {
                    var manualPropTypeCallCache = {};
                    var manualPropTypeWarningCount = 0;
                }
                function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
                    componentName = componentName || ANONYMOUS;
                    propFullName = propFullName || propName;
                    if (secret !== ReactPropTypesSecret) {
                        if (throwOnDirectAccess) {
                            var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
                            err.name = "Invariant Violation";
                            throw err;
                        } else if (typeof console !== "undefined") {
                            var cacheKey = componentName + ":" + propName;
                            if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
                            manualPropTypeWarningCount < 3) {
                                printWarning("You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.");
                                manualPropTypeCallCache[cacheKey] = true;
                                manualPropTypeWarningCount++;
                            }
                        }
                    }
                    if (props[propName] == null) {
                        if (isRequired) {
                            if (props[propName] === null) {
                                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
                            }
                            return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
                        }
                        return null;
                    } else {
                        return validate(props, propName, componentName, location, propFullName);
                    }
                }
                var chainedCheckType = checkType.bind(null, false);
                chainedCheckType.isRequired = checkType.bind(null, true);
                return chainedCheckType;
            }
            function createPrimitiveTypeChecker(expectedType) {
                function validate(props, propName, componentName, location, propFullName, secret) {
                    var propValue = props[propName];
                    var propType = getPropType(propValue);
                    if (propType !== expectedType) {
                        var preciseType = getPreciseType(propValue);
                        return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."), {
                            expectedType
                        });
                    }
                    return null;
                }
                return createChainableTypeChecker(validate);
            }
            function createAnyTypeChecker() {
                return createChainableTypeChecker(emptyFunctionThatReturnsNull);
            }
            function createArrayOfTypeChecker(typeChecker) {
                function validate(props, propName, componentName, location, propFullName) {
                    if (typeof typeChecker !== "function") {
                        return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
                    }
                    var propValue = props[propName];
                    if (!Array.isArray(propValue)) {
                        var propType = getPropType(propValue);
                        return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
                    }
                    for(var i = 0; i < propValue.length; i++){
                        var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
                        if (error instanceof Error) {
                            return error;
                        }
                    }
                    return null;
                }
                return createChainableTypeChecker(validate);
            }
            function createElementTypeChecker() {
                function validate(props, propName, componentName, location, propFullName) {
                    var propValue = props[propName];
                    if (!isValidElement54(propValue)) {
                        var propType = getPropType(propValue);
                        return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
                    }
                    return null;
                }
                return createChainableTypeChecker(validate);
            }
            function createElementTypeTypeChecker() {
                function validate(props, propName, componentName, location, propFullName) {
                    var propValue = props[propName];
                    if (!ReactIs.isValidElementType(propValue)) {
                        var propType = getPropType(propValue);
                        return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
                    }
                    return null;
                }
                return createChainableTypeChecker(validate);
            }
            function createInstanceTypeChecker(expectedClass) {
                function validate(props, propName, componentName, location, propFullName) {
                    if (!(props[propName] instanceof expectedClass)) {
                        var expectedClassName = expectedClass.name || ANONYMOUS;
                        var actualClassName = getClassName(props[propName]);
                        return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
                    }
                    return null;
                }
                return createChainableTypeChecker(validate);
            }
            function createEnumTypeChecker(expectedValues) {
                if (!Array.isArray(expectedValues)) {
                    if (true) {
                        if (arguments.length > 1) {
                            printWarning("Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).");
                        } else {
                            printWarning("Invalid argument supplied to oneOf, expected an array.");
                        }
                    }
                    return emptyFunctionThatReturnsNull;
                }
                function validate(props, propName, componentName, location, propFullName) {
                    var propValue = props[propName];
                    for(var i = 0; i < expectedValues.length; i++){
                        if (is(propValue, expectedValues[i])) {
                            return null;
                        }
                    }
                    var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
                        var type = getPreciseType(value);
                        if (type === "symbol") {
                            return String(value);
                        }
                        return value;
                    });
                    return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
                }
                return createChainableTypeChecker(validate);
            }
            function createObjectOfTypeChecker(typeChecker) {
                function validate(props, propName, componentName, location, propFullName) {
                    if (typeof typeChecker !== "function") {
                        return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
                    }
                    var propValue = props[propName];
                    var propType = getPropType(propValue);
                    if (propType !== "object") {
                        return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
                    }
                    for(var key in propValue){
                        if (has(propValue, key)) {
                            var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                            if (error instanceof Error) {
                                return error;
                            }
                        }
                    }
                    return null;
                }
                return createChainableTypeChecker(validate);
            }
            function createUnionTypeChecker(arrayOfTypeCheckers) {
                if (!Array.isArray(arrayOfTypeCheckers)) {
                    true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
                    return emptyFunctionThatReturnsNull;
                }
                for(var i = 0; i < arrayOfTypeCheckers.length; i++){
                    var checker = arrayOfTypeCheckers[i];
                    if (typeof checker !== "function") {
                        printWarning("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + ".");
                        return emptyFunctionThatReturnsNull;
                    }
                }
                function validate(props, propName, componentName, location, propFullName) {
                    var expectedTypes = [];
                    for(var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++){
                        var checker2 = arrayOfTypeCheckers[i2];
                        var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
                        if (checkerResult == null) {
                            return null;
                        }
                        if (checkerResult.data && has(checkerResult.data, "expectedType")) {
                            expectedTypes.push(checkerResult.data.expectedType);
                        }
                    }
                    var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
                    return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
                }
                return createChainableTypeChecker(validate);
            }
            function createNodeChecker() {
                function validate(props, propName, componentName, location, propFullName) {
                    if (!isNode(props[propName])) {
                        return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
                    }
                    return null;
                }
                return createChainableTypeChecker(validate);
            }
            function invalidValidatorError(componentName, location, propFullName, key, type) {
                return new PropTypeError((componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`.");
            }
            function createShapeTypeChecker(shapeTypes) {
                function validate(props, propName, componentName, location, propFullName) {
                    var propValue = props[propName];
                    var propType = getPropType(propValue);
                    if (propType !== "object") {
                        return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
                    }
                    for(var key in shapeTypes){
                        var checker = shapeTypes[key];
                        if (typeof checker !== "function") {
                            return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
                        }
                        var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                        if (error) {
                            return error;
                        }
                    }
                    return null;
                }
                return createChainableTypeChecker(validate);
            }
            function createStrictShapeTypeChecker(shapeTypes) {
                function validate(props, propName, componentName, location, propFullName) {
                    var propValue = props[propName];
                    var propType = getPropType(propValue);
                    if (propType !== "object") {
                        return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
                    }
                    var allKeys = assign({}, props[propName], shapeTypes);
                    for(var key in allKeys){
                        var checker = shapeTypes[key];
                        if (has(shapeTypes, key) && typeof checker !== "function") {
                            return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
                        }
                        if (!checker) {
                            return new PropTypeError("Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  "));
                        }
                        var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                        if (error) {
                            return error;
                        }
                    }
                    return null;
                }
                return createChainableTypeChecker(validate);
            }
            function isNode(propValue) {
                switch(typeof propValue){
                    case "number":
                    case "string":
                    case "undefined":
                        return true;
                    case "boolean":
                        return !propValue;
                    case "object":
                        if (Array.isArray(propValue)) {
                            return propValue.every(isNode);
                        }
                        if (propValue === null || isValidElement54(propValue)) {
                            return true;
                        }
                        var iteratorFn = getIteratorFn(propValue);
                        if (iteratorFn) {
                            var iterator = iteratorFn.call(propValue);
                            var step;
                            if (iteratorFn !== propValue.entries) {
                                while(!(step = iterator.next()).done){
                                    if (!isNode(step.value)) {
                                        return false;
                                    }
                                }
                            } else {
                                while(!(step = iterator.next()).done){
                                    var entry = step.value;
                                    if (entry) {
                                        if (!isNode(entry[1])) {
                                            return false;
                                        }
                                    }
                                }
                            }
                        } else {
                            return false;
                        }
                        return true;
                    default:
                        return false;
                }
            }
            function isSymbol(propType, propValue) {
                if (propType === "symbol") {
                    return true;
                }
                if (!propValue) {
                    return false;
                }
                if (propValue["@@toStringTag"] === "Symbol") {
                    return true;
                }
                if (typeof Symbol === "function" && propValue instanceof Symbol) {
                    return true;
                }
                return false;
            }
            function getPropType(propValue) {
                var propType = typeof propValue;
                if (Array.isArray(propValue)) {
                    return "array";
                }
                if (propValue instanceof RegExp) {
                    return "object";
                }
                if (isSymbol(propType, propValue)) {
                    return "symbol";
                }
                return propType;
            }
            function getPreciseType(propValue) {
                if (typeof propValue === "undefined" || propValue === null) {
                    return "" + propValue;
                }
                var propType = getPropType(propValue);
                if (propType === "object") {
                    if (propValue instanceof Date) {
                        return "date";
                    } else if (propValue instanceof RegExp) {
                        return "regexp";
                    }
                }
                return propType;
            }
            function getPostfixForTypeWarning(value) {
                var type = getPreciseType(value);
                switch(type){
                    case "array":
                    case "object":
                        return "an " + type;
                    case "boolean":
                    case "date":
                    case "regexp":
                        return "a " + type;
                    default:
                        return type;
                }
            }
            function getClassName(propValue) {
                if (!propValue.constructor || !propValue.constructor.name) {
                    return ANONYMOUS;
                }
                return propValue.constructor.name;
            }
            ReactPropTypes.checkPropTypes = checkPropTypes;
            ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
            ReactPropTypes.PropTypes = ReactPropTypes;
            return ReactPropTypes;
        };
    }
});
// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
    "node_modules/prop-types/index.js" (exports, module) {
        if (true) {
            ReactIs = require_react_is();
            throwOnDirectAccess = true;
            module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
        } else {
            module.exports = (null)();
        }
        var ReactIs;
        var throwOnDirectAccess;
    }
});
// node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
    "node_modules/lodash/_defineProperty.js" (exports, module) {
        var getNative = require_getNative();
        var defineProperty = function() {
            try {
                var func = getNative(Object, "defineProperty");
                func({}, "", {});
                return func;
            } catch (e) {}
        }();
        module.exports = defineProperty;
    }
});
// node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
    "node_modules/lodash/_baseAssignValue.js" (exports, module) {
        var defineProperty = require_defineProperty();
        function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
                defineProperty(object, key, {
                    "configurable": true,
                    "enumerable": true,
                    "value": value,
                    "writable": true
                });
            } else {
                object[key] = value;
            }
        }
        module.exports = baseAssignValue;
    }
});
// node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
    "node_modules/lodash/_assignValue.js" (exports, module) {
        var baseAssignValue = require_baseAssignValue();
        var eq = require_eq();
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
                baseAssignValue(object, key, value);
            }
        }
        module.exports = assignValue;
    }
});
// node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
    "node_modules/lodash/_copyObject.js" (exports, module) {
        var assignValue = require_assignValue();
        var baseAssignValue = require_baseAssignValue();
        function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length = props.length;
            while(++index < length){
                var key = props[index];
                var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
                if (newValue === void 0) {
                    newValue = source[key];
                }
                if (isNew) {
                    baseAssignValue(object, key, newValue);
                } else {
                    assignValue(object, key, newValue);
                }
            }
            return object;
        }
        module.exports = copyObject;
    }
});
// node_modules/lodash/_apply.js
var require_apply = __commonJS({
    "node_modules/lodash/_apply.js" (exports, module) {
        function apply(func, thisArg, args) {
            switch(args.length){
                case 0:
                    return func.call(thisArg);
                case 1:
                    return func.call(thisArg, args[0]);
                case 2:
                    return func.call(thisArg, args[0], args[1]);
                case 3:
                    return func.call(thisArg, args[0], args[1], args[2]);
            }
            return func.apply(thisArg, args);
        }
        module.exports = apply;
    }
});
// node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
    "node_modules/lodash/_overRest.js" (exports, module) {
        var apply = require_apply();
        var nativeMax = Math.max;
        function overRest(func, start, transform) {
            start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
            return function() {
                var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
                while(++index < length){
                    array[index] = args[start + index];
                }
                index = -1;
                var otherArgs = Array(start + 1);
                while(++index < start){
                    otherArgs[index] = args[index];
                }
                otherArgs[start] = transform(array);
                return apply(func, this, otherArgs);
            };
        }
        module.exports = overRest;
    }
});
// node_modules/lodash/constant.js
var require_constant = __commonJS({
    "node_modules/lodash/constant.js" (exports, module) {
        function constant(value) {
            return function() {
                return value;
            };
        }
        module.exports = constant;
    }
});
// node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
    "node_modules/lodash/_baseSetToString.js" (exports, module) {
        var constant = require_constant();
        var defineProperty = require_defineProperty();
        var identity = require_identity();
        var baseSetToString = !defineProperty ? identity : function(func, string) {
            return defineProperty(func, "toString", {
                "configurable": true,
                "enumerable": false,
                "value": constant(string),
                "writable": true
            });
        };
        module.exports = baseSetToString;
    }
});
// node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
    "node_modules/lodash/_shortOut.js" (exports, module) {
        var HOT_COUNT = 800;
        var HOT_SPAN = 16;
        var nativeNow = Date.now;
        function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
                var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                lastCalled = stamp;
                if (remaining > 0) {
                    if (++count >= HOT_COUNT) {
                        return arguments[0];
                    }
                } else {
                    count = 0;
                }
                return func.apply(void 0, arguments);
            };
        }
        module.exports = shortOut;
    }
});
// node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
    "node_modules/lodash/_setToString.js" (exports, module) {
        var baseSetToString = require_baseSetToString();
        var shortOut = require_shortOut();
        var setToString = shortOut(baseSetToString);
        module.exports = setToString;
    }
});
// node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
    "node_modules/lodash/_baseRest.js" (exports, module) {
        var identity = require_identity();
        var overRest = require_overRest();
        var setToString = require_setToString();
        function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + "");
        }
        module.exports = baseRest;
    }
});
// node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
    "node_modules/lodash/_createAssigner.js" (exports, module) {
        var baseRest = require_baseRest();
        var isIterateeCall = require_isIterateeCall();
        function createAssigner(assigner) {
            return baseRest(function(object, sources) {
                var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
                customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? void 0 : customizer;
                    length = 1;
                }
                object = Object(object);
                while(++index < length){
                    var source = sources[index];
                    if (source) {
                        assigner(object, source, index, customizer);
                    }
                }
                return object;
            });
        }
        module.exports = createAssigner;
    }
});
// node_modules/lodash/assign.js
var require_assign = __commonJS({
    "node_modules/lodash/assign.js" (exports, module) {
        var assignValue = require_assignValue();
        var copyObject = require_copyObject();
        var createAssigner = require_createAssigner();
        var isArrayLike = require_isArrayLike();
        var isPrototype = require_isPrototype();
        var keys = require_keys();
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var assign = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
                copyObject(source, keys(source), object);
                return;
            }
            for(var key in source){
                if (hasOwnProperty.call(source, key)) {
                    assignValue(object, key, source[key]);
                }
            }
        });
        module.exports = assign;
    }
});
// node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
    "node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js" (exports) {
        "use strict";
        if (true) {
            (function() {
                "use strict";
                if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
                    __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
                }
                var enableSchedulerDebugging = false;
                var enableProfiling = false;
                var frameYieldMs = 5;
                function push(heap, node) {
                    var index = heap.length;
                    heap.push(node);
                    siftUp(heap, node, index);
                }
                function peek(heap) {
                    return heap.length === 0 ? null : heap[0];
                }
                function pop(heap) {
                    if (heap.length === 0) {
                        return null;
                    }
                    var first = heap[0];
                    var last = heap.pop();
                    if (last !== first) {
                        heap[0] = last;
                        siftDown(heap, last, 0);
                    }
                    return first;
                }
                function siftUp(heap, node, i) {
                    var index = i;
                    while(index > 0){
                        var parentIndex = index - 1 >>> 1;
                        var parent = heap[parentIndex];
                        if (compare(parent, node) > 0) {
                            heap[parentIndex] = node;
                            heap[index] = parent;
                            index = parentIndex;
                        } else {
                            return;
                        }
                    }
                }
                function siftDown(heap, node, i) {
                    var index = i;
                    var length = heap.length;
                    var halfLength = length >>> 1;
                    while(index < halfLength){
                        var leftIndex = (index + 1) * 2 - 1;
                        var left = heap[leftIndex];
                        var rightIndex = leftIndex + 1;
                        var right = heap[rightIndex];
                        if (compare(left, node) < 0) {
                            if (rightIndex < length && compare(right, left) < 0) {
                                heap[index] = right;
                                heap[rightIndex] = node;
                                index = rightIndex;
                            } else {
                                heap[index] = left;
                                heap[leftIndex] = node;
                                index = leftIndex;
                            }
                        } else if (rightIndex < length && compare(right, node) < 0) {
                            heap[index] = right;
                            heap[rightIndex] = node;
                            index = rightIndex;
                        } else {
                            return;
                        }
                    }
                }
                function compare(a, b) {
                    var diff = a.sortIndex - b.sortIndex;
                    return diff !== 0 ? diff : a.id - b.id;
                }
                var ImmediatePriority = 1;
                var UserBlockingPriority = 2;
                var NormalPriority = 3;
                var LowPriority = 4;
                var IdlePriority = 5;
                function markTaskErrored(task, ms) {}
                var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
                if (hasPerformanceNow) {
                    var localPerformance = performance;
                    exports.unstable_now = function() {
                        return localPerformance.now();
                    };
                } else {
                    var localDate = Date;
                    var initialTime = localDate.now();
                    exports.unstable_now = function() {
                        return localDate.now() - initialTime;
                    };
                }
                var maxSigned31BitInt = 1073741823;
                var IMMEDIATE_PRIORITY_TIMEOUT = -1;
                var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
                var NORMAL_PRIORITY_TIMEOUT = 5e3;
                var LOW_PRIORITY_TIMEOUT = 1e4;
                var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
                var taskQueue = [];
                var timerQueue = [];
                var taskIdCounter = 1;
                var currentTask = null;
                var currentPriorityLevel = NormalPriority;
                var isPerformingWork = false;
                var isHostCallbackScheduled = false;
                var isHostTimeoutScheduled = false;
                var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
                var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
                var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
                var isInputPending = typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
                function advanceTimers(currentTime) {
                    var timer = peek(timerQueue);
                    while(timer !== null){
                        if (timer.callback === null) {
                            pop(timerQueue);
                        } else if (timer.startTime <= currentTime) {
                            pop(timerQueue);
                            timer.sortIndex = timer.expirationTime;
                            push(taskQueue, timer);
                        } else {
                            return;
                        }
                        timer = peek(timerQueue);
                    }
                }
                function handleTimeout(currentTime) {
                    isHostTimeoutScheduled = false;
                    advanceTimers(currentTime);
                    if (!isHostCallbackScheduled) {
                        if (peek(taskQueue) !== null) {
                            isHostCallbackScheduled = true;
                            requestHostCallback(flushWork);
                        } else {
                            var firstTimer = peek(timerQueue);
                            if (firstTimer !== null) {
                                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                            }
                        }
                    }
                }
                function flushWork(hasTimeRemaining, initialTime2) {
                    isHostCallbackScheduled = false;
                    if (isHostTimeoutScheduled) {
                        isHostTimeoutScheduled = false;
                        cancelHostTimeout();
                    }
                    isPerformingWork = true;
                    var previousPriorityLevel = currentPriorityLevel;
                    try {
                        if (enableProfiling) {
                            try {
                                return workLoop(hasTimeRemaining, initialTime2);
                            } catch (error) {
                                if (currentTask !== null) {
                                    var currentTime = exports.unstable_now();
                                    markTaskErrored(currentTask, currentTime);
                                    currentTask.isQueued = false;
                                }
                                throw error;
                            }
                        } else {
                            return workLoop(hasTimeRemaining, initialTime2);
                        }
                    } finally{
                        currentTask = null;
                        currentPriorityLevel = previousPriorityLevel;
                        isPerformingWork = false;
                    }
                }
                function workLoop(hasTimeRemaining, initialTime2) {
                    var currentTime = initialTime2;
                    advanceTimers(currentTime);
                    currentTask = peek(taskQueue);
                    while(currentTask !== null && !enableSchedulerDebugging){
                        if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
                            break;
                        }
                        var callback = currentTask.callback;
                        if (typeof callback === "function") {
                            currentTask.callback = null;
                            currentPriorityLevel = currentTask.priorityLevel;
                            var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
                            var continuationCallback = callback(didUserCallbackTimeout);
                            currentTime = exports.unstable_now();
                            if (typeof continuationCallback === "function") {
                                currentTask.callback = continuationCallback;
                            } else {
                                if (currentTask === peek(taskQueue)) {
                                    pop(taskQueue);
                                }
                            }
                            advanceTimers(currentTime);
                        } else {
                            pop(taskQueue);
                        }
                        currentTask = peek(taskQueue);
                    }
                    if (currentTask !== null) {
                        return true;
                    } else {
                        var firstTimer = peek(timerQueue);
                        if (firstTimer !== null) {
                            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                        }
                        return false;
                    }
                }
                function unstable_runWithPriority(priorityLevel, eventHandler) {
                    switch(priorityLevel){
                        case ImmediatePriority:
                        case UserBlockingPriority:
                        case NormalPriority:
                        case LowPriority:
                        case IdlePriority:
                            break;
                        default:
                            priorityLevel = NormalPriority;
                    }
                    var previousPriorityLevel = currentPriorityLevel;
                    currentPriorityLevel = priorityLevel;
                    try {
                        return eventHandler();
                    } finally{
                        currentPriorityLevel = previousPriorityLevel;
                    }
                }
                function unstable_next(eventHandler) {
                    var priorityLevel;
                    switch(currentPriorityLevel){
                        case ImmediatePriority:
                        case UserBlockingPriority:
                        case NormalPriority:
                            priorityLevel = NormalPriority;
                            break;
                        default:
                            priorityLevel = currentPriorityLevel;
                            break;
                    }
                    var previousPriorityLevel = currentPriorityLevel;
                    currentPriorityLevel = priorityLevel;
                    try {
                        return eventHandler();
                    } finally{
                        currentPriorityLevel = previousPriorityLevel;
                    }
                }
                function unstable_wrapCallback(callback) {
                    var parentPriorityLevel = currentPriorityLevel;
                    return function() {
                        var previousPriorityLevel = currentPriorityLevel;
                        currentPriorityLevel = parentPriorityLevel;
                        try {
                            return callback.apply(this, arguments);
                        } finally{
                            currentPriorityLevel = previousPriorityLevel;
                        }
                    };
                }
                function unstable_scheduleCallback(priorityLevel, callback, options) {
                    var currentTime = exports.unstable_now();
                    var startTime2;
                    if (typeof options === "object" && options !== null) {
                        var delay = options.delay;
                        if (typeof delay === "number" && delay > 0) {
                            startTime2 = currentTime + delay;
                        } else {
                            startTime2 = currentTime;
                        }
                    } else {
                        startTime2 = currentTime;
                    }
                    var timeout2;
                    switch(priorityLevel){
                        case ImmediatePriority:
                            timeout2 = IMMEDIATE_PRIORITY_TIMEOUT;
                            break;
                        case UserBlockingPriority:
                            timeout2 = USER_BLOCKING_PRIORITY_TIMEOUT;
                            break;
                        case IdlePriority:
                            timeout2 = IDLE_PRIORITY_TIMEOUT;
                            break;
                        case LowPriority:
                            timeout2 = LOW_PRIORITY_TIMEOUT;
                            break;
                        case NormalPriority:
                        default:
                            timeout2 = NORMAL_PRIORITY_TIMEOUT;
                            break;
                    }
                    var expirationTime = startTime2 + timeout2;
                    var newTask = {
                        id: taskIdCounter++,
                        callback,
                        priorityLevel,
                        startTime: startTime2,
                        expirationTime,
                        sortIndex: -1
                    };
                    if (startTime2 > currentTime) {
                        newTask.sortIndex = startTime2;
                        push(timerQueue, newTask);
                        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
                            if (isHostTimeoutScheduled) {
                                cancelHostTimeout();
                            } else {
                                isHostTimeoutScheduled = true;
                            }
                            requestHostTimeout(handleTimeout, startTime2 - currentTime);
                        }
                    } else {
                        newTask.sortIndex = expirationTime;
                        push(taskQueue, newTask);
                        if (!isHostCallbackScheduled && !isPerformingWork) {
                            isHostCallbackScheduled = true;
                            requestHostCallback(flushWork);
                        }
                    }
                    return newTask;
                }
                function unstable_pauseExecution() {}
                function unstable_continueExecution() {
                    if (!isHostCallbackScheduled && !isPerformingWork) {
                        isHostCallbackScheduled = true;
                        requestHostCallback(flushWork);
                    }
                }
                function unstable_getFirstCallbackNode() {
                    return peek(taskQueue);
                }
                function unstable_cancelCallback(task) {
                    task.callback = null;
                }
                function unstable_getCurrentPriorityLevel() {
                    return currentPriorityLevel;
                }
                var isMessageLoopRunning = false;
                var scheduledHostCallback = null;
                var taskTimeoutID = -1;
                var frameInterval = frameYieldMs;
                var startTime = -1;
                function shouldYieldToHost() {
                    var timeElapsed = exports.unstable_now() - startTime;
                    if (timeElapsed < frameInterval) {
                        return false;
                    }
                    return true;
                }
                function requestPaint() {}
                function forceFrameRate(fps) {
                    if (fps < 0 || fps > 125) {
                        console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
                        return;
                    }
                    if (fps > 0) {
                        frameInterval = Math.floor(1e3 / fps);
                    } else {
                        frameInterval = frameYieldMs;
                    }
                }
                var performWorkUntilDeadline = function() {
                    if (scheduledHostCallback !== null) {
                        var currentTime = exports.unstable_now();
                        startTime = currentTime;
                        var hasTimeRemaining = true;
                        var hasMoreWork = true;
                        try {
                            hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
                        } finally{
                            if (hasMoreWork) {
                                schedulePerformWorkUntilDeadline();
                            } else {
                                isMessageLoopRunning = false;
                                scheduledHostCallback = null;
                            }
                        }
                    } else {
                        isMessageLoopRunning = false;
                    }
                };
                var schedulePerformWorkUntilDeadline;
                if (typeof localSetImmediate === "function") {
                    schedulePerformWorkUntilDeadline = function() {
                        localSetImmediate(performWorkUntilDeadline);
                    };
                } else if (typeof MessageChannel !== "undefined") {
                    var channel = new MessageChannel();
                    var port = channel.port2;
                    channel.port1.onmessage = performWorkUntilDeadline;
                    schedulePerformWorkUntilDeadline = function() {
                        port.postMessage(null);
                    };
                } else {
                    schedulePerformWorkUntilDeadline = function() {
                        localSetTimeout(performWorkUntilDeadline, 0);
                    };
                }
                function requestHostCallback(callback) {
                    scheduledHostCallback = callback;
                    if (!isMessageLoopRunning) {
                        isMessageLoopRunning = true;
                        schedulePerformWorkUntilDeadline();
                    }
                }
                function requestHostTimeout(callback, ms) {
                    taskTimeoutID = localSetTimeout(function() {
                        callback(exports.unstable_now());
                    }, ms);
                }
                function cancelHostTimeout() {
                    localClearTimeout(taskTimeoutID);
                    taskTimeoutID = -1;
                }
                var unstable_requestPaint = requestPaint;
                var unstable_Profiling = null;
                exports.unstable_IdlePriority = IdlePriority;
                exports.unstable_ImmediatePriority = ImmediatePriority;
                exports.unstable_LowPriority = LowPriority;
                exports.unstable_NormalPriority = NormalPriority;
                exports.unstable_Profiling = unstable_Profiling;
                exports.unstable_UserBlockingPriority = UserBlockingPriority;
                exports.unstable_cancelCallback = unstable_cancelCallback;
                exports.unstable_continueExecution = unstable_continueExecution;
                exports.unstable_forceFrameRate = forceFrameRate;
                exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
                exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
                exports.unstable_next = unstable_next;
                exports.unstable_pauseExecution = unstable_pauseExecution;
                exports.unstable_requestPaint = unstable_requestPaint;
                exports.unstable_runWithPriority = unstable_runWithPriority;
                exports.unstable_scheduleCallback = unstable_scheduleCallback;
                exports.unstable_shouldYield = shouldYieldToHost;
                exports.unstable_wrapCallback = unstable_wrapCallback;
                if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
                    __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
                }
            })();
        }
    }
});
// node_modules/react-reconciler/node_modules/scheduler/index.js
var require_scheduler = __commonJS({
    "node_modules/react-reconciler/node_modules/scheduler/index.js" (exports, module) {
        "use strict";
        if (false) {
            module.exports = null;
        } else {
            module.exports = require_scheduler_development();
        }
    }
});
// node_modules/react-reconciler/cjs/react-reconciler.development.js
var require_react_reconciler_development = __commonJS({
    "node_modules/react-reconciler/cjs/react-reconciler.development.js" (exports, module) {
        "use strict";
        if (true) {
            module.exports = function $$$reconciler($$$hostConfig) {
                var exports2 = {};
                "use strict";
                var React188 = require_react();
                var Scheduler = require_scheduler();
                var ReactSharedInternals = React188.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
                var suppressWarning = false;
                function setSuppressWarning(newSuppressWarning) {
                    {
                        suppressWarning = newSuppressWarning;
                    }
                }
                function warn3(format) {
                    {
                        if (!suppressWarning) {
                            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                                args[_key - 1] = arguments[_key];
                            }
                            printWarning("warn", format, args);
                        }
                    }
                }
                function error(format) {
                    {
                        if (!suppressWarning) {
                            for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                                args[_key2 - 1] = arguments[_key2];
                            }
                            printWarning("error", format, args);
                        }
                    }
                }
                function printWarning(level, format, args) {
                    {
                        var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
                        var stack = ReactDebugCurrentFrame2.getStackAddendum();
                        if (stack !== "") {
                            format += "%s";
                            args = args.concat([
                                stack
                            ]);
                        }
                        var argsWithFormat = args.map(function(item) {
                            return String(item);
                        });
                        argsWithFormat.unshift("Warning: " + format);
                        Function.prototype.apply.call(console[level], console, argsWithFormat);
                    }
                }
                var assign = Object.assign;
                function get(key) {
                    return key._reactInternals;
                }
                function set(key, value) {
                    key._reactInternals = value;
                }
                var enablePersistentOffscreenHostContainer = false;
                var enableNewReconciler = false;
                var enableLazyContextPropagation = false;
                var enableLegacyHidden = false;
                var enableSuspenseAvoidThisFallback = false;
                var warnAboutStringRefs = false;
                var enableSchedulingProfiler = true;
                var enableProfilerTimer = true;
                var enableProfilerCommitHooks = true;
                var FunctionComponent = 0;
                var ClassComponent = 1;
                var IndeterminateComponent = 2;
                var HostRoot2 = 3;
                var HostPortal = 4;
                var HostComponent2 = 5;
                var HostText2 = 6;
                var Fragment20 = 7;
                var Mode = 8;
                var ContextConsumer = 9;
                var ContextProvider = 10;
                var ForwardRef = 11;
                var Profiler = 12;
                var SuspenseComponent2 = 13;
                var MemoComponent = 14;
                var SimpleMemoComponent = 15;
                var LazyComponent = 16;
                var IncompleteClassComponent = 17;
                var DehydratedFragment = 18;
                var SuspenseListComponent = 19;
                var ScopeComponent = 21;
                var OffscreenComponent = 22;
                var LegacyHiddenComponent = 23;
                var CacheComponent = 24;
                var TracingMarkerComponent = 25;
                var REACT_ELEMENT_TYPE = Symbol.for("react.element");
                var REACT_PORTAL_TYPE = Symbol.for("react.portal");
                var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
                var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
                var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
                var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
                var REACT_CONTEXT_TYPE = Symbol.for("react.context");
                var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
                var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
                var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
                var REACT_MEMO_TYPE = Symbol.for("react.memo");
                var REACT_LAZY_TYPE = Symbol.for("react.lazy");
                var REACT_SCOPE_TYPE = Symbol.for("react.scope");
                var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
                var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
                var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
                var REACT_CACHE_TYPE = Symbol.for("react.cache");
                var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
                var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
                var FAUX_ITERATOR_SYMBOL = "@@iterator";
                function getIteratorFn(maybeIterable) {
                    if (maybeIterable === null || typeof maybeIterable !== "object") {
                        return null;
                    }
                    var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
                    if (typeof maybeIterator === "function") {
                        return maybeIterator;
                    }
                    return null;
                }
                function getWrappedName(outerType, innerType, wrapperName) {
                    var displayName = outerType.displayName;
                    if (displayName) {
                        return displayName;
                    }
                    var functionName = innerType.displayName || innerType.name || "";
                    return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
                }
                function getContextName(type) {
                    return type.displayName || "Context";
                }
                function getComponentNameFromType(type) {
                    if (type == null) {
                        return null;
                    }
                    {
                        if (typeof type.tag === "number") {
                            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
                        }
                    }
                    if (typeof type === "function") {
                        return type.displayName || type.name || null;
                    }
                    if (typeof type === "string") {
                        return type;
                    }
                    switch(type){
                        case REACT_FRAGMENT_TYPE:
                            return "Fragment";
                        case REACT_PORTAL_TYPE:
                            return "Portal";
                        case REACT_PROFILER_TYPE:
                            return "Profiler";
                        case REACT_STRICT_MODE_TYPE:
                            return "StrictMode";
                        case REACT_SUSPENSE_TYPE:
                            return "Suspense";
                        case REACT_SUSPENSE_LIST_TYPE:
                            return "SuspenseList";
                    }
                    if (typeof type === "object") {
                        switch(type.$$typeof){
                            case REACT_CONTEXT_TYPE:
                                var context = type;
                                return getContextName(context) + ".Consumer";
                            case REACT_PROVIDER_TYPE:
                                var provider = type;
                                return getContextName(provider._context) + ".Provider";
                            case REACT_FORWARD_REF_TYPE:
                                return getWrappedName(type, type.render, "ForwardRef");
                            case REACT_MEMO_TYPE:
                                var outerName = type.displayName || null;
                                if (outerName !== null) {
                                    return outerName;
                                }
                                return getComponentNameFromType(type.type) || "Memo";
                            case REACT_LAZY_TYPE:
                                {
                                    var lazyComponent = type;
                                    var payload = lazyComponent._payload;
                                    var init = lazyComponent._init;
                                    try {
                                        return getComponentNameFromType(init(payload));
                                    } catch (x) {
                                        return null;
                                    }
                                }
                        }
                    }
                    return null;
                }
                function getWrappedName$1(outerType, innerType, wrapperName) {
                    var functionName = innerType.displayName || innerType.name || "";
                    return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
                }
                function getContextName$1(type) {
                    return type.displayName || "Context";
                }
                function getComponentNameFromFiber(fiber) {
                    var tag = fiber.tag, type = fiber.type;
                    switch(tag){
                        case CacheComponent:
                            return "Cache";
                        case ContextConsumer:
                            var context = type;
                            return getContextName$1(context) + ".Consumer";
                        case ContextProvider:
                            var provider = type;
                            return getContextName$1(provider._context) + ".Provider";
                        case DehydratedFragment:
                            return "DehydratedFragment";
                        case ForwardRef:
                            return getWrappedName$1(type, type.render, "ForwardRef");
                        case Fragment20:
                            return "Fragment";
                        case HostComponent2:
                            return type;
                        case HostPortal:
                            return "Portal";
                        case HostRoot2:
                            return "Root";
                        case HostText2:
                            return "Text";
                        case LazyComponent:
                            return getComponentNameFromType(type);
                        case Mode:
                            if (type === REACT_STRICT_MODE_TYPE) {
                                return "StrictMode";
                            }
                            return "Mode";
                        case OffscreenComponent:
                            return "Offscreen";
                        case Profiler:
                            return "Profiler";
                        case ScopeComponent:
                            return "Scope";
                        case SuspenseComponent2:
                            return "Suspense";
                        case SuspenseListComponent:
                            return "SuspenseList";
                        case TracingMarkerComponent:
                            return "TracingMarker";
                        case ClassComponent:
                        case FunctionComponent:
                        case IncompleteClassComponent:
                        case IndeterminateComponent:
                        case MemoComponent:
                        case SimpleMemoComponent:
                            if (typeof type === "function") {
                                return type.displayName || type.name || null;
                            }
                            if (typeof type === "string") {
                                return type;
                            }
                            break;
                    }
                    return null;
                }
                var NoFlags = /*                      */ 0;
                var PerformedWork = /*                */ 1;
                var Placement = /*                    */ 2;
                var Update = /*                       */ 4;
                var PlacementAndUpdate = /*           */ Placement | Update;
                var ChildDeletion = /*                */ 16;
                var ContentReset = /*                 */ 32;
                var Callback = /*                     */ 64;
                var DidCapture = /*                   */ 128;
                var ForceClientRender = /*            */ 256;
                var Ref = /*                          */ 512;
                var Snapshot = /*                     */ 1024;
                var Passive = /*                      */ 2048;
                var Hydrating = /*                    */ 4096;
                var HydratingAndUpdate = /*           */ Hydrating | Update;
                var Visibility = /*                   */ 8192;
                var StoreConsistency = /*             */ 16384;
                var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;
                var HostEffectMask = /*               */ 32767;
                var Incomplete = /*                   */ 32768;
                var ShouldCapture = /*                */ 65536;
                var ForceUpdateForLegacySuspense = /* */ 131072;
                var Forked = /*                       */ 1048576;
                var RefStatic = /*                    */ 2097152;
                var LayoutStatic = /*                 */ 4194304;
                var PassiveStatic = /*                */ 8388608;
                var MountLayoutDev = /*               */ 16777216;
                var MountPassiveDev = /*              */ 33554432;
                var BeforeMutationMask = // TODO: Remove Update flag from before mutation phase by re-landing Visibility
                // flag logic (see #20043)
                Update | Snapshot | 0;
                var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
                var LayoutMask = Update | Callback | Ref | Visibility;
                var PassiveMask = Passive | ChildDeletion;
                var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
                var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
                function getNearestMountedFiber(fiber) {
                    var node = fiber;
                    var nearestMounted = fiber;
                    if (!fiber.alternate) {
                        var nextNode = node;
                        do {
                            node = nextNode;
                            if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                                nearestMounted = node.return;
                            }
                            nextNode = node.return;
                        }while (nextNode)
                    } else {
                        while(node.return){
                            node = node.return;
                        }
                    }
                    if (node.tag === HostRoot2) {
                        return nearestMounted;
                    }
                    return null;
                }
                function isFiberMounted(fiber) {
                    return getNearestMountedFiber(fiber) === fiber;
                }
                function isMounted(component) {
                    {
                        var owner = ReactCurrentOwner.current;
                        if (owner !== null && owner.tag === ClassComponent) {
                            var ownerFiber = owner;
                            var instance = ownerFiber.stateNode;
                            if (!instance._warnedAboutRefsInRender) {
                                error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component");
                            }
                            instance._warnedAboutRefsInRender = true;
                        }
                    }
                    var fiber = get(component);
                    if (!fiber) {
                        return false;
                    }
                    return getNearestMountedFiber(fiber) === fiber;
                }
                function assertIsMounted(fiber) {
                    if (getNearestMountedFiber(fiber) !== fiber) {
                        throw new Error("Unable to find node on an unmounted component.");
                    }
                }
                function findCurrentFiberUsingSlowPath(fiber) {
                    var alternate = fiber.alternate;
                    if (!alternate) {
                        var nearestMounted = getNearestMountedFiber(fiber);
                        if (nearestMounted === null) {
                            throw new Error("Unable to find node on an unmounted component.");
                        }
                        if (nearestMounted !== fiber) {
                            return null;
                        }
                        return fiber;
                    }
                    var a = fiber;
                    var b = alternate;
                    while(true){
                        var parentA = a.return;
                        if (parentA === null) {
                            break;
                        }
                        var parentB = parentA.alternate;
                        if (parentB === null) {
                            var nextParent = parentA.return;
                            if (nextParent !== null) {
                                a = b = nextParent;
                                continue;
                            }
                            break;
                        }
                        if (parentA.child === parentB.child) {
                            var child = parentA.child;
                            while(child){
                                if (child === a) {
                                    assertIsMounted(parentA);
                                    return fiber;
                                }
                                if (child === b) {
                                    assertIsMounted(parentA);
                                    return alternate;
                                }
                                child = child.sibling;
                            }
                            throw new Error("Unable to find node on an unmounted component.");
                        }
                        if (a.return !== b.return) {
                            a = parentA;
                            b = parentB;
                        } else {
                            var didFindChild = false;
                            var _child = parentA.child;
                            while(_child){
                                if (_child === a) {
                                    didFindChild = true;
                                    a = parentA;
                                    b = parentB;
                                    break;
                                }
                                if (_child === b) {
                                    didFindChild = true;
                                    b = parentA;
                                    a = parentB;
                                    break;
                                }
                                _child = _child.sibling;
                            }
                            if (!didFindChild) {
                                _child = parentB.child;
                                while(_child){
                                    if (_child === a) {
                                        didFindChild = true;
                                        a = parentB;
                                        b = parentA;
                                        break;
                                    }
                                    if (_child === b) {
                                        didFindChild = true;
                                        b = parentB;
                                        a = parentA;
                                        break;
                                    }
                                    _child = _child.sibling;
                                }
                                if (!didFindChild) {
                                    throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                                }
                            }
                        }
                        if (a.alternate !== b) {
                            throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
                        }
                    }
                    if (a.tag !== HostRoot2) {
                        throw new Error("Unable to find node on an unmounted component.");
                    }
                    if (a.stateNode.current === a) {
                        return fiber;
                    }
                    return alternate;
                }
                function findCurrentHostFiber(parent) {
                    var currentParent = findCurrentFiberUsingSlowPath(parent);
                    return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
                }
                function findCurrentHostFiberImpl(node) {
                    if (node.tag === HostComponent2 || node.tag === HostText2) {
                        return node;
                    }
                    var child = node.child;
                    while(child !== null){
                        var match = findCurrentHostFiberImpl(child);
                        if (match !== null) {
                            return match;
                        }
                        child = child.sibling;
                    }
                    return null;
                }
                function findCurrentHostFiberWithNoPortals(parent) {
                    var currentParent = findCurrentFiberUsingSlowPath(parent);
                    return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
                }
                function findCurrentHostFiberWithNoPortalsImpl(node) {
                    if (node.tag === HostComponent2 || node.tag === HostText2) {
                        return node;
                    }
                    var child = node.child;
                    while(child !== null){
                        if (child.tag !== HostPortal) {
                            var match = findCurrentHostFiberWithNoPortalsImpl(child);
                            if (match !== null) {
                                return match;
                            }
                        }
                        child = child.sibling;
                    }
                    return null;
                }
                var isArrayImpl = Array.isArray;
                function isArray(a) {
                    return isArrayImpl(a);
                }
                var getPublicInstance = $$$hostConfig.getPublicInstance;
                var getRootHostContext = $$$hostConfig.getRootHostContext;
                var getChildHostContext = $$$hostConfig.getChildHostContext;
                var prepareForCommit = $$$hostConfig.prepareForCommit;
                var resetAfterCommit = $$$hostConfig.resetAfterCommit;
                var createInstance = $$$hostConfig.createInstance;
                var appendInitialChild = $$$hostConfig.appendInitialChild;
                var finalizeInitialChildren = $$$hostConfig.finalizeInitialChildren;
                var prepareUpdate = $$$hostConfig.prepareUpdate;
                var shouldSetTextContent = $$$hostConfig.shouldSetTextContent;
                var createTextInstance = $$$hostConfig.createTextInstance;
                var scheduleTimeout = $$$hostConfig.scheduleTimeout;
                var cancelTimeout = $$$hostConfig.cancelTimeout;
                var noTimeout = $$$hostConfig.noTimeout;
                var now = $$$hostConfig.now;
                var isPrimaryRenderer = $$$hostConfig.isPrimaryRenderer;
                var warnsIfNotActing = $$$hostConfig.warnsIfNotActing;
                var supportsMutation = $$$hostConfig.supportsMutation;
                var supportsPersistence = $$$hostConfig.supportsPersistence;
                var supportsHydration = $$$hostConfig.supportsHydration;
                var getInstanceFromNode2 = $$$hostConfig.getInstanceFromNode;
                var beforeActiveInstanceBlur = $$$hostConfig.beforeActiveInstanceBlur;
                var afterActiveInstanceBlur = $$$hostConfig.afterActiveInstanceBlur;
                var preparePortalMount = $$$hostConfig.preparePortalMount;
                var prepareScopeUpdate = $$$hostConfig.preparePortalMount;
                var getInstanceFromScope = $$$hostConfig.getInstanceFromScope;
                var getCurrentEventPriority = $$$hostConfig.getCurrentEventPriority;
                var detachDeletedInstance = $$$hostConfig.detachDeletedInstance;
                var supportsMicrotasks = $$$hostConfig.supportsMicrotasks;
                var scheduleMicrotask = $$$hostConfig.scheduleMicrotask;
                var supportsTestSelectors = $$$hostConfig.supportsTestSelectors;
                var findFiberRoot = $$$hostConfig.findFiberRoot;
                var getBoundingRect = $$$hostConfig.getBoundingRect;
                var getTextContent = $$$hostConfig.getTextContent;
                var isHiddenSubtree = $$$hostConfig.isHiddenSubtree;
                var matchAccessibilityRole = $$$hostConfig.matchAccessibilityRole;
                var setFocusIfFocusable = $$$hostConfig.setFocusIfFocusable;
                var setupIntersectionObserver = $$$hostConfig.setupIntersectionObserver;
                var appendChild = $$$hostConfig.appendChild;
                var appendChildToContainer = $$$hostConfig.appendChildToContainer;
                var commitTextUpdate = $$$hostConfig.commitTextUpdate;
                var commitMount = $$$hostConfig.commitMount;
                var commitUpdate = $$$hostConfig.commitUpdate;
                var insertBefore = $$$hostConfig.insertBefore;
                var insertInContainerBefore = $$$hostConfig.insertInContainerBefore;
                var removeChild = $$$hostConfig.removeChild;
                var removeChildFromContainer = $$$hostConfig.removeChildFromContainer;
                var resetTextContent = $$$hostConfig.resetTextContent;
                var hideInstance = $$$hostConfig.hideInstance;
                var hideTextInstance = $$$hostConfig.hideTextInstance;
                var unhideInstance = $$$hostConfig.unhideInstance;
                var unhideTextInstance = $$$hostConfig.unhideTextInstance;
                var clearContainer = $$$hostConfig.clearContainer;
                var cloneInstance = $$$hostConfig.cloneInstance;
                var createContainerChildSet = $$$hostConfig.createContainerChildSet;
                var appendChildToContainerChildSet = $$$hostConfig.appendChildToContainerChildSet;
                var finalizeContainerChildren = $$$hostConfig.finalizeContainerChildren;
                var replaceContainerChildren = $$$hostConfig.replaceContainerChildren;
                var getOffscreenContainerType = $$$hostConfig.getOffscreenContainerType;
                var getOffscreenContainerProps = $$$hostConfig.getOffscreenContainerProps;
                var cloneHiddenInstance = $$$hostConfig.cloneHiddenInstance;
                var cloneHiddenTextInstance = $$$hostConfig.cloneHiddenTextInstance;
                var canHydrateInstance = $$$hostConfig.canHydrateInstance;
                var canHydrateTextInstance = $$$hostConfig.canHydrateTextInstance;
                var canHydrateSuspenseInstance = $$$hostConfig.canHydrateSuspenseInstance;
                var isSuspenseInstancePending = $$$hostConfig.isSuspenseInstancePending;
                var isSuspenseInstanceFallback = $$$hostConfig.isSuspenseInstanceFallback;
                var registerSuspenseInstanceRetry = $$$hostConfig.registerSuspenseInstanceRetry;
                var getNextHydratableSibling = $$$hostConfig.getNextHydratableSibling;
                var getFirstHydratableChild = $$$hostConfig.getFirstHydratableChild;
                var getFirstHydratableChildWithinContainer = $$$hostConfig.getFirstHydratableChildWithinContainer;
                var getFirstHydratableChildWithinSuspenseInstance = $$$hostConfig.getFirstHydratableChildWithinSuspenseInstance;
                var hydrateInstance = $$$hostConfig.hydrateInstance;
                var hydrateTextInstance = $$$hostConfig.hydrateTextInstance;
                var hydrateSuspenseInstance = $$$hostConfig.hydrateSuspenseInstance;
                var getNextHydratableInstanceAfterSuspenseInstance = $$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance;
                var commitHydratedContainer = $$$hostConfig.commitHydratedContainer;
                var commitHydratedSuspenseInstance = $$$hostConfig.commitHydratedSuspenseInstance;
                var clearSuspenseBoundary = $$$hostConfig.clearSuspenseBoundary;
                var clearSuspenseBoundaryFromContainer = $$$hostConfig.clearSuspenseBoundaryFromContainer;
                var shouldDeleteUnhydratedTailInstances = $$$hostConfig.shouldDeleteUnhydratedTailInstances;
                var didNotMatchHydratedContainerTextInstance = $$$hostConfig.didNotMatchHydratedContainerTextInstance;
                var didNotMatchHydratedTextInstance = $$$hostConfig.didNotMatchHydratedTextInstance;
                var didNotHydrateInstanceWithinContainer = $$$hostConfig.didNotHydrateInstanceWithinContainer;
                var didNotHydrateInstanceWithinSuspenseInstance = $$$hostConfig.didNotHydrateInstanceWithinSuspenseInstance;
                var didNotHydrateInstance = $$$hostConfig.didNotHydrateInstance;
                var didNotFindHydratableInstanceWithinContainer = $$$hostConfig.didNotFindHydratableInstanceWithinContainer;
                var didNotFindHydratableTextInstanceWithinContainer = $$$hostConfig.didNotFindHydratableTextInstanceWithinContainer;
                var didNotFindHydratableSuspenseInstanceWithinContainer = $$$hostConfig.didNotFindHydratableSuspenseInstanceWithinContainer;
                var didNotFindHydratableInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableInstanceWithinSuspenseInstance;
                var didNotFindHydratableTextInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableTextInstanceWithinSuspenseInstance;
                var didNotFindHydratableSuspenseInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance;
                var didNotFindHydratableInstance = $$$hostConfig.didNotFindHydratableInstance;
                var didNotFindHydratableTextInstance = $$$hostConfig.didNotFindHydratableTextInstance;
                var didNotFindHydratableSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstance;
                var errorHydratingContainer = $$$hostConfig.errorHydratingContainer;
                var disabledDepth = 0;
                var prevLog;
                var prevInfo;
                var prevWarn;
                var prevError;
                var prevGroup;
                var prevGroupCollapsed;
                var prevGroupEnd;
                function disabledLog() {}
                disabledLog.__reactDisabledLog = true;
                function disableLogs() {
                    {
                        if (disabledDepth === 0) {
                            prevLog = console.log;
                            prevInfo = console.info;
                            prevWarn = console.warn;
                            prevError = console.error;
                            prevGroup = console.group;
                            prevGroupCollapsed = console.groupCollapsed;
                            prevGroupEnd = console.groupEnd;
                            var props = {
                                configurable: true,
                                enumerable: true,
                                value: disabledLog,
                                writable: true
                            };
                            Object.defineProperties(console, {
                                info: props,
                                log: props,
                                warn: props,
                                error: props,
                                group: props,
                                groupCollapsed: props,
                                groupEnd: props
                            });
                        }
                        disabledDepth++;
                    }
                }
                function reenableLogs() {
                    {
                        disabledDepth--;
                        if (disabledDepth === 0) {
                            var props = {
                                configurable: true,
                                enumerable: true,
                                writable: true
                            };
                            Object.defineProperties(console, {
                                log: assign({}, props, {
                                    value: prevLog
                                }),
                                info: assign({}, props, {
                                    value: prevInfo
                                }),
                                warn: assign({}, props, {
                                    value: prevWarn
                                }),
                                error: assign({}, props, {
                                    value: prevError
                                }),
                                group: assign({}, props, {
                                    value: prevGroup
                                }),
                                groupCollapsed: assign({}, props, {
                                    value: prevGroupCollapsed
                                }),
                                groupEnd: assign({}, props, {
                                    value: prevGroupEnd
                                })
                            });
                        }
                        if (disabledDepth < 0) {
                            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
                        }
                    }
                }
                var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
                var prefix;
                function describeBuiltInComponentFrame(name, source, ownerFn) {
                    {
                        if (prefix === void 0) {
                            try {
                                throw Error();
                            } catch (x) {
                                var match = x.stack.trim().match(/\n( *(at )?)/);
                                prefix = match && match[1] || "";
                            }
                        }
                        return "\n" + prefix + name;
                    }
                }
                var reentry = false;
                var componentFrameCache;
                {
                    var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
                    componentFrameCache = new PossiblyWeakMap();
                }
                function describeNativeComponentFrame(fn, construct) {
                    if (!fn || reentry) {
                        return "";
                    }
                    {
                        var frame = componentFrameCache.get(fn);
                        if (frame !== void 0) {
                            return frame;
                        }
                    }
                    var control;
                    reentry = true;
                    var previousPrepareStackTrace = Error.prepareStackTrace;
                    Error.prepareStackTrace = void 0;
                    var previousDispatcher;
                    {
                        previousDispatcher = ReactCurrentDispatcher.current;
                        ReactCurrentDispatcher.current = null;
                        disableLogs();
                    }
                    try {
                        if (construct) {
                            var Fake = function() {
                                throw Error();
                            };
                            Object.defineProperty(Fake.prototype, "props", {
                                set: function() {
                                    throw Error();
                                }
                            });
                            if (typeof Reflect === "object" && Reflect.construct) {
                                try {
                                    Reflect.construct(Fake, []);
                                } catch (x) {
                                    control = x;
                                }
                                Reflect.construct(fn, [], Fake);
                            } else {
                                try {
                                    Fake.call();
                                } catch (x) {
                                    control = x;
                                }
                                fn.call(Fake.prototype);
                            }
                        } else {
                            try {
                                throw Error();
                            } catch (x) {
                                control = x;
                            }
                            fn();
                        }
                    } catch (sample) {
                        if (sample && control && typeof sample.stack === "string") {
                            var sampleLines = sample.stack.split("\n");
                            var controlLines = control.stack.split("\n");
                            var s = sampleLines.length - 1;
                            var c = controlLines.length - 1;
                            while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){
                                c--;
                            }
                            for(; s >= 1 && c >= 0; s--, c--){
                                if (sampleLines[s] !== controlLines[c]) {
                                    if (s !== 1 || c !== 1) {
                                        do {
                                            s--;
                                            c--;
                                            if (c < 0 || sampleLines[s] !== controlLines[c]) {
                                                var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                                                if (fn.displayName && _frame.includes("<anonymous>")) {
                                                    _frame = _frame.replace("<anonymous>", fn.displayName);
                                                }
                                                {
                                                    if (typeof fn === "function") {
                                                        componentFrameCache.set(fn, _frame);
                                                    }
                                                }
                                                return _frame;
                                            }
                                        }while (s >= 1 && c >= 0)
                                    }
                                    break;
                                }
                            }
                        }
                    } finally{
                        reentry = false;
                        {
                            ReactCurrentDispatcher.current = previousDispatcher;
                            reenableLogs();
                        }
                        Error.prepareStackTrace = previousPrepareStackTrace;
                    }
                    var name = fn ? fn.displayName || fn.name : "";
                    var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
                    {
                        if (typeof fn === "function") {
                            componentFrameCache.set(fn, syntheticFrame);
                        }
                    }
                    return syntheticFrame;
                }
                function describeClassComponentFrame(ctor, source, ownerFn) {
                    {
                        return describeNativeComponentFrame(ctor, true);
                    }
                }
                function describeFunctionComponentFrame(fn, source, ownerFn) {
                    {
                        return describeNativeComponentFrame(fn, false);
                    }
                }
                function shouldConstruct(Component) {
                    var prototype = Component.prototype;
                    return !!(prototype && prototype.isReactComponent);
                }
                function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
                    if (type == null) {
                        return "";
                    }
                    if (typeof type === "function") {
                        {
                            return describeNativeComponentFrame(type, shouldConstruct(type));
                        }
                    }
                    if (typeof type === "string") {
                        return describeBuiltInComponentFrame(type);
                    }
                    switch(type){
                        case REACT_SUSPENSE_TYPE:
                            return describeBuiltInComponentFrame("Suspense");
                        case REACT_SUSPENSE_LIST_TYPE:
                            return describeBuiltInComponentFrame("SuspenseList");
                    }
                    if (typeof type === "object") {
                        switch(type.$$typeof){
                            case REACT_FORWARD_REF_TYPE:
                                return describeFunctionComponentFrame(type.render);
                            case REACT_MEMO_TYPE:
                                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                            case REACT_LAZY_TYPE:
                                {
                                    var lazyComponent = type;
                                    var payload = lazyComponent._payload;
                                    var init = lazyComponent._init;
                                    try {
                                        return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                                    } catch (x) {}
                                }
                        }
                    }
                    return "";
                }
                var hasOwnProperty = Object.prototype.hasOwnProperty;
                var loggedTypeFailures = {};
                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
                function setCurrentlyValidatingElement(element) {
                    {
                        if (element) {
                            var owner = element._owner;
                            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                            ReactDebugCurrentFrame.setExtraStackFrame(stack);
                        } else {
                            ReactDebugCurrentFrame.setExtraStackFrame(null);
                        }
                    }
                }
                function checkPropTypes(typeSpecs, values2, location, componentName, element) {
                    {
                        var has = Function.call.bind(hasOwnProperty);
                        for(var typeSpecName in typeSpecs){
                            if (has(typeSpecs, typeSpecName)) {
                                var error$1 = void 0;
                                try {
                                    if (typeof typeSpecs[typeSpecName] !== "function") {
                                        var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                                        err.name = "Invariant Violation";
                                        throw err;
                                    }
                                    error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                                } catch (ex) {
                                    error$1 = ex;
                                }
                                if (error$1 && !(error$1 instanceof Error)) {
                                    setCurrentlyValidatingElement(element);
                                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                                    setCurrentlyValidatingElement(null);
                                }
                                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                                    loggedTypeFailures[error$1.message] = true;
                                    setCurrentlyValidatingElement(element);
                                    error("Failed %s type: %s", location, error$1.message);
                                    setCurrentlyValidatingElement(null);
                                }
                            }
                        }
                    }
                }
                var valueStack = [];
                var fiberStack;
                {
                    fiberStack = [];
                }
                var index = -1;
                function createCursor(defaultValue) {
                    return {
                        current: defaultValue
                    };
                }
                function pop(cursor, fiber) {
                    if (index < 0) {
                        {
                            error("Unexpected pop.");
                        }
                        return;
                    }
                    {
                        if (fiber !== fiberStack[index]) {
                            error("Unexpected Fiber popped.");
                        }
                    }
                    cursor.current = valueStack[index];
                    valueStack[index] = null;
                    {
                        fiberStack[index] = null;
                    }
                    index--;
                }
                function push(cursor, value, fiber) {
                    index++;
                    valueStack[index] = cursor.current;
                    {
                        fiberStack[index] = fiber;
                    }
                    cursor.current = value;
                }
                var warnedAboutMissingGetChildContext;
                {
                    warnedAboutMissingGetChildContext = {};
                }
                var emptyContextObject = {};
                {
                    Object.freeze(emptyContextObject);
                }
                var contextStackCursor = createCursor(emptyContextObject);
                var didPerformWorkStackCursor = createCursor(false);
                var previousContext = emptyContextObject;
                function getUnmaskedContext(workInProgress2, Component, didPushOwnContextIfProvider) {
                    {
                        if (didPushOwnContextIfProvider && isContextProvider(Component)) {
                            return previousContext;
                        }
                        return contextStackCursor.current;
                    }
                }
                function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
                    {
                        var instance = workInProgress2.stateNode;
                        instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
                        instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
                    }
                }
                function getMaskedContext(workInProgress2, unmaskedContext) {
                    {
                        var type = workInProgress2.type;
                        var contextTypes = type.contextTypes;
                        if (!contextTypes) {
                            return emptyContextObject;
                        }
                        var instance = workInProgress2.stateNode;
                        if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
                            return instance.__reactInternalMemoizedMaskedChildContext;
                        }
                        var context = {};
                        for(var key in contextTypes){
                            context[key] = unmaskedContext[key];
                        }
                        {
                            var name = getComponentNameFromFiber(workInProgress2) || "Unknown";
                            checkPropTypes(contextTypes, context, "context", name);
                        }
                        if (instance) {
                            cacheContext(workInProgress2, unmaskedContext, context);
                        }
                        return context;
                    }
                }
                function hasContextChanged() {
                    {
                        return didPerformWorkStackCursor.current;
                    }
                }
                function isContextProvider(type) {
                    {
                        var childContextTypes = type.childContextTypes;
                        return childContextTypes !== null && childContextTypes !== void 0;
                    }
                }
                function popContext(fiber) {
                    {
                        pop(didPerformWorkStackCursor, fiber);
                        pop(contextStackCursor, fiber);
                    }
                }
                function popTopLevelContextObject(fiber) {
                    {
                        pop(didPerformWorkStackCursor, fiber);
                        pop(contextStackCursor, fiber);
                    }
                }
                function pushTopLevelContextObject(fiber, context, didChange) {
                    {
                        if (contextStackCursor.current !== emptyContextObject) {
                            throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
                        }
                        push(contextStackCursor, context, fiber);
                        push(didPerformWorkStackCursor, didChange, fiber);
                    }
                }
                function processChildContext(fiber, type, parentContext) {
                    {
                        var instance = fiber.stateNode;
                        var childContextTypes = type.childContextTypes;
                        if (typeof instance.getChildContext !== "function") {
                            {
                                var componentName = getComponentNameFromFiber(fiber) || "Unknown";
                                if (!warnedAboutMissingGetChildContext[componentName]) {
                                    warnedAboutMissingGetChildContext[componentName] = true;
                                    error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                                }
                            }
                            return parentContext;
                        }
                        var childContext = instance.getChildContext();
                        for(var contextKey in childContext){
                            if (!(contextKey in childContextTypes)) {
                                throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                            }
                        }
                        {
                            var name = getComponentNameFromFiber(fiber) || "Unknown";
                            checkPropTypes(childContextTypes, childContext, "child context", name);
                        }
                        return assign({}, parentContext, childContext);
                    }
                }
                function pushContextProvider(workInProgress2) {
                    {
                        var instance = workInProgress2.stateNode;
                        var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
                        previousContext = contextStackCursor.current;
                        push(contextStackCursor, memoizedMergedChildContext, workInProgress2);
                        push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
                        return true;
                    }
                }
                function invalidateContextProvider(workInProgress2, type, didChange) {
                    {
                        var instance = workInProgress2.stateNode;
                        if (!instance) {
                            throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
                        }
                        if (didChange) {
                            var mergedContext = processChildContext(workInProgress2, type, previousContext);
                            instance.__reactInternalMemoizedMergedChildContext = mergedContext;
                            pop(didPerformWorkStackCursor, workInProgress2);
                            pop(contextStackCursor, workInProgress2);
                            push(contextStackCursor, mergedContext, workInProgress2);
                            push(didPerformWorkStackCursor, didChange, workInProgress2);
                        } else {
                            pop(didPerformWorkStackCursor, workInProgress2);
                            push(didPerformWorkStackCursor, didChange, workInProgress2);
                        }
                    }
                }
                function findCurrentUnmaskedContext(fiber) {
                    {
                        if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
                            throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
                        }
                        var node = fiber;
                        do {
                            switch(node.tag){
                                case HostRoot2:
                                    return node.stateNode.context;
                                case ClassComponent:
                                    {
                                        var Component = node.type;
                                        if (isContextProvider(Component)) {
                                            return node.stateNode.__reactInternalMemoizedMergedChildContext;
                                        }
                                        break;
                                    }
                            }
                            node = node.return;
                        }while (node !== null)
                        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
                    }
                }
                var LegacyRoot = 0;
                var ConcurrentRoot = 1;
                var NoMode = /*                         */ 0;
                var ConcurrentMode = /*                 */ 1;
                var ProfileMode = /*                    */ 2;
                var StrictLegacyMode = /*               */ 8;
                var StrictEffectsMode = /*              */ 16;
                var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
                var log = Math.log;
                var LN2 = Math.LN2;
                function clz32Fallback(x) {
                    var asUint = x >>> 0;
                    if (asUint === 0) {
                        return 32;
                    }
                    return 31 - (log(asUint) / LN2 | 0) | 0;
                }
                var TotalLanes = 31;
                var NoLanes = /*                        */ 0;
                var NoLane = /*                          */ 0;
                var SyncLane = /*                        */ 1;
                var InputContinuousHydrationLane = /*    */ 2;
                var InputContinuousLane = /*            */ 4;
                var DefaultHydrationLane = /*            */ 8;
                var DefaultLane = /*                    */ 16;
                var TransitionHydrationLane = /*                */ 32;
                var TransitionLanes = /*                       */ 4194240;
                var TransitionLane1 = /*                        */ 64;
                var TransitionLane2 = /*                        */ 128;
                var TransitionLane3 = /*                        */ 256;
                var TransitionLane4 = /*                        */ 512;
                var TransitionLane5 = /*                        */ 1024;
                var TransitionLane6 = /*                        */ 2048;
                var TransitionLane7 = /*                        */ 4096;
                var TransitionLane8 = /*                        */ 8192;
                var TransitionLane9 = /*                        */ 16384;
                var TransitionLane10 = /*                       */ 32768;
                var TransitionLane11 = /*                       */ 65536;
                var TransitionLane12 = /*                       */ 131072;
                var TransitionLane13 = /*                       */ 262144;
                var TransitionLane14 = /*                       */ 524288;
                var TransitionLane15 = /*                       */ 1048576;
                var TransitionLane16 = /*                       */ 2097152;
                var RetryLanes = /*                            */ 130023424;
                var RetryLane1 = /*                             */ 4194304;
                var RetryLane2 = /*                             */ 8388608;
                var RetryLane3 = /*                             */ 16777216;
                var RetryLane4 = /*                             */ 33554432;
                var RetryLane5 = /*                             */ 67108864;
                var SomeRetryLane = RetryLane1;
                var SelectiveHydrationLane = /*          */ 134217728;
                var NonIdleLanes = /*                                 */ 268435455;
                var IdleHydrationLane = /*               */ 268435456;
                var IdleLane = /*                       */ 536870912;
                var OffscreenLane = /*                   */ 1073741824;
                function getLabelForLane(lane) {
                    {
                        if (lane & SyncLane) {
                            return "Sync";
                        }
                        if (lane & InputContinuousHydrationLane) {
                            return "InputContinuousHydration";
                        }
                        if (lane & InputContinuousLane) {
                            return "InputContinuous";
                        }
                        if (lane & DefaultHydrationLane) {
                            return "DefaultHydration";
                        }
                        if (lane & DefaultLane) {
                            return "Default";
                        }
                        if (lane & TransitionHydrationLane) {
                            return "TransitionHydration";
                        }
                        if (lane & TransitionLanes) {
                            return "Transition";
                        }
                        if (lane & RetryLanes) {
                            return "Retry";
                        }
                        if (lane & SelectiveHydrationLane) {
                            return "SelectiveHydration";
                        }
                        if (lane & IdleHydrationLane) {
                            return "IdleHydration";
                        }
                        if (lane & IdleLane) {
                            return "Idle";
                        }
                        if (lane & OffscreenLane) {
                            return "Offscreen";
                        }
                    }
                }
                var NoTimestamp = -1;
                var nextTransitionLane = TransitionLane1;
                var nextRetryLane = RetryLane1;
                function getHighestPriorityLanes(lanes) {
                    switch(getHighestPriorityLane(lanes)){
                        case SyncLane:
                            return SyncLane;
                        case InputContinuousHydrationLane:
                            return InputContinuousHydrationLane;
                        case InputContinuousLane:
                            return InputContinuousLane;
                        case DefaultHydrationLane:
                            return DefaultHydrationLane;
                        case DefaultLane:
                            return DefaultLane;
                        case TransitionHydrationLane:
                            return TransitionHydrationLane;
                        case TransitionLane1:
                        case TransitionLane2:
                        case TransitionLane3:
                        case TransitionLane4:
                        case TransitionLane5:
                        case TransitionLane6:
                        case TransitionLane7:
                        case TransitionLane8:
                        case TransitionLane9:
                        case TransitionLane10:
                        case TransitionLane11:
                        case TransitionLane12:
                        case TransitionLane13:
                        case TransitionLane14:
                        case TransitionLane15:
                        case TransitionLane16:
                            return lanes & TransitionLanes;
                        case RetryLane1:
                        case RetryLane2:
                        case RetryLane3:
                        case RetryLane4:
                        case RetryLane5:
                            return lanes & RetryLanes;
                        case SelectiveHydrationLane:
                            return SelectiveHydrationLane;
                        case IdleHydrationLane:
                            return IdleHydrationLane;
                        case IdleLane:
                            return IdleLane;
                        case OffscreenLane:
                            return OffscreenLane;
                        default:
                            {
                                error("Should have found matching lanes. This is a bug in React.");
                            }
                            return lanes;
                    }
                }
                function getNextLanes(root, wipLanes) {
                    var pendingLanes = root.pendingLanes;
                    if (pendingLanes === NoLanes) {
                        return NoLanes;
                    }
                    var nextLanes = NoLanes;
                    var suspendedLanes = root.suspendedLanes;
                    var pingedLanes = root.pingedLanes;
                    var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
                    if (nonIdlePendingLanes !== NoLanes) {
                        var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
                        if (nonIdleUnblockedLanes !== NoLanes) {
                            nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
                        } else {
                            var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
                            if (nonIdlePingedLanes !== NoLanes) {
                                nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
                            }
                        }
                    } else {
                        var unblockedLanes = pendingLanes & ~suspendedLanes;
                        if (unblockedLanes !== NoLanes) {
                            nextLanes = getHighestPriorityLanes(unblockedLanes);
                        } else {
                            if (pingedLanes !== NoLanes) {
                                nextLanes = getHighestPriorityLanes(pingedLanes);
                            }
                        }
                    }
                    if (nextLanes === NoLanes) {
                        return NoLanes;
                    }
                    if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
                    // bother waiting until the root is complete.
                    (wipLanes & suspendedLanes) === NoLanes) {
                        var nextLane = getHighestPriorityLane(nextLanes);
                        var wipLane = getHighestPriorityLane(wipLanes);
                        if (// Tests whether the next lane is equal or lower priority than the wip
                        // one. This works because the bits decrease in priority as you go left.
                        nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The
                        // only difference between default updates and transition updates is that
                        // default updates do not support refresh transitions.
                        nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {
                            return wipLanes;
                        }
                    }
                    if ((nextLanes & InputContinuousLane) !== NoLanes) {
                        nextLanes |= pendingLanes & DefaultLane;
                    }
                    var entangledLanes = root.entangledLanes;
                    if (entangledLanes !== NoLanes) {
                        var entanglements = root.entanglements;
                        var lanes = nextLanes & entangledLanes;
                        while(lanes > 0){
                            var index2 = pickArbitraryLaneIndex(lanes);
                            var lane = 1 << index2;
                            nextLanes |= entanglements[index2];
                            lanes &= ~lane;
                        }
                    }
                    return nextLanes;
                }
                function getMostRecentEventTime(root, lanes) {
                    var eventTimes = root.eventTimes;
                    var mostRecentEventTime = NoTimestamp;
                    while(lanes > 0){
                        var index2 = pickArbitraryLaneIndex(lanes);
                        var lane = 1 << index2;
                        var eventTime = eventTimes[index2];
                        if (eventTime > mostRecentEventTime) {
                            mostRecentEventTime = eventTime;
                        }
                        lanes &= ~lane;
                    }
                    return mostRecentEventTime;
                }
                function computeExpirationTime(lane, currentTime) {
                    switch(lane){
                        case SyncLane:
                        case InputContinuousHydrationLane:
                        case InputContinuousLane:
                            return currentTime + 250;
                        case DefaultHydrationLane:
                        case DefaultLane:
                        case TransitionHydrationLane:
                        case TransitionLane1:
                        case TransitionLane2:
                        case TransitionLane3:
                        case TransitionLane4:
                        case TransitionLane5:
                        case TransitionLane6:
                        case TransitionLane7:
                        case TransitionLane8:
                        case TransitionLane9:
                        case TransitionLane10:
                        case TransitionLane11:
                        case TransitionLane12:
                        case TransitionLane13:
                        case TransitionLane14:
                        case TransitionLane15:
                        case TransitionLane16:
                            return currentTime + 5e3;
                        case RetryLane1:
                        case RetryLane2:
                        case RetryLane3:
                        case RetryLane4:
                        case RetryLane5:
                            return NoTimestamp;
                        case SelectiveHydrationLane:
                        case IdleHydrationLane:
                        case IdleLane:
                        case OffscreenLane:
                            return NoTimestamp;
                        default:
                            {
                                error("Should have found matching lanes. This is a bug in React.");
                            }
                            return NoTimestamp;
                    }
                }
                function markStarvedLanesAsExpired(root, currentTime) {
                    var pendingLanes = root.pendingLanes;
                    var suspendedLanes = root.suspendedLanes;
                    var pingedLanes = root.pingedLanes;
                    var expirationTimes = root.expirationTimes;
                    var lanes = pendingLanes;
                    while(lanes > 0){
                        var index2 = pickArbitraryLaneIndex(lanes);
                        var lane = 1 << index2;
                        var expirationTime = expirationTimes[index2];
                        if (expirationTime === NoTimestamp) {
                            if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                                expirationTimes[index2] = computeExpirationTime(lane, currentTime);
                            }
                        } else if (expirationTime <= currentTime) {
                            root.expiredLanes |= lane;
                        }
                        lanes &= ~lane;
                    }
                }
                function getHighestPriorityPendingLanes(root) {
                    return getHighestPriorityLanes(root.pendingLanes);
                }
                function getLanesToRetrySynchronouslyOnError(root) {
                    var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;
                    if (everythingButOffscreen !== NoLanes) {
                        return everythingButOffscreen;
                    }
                    if (everythingButOffscreen & OffscreenLane) {
                        return OffscreenLane;
                    }
                    return NoLanes;
                }
                function includesSyncLane(lanes) {
                    return (lanes & SyncLane) !== NoLanes;
                }
                function includesNonIdleWork(lanes) {
                    return (lanes & NonIdleLanes) !== NoLanes;
                }
                function includesOnlyRetries(lanes) {
                    return (lanes & RetryLanes) === lanes;
                }
                function includesOnlyTransitions(lanes) {
                    return (lanes & TransitionLanes) === lanes;
                }
                function includesBlockingLane(root, lanes) {
                    var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
                    return (lanes & SyncDefaultLanes) !== NoLanes;
                }
                function includesExpiredLane(root, lanes) {
                    return (lanes & root.expiredLanes) !== NoLanes;
                }
                function isTransitionLane(lane) {
                    return (lane & TransitionLanes) !== 0;
                }
                function claimNextTransitionLane() {
                    var lane = nextTransitionLane;
                    nextTransitionLane <<= 1;
                    if ((nextTransitionLane & TransitionLanes) === 0) {
                        nextTransitionLane = TransitionLane1;
                    }
                    return lane;
                }
                function claimNextRetryLane() {
                    var lane = nextRetryLane;
                    nextRetryLane <<= 1;
                    if ((nextRetryLane & RetryLanes) === 0) {
                        nextRetryLane = RetryLane1;
                    }
                    return lane;
                }
                function getHighestPriorityLane(lanes) {
                    return lanes & -lanes;
                }
                function pickArbitraryLane(lanes) {
                    return getHighestPriorityLane(lanes);
                }
                function pickArbitraryLaneIndex(lanes) {
                    return 31 - clz32(lanes);
                }
                function laneToIndex(lane) {
                    return pickArbitraryLaneIndex(lane);
                }
                function includesSomeLane(a, b) {
                    return (a & b) !== NoLanes;
                }
                function isSubsetOfLanes(set2, subset) {
                    return (set2 & subset) === subset;
                }
                function mergeLanes(a, b) {
                    return a | b;
                }
                function removeLanes(set2, subset) {
                    return set2 & ~subset;
                }
                function intersectLanes(a, b) {
                    return a & b;
                }
                function laneToLanes(lane) {
                    return lane;
                }
                function higherPriorityLane(a, b) {
                    return a !== NoLane && a < b ? a : b;
                }
                function createLaneMap(initial) {
                    var laneMap = [];
                    for(var i = 0; i < TotalLanes; i++){
                        laneMap.push(initial);
                    }
                    return laneMap;
                }
                function markRootUpdated(root, updateLane, eventTime) {
                    root.pendingLanes |= updateLane;
                    if (updateLane !== IdleLane) {
                        root.suspendedLanes = NoLanes;
                        root.pingedLanes = NoLanes;
                    }
                    var eventTimes = root.eventTimes;
                    var index2 = laneToIndex(updateLane);
                    eventTimes[index2] = eventTime;
                }
                function markRootSuspended(root, suspendedLanes) {
                    root.suspendedLanes |= suspendedLanes;
                    root.pingedLanes &= ~suspendedLanes;
                    var expirationTimes = root.expirationTimes;
                    var lanes = suspendedLanes;
                    while(lanes > 0){
                        var index2 = pickArbitraryLaneIndex(lanes);
                        var lane = 1 << index2;
                        expirationTimes[index2] = NoTimestamp;
                        lanes &= ~lane;
                    }
                }
                function markRootPinged(root, pingedLanes, eventTime) {
                    root.pingedLanes |= root.suspendedLanes & pingedLanes;
                }
                function markRootFinished(root, remainingLanes) {
                    var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
                    root.pendingLanes = remainingLanes;
                    root.suspendedLanes = 0;
                    root.pingedLanes = 0;
                    root.expiredLanes &= remainingLanes;
                    root.mutableReadLanes &= remainingLanes;
                    root.entangledLanes &= remainingLanes;
                    var entanglements = root.entanglements;
                    var eventTimes = root.eventTimes;
                    var expirationTimes = root.expirationTimes;
                    var lanes = noLongerPendingLanes;
                    while(lanes > 0){
                        var index2 = pickArbitraryLaneIndex(lanes);
                        var lane = 1 << index2;
                        entanglements[index2] = NoLanes;
                        eventTimes[index2] = NoTimestamp;
                        expirationTimes[index2] = NoTimestamp;
                        lanes &= ~lane;
                    }
                }
                function markRootEntangled(root, entangledLanes) {
                    var rootEntangledLanes = root.entangledLanes |= entangledLanes;
                    var entanglements = root.entanglements;
                    var lanes = rootEntangledLanes;
                    while(lanes){
                        var index2 = pickArbitraryLaneIndex(lanes);
                        var lane = 1 << index2;
                        if (// Is this one of the newly entangled lanes?
                        lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?
                        entanglements[index2] & entangledLanes) {
                            entanglements[index2] |= entangledLanes;
                        }
                        lanes &= ~lane;
                    }
                }
                function getBumpedLaneForHydration(root, renderLanes2) {
                    var renderLane = getHighestPriorityLane(renderLanes2);
                    var lane;
                    switch(renderLane){
                        case InputContinuousLane:
                            lane = InputContinuousHydrationLane;
                            break;
                        case DefaultLane:
                            lane = DefaultHydrationLane;
                            break;
                        case TransitionLane1:
                        case TransitionLane2:
                        case TransitionLane3:
                        case TransitionLane4:
                        case TransitionLane5:
                        case TransitionLane6:
                        case TransitionLane7:
                        case TransitionLane8:
                        case TransitionLane9:
                        case TransitionLane10:
                        case TransitionLane11:
                        case TransitionLane12:
                        case TransitionLane13:
                        case TransitionLane14:
                        case TransitionLane15:
                        case TransitionLane16:
                        case RetryLane1:
                        case RetryLane2:
                        case RetryLane3:
                        case RetryLane4:
                        case RetryLane5:
                            lane = TransitionHydrationLane;
                            break;
                        case IdleLane:
                            lane = IdleHydrationLane;
                            break;
                        default:
                            lane = NoLane;
                            break;
                    }
                    if ((lane & (root.suspendedLanes | renderLanes2)) !== NoLane) {
                        return NoLane;
                    }
                    return lane;
                }
                function addFiberToLanesMap(root, fiber, lanes) {
                    if (!isDevToolsPresent) {
                        return;
                    }
                    var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;
                    while(lanes > 0){
                        var index2 = laneToIndex(lanes);
                        var lane = 1 << index2;
                        var updaters = pendingUpdatersLaneMap[index2];
                        updaters.add(fiber);
                        lanes &= ~lane;
                    }
                }
                function movePendingFibersToMemoized(root, lanes) {
                    if (!isDevToolsPresent) {
                        return;
                    }
                    var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;
                    var memoizedUpdaters = root.memoizedUpdaters;
                    while(lanes > 0){
                        var index2 = laneToIndex(lanes);
                        var lane = 1 << index2;
                        var updaters = pendingUpdatersLaneMap[index2];
                        if (updaters.size > 0) {
                            updaters.forEach(function(fiber) {
                                var alternate = fiber.alternate;
                                if (alternate === null || !memoizedUpdaters.has(alternate)) {
                                    memoizedUpdaters.add(fiber);
                                }
                            });
                            updaters.clear();
                        }
                        lanes &= ~lane;
                    }
                }
                var DiscreteEventPriority = SyncLane;
                var ContinuousEventPriority = InputContinuousLane;
                var DefaultEventPriority = DefaultLane;
                var IdleEventPriority = IdleLane;
                var currentUpdatePriority = NoLane;
                function getCurrentUpdatePriority() {
                    return currentUpdatePriority;
                }
                function setCurrentUpdatePriority(newPriority) {
                    currentUpdatePriority = newPriority;
                }
                function runWithPriority(priority, fn) {
                    var previousPriority = currentUpdatePriority;
                    try {
                        currentUpdatePriority = priority;
                        return fn();
                    } finally{
                        currentUpdatePriority = previousPriority;
                    }
                }
                function higherEventPriority(a, b) {
                    return a !== 0 && a < b ? a : b;
                }
                function lowerEventPriority(a, b) {
                    return a === 0 || a > b ? a : b;
                }
                function isHigherEventPriority(a, b) {
                    return a !== 0 && a < b;
                }
                function lanesToEventPriority(lanes) {
                    var lane = getHighestPriorityLane(lanes);
                    if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
                        return DiscreteEventPriority;
                    }
                    if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
                        return ContinuousEventPriority;
                    }
                    if (includesNonIdleWork(lane)) {
                        return DefaultEventPriority;
                    }
                    return IdleEventPriority;
                }
                var scheduleCallback = Scheduler.unstable_scheduleCallback;
                var cancelCallback = Scheduler.unstable_cancelCallback;
                var shouldYield = Scheduler.unstable_shouldYield;
                var requestPaint = Scheduler.unstable_requestPaint;
                var now$1 = Scheduler.unstable_now;
                var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
                var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
                var NormalPriority = Scheduler.unstable_NormalPriority;
                var IdlePriority = Scheduler.unstable_IdlePriority;
                var unstable_yieldValue = Scheduler.unstable_yieldValue;
                var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
                var rendererID = null;
                var injectedHook = null;
                var injectedProfilingHooks = null;
                var hasLoggedError = false;
                var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
                function injectInternals(internals) {
                    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
                        return false;
                    }
                    var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                    if (hook.isDisabled) {
                        return true;
                    }
                    if (!hook.supportsFiber) {
                        {
                            error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
                        }
                        return true;
                    }
                    try {
                        if (enableSchedulingProfiler) {
                            internals = assign({}, internals, {
                                getLaneLabelMap,
                                injectProfilingHooks
                            });
                        }
                        rendererID = hook.inject(internals);
                        injectedHook = hook;
                    } catch (err) {
                        {
                            error("React instrumentation encountered an error: %s.", err);
                        }
                    }
                    if (hook.checkDCE) {
                        return true;
                    } else {
                        return false;
                    }
                }
                function onScheduleRoot(root, children2) {
                    {
                        if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
                            try {
                                injectedHook.onScheduleFiberRoot(rendererID, root, children2);
                            } catch (err) {
                                if (!hasLoggedError) {
                                    hasLoggedError = true;
                                    error("React instrumentation encountered an error: %s", err);
                                }
                            }
                        }
                    }
                }
                function onCommitRoot(root, eventPriority) {
                    if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
                        try {
                            var didError = (root.current.flags & DidCapture) === DidCapture;
                            if (enableProfilerTimer) {
                                var schedulerPriority;
                                switch(eventPriority){
                                    case DiscreteEventPriority:
                                        schedulerPriority = ImmediatePriority;
                                        break;
                                    case ContinuousEventPriority:
                                        schedulerPriority = UserBlockingPriority;
                                        break;
                                    case DefaultEventPriority:
                                        schedulerPriority = NormalPriority;
                                        break;
                                    case IdleEventPriority:
                                        schedulerPriority = IdlePriority;
                                        break;
                                    default:
                                        schedulerPriority = NormalPriority;
                                        break;
                                }
                                injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);
                            } else {
                                injectedHook.onCommitFiberRoot(rendererID, root, void 0, didError);
                            }
                        } catch (err) {
                            {
                                if (!hasLoggedError) {
                                    hasLoggedError = true;
                                    error("React instrumentation encountered an error: %s", err);
                                }
                            }
                        }
                    }
                }
                function onPostCommitRoot(root) {
                    if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
                        try {
                            injectedHook.onPostCommitFiberRoot(rendererID, root);
                        } catch (err) {
                            {
                                if (!hasLoggedError) {
                                    hasLoggedError = true;
                                    error("React instrumentation encountered an error: %s", err);
                                }
                            }
                        }
                    }
                }
                function onCommitUnmount(fiber) {
                    if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
                        try {
                            injectedHook.onCommitFiberUnmount(rendererID, fiber);
                        } catch (err) {
                            {
                                if (!hasLoggedError) {
                                    hasLoggedError = true;
                                    error("React instrumentation encountered an error: %s", err);
                                }
                            }
                        }
                    }
                }
                function setIsStrictModeForDevtools(newIsStrictMode) {
                    {
                        if (typeof unstable_yieldValue === "function") {
                            unstable_setDisableYieldValue(newIsStrictMode);
                            setSuppressWarning(newIsStrictMode);
                        }
                        if (injectedHook && typeof injectedHook.setStrictMode === "function") {
                            try {
                                injectedHook.setStrictMode(rendererID, newIsStrictMode);
                            } catch (err) {
                                {
                                    if (!hasLoggedError) {
                                        hasLoggedError = true;
                                        error("React instrumentation encountered an error: %s", err);
                                    }
                                }
                            }
                        }
                    }
                }
                function injectProfilingHooks(profilingHooks) {
                    injectedProfilingHooks = profilingHooks;
                }
                function getLaneLabelMap() {
                    {
                        var map2 = /* @__PURE__ */ new Map();
                        var lane = 1;
                        for(var index2 = 0; index2 < TotalLanes; index2++){
                            var label = getLabelForLane(lane);
                            map2.set(lane, label);
                            lane *= 2;
                        }
                        return map2;
                    }
                }
                function markCommitStarted(lanes) {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
                            injectedProfilingHooks.markCommitStarted(lanes);
                        }
                    }
                }
                function markCommitStopped() {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
                            injectedProfilingHooks.markCommitStopped();
                        }
                    }
                }
                function markComponentRenderStarted(fiber) {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
                            injectedProfilingHooks.markComponentRenderStarted(fiber);
                        }
                    }
                }
                function markComponentRenderStopped() {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
                            injectedProfilingHooks.markComponentRenderStopped();
                        }
                    }
                }
                function markComponentPassiveEffectMountStarted(fiber) {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
                            injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
                        }
                    }
                }
                function markComponentPassiveEffectMountStopped() {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
                            injectedProfilingHooks.markComponentPassiveEffectMountStopped();
                        }
                    }
                }
                function markComponentPassiveEffectUnmountStarted(fiber) {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
                            injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
                        }
                    }
                }
                function markComponentPassiveEffectUnmountStopped() {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
                            injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
                        }
                    }
                }
                function markComponentLayoutEffectMountStarted(fiber) {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
                            injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
                        }
                    }
                }
                function markComponentLayoutEffectMountStopped() {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
                            injectedProfilingHooks.markComponentLayoutEffectMountStopped();
                        }
                    }
                }
                function markComponentLayoutEffectUnmountStarted(fiber) {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
                            injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
                        }
                    }
                }
                function markComponentLayoutEffectUnmountStopped() {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
                            injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
                        }
                    }
                }
                function markComponentErrored(fiber, thrownValue, lanes) {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
                            injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
                        }
                    }
                }
                function markComponentSuspended(fiber, wakeable, lanes) {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
                            injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
                        }
                    }
                }
                function markLayoutEffectsStarted(lanes) {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
                            injectedProfilingHooks.markLayoutEffectsStarted(lanes);
                        }
                    }
                }
                function markLayoutEffectsStopped() {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
                            injectedProfilingHooks.markLayoutEffectsStopped();
                        }
                    }
                }
                function markPassiveEffectsStarted(lanes) {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
                            injectedProfilingHooks.markPassiveEffectsStarted(lanes);
                        }
                    }
                }
                function markPassiveEffectsStopped() {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
                            injectedProfilingHooks.markPassiveEffectsStopped();
                        }
                    }
                }
                function markRenderStarted(lanes) {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
                            injectedProfilingHooks.markRenderStarted(lanes);
                        }
                    }
                }
                function markRenderYielded() {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
                            injectedProfilingHooks.markRenderYielded();
                        }
                    }
                }
                function markRenderStopped() {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
                            injectedProfilingHooks.markRenderStopped();
                        }
                    }
                }
                function markRenderScheduled(lane) {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
                            injectedProfilingHooks.markRenderScheduled(lane);
                        }
                    }
                }
                function markForceUpdateScheduled(fiber, lane) {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
                            injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
                        }
                    }
                }
                function markStateUpdateScheduled(fiber, lane) {
                    {
                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
                            injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
                        }
                    }
                }
                function is(x, y) {
                    return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
                }
                var objectIs = typeof Object.is === "function" ? Object.is : is;
                var syncQueue = null;
                var includesLegacySyncCallbacks = false;
                var isFlushingSyncQueue = false;
                function scheduleSyncCallback(callback) {
                    if (syncQueue === null) {
                        syncQueue = [
                            callback
                        ];
                    } else {
                        syncQueue.push(callback);
                    }
                }
                function scheduleLegacySyncCallback(callback) {
                    includesLegacySyncCallbacks = true;
                    scheduleSyncCallback(callback);
                }
                function flushSyncCallbacksOnlyInLegacyMode() {
                    if (includesLegacySyncCallbacks) {
                        flushSyncCallbacks();
                    }
                }
                function flushSyncCallbacks() {
                    if (!isFlushingSyncQueue && syncQueue !== null) {
                        isFlushingSyncQueue = true;
                        var i = 0;
                        var previousUpdatePriority = getCurrentUpdatePriority();
                        try {
                            var isSync = true;
                            var queue = syncQueue;
                            setCurrentUpdatePriority(DiscreteEventPriority);
                            for(; i < queue.length; i++){
                                var callback = queue[i];
                                do {
                                    callback = callback(isSync);
                                }while (callback !== null)
                            }
                            syncQueue = null;
                            includesLegacySyncCallbacks = false;
                        } catch (error2) {
                            if (syncQueue !== null) {
                                syncQueue = syncQueue.slice(i + 1);
                            }
                            scheduleCallback(ImmediatePriority, flushSyncCallbacks);
                            throw error2;
                        } finally{
                            setCurrentUpdatePriority(previousUpdatePriority);
                            isFlushingSyncQueue = false;
                        }
                    }
                    return null;
                }
                function isRootDehydrated(root) {
                    var currentState = root.current.memoizedState;
                    return currentState.isDehydrated;
                }
                var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
                var NoTransition = null;
                function requestCurrentTransition() {
                    return ReactCurrentBatchConfig.transition;
                }
                function shallowEqual(objA, objB) {
                    if (objectIs(objA, objB)) {
                        return true;
                    }
                    if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
                        return false;
                    }
                    var keysA = Object.keys(objA);
                    var keysB = Object.keys(objB);
                    if (keysA.length !== keysB.length) {
                        return false;
                    }
                    for(var i = 0; i < keysA.length; i++){
                        var currentKey = keysA[i];
                        if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
                            return false;
                        }
                    }
                    return true;
                }
                function describeFiber(fiber) {
                    var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
                    var source = fiber._debugSource;
                    switch(fiber.tag){
                        case HostComponent2:
                            return describeBuiltInComponentFrame(fiber.type);
                        case LazyComponent:
                            return describeBuiltInComponentFrame("Lazy");
                        case SuspenseComponent2:
                            return describeBuiltInComponentFrame("Suspense");
                        case SuspenseListComponent:
                            return describeBuiltInComponentFrame("SuspenseList");
                        case FunctionComponent:
                        case IndeterminateComponent:
                        case SimpleMemoComponent:
                            return describeFunctionComponentFrame(fiber.type);
                        case ForwardRef:
                            return describeFunctionComponentFrame(fiber.type.render);
                        case ClassComponent:
                            return describeClassComponentFrame(fiber.type);
                        default:
                            return "";
                    }
                }
                function getStackByFiberInDevAndProd(workInProgress2) {
                    try {
                        var info = "";
                        var node = workInProgress2;
                        do {
                            info += describeFiber(node);
                            node = node.return;
                        }while (node)
                        return info;
                    } catch (x) {
                        return "\nError generating stack: " + x.message + "\n" + x.stack;
                    }
                }
                var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
                var current = null;
                var isRendering = false;
                function getCurrentFiberOwnerNameInDevOrNull() {
                    {
                        if (current === null) {
                            return null;
                        }
                        var owner = current._debugOwner;
                        if (owner !== null && typeof owner !== "undefined") {
                            return getComponentNameFromFiber(owner);
                        }
                    }
                    return null;
                }
                function getCurrentFiberStackInDev() {
                    {
                        if (current === null) {
                            return "";
                        }
                        return getStackByFiberInDevAndProd(current);
                    }
                }
                function resetCurrentFiber() {
                    {
                        ReactDebugCurrentFrame$1.getCurrentStack = null;
                        current = null;
                        isRendering = false;
                    }
                }
                function setCurrentFiber(fiber) {
                    {
                        ReactDebugCurrentFrame$1.getCurrentStack = getCurrentFiberStackInDev;
                        current = fiber;
                        isRendering = false;
                    }
                }
                function setIsRendering(rendering) {
                    {
                        isRendering = rendering;
                    }
                }
                var ReactStrictModeWarnings = {
                    recordUnsafeLifecycleWarnings: function(fiber, instance) {},
                    flushPendingUnsafeLifecycleWarnings: function() {},
                    recordLegacyContextWarning: function(fiber, instance) {},
                    flushLegacyContextWarning: function() {},
                    discardPendingWarnings: function() {}
                };
                {
                    var findStrictRoot = function(fiber) {
                        var maybeStrictRoot = null;
                        var node = fiber;
                        while(node !== null){
                            if (node.mode & StrictLegacyMode) {
                                maybeStrictRoot = node;
                            }
                            node = node.return;
                        }
                        return maybeStrictRoot;
                    };
                    var setToSortedString = function(set2) {
                        var array = [];
                        set2.forEach(function(value) {
                            array.push(value);
                        });
                        return array.sort().join(", ");
                    };
                    var pendingComponentWillMountWarnings = [];
                    var pendingUNSAFE_ComponentWillMountWarnings = [];
                    var pendingComponentWillReceivePropsWarnings = [];
                    var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
                    var pendingComponentWillUpdateWarnings = [];
                    var pendingUNSAFE_ComponentWillUpdateWarnings = [];
                    var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
                    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
                        if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
                            return;
                        }
                        if (typeof instance.componentWillMount === "function" && // Don't warn about react-lifecycles-compat polyfilled components.
                        instance.componentWillMount.__suppressDeprecationWarning !== true) {
                            pendingComponentWillMountWarnings.push(fiber);
                        }
                        if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === "function") {
                            pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
                        }
                        if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                            pendingComponentWillReceivePropsWarnings.push(fiber);
                        }
                        if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                            pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
                        }
                        if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                            pendingComponentWillUpdateWarnings.push(fiber);
                        }
                        if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
                            pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
                        }
                    };
                    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
                        var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
                        if (pendingComponentWillMountWarnings.length > 0) {
                            pendingComponentWillMountWarnings.forEach(function(fiber) {
                                componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                                didWarnAboutUnsafeLifecycles.add(fiber.type);
                            });
                            pendingComponentWillMountWarnings = [];
                        }
                        var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
                        if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
                            pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                                UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                                didWarnAboutUnsafeLifecycles.add(fiber.type);
                            });
                            pendingUNSAFE_ComponentWillMountWarnings = [];
                        }
                        var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
                        if (pendingComponentWillReceivePropsWarnings.length > 0) {
                            pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                                componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                                didWarnAboutUnsafeLifecycles.add(fiber.type);
                            });
                            pendingComponentWillReceivePropsWarnings = [];
                        }
                        var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
                        if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
                            pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                                UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                                didWarnAboutUnsafeLifecycles.add(fiber.type);
                            });
                            pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
                        }
                        var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
                        if (pendingComponentWillUpdateWarnings.length > 0) {
                            pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                                componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                                didWarnAboutUnsafeLifecycles.add(fiber.type);
                            });
                            pendingComponentWillUpdateWarnings = [];
                        }
                        var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
                        if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
                            pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                                UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                                didWarnAboutUnsafeLifecycles.add(fiber.type);
                            });
                            pendingUNSAFE_ComponentWillUpdateWarnings = [];
                        }
                        if (UNSAFE_componentWillMountUniqueNames.size > 0) {
                            var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
                            error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
                        }
                        if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
                            var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
                            error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
                        }
                        if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
                            var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
                            error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
                        }
                        if (componentWillMountUniqueNames.size > 0) {
                            var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
                            warn3("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
                        }
                        if (componentWillReceivePropsUniqueNames.size > 0) {
                            var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
                            warn3("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
                        }
                        if (componentWillUpdateUniqueNames.size > 0) {
                            var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
                            warn3("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
                        }
                    };
                    var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
                    var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
                    ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
                        var strictRoot = findStrictRoot(fiber);
                        if (strictRoot === null) {
                            error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
                            return;
                        }
                        if (didWarnAboutLegacyContext.has(fiber.type)) {
                            return;
                        }
                        var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
                        if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
                            if (warningsForRoot === void 0) {
                                warningsForRoot = [];
                                pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
                            }
                            warningsForRoot.push(fiber);
                        }
                    };
                    ReactStrictModeWarnings.flushLegacyContextWarning = function() {
                        pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
                            if (fiberArray.length === 0) {
                                return;
                            }
                            var firstFiber = fiberArray[0];
                            var uniqueNames = /* @__PURE__ */ new Set();
                            fiberArray.forEach(function(fiber) {
                                uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                                didWarnAboutLegacyContext.add(fiber.type);
                            });
                            var sortedNames = setToSortedString(uniqueNames);
                            try {
                                setCurrentFiber(firstFiber);
                                error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
                            } finally{
                                resetCurrentFiber();
                            }
                        });
                    };
                    ReactStrictModeWarnings.discardPendingWarnings = function() {
                        pendingComponentWillMountWarnings = [];
                        pendingUNSAFE_ComponentWillMountWarnings = [];
                        pendingComponentWillReceivePropsWarnings = [];
                        pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
                        pendingComponentWillUpdateWarnings = [];
                        pendingUNSAFE_ComponentWillUpdateWarnings = [];
                        pendingLegacyContextWarning = /* @__PURE__ */ new Map();
                    };
                }
                function typeName(value) {
                    {
                        var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
                        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
                        return type;
                    }
                }
                function willCoercionThrow(value) {
                    {
                        try {
                            testStringCoercion(value);
                            return false;
                        } catch (e) {
                            return true;
                        }
                    }
                }
                function testStringCoercion(value) {
                    return "" + value;
                }
                function checkKeyStringCoercion(value) {
                    {
                        if (willCoercionThrow(value)) {
                            error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                            return testStringCoercion(value);
                        }
                    }
                }
                function checkPropStringCoercion(value, propName) {
                    {
                        if (willCoercionThrow(value)) {
                            error("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
                            return testStringCoercion(value);
                        }
                    }
                }
                function resolveDefaultProps(Component, baseProps) {
                    if (Component && Component.defaultProps) {
                        var props = assign({}, baseProps);
                        var defaultProps2 = Component.defaultProps;
                        for(var propName in defaultProps2){
                            if (props[propName] === void 0) {
                                props[propName] = defaultProps2[propName];
                            }
                        }
                        return props;
                    }
                    return baseProps;
                }
                var valueCursor = createCursor(null);
                var rendererSigil;
                {
                    rendererSigil = {};
                }
                var currentlyRenderingFiber = null;
                var lastContextDependency = null;
                var lastFullyObservedContext = null;
                var isDisallowedContextReadInDEV = false;
                function resetContextDependencies() {
                    currentlyRenderingFiber = null;
                    lastContextDependency = null;
                    lastFullyObservedContext = null;
                    {
                        isDisallowedContextReadInDEV = false;
                    }
                }
                function enterDisallowedContextReadInDEV() {
                    {
                        isDisallowedContextReadInDEV = true;
                    }
                }
                function exitDisallowedContextReadInDEV() {
                    {
                        isDisallowedContextReadInDEV = false;
                    }
                }
                function pushProvider(providerFiber, context, nextValue) {
                    if (isPrimaryRenderer) {
                        push(valueCursor, context._currentValue, providerFiber);
                        context._currentValue = nextValue;
                        {
                            if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                            }
                            context._currentRenderer = rendererSigil;
                        }
                    } else {
                        push(valueCursor, context._currentValue2, providerFiber);
                        context._currentValue2 = nextValue;
                        {
                            if (context._currentRenderer2 !== void 0 && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
                                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                            }
                            context._currentRenderer2 = rendererSigil;
                        }
                    }
                }
                function popProvider(context, providerFiber) {
                    var currentValue = valueCursor.current;
                    pop(valueCursor, providerFiber);
                    if (isPrimaryRenderer) {
                        {
                            context._currentValue = currentValue;
                        }
                    } else {
                        {
                            context._currentValue2 = currentValue;
                        }
                    }
                }
                function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
                    var node = parent;
                    while(node !== null){
                        var alternate = node.alternate;
                        if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
                            node.childLanes = mergeLanes(node.childLanes, renderLanes2);
                            if (alternate !== null) {
                                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
                            }
                        } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
                            alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
                        }
                        if (node === propagationRoot) {
                            break;
                        }
                        node = node.return;
                    }
                    {
                        if (node !== propagationRoot) {
                            error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
                        }
                    }
                }
                function propagateContextChange(workInProgress2, context, renderLanes2) {
                    {
                        propagateContextChange_eager(workInProgress2, context, renderLanes2);
                    }
                }
                function propagateContextChange_eager(workInProgress2, context, renderLanes2) {
                    var fiber = workInProgress2.child;
                    if (fiber !== null) {
                        fiber.return = workInProgress2;
                    }
                    while(fiber !== null){
                        var nextFiber = void 0;
                        var list = fiber.dependencies;
                        if (list !== null) {
                            nextFiber = fiber.child;
                            var dependency = list.firstContext;
                            while(dependency !== null){
                                if (dependency.context === context) {
                                    if (fiber.tag === ClassComponent) {
                                        var lane = pickArbitraryLane(renderLanes2);
                                        var update = createUpdate(NoTimestamp, lane);
                                        update.tag = ForceUpdate;
                                        var updateQueue = fiber.updateQueue;
                                        if (updateQueue === null) ;
                                        else {
                                            var sharedQueue = updateQueue.shared;
                                            var pending = sharedQueue.pending;
                                            if (pending === null) {
                                                update.next = update;
                                            } else {
                                                update.next = pending.next;
                                                pending.next = update;
                                            }
                                            sharedQueue.pending = update;
                                        }
                                    }
                                    fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                                    var alternate = fiber.alternate;
                                    if (alternate !== null) {
                                        alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                                    }
                                    scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);
                                    list.lanes = mergeLanes(list.lanes, renderLanes2);
                                    break;
                                }
                                dependency = dependency.next;
                            }
                        } else if (fiber.tag === ContextProvider) {
                            nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
                        } else if (fiber.tag === DehydratedFragment) {
                            var parentSuspense = fiber.return;
                            if (parentSuspense === null) {
                                throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
                            }
                            parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
                            var _alternate = parentSuspense.alternate;
                            if (_alternate !== null) {
                                _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);
                            }
                            scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);
                            nextFiber = fiber.sibling;
                        } else {
                            nextFiber = fiber.child;
                        }
                        if (nextFiber !== null) {
                            nextFiber.return = fiber;
                        } else {
                            nextFiber = fiber;
                            while(nextFiber !== null){
                                if (nextFiber === workInProgress2) {
                                    nextFiber = null;
                                    break;
                                }
                                var sibling = nextFiber.sibling;
                                if (sibling !== null) {
                                    sibling.return = nextFiber.return;
                                    nextFiber = sibling;
                                    break;
                                }
                                nextFiber = nextFiber.return;
                            }
                        }
                        fiber = nextFiber;
                    }
                }
                function prepareToReadContext(workInProgress2, renderLanes2) {
                    currentlyRenderingFiber = workInProgress2;
                    lastContextDependency = null;
                    lastFullyObservedContext = null;
                    var dependencies = workInProgress2.dependencies;
                    if (dependencies !== null) {
                        {
                            var firstContext = dependencies.firstContext;
                            if (firstContext !== null) {
                                if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                                    markWorkInProgressReceivedUpdate();
                                }
                                dependencies.firstContext = null;
                            }
                        }
                    }
                }
                function readContext(context) {
                    {
                        if (isDisallowedContextReadInDEV) {
                            error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
                        }
                    }
                    var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;
                    if (lastFullyObservedContext === context) ;
                    else {
                        var contextItem = {
                            context,
                            memoizedValue: value,
                            next: null
                        };
                        if (lastContextDependency === null) {
                            if (currentlyRenderingFiber === null) {
                                throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
                            }
                            lastContextDependency = contextItem;
                            currentlyRenderingFiber.dependencies = {
                                lanes: NoLanes,
                                firstContext: contextItem
                            };
                        } else {
                            lastContextDependency = lastContextDependency.next = contextItem;
                        }
                    }
                    return value;
                }
                var interleavedQueues = null;
                function pushInterleavedQueue(queue) {
                    if (interleavedQueues === null) {
                        interleavedQueues = [
                            queue
                        ];
                    } else {
                        interleavedQueues.push(queue);
                    }
                }
                function enqueueInterleavedUpdates() {
                    if (interleavedQueues !== null) {
                        for(var i = 0; i < interleavedQueues.length; i++){
                            var queue = interleavedQueues[i];
                            var lastInterleavedUpdate = queue.interleaved;
                            if (lastInterleavedUpdate !== null) {
                                queue.interleaved = null;
                                var firstInterleavedUpdate = lastInterleavedUpdate.next;
                                var lastPendingUpdate = queue.pending;
                                if (lastPendingUpdate !== null) {
                                    var firstPendingUpdate = lastPendingUpdate.next;
                                    lastPendingUpdate.next = firstInterleavedUpdate;
                                    lastInterleavedUpdate.next = firstPendingUpdate;
                                }
                                queue.pending = lastInterleavedUpdate;
                            }
                        }
                        interleavedQueues = null;
                    }
                }
                var UpdateState = 0;
                var ReplaceState = 1;
                var ForceUpdate = 2;
                var CaptureUpdate = 3;
                var hasForceUpdate = false;
                var didWarnUpdateInsideUpdate;
                var currentlyProcessingQueue;
                {
                    didWarnUpdateInsideUpdate = false;
                    currentlyProcessingQueue = null;
                }
                function initializeUpdateQueue(fiber) {
                    var queue = {
                        baseState: fiber.memoizedState,
                        firstBaseUpdate: null,
                        lastBaseUpdate: null,
                        shared: {
                            pending: null,
                            interleaved: null,
                            lanes: NoLanes
                        },
                        effects: null
                    };
                    fiber.updateQueue = queue;
                }
                function cloneUpdateQueue(current2, workInProgress2) {
                    var queue = workInProgress2.updateQueue;
                    var currentQueue = current2.updateQueue;
                    if (queue === currentQueue) {
                        var clone = {
                            baseState: currentQueue.baseState,
                            firstBaseUpdate: currentQueue.firstBaseUpdate,
                            lastBaseUpdate: currentQueue.lastBaseUpdate,
                            shared: currentQueue.shared,
                            effects: currentQueue.effects
                        };
                        workInProgress2.updateQueue = clone;
                    }
                }
                function createUpdate(eventTime, lane) {
                    var update = {
                        eventTime,
                        lane,
                        tag: UpdateState,
                        payload: null,
                        callback: null,
                        next: null
                    };
                    return update;
                }
                function enqueueUpdate(fiber, update, lane) {
                    var updateQueue = fiber.updateQueue;
                    if (updateQueue === null) {
                        return;
                    }
                    var sharedQueue = updateQueue.shared;
                    if (isInterleavedUpdate(fiber)) {
                        var interleaved = sharedQueue.interleaved;
                        if (interleaved === null) {
                            update.next = update;
                            pushInterleavedQueue(sharedQueue);
                        } else {
                            update.next = interleaved.next;
                            interleaved.next = update;
                        }
                        sharedQueue.interleaved = update;
                    } else {
                        var pending = sharedQueue.pending;
                        if (pending === null) {
                            update.next = update;
                        } else {
                            update.next = pending.next;
                            pending.next = update;
                        }
                        sharedQueue.pending = update;
                    }
                    {
                        if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
                            error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
                            didWarnUpdateInsideUpdate = true;
                        }
                    }
                }
                function entangleTransitions(root, fiber, lane) {
                    var updateQueue = fiber.updateQueue;
                    if (updateQueue === null) {
                        return;
                    }
                    var sharedQueue = updateQueue.shared;
                    if (isTransitionLane(lane)) {
                        var queueLanes = sharedQueue.lanes;
                        queueLanes = intersectLanes(queueLanes, root.pendingLanes);
                        var newQueueLanes = mergeLanes(queueLanes, lane);
                        sharedQueue.lanes = newQueueLanes;
                        markRootEntangled(root, newQueueLanes);
                    }
                }
                function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
                    var queue = workInProgress2.updateQueue;
                    var current2 = workInProgress2.alternate;
                    if (current2 !== null) {
                        var currentQueue = current2.updateQueue;
                        if (queue === currentQueue) {
                            var newFirst = null;
                            var newLast = null;
                            var firstBaseUpdate = queue.firstBaseUpdate;
                            if (firstBaseUpdate !== null) {
                                var update = firstBaseUpdate;
                                do {
                                    var clone = {
                                        eventTime: update.eventTime,
                                        lane: update.lane,
                                        tag: update.tag,
                                        payload: update.payload,
                                        callback: update.callback,
                                        next: null
                                    };
                                    if (newLast === null) {
                                        newFirst = newLast = clone;
                                    } else {
                                        newLast.next = clone;
                                        newLast = clone;
                                    }
                                    update = update.next;
                                }while (update !== null)
                                if (newLast === null) {
                                    newFirst = newLast = capturedUpdate;
                                } else {
                                    newLast.next = capturedUpdate;
                                    newLast = capturedUpdate;
                                }
                            } else {
                                newFirst = newLast = capturedUpdate;
                            }
                            queue = {
                                baseState: currentQueue.baseState,
                                firstBaseUpdate: newFirst,
                                lastBaseUpdate: newLast,
                                shared: currentQueue.shared,
                                effects: currentQueue.effects
                            };
                            workInProgress2.updateQueue = queue;
                            return;
                        }
                    }
                    var lastBaseUpdate = queue.lastBaseUpdate;
                    if (lastBaseUpdate === null) {
                        queue.firstBaseUpdate = capturedUpdate;
                    } else {
                        lastBaseUpdate.next = capturedUpdate;
                    }
                    queue.lastBaseUpdate = capturedUpdate;
                }
                function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {
                    switch(update.tag){
                        case ReplaceState:
                            {
                                var payload = update.payload;
                                if (typeof payload === "function") {
                                    {
                                        enterDisallowedContextReadInDEV();
                                    }
                                    var nextState = payload.call(instance, prevState, nextProps);
                                    {
                                        if (workInProgress2.mode & StrictLegacyMode) {
                                            setIsStrictModeForDevtools(true);
                                            try {
                                                payload.call(instance, prevState, nextProps);
                                            } finally{
                                                setIsStrictModeForDevtools(false);
                                            }
                                        }
                                        exitDisallowedContextReadInDEV();
                                    }
                                    return nextState;
                                }
                                return payload;
                            }
                        case CaptureUpdate:
                            {
                                workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
                            }
                        case UpdateState:
                            {
                                var _payload = update.payload;
                                var partialState;
                                if (typeof _payload === "function") {
                                    {
                                        enterDisallowedContextReadInDEV();
                                    }
                                    partialState = _payload.call(instance, prevState, nextProps);
                                    {
                                        if (workInProgress2.mode & StrictLegacyMode) {
                                            setIsStrictModeForDevtools(true);
                                            try {
                                                _payload.call(instance, prevState, nextProps);
                                            } finally{
                                                setIsStrictModeForDevtools(false);
                                            }
                                        }
                                        exitDisallowedContextReadInDEV();
                                    }
                                } else {
                                    partialState = _payload;
                                }
                                if (partialState === null || partialState === void 0) {
                                    return prevState;
                                }
                                return assign({}, prevState, partialState);
                            }
                        case ForceUpdate:
                            {
                                hasForceUpdate = true;
                                return prevState;
                            }
                    }
                    return prevState;
                }
                function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
                    var queue = workInProgress2.updateQueue;
                    hasForceUpdate = false;
                    {
                        currentlyProcessingQueue = queue.shared;
                    }
                    var firstBaseUpdate = queue.firstBaseUpdate;
                    var lastBaseUpdate = queue.lastBaseUpdate;
                    var pendingQueue = queue.shared.pending;
                    if (pendingQueue !== null) {
                        queue.shared.pending = null;
                        var lastPendingUpdate = pendingQueue;
                        var firstPendingUpdate = lastPendingUpdate.next;
                        lastPendingUpdate.next = null;
                        if (lastBaseUpdate === null) {
                            firstBaseUpdate = firstPendingUpdate;
                        } else {
                            lastBaseUpdate.next = firstPendingUpdate;
                        }
                        lastBaseUpdate = lastPendingUpdate;
                        var current2 = workInProgress2.alternate;
                        if (current2 !== null) {
                            var currentQueue = current2.updateQueue;
                            var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
                            if (currentLastBaseUpdate !== lastBaseUpdate) {
                                if (currentLastBaseUpdate === null) {
                                    currentQueue.firstBaseUpdate = firstPendingUpdate;
                                } else {
                                    currentLastBaseUpdate.next = firstPendingUpdate;
                                }
                                currentQueue.lastBaseUpdate = lastPendingUpdate;
                            }
                        }
                    }
                    if (firstBaseUpdate !== null) {
                        var newState = queue.baseState;
                        var newLanes = NoLanes;
                        var newBaseState = null;
                        var newFirstBaseUpdate = null;
                        var newLastBaseUpdate = null;
                        var update = firstBaseUpdate;
                        do {
                            var updateLane = update.lane;
                            var updateEventTime = update.eventTime;
                            if (!isSubsetOfLanes(renderLanes2, updateLane)) {
                                var clone = {
                                    eventTime: updateEventTime,
                                    lane: updateLane,
                                    tag: update.tag,
                                    payload: update.payload,
                                    callback: update.callback,
                                    next: null
                                };
                                if (newLastBaseUpdate === null) {
                                    newFirstBaseUpdate = newLastBaseUpdate = clone;
                                    newBaseState = newState;
                                } else {
                                    newLastBaseUpdate = newLastBaseUpdate.next = clone;
                                }
                                newLanes = mergeLanes(newLanes, updateLane);
                            } else {
                                if (newLastBaseUpdate !== null) {
                                    var _clone = {
                                        eventTime: updateEventTime,
                                        // This update is going to be committed so we never want uncommit
                                        // it. Using NoLane works because 0 is a subset of all bitmasks, so
                                        // this will never be skipped by the check above.
                                        lane: NoLane,
                                        tag: update.tag,
                                        payload: update.payload,
                                        callback: update.callback,
                                        next: null
                                    };
                                    newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                                }
                                newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);
                                var callback = update.callback;
                                if (callback !== null && // If the update was already committed, we should not queue its
                                // callback again.
                                update.lane !== NoLane) {
                                    workInProgress2.flags |= Callback;
                                    var effects = queue.effects;
                                    if (effects === null) {
                                        queue.effects = [
                                            update
                                        ];
                                    } else {
                                        effects.push(update);
                                    }
                                }
                            }
                            update = update.next;
                            if (update === null) {
                                pendingQueue = queue.shared.pending;
                                if (pendingQueue === null) {
                                    break;
                                } else {
                                    var _lastPendingUpdate = pendingQueue;
                                    var _firstPendingUpdate = _lastPendingUpdate.next;
                                    _lastPendingUpdate.next = null;
                                    update = _firstPendingUpdate;
                                    queue.lastBaseUpdate = _lastPendingUpdate;
                                    queue.shared.pending = null;
                                }
                            }
                        }while (true)
                        if (newLastBaseUpdate === null) {
                            newBaseState = newState;
                        }
                        queue.baseState = newBaseState;
                        queue.firstBaseUpdate = newFirstBaseUpdate;
                        queue.lastBaseUpdate = newLastBaseUpdate;
                        var lastInterleaved = queue.shared.interleaved;
                        if (lastInterleaved !== null) {
                            var interleaved = lastInterleaved;
                            do {
                                newLanes = mergeLanes(newLanes, interleaved.lane);
                                interleaved = interleaved.next;
                            }while (interleaved !== lastInterleaved)
                        } else if (firstBaseUpdate === null) {
                            queue.shared.lanes = NoLanes;
                        }
                        markSkippedUpdateLanes(newLanes);
                        workInProgress2.lanes = newLanes;
                        workInProgress2.memoizedState = newState;
                    }
                    {
                        currentlyProcessingQueue = null;
                    }
                }
                function callCallback(callback, context) {
                    if (typeof callback !== "function") {
                        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
                    }
                    callback.call(context);
                }
                function resetHasForceUpdateBeforeProcessing() {
                    hasForceUpdate = false;
                }
                function checkHasForceUpdateAfterProcessing() {
                    return hasForceUpdate;
                }
                function commitUpdateQueue(finishedWork, finishedQueue, instance) {
                    var effects = finishedQueue.effects;
                    finishedQueue.effects = null;
                    if (effects !== null) {
                        for(var i = 0; i < effects.length; i++){
                            var effect = effects[i];
                            var callback = effect.callback;
                            if (callback !== null) {
                                effect.callback = null;
                                callCallback(callback, instance);
                            }
                        }
                    }
                }
                var fakeInternalInstance = {};
                var emptyRefsObject = new React188.Component().refs;
                var didWarnAboutStateAssignmentForComponent;
                var didWarnAboutUninitializedState;
                var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
                var didWarnAboutLegacyLifecyclesAndDerivedState;
                var didWarnAboutUndefinedDerivedState;
                var warnOnUndefinedDerivedState;
                var warnOnInvalidCallback;
                var didWarnAboutDirectlyAssigningPropsToState;
                var didWarnAboutContextTypeAndContextTypes;
                var didWarnAboutInvalidateContextType;
                {
                    didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
                    didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
                    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
                    didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
                    didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
                    didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
                    didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
                    didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
                    var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
                    warnOnInvalidCallback = function(callback, callerName) {
                        if (callback === null || typeof callback === "function") {
                            return;
                        }
                        var key = callerName + "_" + callback;
                        if (!didWarnOnInvalidCallback.has(key)) {
                            didWarnOnInvalidCallback.add(key);
                            error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
                        }
                    };
                    warnOnUndefinedDerivedState = function(type, partialState) {
                        if (partialState === void 0) {
                            var componentName = getComponentNameFromType(type) || "Component";
                            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                                didWarnAboutUndefinedDerivedState.add(componentName);
                                error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
                            }
                        }
                    };
                    Object.defineProperty(fakeInternalInstance, "_processChildContext", {
                        enumerable: false,
                        value: function() {
                            throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
                        }
                    });
                    Object.freeze(fakeInternalInstance);
                }
                function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
                    var prevState = workInProgress2.memoizedState;
                    var partialState = getDerivedStateFromProps(nextProps, prevState);
                    {
                        if (workInProgress2.mode & StrictLegacyMode) {
                            setIsStrictModeForDevtools(true);
                            try {
                                partialState = getDerivedStateFromProps(nextProps, prevState);
                            } finally{
                                setIsStrictModeForDevtools(false);
                            }
                        }
                        warnOnUndefinedDerivedState(ctor, partialState);
                    }
                    var memoizedState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
                    workInProgress2.memoizedState = memoizedState;
                    if (workInProgress2.lanes === NoLanes) {
                        var updateQueue = workInProgress2.updateQueue;
                        updateQueue.baseState = memoizedState;
                    }
                }
                var classComponentUpdater = {
                    isMounted,
                    enqueueSetState: function(inst, payload, callback) {
                        var fiber = get(inst);
                        var eventTime = requestEventTime();
                        var lane = requestUpdateLane(fiber);
                        var update = createUpdate(eventTime, lane);
                        update.payload = payload;
                        if (callback !== void 0 && callback !== null) {
                            {
                                warnOnInvalidCallback(callback, "setState");
                            }
                            update.callback = callback;
                        }
                        enqueueUpdate(fiber, update);
                        var root = scheduleUpdateOnFiber(fiber, lane, eventTime);
                        if (root !== null) {
                            entangleTransitions(root, fiber, lane);
                        }
                        {
                            markStateUpdateScheduled(fiber, lane);
                        }
                    },
                    enqueueReplaceState: function(inst, payload, callback) {
                        var fiber = get(inst);
                        var eventTime = requestEventTime();
                        var lane = requestUpdateLane(fiber);
                        var update = createUpdate(eventTime, lane);
                        update.tag = ReplaceState;
                        update.payload = payload;
                        if (callback !== void 0 && callback !== null) {
                            {
                                warnOnInvalidCallback(callback, "replaceState");
                            }
                            update.callback = callback;
                        }
                        enqueueUpdate(fiber, update);
                        var root = scheduleUpdateOnFiber(fiber, lane, eventTime);
                        if (root !== null) {
                            entangleTransitions(root, fiber, lane);
                        }
                        {
                            markStateUpdateScheduled(fiber, lane);
                        }
                    },
                    enqueueForceUpdate: function(inst, callback) {
                        var fiber = get(inst);
                        var eventTime = requestEventTime();
                        var lane = requestUpdateLane(fiber);
                        var update = createUpdate(eventTime, lane);
                        update.tag = ForceUpdate;
                        if (callback !== void 0 && callback !== null) {
                            {
                                warnOnInvalidCallback(callback, "forceUpdate");
                            }
                            update.callback = callback;
                        }
                        enqueueUpdate(fiber, update);
                        var root = scheduleUpdateOnFiber(fiber, lane, eventTime);
                        if (root !== null) {
                            entangleTransitions(root, fiber, lane);
                        }
                        {
                            markForceUpdateScheduled(fiber, lane);
                        }
                    }
                };
                function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
                    var instance = workInProgress2.stateNode;
                    if (typeof instance.shouldComponentUpdate === "function") {
                        var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
                        {
                            if (workInProgress2.mode & StrictLegacyMode) {
                                setIsStrictModeForDevtools(true);
                                try {
                                    shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
                                } finally{
                                    setIsStrictModeForDevtools(false);
                                }
                            }
                            if (shouldUpdate === void 0) {
                                error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
                            }
                        }
                        return shouldUpdate;
                    }
                    if (ctor.prototype && ctor.prototype.isPureReactComponent) {
                        return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
                    }
                    return true;
                }
                function checkClassInstance(workInProgress2, ctor, newProps) {
                    var instance = workInProgress2.stateNode;
                    {
                        var name = getComponentNameFromType(ctor) || "Component";
                        var renderPresent = instance.render;
                        if (!renderPresent) {
                            if (ctor.prototype && typeof ctor.prototype.render === "function") {
                                error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
                            } else {
                                error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
                            }
                        }
                        if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
                            error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
                        }
                        if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
                            error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
                        }
                        if (instance.propTypes) {
                            error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
                        }
                        if (instance.contextType) {
                            error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
                        }
                        {
                            if (instance.contextTypes) {
                                error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
                            }
                            if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                                didWarnAboutContextTypeAndContextTypes.add(ctor);
                                error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
                            }
                        }
                        if (typeof instance.componentShouldUpdate === "function") {
                            error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
                        }
                        if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
                            error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
                        }
                        if (typeof instance.componentDidUnmount === "function") {
                            error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
                        }
                        if (typeof instance.componentDidReceiveProps === "function") {
                            error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
                        }
                        if (typeof instance.componentWillRecieveProps === "function") {
                            error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
                        }
                        if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
                            error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
                        }
                        var hasMutatedProps = instance.props !== newProps;
                        if (instance.props !== void 0 && hasMutatedProps) {
                            error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
                        }
                        if (instance.defaultProps) {
                            error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
                        }
                        if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
                            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
                            error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
                        }
                        if (typeof instance.getDerivedStateFromProps === "function") {
                            error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
                        }
                        if (typeof instance.getDerivedStateFromError === "function") {
                            error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
                        }
                        if (typeof ctor.getSnapshotBeforeUpdate === "function") {
                            error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
                        }
                        var _state = instance.state;
                        if (_state && (typeof _state !== "object" || isArray(_state))) {
                            error("%s.state: must be set to an object or null", name);
                        }
                        if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
                            error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
                        }
                    }
                }
                function adoptClassInstance(workInProgress2, instance) {
                    instance.updater = classComponentUpdater;
                    workInProgress2.stateNode = instance;
                    set(instance, workInProgress2);
                    {
                        instance._reactInternalInstance = fakeInternalInstance;
                    }
                }
                function constructClassInstance(workInProgress2, ctor, props) {
                    var isLegacyContextConsumer = false;
                    var unmaskedContext = emptyContextObject;
                    var context = emptyContextObject;
                    var contextType = ctor.contextType;
                    {
                        if ("contextType" in ctor) {
                            var isValid = // Allow null for conditional declaration
                            contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
                            if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                                didWarnAboutInvalidateContextType.add(ctor);
                                var addendum = "";
                                if (contextType === void 0) {
                                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                                } else if (typeof contextType !== "object") {
                                    addendum = " However, it is set to a " + typeof contextType + ".";
                                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                                    addendum = " Did you accidentally pass the Context.Provider instead?";
                                } else if (contextType._context !== void 0) {
                                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                                } else {
                                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                                }
                                error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
                            }
                        }
                    }
                    if (typeof contextType === "object" && contextType !== null) {
                        context = readContext(contextType);
                    } else {
                        unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
                        var contextTypes = ctor.contextTypes;
                        isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
                        context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
                    }
                    var instance = new ctor(props, context);
                    {
                        if (workInProgress2.mode & StrictLegacyMode) {
                            setIsStrictModeForDevtools(true);
                            try {
                                instance = new ctor(props, context);
                            } finally{
                                setIsStrictModeForDevtools(false);
                            }
                        }
                    }
                    var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
                    adoptClassInstance(workInProgress2, instance);
                    {
                        if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
                            var componentName = getComponentNameFromType(ctor) || "Component";
                            if (!didWarnAboutUninitializedState.has(componentName)) {
                                didWarnAboutUninitializedState.add(componentName);
                                error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
                            }
                        }
                        if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
                            var foundWillMountName = null;
                            var foundWillReceivePropsName = null;
                            var foundWillUpdateName = null;
                            if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                                foundWillMountName = "componentWillMount";
                            } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                                foundWillMountName = "UNSAFE_componentWillMount";
                            }
                            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                                foundWillReceivePropsName = "componentWillReceiveProps";
                            } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                                foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
                            }
                            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                                foundWillUpdateName = "componentWillUpdate";
                            } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                                foundWillUpdateName = "UNSAFE_componentWillUpdate";
                            }
                            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                                var _componentName = getComponentNameFromType(ctor) || "Component";
                                var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                                    error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                                }
                            }
                        }
                    }
                    if (isLegacyContextConsumer) {
                        cacheContext(workInProgress2, unmaskedContext, context);
                    }
                    return instance;
                }
                function callComponentWillMount(workInProgress2, instance) {
                    var oldState = instance.state;
                    if (typeof instance.componentWillMount === "function") {
                        instance.componentWillMount();
                    }
                    if (typeof instance.UNSAFE_componentWillMount === "function") {
                        instance.UNSAFE_componentWillMount();
                    }
                    if (oldState !== instance.state) {
                        {
                            error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component");
                        }
                        classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
                    }
                }
                function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
                    var oldState = instance.state;
                    if (typeof instance.componentWillReceiveProps === "function") {
                        instance.componentWillReceiveProps(newProps, nextContext);
                    }
                    if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                        instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
                    }
                    if (instance.state !== oldState) {
                        {
                            var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
                            if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                                didWarnAboutStateAssignmentForComponent.add(componentName);
                                error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
                            }
                        }
                        classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
                    }
                }
                function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
                    {
                        checkClassInstance(workInProgress2, ctor, newProps);
                    }
                    var instance = workInProgress2.stateNode;
                    instance.props = newProps;
                    instance.state = workInProgress2.memoizedState;
                    instance.refs = emptyRefsObject;
                    initializeUpdateQueue(workInProgress2);
                    var contextType = ctor.contextType;
                    if (typeof contextType === "object" && contextType !== null) {
                        instance.context = readContext(contextType);
                    } else {
                        var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
                        instance.context = getMaskedContext(workInProgress2, unmaskedContext);
                    }
                    {
                        if (instance.state === newProps) {
                            var componentName = getComponentNameFromType(ctor) || "Component";
                            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                                error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
                            }
                        }
                        if (workInProgress2.mode & StrictLegacyMode) {
                            ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
                        }
                        {
                            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
                        }
                    }
                    instance.state = workInProgress2.memoizedState;
                    var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
                    if (typeof getDerivedStateFromProps === "function") {
                        applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
                        instance.state = workInProgress2.memoizedState;
                    }
                    if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
                        callComponentWillMount(workInProgress2, instance);
                        processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
                        instance.state = workInProgress2.memoizedState;
                    }
                    if (typeof instance.componentDidMount === "function") {
                        var fiberFlags = Update;
                        {
                            fiberFlags |= LayoutStatic;
                        }
                        if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                            fiberFlags |= MountLayoutDev;
                        }
                        workInProgress2.flags |= fiberFlags;
                    }
                }
                function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
                    var instance = workInProgress2.stateNode;
                    var oldProps = workInProgress2.memoizedProps;
                    instance.props = oldProps;
                    var oldContext = instance.context;
                    var contextType = ctor.contextType;
                    var nextContext = emptyContextObject;
                    if (typeof contextType === "object" && contextType !== null) {
                        nextContext = readContext(contextType);
                    } else {
                        var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
                        nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
                    }
                    var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
                    var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
                    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
                        if (oldProps !== newProps || oldContext !== nextContext) {
                            callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
                        }
                    }
                    resetHasForceUpdateBeforeProcessing();
                    var oldState = workInProgress2.memoizedState;
                    var newState = instance.state = oldState;
                    processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
                    newState = workInProgress2.memoizedState;
                    if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
                        if (typeof instance.componentDidMount === "function") {
                            var fiberFlags = Update;
                            {
                                fiberFlags |= LayoutStatic;
                            }
                            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                                fiberFlags |= MountLayoutDev;
                            }
                            workInProgress2.flags |= fiberFlags;
                        }
                        return false;
                    }
                    if (typeof getDerivedStateFromProps === "function") {
                        applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
                        newState = workInProgress2.memoizedState;
                    }
                    var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
                    if (shouldUpdate) {
                        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
                            if (typeof instance.componentWillMount === "function") {
                                instance.componentWillMount();
                            }
                            if (typeof instance.UNSAFE_componentWillMount === "function") {
                                instance.UNSAFE_componentWillMount();
                            }
                        }
                        if (typeof instance.componentDidMount === "function") {
                            var _fiberFlags = Update;
                            {
                                _fiberFlags |= LayoutStatic;
                            }
                            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                                _fiberFlags |= MountLayoutDev;
                            }
                            workInProgress2.flags |= _fiberFlags;
                        }
                    } else {
                        if (typeof instance.componentDidMount === "function") {
                            var _fiberFlags2 = Update;
                            {
                                _fiberFlags2 |= LayoutStatic;
                            }
                            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                                _fiberFlags2 |= MountLayoutDev;
                            }
                            workInProgress2.flags |= _fiberFlags2;
                        }
                        workInProgress2.memoizedProps = newProps;
                        workInProgress2.memoizedState = newState;
                    }
                    instance.props = newProps;
                    instance.state = newState;
                    instance.context = nextContext;
                    return shouldUpdate;
                }
                function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
                    var instance = workInProgress2.stateNode;
                    cloneUpdateQueue(current2, workInProgress2);
                    var unresolvedOldProps = workInProgress2.memoizedProps;
                    var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
                    instance.props = oldProps;
                    var unresolvedNewProps = workInProgress2.pendingProps;
                    var oldContext = instance.context;
                    var contextType = ctor.contextType;
                    var nextContext = emptyContextObject;
                    if (typeof contextType === "object" && contextType !== null) {
                        nextContext = readContext(contextType);
                    } else {
                        var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
                        nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
                    }
                    var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
                    var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
                    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
                        if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
                            callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
                        }
                    }
                    resetHasForceUpdateBeforeProcessing();
                    var oldState = workInProgress2.memoizedState;
                    var newState = instance.state = oldState;
                    processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
                    newState = workInProgress2.memoizedState;
                    if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {
                        if (typeof instance.componentDidUpdate === "function") {
                            if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                                workInProgress2.flags |= Update;
                            }
                        }
                        if (typeof instance.getSnapshotBeforeUpdate === "function") {
                            if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                                workInProgress2.flags |= Snapshot;
                            }
                        }
                        return false;
                    }
                    if (typeof getDerivedStateFromProps === "function") {
                        applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
                        newState = workInProgress2.memoizedState;
                    }
                    var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,
                    // both before and after `shouldComponentUpdate` has been called. Not ideal,
                    // but I'm loath to refactor this function. This only happens for memoized
                    // components so it's not that common.
                    enableLazyContextPropagation;
                    if (shouldUpdate) {
                        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
                            if (typeof instance.componentWillUpdate === "function") {
                                instance.componentWillUpdate(newProps, newState, nextContext);
                            }
                            if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                                instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
                            }
                        }
                        if (typeof instance.componentDidUpdate === "function") {
                            workInProgress2.flags |= Update;
                        }
                        if (typeof instance.getSnapshotBeforeUpdate === "function") {
                            workInProgress2.flags |= Snapshot;
                        }
                    } else {
                        if (typeof instance.componentDidUpdate === "function") {
                            if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                                workInProgress2.flags |= Update;
                            }
                        }
                        if (typeof instance.getSnapshotBeforeUpdate === "function") {
                            if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                                workInProgress2.flags |= Snapshot;
                            }
                        }
                        workInProgress2.memoizedProps = newProps;
                        workInProgress2.memoizedState = newState;
                    }
                    instance.props = newProps;
                    instance.state = newState;
                    instance.context = nextContext;
                    return shouldUpdate;
                }
                var forkStack = [];
                var forkStackIndex = 0;
                var treeForkProvider = null;
                var treeForkCount = 0;
                var idStack = [];
                var idStackIndex = 0;
                var treeContextProvider = null;
                var treeContextId = 1;
                var treeContextOverflow = "";
                function isForkedChild(workInProgress2) {
                    warnIfNotHydrating();
                    return (workInProgress2.flags & Forked) !== NoFlags;
                }
                function getForksAtLevel(workInProgress2) {
                    warnIfNotHydrating();
                    return treeForkCount;
                }
                function getTreeId() {
                    var overflow = treeContextOverflow;
                    var idWithLeadingBit = treeContextId;
                    var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
                    return id.toString(32) + overflow;
                }
                function pushTreeFork(workInProgress2, totalChildren) {
                    warnIfNotHydrating();
                    forkStack[forkStackIndex++] = treeForkCount;
                    forkStack[forkStackIndex++] = treeForkProvider;
                    treeForkProvider = workInProgress2;
                    treeForkCount = totalChildren;
                }
                function pushTreeId(workInProgress2, totalChildren, index2) {
                    warnIfNotHydrating();
                    idStack[idStackIndex++] = treeContextId;
                    idStack[idStackIndex++] = treeContextOverflow;
                    idStack[idStackIndex++] = treeContextProvider;
                    treeContextProvider = workInProgress2;
                    var baseIdWithLeadingBit = treeContextId;
                    var baseOverflow = treeContextOverflow;
                    var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
                    var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
                    var slot = index2 + 1;
                    var length = getBitLength(totalChildren) + baseLength;
                    if (length > 30) {
                        var numberOfOverflowBits = baseLength - baseLength % 5;
                        var newOverflowBits = (1 << numberOfOverflowBits) - 1;
                        var newOverflow = (baseId & newOverflowBits).toString(32);
                        var restOfBaseId = baseId >> numberOfOverflowBits;
                        var restOfBaseLength = baseLength - numberOfOverflowBits;
                        var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
                        var restOfNewBits = slot << restOfBaseLength;
                        var id = restOfNewBits | restOfBaseId;
                        var overflow = newOverflow + baseOverflow;
                        treeContextId = 1 << restOfLength | id;
                        treeContextOverflow = overflow;
                    } else {
                        var newBits = slot << baseLength;
                        var _id = newBits | baseId;
                        var _overflow = baseOverflow;
                        treeContextId = 1 << length | _id;
                        treeContextOverflow = _overflow;
                    }
                }
                function pushMaterializedTreeId(workInProgress2) {
                    warnIfNotHydrating();
                    var returnFiber = workInProgress2.return;
                    if (returnFiber !== null) {
                        var numberOfForks = 1;
                        var slotIndex = 0;
                        pushTreeFork(workInProgress2, numberOfForks);
                        pushTreeId(workInProgress2, numberOfForks, slotIndex);
                    }
                }
                function getBitLength(number) {
                    return 32 - clz32(number);
                }
                function getLeadingBit(id) {
                    return 1 << getBitLength(id) - 1;
                }
                function popTreeContext(workInProgress2) {
                    while(workInProgress2 === treeForkProvider){
                        treeForkProvider = forkStack[--forkStackIndex];
                        forkStack[forkStackIndex] = null;
                        treeForkCount = forkStack[--forkStackIndex];
                        forkStack[forkStackIndex] = null;
                    }
                    while(workInProgress2 === treeContextProvider){
                        treeContextProvider = idStack[--idStackIndex];
                        idStack[idStackIndex] = null;
                        treeContextOverflow = idStack[--idStackIndex];
                        idStack[idStackIndex] = null;
                        treeContextId = idStack[--idStackIndex];
                        idStack[idStackIndex] = null;
                    }
                }
                function getSuspendedTreeContext() {
                    warnIfNotHydrating();
                    if (treeContextProvider !== null) {
                        return {
                            id: treeContextId,
                            overflow: treeContextOverflow
                        };
                    } else {
                        return null;
                    }
                }
                function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
                    warnIfNotHydrating();
                    idStack[idStackIndex++] = treeContextId;
                    idStack[idStackIndex++] = treeContextOverflow;
                    idStack[idStackIndex++] = treeContextProvider;
                    treeContextId = suspendedContext.id;
                    treeContextOverflow = suspendedContext.overflow;
                    treeContextProvider = workInProgress2;
                }
                function warnIfNotHydrating() {
                    {
                        if (!getIsHydrating()) {
                            error("Expected to be hydrating. This is a bug in React. Please file an issue.");
                        }
                    }
                }
                var hydrationParentFiber = null;
                var nextHydratableInstance = null;
                var isHydrating = false;
                var didSuspend = false;
                var hydrationErrors = null;
                function warnIfHydrating() {
                    {
                        if (isHydrating) {
                            error("We should not be hydrating here. This is a bug in React. Please file a bug.");
                        }
                    }
                }
                function markDidSuspendWhileHydratingDEV() {
                    {
                        didSuspend = true;
                    }
                }
                function enterHydrationState(fiber) {
                    if (!supportsHydration) {
                        return false;
                    }
                    var parentInstance = fiber.stateNode.containerInfo;
                    nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
                    hydrationParentFiber = fiber;
                    isHydrating = true;
                    hydrationErrors = null;
                    didSuspend = false;
                    return true;
                }
                function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
                    if (!supportsHydration) {
                        return false;
                    }
                    nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
                    hydrationParentFiber = fiber;
                    isHydrating = true;
                    hydrationErrors = null;
                    didSuspend = false;
                    if (treeContext !== null) {
                        restoreSuspendedTreeContext(fiber, treeContext);
                    }
                    return true;
                }
                function warnUnhydratedInstance(returnFiber, instance) {
                    {
                        switch(returnFiber.tag){
                            case HostRoot2:
                                didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
                                break;
                            case HostComponent2:
                                didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
                                break;
                            case SuspenseComponent2:
                                var suspenseState = returnFiber.memoizedState;
                                if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
                                break;
                        }
                    }
                }
                function deleteHydratableInstance(returnFiber, instance) {
                    warnUnhydratedInstance(returnFiber, instance);
                    var childToDelete = createFiberFromHostInstanceForDeletion();
                    childToDelete.stateNode = instance;
                    childToDelete.return = returnFiber;
                    var deletions = returnFiber.deletions;
                    if (deletions === null) {
                        returnFiber.deletions = [
                            childToDelete
                        ];
                        returnFiber.flags |= ChildDeletion;
                    } else {
                        deletions.push(childToDelete);
                    }
                }
                function warnNonhydratedInstance(returnFiber, fiber) {
                    {
                        if (didSuspend) {
                            return;
                        }
                        switch(returnFiber.tag){
                            case HostRoot2:
                                {
                                    var parentContainer = returnFiber.stateNode.containerInfo;
                                    switch(fiber.tag){
                                        case HostComponent2:
                                            var type = fiber.type;
                                            var props = fiber.pendingProps;
                                            didNotFindHydratableInstanceWithinContainer(parentContainer, type, props);
                                            break;
                                        case HostText2:
                                            var text = fiber.pendingProps;
                                            didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);
                                            break;
                                        case SuspenseComponent2:
                                            didNotFindHydratableSuspenseInstanceWithinContainer(parentContainer);
                                            break;
                                    }
                                    break;
                                }
                            case HostComponent2:
                                {
                                    var parentType = returnFiber.type;
                                    var parentProps = returnFiber.memoizedProps;
                                    var parentInstance = returnFiber.stateNode;
                                    switch(fiber.tag){
                                        case HostComponent2:
                                            var _type = fiber.type;
                                            var _props = fiber.pendingProps;
                                            didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);
                                            break;
                                        case HostText2:
                                            var _text = fiber.pendingProps;
                                            didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                                            break;
                                        case SuspenseComponent2:
                                            didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance);
                                            break;
                                    }
                                    break;
                                }
                            case SuspenseComponent2:
                                {
                                    var suspenseState = returnFiber.memoizedState;
                                    var _parentInstance = suspenseState.dehydrated;
                                    if (_parentInstance !== null) switch(fiber.tag){
                                        case HostComponent2:
                                            var _type2 = fiber.type;
                                            var _props2 = fiber.pendingProps;
                                            didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2, _props2);
                                            break;
                                        case HostText2:
                                            var _text2 = fiber.pendingProps;
                                            didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                                            break;
                                        case SuspenseComponent2:
                                            didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(_parentInstance);
                                            break;
                                    }
                                    break;
                                }
                            default:
                                return;
                        }
                    }
                }
                function insertNonHydratedInstance(returnFiber, fiber) {
                    fiber.flags = fiber.flags & ~Hydrating | Placement;
                    warnNonhydratedInstance(returnFiber, fiber);
                }
                function tryHydrate(fiber, nextInstance) {
                    switch(fiber.tag){
                        case HostComponent2:
                            {
                                var type = fiber.type;
                                var props = fiber.pendingProps;
                                var instance = canHydrateInstance(nextInstance, type, props);
                                if (instance !== null) {
                                    fiber.stateNode = instance;
                                    hydrationParentFiber = fiber;
                                    nextHydratableInstance = getFirstHydratableChild(instance);
                                    return true;
                                }
                                return false;
                            }
                        case HostText2:
                            {
                                var text = fiber.pendingProps;
                                var textInstance = canHydrateTextInstance(nextInstance, text);
                                if (textInstance !== null) {
                                    fiber.stateNode = textInstance;
                                    hydrationParentFiber = fiber;
                                    nextHydratableInstance = null;
                                    return true;
                                }
                                return false;
                            }
                        case SuspenseComponent2:
                            {
                                {
                                    var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
                                    if (suspenseInstance !== null) {
                                        var suspenseState = {
                                            dehydrated: suspenseInstance,
                                            treeContext: getSuspendedTreeContext(),
                                            retryLane: OffscreenLane
                                        };
                                        fiber.memoizedState = suspenseState;
                                        var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
                                        dehydratedFragment.return = fiber;
                                        fiber.child = dehydratedFragment;
                                        hydrationParentFiber = fiber;
                                        nextHydratableInstance = null;
                                        return true;
                                    }
                                }
                                return false;
                            }
                        default:
                            return false;
                    }
                }
                function shouldClientRenderOnMismatch(fiber) {
                    return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
                }
                function throwOnHydrationMismatch(fiber) {
                    throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
                }
                function tryToClaimNextHydratableInstance(fiber) {
                    if (!isHydrating) {
                        return;
                    }
                    var nextInstance = nextHydratableInstance;
                    if (!nextInstance) {
                        if (shouldClientRenderOnMismatch(fiber)) {
                            warnNonhydratedInstance(hydrationParentFiber, fiber);
                            throwOnHydrationMismatch();
                        }
                        insertNonHydratedInstance(hydrationParentFiber, fiber);
                        isHydrating = false;
                        hydrationParentFiber = fiber;
                        return;
                    }
                    var firstAttemptedInstance = nextInstance;
                    if (!tryHydrate(fiber, nextInstance)) {
                        if (shouldClientRenderOnMismatch(fiber)) {
                            warnNonhydratedInstance(hydrationParentFiber, fiber);
                            throwOnHydrationMismatch();
                        }
                        nextInstance = getNextHydratableSibling(firstAttemptedInstance);
                        var prevHydrationParentFiber = hydrationParentFiber;
                        if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
                            insertNonHydratedInstance(hydrationParentFiber, fiber);
                            isHydrating = false;
                            hydrationParentFiber = fiber;
                            return;
                        }
                        deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
                    }
                }
                function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
                    if (!supportsHydration) {
                        throw new Error("Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    var instance = fiber.stateNode;
                    var shouldWarnIfMismatchDev = !didSuspend;
                    var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
                    fiber.updateQueue = updatePayload;
                    if (updatePayload !== null) {
                        return true;
                    }
                    return false;
                }
                function prepareToHydrateHostTextInstance(fiber) {
                    if (!supportsHydration) {
                        throw new Error("Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    var textInstance = fiber.stateNode;
                    var textContent = fiber.memoizedProps;
                    var shouldWarnIfMismatchDev = !didSuspend;
                    var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber, shouldWarnIfMismatchDev);
                    if (shouldUpdate) {
                        var returnFiber = hydrationParentFiber;
                        if (returnFiber !== null) {
                            var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                            switch(returnFiber.tag){
                                case HostRoot2:
                                    {
                                        var parentContainer = returnFiber.stateNode.containerInfo;
                                        didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent, // TODO: Delete this argument when we remove the legacy root API.
                                        isConcurrentMode);
                                        break;
                                    }
                                case HostComponent2:
                                    {
                                        var parentType = returnFiber.type;
                                        var parentProps = returnFiber.memoizedProps;
                                        var parentInstance = returnFiber.stateNode;
                                        didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent, // TODO: Delete this argument when we remove the legacy root API.
                                        isConcurrentMode);
                                        break;
                                    }
                            }
                        }
                    }
                    return shouldUpdate;
                }
                function prepareToHydrateHostSuspenseInstance(fiber) {
                    if (!supportsHydration) {
                        throw new Error("Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    var suspenseState = fiber.memoizedState;
                    var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
                    if (!suspenseInstance) {
                        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    hydrateSuspenseInstance(suspenseInstance, fiber);
                }
                function skipPastDehydratedSuspenseInstance(fiber) {
                    if (!supportsHydration) {
                        throw new Error("Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    var suspenseState = fiber.memoizedState;
                    var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
                    if (!suspenseInstance) {
                        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
                }
                function popToNextHostParent(fiber) {
                    var parent = fiber.return;
                    while(parent !== null && parent.tag !== HostComponent2 && parent.tag !== HostRoot2 && parent.tag !== SuspenseComponent2){
                        parent = parent.return;
                    }
                    hydrationParentFiber = parent;
                }
                function popHydrationState(fiber) {
                    if (!supportsHydration) {
                        return false;
                    }
                    if (fiber !== hydrationParentFiber) {
                        return false;
                    }
                    if (!isHydrating) {
                        popToNextHostParent(fiber);
                        isHydrating = true;
                        return false;
                    }
                    if (fiber.tag !== HostRoot2 && (fiber.tag !== HostComponent2 || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
                        var nextInstance = nextHydratableInstance;
                        if (nextInstance) {
                            if (shouldClientRenderOnMismatch(fiber)) {
                                warnIfUnhydratedTailNodes(fiber);
                                throwOnHydrationMismatch();
                            } else {
                                while(nextInstance){
                                    deleteHydratableInstance(fiber, nextInstance);
                                    nextInstance = getNextHydratableSibling(nextInstance);
                                }
                            }
                        }
                    }
                    popToNextHostParent(fiber);
                    if (fiber.tag === SuspenseComponent2) {
                        nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
                    } else {
                        nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
                    }
                    return true;
                }
                function hasUnhydratedTailNodes() {
                    return isHydrating && nextHydratableInstance !== null;
                }
                function warnIfUnhydratedTailNodes(fiber) {
                    var nextInstance = nextHydratableInstance;
                    while(nextInstance){
                        warnUnhydratedInstance(fiber, nextInstance);
                        nextInstance = getNextHydratableSibling(nextInstance);
                    }
                }
                function resetHydrationState() {
                    if (!supportsHydration) {
                        return;
                    }
                    hydrationParentFiber = null;
                    nextHydratableInstance = null;
                    isHydrating = false;
                    didSuspend = false;
                }
                function upgradeHydrationErrorsToRecoverable() {
                    if (hydrationErrors !== null) {
                        queueRecoverableErrors(hydrationErrors);
                        hydrationErrors = null;
                    }
                }
                function getIsHydrating() {
                    return isHydrating;
                }
                function queueHydrationError(error2) {
                    if (hydrationErrors === null) {
                        hydrationErrors = [
                            error2
                        ];
                    } else {
                        hydrationErrors.push(error2);
                    }
                }
                var didWarnAboutMaps;
                var didWarnAboutGenerators;
                var didWarnAboutStringRefs;
                var ownerHasKeyUseWarning;
                var ownerHasFunctionTypeWarning;
                var warnForMissingKey = function(child, returnFiber) {};
                {
                    didWarnAboutMaps = false;
                    didWarnAboutGenerators = false;
                    didWarnAboutStringRefs = {};
                    ownerHasKeyUseWarning = {};
                    ownerHasFunctionTypeWarning = {};
                    warnForMissingKey = function(child, returnFiber) {
                        if (child === null || typeof child !== "object") {
                            return;
                        }
                        if (!child._store || child._store.validated || child.key != null) {
                            return;
                        }
                        if (typeof child._store !== "object") {
                            throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
                        }
                        child._store.validated = true;
                        var componentName = getComponentNameFromFiber(returnFiber) || "Component";
                        if (ownerHasKeyUseWarning[componentName]) {
                            return;
                        }
                        ownerHasKeyUseWarning[componentName] = true;
                        error('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
                    };
                }
                function coerceRef(returnFiber, current2, element) {
                    var mixedRef = element.ref;
                    if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
                        {
                            if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
                            // because these cannot be automatically converted to an arrow function
                            // using a codemod. Therefore, we don't have to warn about string refs again.
                            !(element._owner && element._self && element._owner.stateNode !== element._self)) {
                                var componentName = getComponentNameFromFiber(returnFiber) || "Component";
                                if (!didWarnAboutStringRefs[componentName]) {
                                    {
                                        error('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', mixedRef);
                                    }
                                    didWarnAboutStringRefs[componentName] = true;
                                }
                            }
                        }
                        if (element._owner) {
                            var owner = element._owner;
                            var inst;
                            if (owner) {
                                var ownerFiber = owner;
                                if (ownerFiber.tag !== ClassComponent) {
                                    throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                                }
                                inst = ownerFiber.stateNode;
                            }
                            if (!inst) {
                                throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
                            }
                            var resolvedInst = inst;
                            {
                                checkPropStringCoercion(mixedRef, "ref");
                            }
                            var stringRef = "" + mixedRef;
                            if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
                                return current2.ref;
                            }
                            var ref = function(value) {
                                var refs = resolvedInst.refs;
                                if (refs === emptyRefsObject) {
                                    refs = resolvedInst.refs = {};
                                }
                                if (value === null) {
                                    delete refs[stringRef];
                                } else {
                                    refs[stringRef] = value;
                                }
                            };
                            ref._stringRef = stringRef;
                            return ref;
                        } else {
                            if (typeof mixedRef !== "string") {
                                throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
                            }
                            if (!element._owner) {
                                throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
                            }
                        }
                    }
                    return mixedRef;
                }
                function throwOnInvalidObjectType(returnFiber, newChild) {
                    var childString = Object.prototype.toString.call(newChild);
                    throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
                }
                function warnOnFunctionType(returnFiber) {
                    {
                        var componentName = getComponentNameFromFiber(returnFiber) || "Component";
                        if (ownerHasFunctionTypeWarning[componentName]) {
                            return;
                        }
                        ownerHasFunctionTypeWarning[componentName] = true;
                        error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
                    }
                }
                function resolveLazy(lazyType) {
                    var payload = lazyType._payload;
                    var init = lazyType._init;
                    return init(payload);
                }
                function ChildReconciler(shouldTrackSideEffects) {
                    function deleteChild(returnFiber, childToDelete) {
                        if (!shouldTrackSideEffects) {
                            return;
                        }
                        var deletions = returnFiber.deletions;
                        if (deletions === null) {
                            returnFiber.deletions = [
                                childToDelete
                            ];
                            returnFiber.flags |= ChildDeletion;
                        } else {
                            deletions.push(childToDelete);
                        }
                    }
                    function deleteRemainingChildren(returnFiber, currentFirstChild) {
                        if (!shouldTrackSideEffects) {
                            return null;
                        }
                        var childToDelete = currentFirstChild;
                        while(childToDelete !== null){
                            deleteChild(returnFiber, childToDelete);
                            childToDelete = childToDelete.sibling;
                        }
                        return null;
                    }
                    function mapRemainingChildren(returnFiber, currentFirstChild) {
                        var existingChildren = /* @__PURE__ */ new Map();
                        var existingChild = currentFirstChild;
                        while(existingChild !== null){
                            if (existingChild.key !== null) {
                                existingChildren.set(existingChild.key, existingChild);
                            } else {
                                existingChildren.set(existingChild.index, existingChild);
                            }
                            existingChild = existingChild.sibling;
                        }
                        return existingChildren;
                    }
                    function useFiber(fiber, pendingProps) {
                        var clone = createWorkInProgress(fiber, pendingProps);
                        clone.index = 0;
                        clone.sibling = null;
                        return clone;
                    }
                    function placeChild(newFiber, lastPlacedIndex, newIndex) {
                        newFiber.index = newIndex;
                        if (!shouldTrackSideEffects) {
                            newFiber.flags |= Forked;
                            return lastPlacedIndex;
                        }
                        var current2 = newFiber.alternate;
                        if (current2 !== null) {
                            var oldIndex = current2.index;
                            if (oldIndex < lastPlacedIndex) {
                                newFiber.flags |= Placement;
                                return lastPlacedIndex;
                            } else {
                                return oldIndex;
                            }
                        } else {
                            newFiber.flags |= Placement;
                            return lastPlacedIndex;
                        }
                    }
                    function placeSingleChild(newFiber) {
                        if (shouldTrackSideEffects && newFiber.alternate === null) {
                            newFiber.flags |= Placement;
                        }
                        return newFiber;
                    }
                    function updateTextNode(returnFiber, current2, textContent, lanes) {
                        if (current2 === null || current2.tag !== HostText2) {
                            var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                            created.return = returnFiber;
                            return created;
                        } else {
                            var existing = useFiber(current2, textContent);
                            existing.return = returnFiber;
                            return existing;
                        }
                    }
                    function updateElement(returnFiber, current2, element, lanes) {
                        var elementType = element.type;
                        if (elementType === REACT_FRAGMENT_TYPE) {
                            return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);
                        }
                        if (current2 !== null) {
                            if (current2.elementType === elementType || // Keep this check inline so it only runs on the false path:
                            isCompatibleFamilyForHotReloading(current2, element) || // Lazy types should reconcile their resolved type.
                            // We need to do this after the Hot Reloading check above,
                            // because hot reloading has different semantics than prod because
                            // it doesn't resuspend. So we can't let the call below suspend.
                            typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type) {
                                var existing = useFiber(current2, element.props);
                                existing.ref = coerceRef(returnFiber, current2, element);
                                existing.return = returnFiber;
                                {
                                    existing._debugSource = element._source;
                                    existing._debugOwner = element._owner;
                                }
                                return existing;
                            }
                        }
                        var created = createFiberFromElement(element, returnFiber.mode, lanes);
                        created.ref = coerceRef(returnFiber, current2, element);
                        created.return = returnFiber;
                        return created;
                    }
                    function updatePortal(returnFiber, current2, portal, lanes) {
                        if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
                            var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                            created.return = returnFiber;
                            return created;
                        } else {
                            var existing = useFiber(current2, portal.children || []);
                            existing.return = returnFiber;
                            return existing;
                        }
                    }
                    function updateFragment2(returnFiber, current2, fragment, lanes, key) {
                        if (current2 === null || current2.tag !== Fragment20) {
                            var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
                            created.return = returnFiber;
                            return created;
                        } else {
                            var existing = useFiber(current2, fragment);
                            existing.return = returnFiber;
                            return existing;
                        }
                    }
                    function createChild(returnFiber, newChild, lanes) {
                        if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                            var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
                            created.return = returnFiber;
                            return created;
                        }
                        if (typeof newChild === "object" && newChild !== null) {
                            switch(newChild.$$typeof){
                                case REACT_ELEMENT_TYPE:
                                    {
                                        var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                                        _created.ref = coerceRef(returnFiber, null, newChild);
                                        _created.return = returnFiber;
                                        return _created;
                                    }
                                case REACT_PORTAL_TYPE:
                                    {
                                        var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                                        _created2.return = returnFiber;
                                        return _created2;
                                    }
                                case REACT_LAZY_TYPE:
                                    {
                                        {
                                            var payload = newChild._payload;
                                            var init = newChild._init;
                                            return createChild(returnFiber, init(payload), lanes);
                                        }
                                    }
                            }
                            if (isArray(newChild) || getIteratorFn(newChild)) {
                                var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                                _created3.return = returnFiber;
                                return _created3;
                            }
                            throwOnInvalidObjectType(returnFiber, newChild);
                        }
                        {
                            if (typeof newChild === "function") {
                                warnOnFunctionType(returnFiber);
                            }
                        }
                        return null;
                    }
                    function updateSlot(returnFiber, oldFiber, newChild, lanes) {
                        var key = oldFiber !== null ? oldFiber.key : null;
                        if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                            if (key !== null) {
                                return null;
                            }
                            return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
                        }
                        if (typeof newChild === "object" && newChild !== null) {
                            switch(newChild.$$typeof){
                                case REACT_ELEMENT_TYPE:
                                    {
                                        if (newChild.key === key) {
                                            return updateElement(returnFiber, oldFiber, newChild, lanes);
                                        } else {
                                            return null;
                                        }
                                    }
                                case REACT_PORTAL_TYPE:
                                    {
                                        if (newChild.key === key) {
                                            return updatePortal(returnFiber, oldFiber, newChild, lanes);
                                        } else {
                                            return null;
                                        }
                                    }
                                case REACT_LAZY_TYPE:
                                    {
                                        {
                                            var payload = newChild._payload;
                                            var init = newChild._init;
                                            return updateSlot(returnFiber, oldFiber, init(payload), lanes);
                                        }
                                    }
                            }
                            if (isArray(newChild) || getIteratorFn(newChild)) {
                                if (key !== null) {
                                    return null;
                                }
                                return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
                            }
                            throwOnInvalidObjectType(returnFiber, newChild);
                        }
                        {
                            if (typeof newChild === "function") {
                                warnOnFunctionType(returnFiber);
                            }
                        }
                        return null;
                    }
                    function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
                        if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                            var matchedFiber = existingChildren.get(newIdx) || null;
                            return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
                        }
                        if (typeof newChild === "object" && newChild !== null) {
                            switch(newChild.$$typeof){
                                case REACT_ELEMENT_TYPE:
                                    {
                                        var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                                        return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                                    }
                                case REACT_PORTAL_TYPE:
                                    {
                                        var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                                        return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                                    }
                                case REACT_LAZY_TYPE:
                                    {
                                        var payload = newChild._payload;
                                        var init = newChild._init;
                                        return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);
                                    }
                            }
                            if (isArray(newChild) || getIteratorFn(newChild)) {
                                var _matchedFiber3 = existingChildren.get(newIdx) || null;
                                return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
                            }
                            throwOnInvalidObjectType(returnFiber, newChild);
                        }
                        {
                            if (typeof newChild === "function") {
                                warnOnFunctionType(returnFiber);
                            }
                        }
                        return null;
                    }
                    function warnOnInvalidKey(child, knownKeys, returnFiber) {
                        {
                            if (typeof child !== "object" || child === null) {
                                return knownKeys;
                            }
                            switch(child.$$typeof){
                                case REACT_ELEMENT_TYPE:
                                case REACT_PORTAL_TYPE:
                                    warnForMissingKey(child, returnFiber);
                                    var key = child.key;
                                    if (typeof key !== "string") {
                                        break;
                                    }
                                    if (knownKeys === null) {
                                        knownKeys = /* @__PURE__ */ new Set();
                                        knownKeys.add(key);
                                        break;
                                    }
                                    if (!knownKeys.has(key)) {
                                        knownKeys.add(key);
                                        break;
                                    }
                                    error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
                                    break;
                                case REACT_LAZY_TYPE:
                                    {
                                        var payload = child._payload;
                                        var init = child._init;
                                        warnOnInvalidKey(init(payload), knownKeys, returnFiber);
                                        break;
                                    }
                            }
                        }
                        return knownKeys;
                    }
                    function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
                        {
                            var knownKeys = null;
                            for(var i = 0; i < newChildren.length; i++){
                                var child = newChildren[i];
                                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                            }
                        }
                        var resultingFirstChild = null;
                        var previousNewFiber = null;
                        var oldFiber = currentFirstChild;
                        var lastPlacedIndex = 0;
                        var newIdx = 0;
                        var nextOldFiber = null;
                        for(; oldFiber !== null && newIdx < newChildren.length; newIdx++){
                            if (oldFiber.index > newIdx) {
                                nextOldFiber = oldFiber;
                                oldFiber = null;
                            } else {
                                nextOldFiber = oldFiber.sibling;
                            }
                            var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
                            if (newFiber === null) {
                                if (oldFiber === null) {
                                    oldFiber = nextOldFiber;
                                }
                                break;
                            }
                            if (shouldTrackSideEffects) {
                                if (oldFiber && newFiber.alternate === null) {
                                    deleteChild(returnFiber, oldFiber);
                                }
                            }
                            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                            if (previousNewFiber === null) {
                                resultingFirstChild = newFiber;
                            } else {
                                previousNewFiber.sibling = newFiber;
                            }
                            previousNewFiber = newFiber;
                            oldFiber = nextOldFiber;
                        }
                        if (newIdx === newChildren.length) {
                            deleteRemainingChildren(returnFiber, oldFiber);
                            if (getIsHydrating()) {
                                var numberOfForks = newIdx;
                                pushTreeFork(returnFiber, numberOfForks);
                            }
                            return resultingFirstChild;
                        }
                        if (oldFiber === null) {
                            for(; newIdx < newChildren.length; newIdx++){
                                var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                                if (_newFiber === null) {
                                    continue;
                                }
                                lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                                if (previousNewFiber === null) {
                                    resultingFirstChild = _newFiber;
                                } else {
                                    previousNewFiber.sibling = _newFiber;
                                }
                                previousNewFiber = _newFiber;
                            }
                            if (getIsHydrating()) {
                                var _numberOfForks = newIdx;
                                pushTreeFork(returnFiber, _numberOfForks);
                            }
                            return resultingFirstChild;
                        }
                        var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
                        for(; newIdx < newChildren.length; newIdx++){
                            var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
                            if (_newFiber2 !== null) {
                                if (shouldTrackSideEffects) {
                                    if (_newFiber2.alternate !== null) {
                                        existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                                    }
                                }
                                lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                                if (previousNewFiber === null) {
                                    resultingFirstChild = _newFiber2;
                                } else {
                                    previousNewFiber.sibling = _newFiber2;
                                }
                                previousNewFiber = _newFiber2;
                            }
                        }
                        if (shouldTrackSideEffects) {
                            existingChildren.forEach(function(child2) {
                                return deleteChild(returnFiber, child2);
                            });
                        }
                        if (getIsHydrating()) {
                            var _numberOfForks2 = newIdx;
                            pushTreeFork(returnFiber, _numberOfForks2);
                        }
                        return resultingFirstChild;
                    }
                    function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
                        var iteratorFn = getIteratorFn(newChildrenIterable);
                        if (typeof iteratorFn !== "function") {
                            throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
                        }
                        {
                            if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
                            newChildrenIterable[Symbol.toStringTag] === "Generator") {
                                if (!didWarnAboutGenerators) {
                                    error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                                }
                                didWarnAboutGenerators = true;
                            }
                            if (newChildrenIterable.entries === iteratorFn) {
                                if (!didWarnAboutMaps) {
                                    error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                                }
                                didWarnAboutMaps = true;
                            }
                            var _newChildren = iteratorFn.call(newChildrenIterable);
                            if (_newChildren) {
                                var knownKeys = null;
                                var _step = _newChildren.next();
                                for(; !_step.done; _step = _newChildren.next()){
                                    var child = _step.value;
                                    knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                                }
                            }
                        }
                        var newChildren = iteratorFn.call(newChildrenIterable);
                        if (newChildren == null) {
                            throw new Error("An iterable object provided no iterator.");
                        }
                        var resultingFirstChild = null;
                        var previousNewFiber = null;
                        var oldFiber = currentFirstChild;
                        var lastPlacedIndex = 0;
                        var newIdx = 0;
                        var nextOldFiber = null;
                        var step = newChildren.next();
                        for(; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()){
                            if (oldFiber.index > newIdx) {
                                nextOldFiber = oldFiber;
                                oldFiber = null;
                            } else {
                                nextOldFiber = oldFiber.sibling;
                            }
                            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
                            if (newFiber === null) {
                                if (oldFiber === null) {
                                    oldFiber = nextOldFiber;
                                }
                                break;
                            }
                            if (shouldTrackSideEffects) {
                                if (oldFiber && newFiber.alternate === null) {
                                    deleteChild(returnFiber, oldFiber);
                                }
                            }
                            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                            if (previousNewFiber === null) {
                                resultingFirstChild = newFiber;
                            } else {
                                previousNewFiber.sibling = newFiber;
                            }
                            previousNewFiber = newFiber;
                            oldFiber = nextOldFiber;
                        }
                        if (step.done) {
                            deleteRemainingChildren(returnFiber, oldFiber);
                            if (getIsHydrating()) {
                                var numberOfForks = newIdx;
                                pushTreeFork(returnFiber, numberOfForks);
                            }
                            return resultingFirstChild;
                        }
                        if (oldFiber === null) {
                            for(; !step.done; newIdx++, step = newChildren.next()){
                                var _newFiber3 = createChild(returnFiber, step.value, lanes);
                                if (_newFiber3 === null) {
                                    continue;
                                }
                                lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                                if (previousNewFiber === null) {
                                    resultingFirstChild = _newFiber3;
                                } else {
                                    previousNewFiber.sibling = _newFiber3;
                                }
                                previousNewFiber = _newFiber3;
                            }
                            if (getIsHydrating()) {
                                var _numberOfForks3 = newIdx;
                                pushTreeFork(returnFiber, _numberOfForks3);
                            }
                            return resultingFirstChild;
                        }
                        var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
                        for(; !step.done; newIdx++, step = newChildren.next()){
                            var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
                            if (_newFiber4 !== null) {
                                if (shouldTrackSideEffects) {
                                    if (_newFiber4.alternate !== null) {
                                        existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                                    }
                                }
                                lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                                if (previousNewFiber === null) {
                                    resultingFirstChild = _newFiber4;
                                } else {
                                    previousNewFiber.sibling = _newFiber4;
                                }
                                previousNewFiber = _newFiber4;
                            }
                        }
                        if (shouldTrackSideEffects) {
                            existingChildren.forEach(function(child2) {
                                return deleteChild(returnFiber, child2);
                            });
                        }
                        if (getIsHydrating()) {
                            var _numberOfForks4 = newIdx;
                            pushTreeFork(returnFiber, _numberOfForks4);
                        }
                        return resultingFirstChild;
                    }
                    function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
                        if (currentFirstChild !== null && currentFirstChild.tag === HostText2) {
                            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                            var existing = useFiber(currentFirstChild, textContent);
                            existing.return = returnFiber;
                            return existing;
                        }
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                        created.return = returnFiber;
                        return created;
                    }
                    function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
                        var key = element.key;
                        var child = currentFirstChild;
                        while(child !== null){
                            if (child.key === key) {
                                var elementType = element.type;
                                if (elementType === REACT_FRAGMENT_TYPE) {
                                    if (child.tag === Fragment20) {
                                        deleteRemainingChildren(returnFiber, child.sibling);
                                        var existing = useFiber(child, element.props.children);
                                        existing.return = returnFiber;
                                        {
                                            existing._debugSource = element._source;
                                            existing._debugOwner = element._owner;
                                        }
                                        return existing;
                                    }
                                } else {
                                    if (child.elementType === elementType || // Keep this check inline so it only runs on the false path:
                                    isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.
                                    // We need to do this after the Hot Reloading check above,
                                    // because hot reloading has different semantics than prod because
                                    // it doesn't resuspend. So we can't let the call below suspend.
                                    typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                                        deleteRemainingChildren(returnFiber, child.sibling);
                                        var _existing = useFiber(child, element.props);
                                        _existing.ref = coerceRef(returnFiber, child, element);
                                        _existing.return = returnFiber;
                                        {
                                            _existing._debugSource = element._source;
                                            _existing._debugOwner = element._owner;
                                        }
                                        return _existing;
                                    }
                                }
                                deleteRemainingChildren(returnFiber, child);
                                break;
                            } else {
                                deleteChild(returnFiber, child);
                            }
                            child = child.sibling;
                        }
                        if (element.type === REACT_FRAGMENT_TYPE) {
                            var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
                            created.return = returnFiber;
                            return created;
                        } else {
                            var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
                            _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
                            _created4.return = returnFiber;
                            return _created4;
                        }
                    }
                    function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
                        var key = portal.key;
                        var child = currentFirstChild;
                        while(child !== null){
                            if (child.key === key) {
                                if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                                    deleteRemainingChildren(returnFiber, child.sibling);
                                    var existing = useFiber(child, portal.children || []);
                                    existing.return = returnFiber;
                                    return existing;
                                } else {
                                    deleteRemainingChildren(returnFiber, child);
                                    break;
                                }
                            } else {
                                deleteChild(returnFiber, child);
                            }
                            child = child.sibling;
                        }
                        var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                        created.return = returnFiber;
                        return created;
                    }
                    function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
                        var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
                        if (isUnkeyedTopLevelFragment) {
                            newChild = newChild.props.children;
                        }
                        if (typeof newChild === "object" && newChild !== null) {
                            switch(newChild.$$typeof){
                                case REACT_ELEMENT_TYPE:
                                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                                case REACT_PORTAL_TYPE:
                                    return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                                case REACT_LAZY_TYPE:
                                    {
                                        var payload = newChild._payload;
                                        var init = newChild._init;
                                        return reconcileChildFibers2(returnFiber, currentFirstChild, init(payload), lanes);
                                    }
                            }
                            if (isArray(newChild)) {
                                return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
                            }
                            if (getIteratorFn(newChild)) {
                                return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
                            }
                            throwOnInvalidObjectType(returnFiber, newChild);
                        }
                        if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                            return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
                        }
                        {
                            if (typeof newChild === "function") {
                                warnOnFunctionType(returnFiber);
                            }
                        }
                        return deleteRemainingChildren(returnFiber, currentFirstChild);
                    }
                    return reconcileChildFibers2;
                }
                var reconcileChildFibers = ChildReconciler(true);
                var mountChildFibers = ChildReconciler(false);
                function cloneChildFibers(current2, workInProgress2) {
                    if (current2 !== null && workInProgress2.child !== current2.child) {
                        throw new Error("Resuming work not yet implemented.");
                    }
                    if (workInProgress2.child === null) {
                        return;
                    }
                    var currentChild = workInProgress2.child;
                    var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
                    workInProgress2.child = newChild;
                    newChild.return = workInProgress2;
                    while(currentChild.sibling !== null){
                        currentChild = currentChild.sibling;
                        newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
                        newChild.return = workInProgress2;
                    }
                    newChild.sibling = null;
                }
                function resetChildFibers(workInProgress2, lanes) {
                    var child = workInProgress2.child;
                    while(child !== null){
                        resetWorkInProgress(child, lanes);
                        child = child.sibling;
                    }
                }
                var NO_CONTEXT = {};
                var contextStackCursor$1 = createCursor(NO_CONTEXT);
                var contextFiberStackCursor = createCursor(NO_CONTEXT);
                var rootInstanceStackCursor = createCursor(NO_CONTEXT);
                function requiredContext(c) {
                    if (c === NO_CONTEXT) {
                        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    return c;
                }
                function getRootHostContainer() {
                    var rootInstance = requiredContext(rootInstanceStackCursor.current);
                    return rootInstance;
                }
                function pushHostContainer(fiber, nextRootInstance) {
                    push(rootInstanceStackCursor, nextRootInstance, fiber);
                    push(contextFiberStackCursor, fiber, fiber);
                    push(contextStackCursor$1, NO_CONTEXT, fiber);
                    var nextRootContext = getRootHostContext(nextRootInstance);
                    pop(contextStackCursor$1, fiber);
                    push(contextStackCursor$1, nextRootContext, fiber);
                }
                function popHostContainer(fiber) {
                    pop(contextStackCursor$1, fiber);
                    pop(contextFiberStackCursor, fiber);
                    pop(rootInstanceStackCursor, fiber);
                }
                function getHostContext() {
                    var context = requiredContext(contextStackCursor$1.current);
                    return context;
                }
                function pushHostContext(fiber) {
                    var rootInstance = requiredContext(rootInstanceStackCursor.current);
                    var context = requiredContext(contextStackCursor$1.current);
                    var nextContext = getChildHostContext(context, fiber.type, rootInstance);
                    if (context === nextContext) {
                        return;
                    }
                    push(contextFiberStackCursor, fiber, fiber);
                    push(contextStackCursor$1, nextContext, fiber);
                }
                function popHostContext(fiber) {
                    if (contextFiberStackCursor.current !== fiber) {
                        return;
                    }
                    pop(contextStackCursor$1, fiber);
                    pop(contextFiberStackCursor, fiber);
                }
                var DefaultSuspenseContext = 0;
                var SubtreeSuspenseContextMask = 1;
                var InvisibleParentSuspenseContext = 1;
                var ForceSuspenseFallback = 2;
                var suspenseStackCursor = createCursor(DefaultSuspenseContext);
                function hasSuspenseContext(parentContext, flag) {
                    return (parentContext & flag) !== 0;
                }
                function setDefaultShallowSuspenseContext(parentContext) {
                    return parentContext & SubtreeSuspenseContextMask;
                }
                function setShallowSuspenseContext(parentContext, shallowContext) {
                    return parentContext & SubtreeSuspenseContextMask | shallowContext;
                }
                function addSubtreeSuspenseContext(parentContext, subtreeContext) {
                    return parentContext | subtreeContext;
                }
                function pushSuspenseContext(fiber, newContext) {
                    push(suspenseStackCursor, newContext, fiber);
                }
                function popSuspenseContext(fiber) {
                    pop(suspenseStackCursor, fiber);
                }
                function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
                    var nextState = workInProgress2.memoizedState;
                    if (nextState !== null) {
                        if (nextState.dehydrated !== null) {
                            return true;
                        }
                        return false;
                    }
                    var props = workInProgress2.memoizedProps;
                    {
                        return true;
                    }
                }
                function findFirstSuspended(row) {
                    var node = row;
                    while(node !== null){
                        if (node.tag === SuspenseComponent2) {
                            var state = node.memoizedState;
                            if (state !== null) {
                                var dehydrated = state.dehydrated;
                                if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                                    return node;
                                }
                            }
                        } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
                        // keep track of whether it suspended or not.
                        node.memoizedProps.revealOrder !== void 0) {
                            var didSuspend2 = (node.flags & DidCapture) !== NoFlags;
                            if (didSuspend2) {
                                return node;
                            }
                        } else if (node.child !== null) {
                            node.child.return = node;
                            node = node.child;
                            continue;
                        }
                        if (node === row) {
                            return null;
                        }
                        while(node.sibling === null){
                            if (node.return === null || node.return === row) {
                                return null;
                            }
                            node = node.return;
                        }
                        node.sibling.return = node.return;
                        node = node.sibling;
                    }
                    return null;
                }
                var NoFlags$1 = /*   */ 0;
                var HasEffect = /* */ 1;
                var Insertion = /*  */ 2;
                var Layout = /*    */ 4;
                var Passive$1 = /*   */ 8;
                var workInProgressSources = [];
                function resetWorkInProgressVersions() {
                    for(var i = 0; i < workInProgressSources.length; i++){
                        var mutableSource = workInProgressSources[i];
                        if (isPrimaryRenderer) {
                            mutableSource._workInProgressVersionPrimary = null;
                        } else {
                            mutableSource._workInProgressVersionSecondary = null;
                        }
                    }
                    workInProgressSources.length = 0;
                }
                function registerMutableSourceForHydration(root, mutableSource) {
                    var getVersion = mutableSource._getVersion;
                    var version = getVersion(mutableSource._source);
                    if (root.mutableSourceEagerHydrationData == null) {
                        root.mutableSourceEagerHydrationData = [
                            mutableSource,
                            version
                        ];
                    } else {
                        root.mutableSourceEagerHydrationData.push(mutableSource, version);
                    }
                }
                var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
                var didWarnAboutMismatchedHooksForComponent;
                var didWarnUncachedGetSnapshot;
                {
                    didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
                }
                var renderLanes = NoLanes;
                var currentlyRenderingFiber$1 = null;
                var currentHook = null;
                var workInProgressHook = null;
                var didScheduleRenderPhaseUpdate = false;
                var didScheduleRenderPhaseUpdateDuringThisPass = false;
                var localIdCounter = 0;
                var globalClientIdCounter = 0;
                var RE_RENDER_LIMIT = 25;
                var currentHookNameInDev = null;
                var hookTypesDev = null;
                var hookTypesUpdateIndexDev = -1;
                var ignorePreviousDependencies = false;
                function mountHookTypesDev() {
                    {
                        var hookName = currentHookNameInDev;
                        if (hookTypesDev === null) {
                            hookTypesDev = [
                                hookName
                            ];
                        } else {
                            hookTypesDev.push(hookName);
                        }
                    }
                }
                function updateHookTypesDev() {
                    {
                        var hookName = currentHookNameInDev;
                        if (hookTypesDev !== null) {
                            hookTypesUpdateIndexDev++;
                            if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                                warnOnHookMismatchInDev(hookName);
                            }
                        }
                    }
                }
                function checkDepsAreArrayDev(deps) {
                    {
                        if (deps !== void 0 && deps !== null && !isArray(deps)) {
                            error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
                        }
                    }
                }
                function warnOnHookMismatchInDev(currentHookName) {
                    {
                        var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
                        if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
                            didWarnAboutMismatchedHooksForComponent.add(componentName);
                            if (hookTypesDev !== null) {
                                var table = "";
                                var secondColumnStart = 30;
                                for(var i = 0; i <= hookTypesUpdateIndexDev; i++){
                                    var oldHookName = hookTypesDev[i];
                                    var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                                    var row = i + 1 + ". " + oldHookName;
                                    while(row.length < secondColumnStart){
                                        row += " ";
                                    }
                                    row += newHookName + "\n";
                                    table += row;
                                }
                                error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
                            }
                        }
                    }
                }
                function throwInvalidHookError() {
                    throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
                }
                function areHookInputsEqual(nextDeps, prevDeps) {
                    {
                        if (ignorePreviousDependencies) {
                            return false;
                        }
                    }
                    if (prevDeps === null) {
                        {
                            error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
                        }
                        return false;
                    }
                    {
                        if (nextDeps.length !== prevDeps.length) {
                            error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
                        }
                    }
                    for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){
                        if (objectIs(nextDeps[i], prevDeps[i])) {
                            continue;
                        }
                        return false;
                    }
                    return true;
                }
                function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
                    renderLanes = nextRenderLanes;
                    currentlyRenderingFiber$1 = workInProgress2;
                    {
                        hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
                        hookTypesUpdateIndexDev = -1;
                        ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
                    }
                    workInProgress2.memoizedState = null;
                    workInProgress2.updateQueue = null;
                    workInProgress2.lanes = NoLanes;
                    {
                        if (current2 !== null && current2.memoizedState !== null) {
                            ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
                        } else if (hookTypesDev !== null) {
                            ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
                        } else {
                            ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
                        }
                    }
                    var children2 = Component(props, secondArg);
                    if (didScheduleRenderPhaseUpdateDuringThisPass) {
                        var numberOfReRenders = 0;
                        do {
                            didScheduleRenderPhaseUpdateDuringThisPass = false;
                            localIdCounter = 0;
                            if (numberOfReRenders >= RE_RENDER_LIMIT) {
                                throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
                            }
                            numberOfReRenders += 1;
                            {
                                ignorePreviousDependencies = false;
                            }
                            currentHook = null;
                            workInProgressHook = null;
                            workInProgress2.updateQueue = null;
                            {
                                hookTypesUpdateIndexDev = -1;
                            }
                            ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
                            children2 = Component(props, secondArg);
                        }while (didScheduleRenderPhaseUpdateDuringThisPass)
                    }
                    ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
                    {
                        workInProgress2._debugHookTypes = hookTypesDev;
                    }
                    var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
                    renderLanes = NoLanes;
                    currentlyRenderingFiber$1 = null;
                    currentHook = null;
                    workInProgressHook = null;
                    {
                        currentHookNameInDev = null;
                        hookTypesDev = null;
                        hookTypesUpdateIndexDev = -1;
                        if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird
                        // and creates false positives. To make this work in legacy mode, we'd
                        // need to mark fibers that commit in an incomplete state, somehow. For
                        // now I'll disable the warning that most of the bugs that would trigger
                        // it are either exclusive to concurrent mode or exist in both.
                        (current2.mode & ConcurrentMode) !== NoMode) {
                            error("Internal React error: Expected static flag was missing. Please notify the React team.");
                        }
                    }
                    didScheduleRenderPhaseUpdate = false;
                    if (didRenderTooFewHooks) {
                        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
                    }
                    return children2;
                }
                function checkDidRenderIdHook() {
                    var didRenderIdHook = localIdCounter !== 0;
                    localIdCounter = 0;
                    return didRenderIdHook;
                }
                function bailoutHooks(current2, workInProgress2, lanes) {
                    workInProgress2.updateQueue = current2.updateQueue;
                    if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                        workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);
                    } else {
                        workInProgress2.flags &= ~(Passive | Update);
                    }
                    current2.lanes = removeLanes(current2.lanes, lanes);
                }
                function resetHooksAfterThrow() {
                    ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
                    if (didScheduleRenderPhaseUpdate) {
                        var hook = currentlyRenderingFiber$1.memoizedState;
                        while(hook !== null){
                            var queue = hook.queue;
                            if (queue !== null) {
                                queue.pending = null;
                            }
                            hook = hook.next;
                        }
                        didScheduleRenderPhaseUpdate = false;
                    }
                    renderLanes = NoLanes;
                    currentlyRenderingFiber$1 = null;
                    currentHook = null;
                    workInProgressHook = null;
                    {
                        hookTypesDev = null;
                        hookTypesUpdateIndexDev = -1;
                        currentHookNameInDev = null;
                        isUpdatingOpaqueValueInRenderPhase = false;
                    }
                    didScheduleRenderPhaseUpdateDuringThisPass = false;
                    localIdCounter = 0;
                }
                function mountWorkInProgressHook() {
                    var hook = {
                        memoizedState: null,
                        baseState: null,
                        baseQueue: null,
                        queue: null,
                        next: null
                    };
                    if (workInProgressHook === null) {
                        currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
                    } else {
                        workInProgressHook = workInProgressHook.next = hook;
                    }
                    return workInProgressHook;
                }
                function updateWorkInProgressHook() {
                    var nextCurrentHook;
                    if (currentHook === null) {
                        var current2 = currentlyRenderingFiber$1.alternate;
                        if (current2 !== null) {
                            nextCurrentHook = current2.memoizedState;
                        } else {
                            nextCurrentHook = null;
                        }
                    } else {
                        nextCurrentHook = currentHook.next;
                    }
                    var nextWorkInProgressHook;
                    if (workInProgressHook === null) {
                        nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
                    } else {
                        nextWorkInProgressHook = workInProgressHook.next;
                    }
                    if (nextWorkInProgressHook !== null) {
                        workInProgressHook = nextWorkInProgressHook;
                        nextWorkInProgressHook = workInProgressHook.next;
                        currentHook = nextCurrentHook;
                    } else {
                        if (nextCurrentHook === null) {
                            throw new Error("Rendered more hooks than during the previous render.");
                        }
                        currentHook = nextCurrentHook;
                        var newHook = {
                            memoizedState: currentHook.memoizedState,
                            baseState: currentHook.baseState,
                            baseQueue: currentHook.baseQueue,
                            queue: currentHook.queue,
                            next: null
                        };
                        if (workInProgressHook === null) {
                            currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
                        } else {
                            workInProgressHook = workInProgressHook.next = newHook;
                        }
                    }
                    return workInProgressHook;
                }
                function createFunctionComponentUpdateQueue() {
                    return {
                        lastEffect: null,
                        stores: null
                    };
                }
                function basicStateReducer(state, action) {
                    return typeof action === "function" ? action(state) : action;
                }
                function mountReducer(reducer, initialArg, init) {
                    var hook = mountWorkInProgressHook();
                    var initialState;
                    if (init !== void 0) {
                        initialState = init(initialArg);
                    } else {
                        initialState = initialArg;
                    }
                    hook.memoizedState = hook.baseState = initialState;
                    var queue = {
                        pending: null,
                        interleaved: null,
                        lanes: NoLanes,
                        dispatch: null,
                        lastRenderedReducer: reducer,
                        lastRenderedState: initialState
                    };
                    hook.queue = queue;
                    var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
                    return [
                        hook.memoizedState,
                        dispatch
                    ];
                }
                function updateReducer2(reducer, initialArg, init) {
                    var hook = updateWorkInProgressHook();
                    var queue = hook.queue;
                    if (queue === null) {
                        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
                    }
                    queue.lastRenderedReducer = reducer;
                    var current2 = currentHook;
                    var baseQueue = current2.baseQueue;
                    var pendingQueue = queue.pending;
                    if (pendingQueue !== null) {
                        if (baseQueue !== null) {
                            var baseFirst = baseQueue.next;
                            var pendingFirst = pendingQueue.next;
                            baseQueue.next = pendingFirst;
                            pendingQueue.next = baseFirst;
                        }
                        {
                            if (current2.baseQueue !== baseQueue) {
                                error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
                            }
                        }
                        current2.baseQueue = baseQueue = pendingQueue;
                        queue.pending = null;
                    }
                    if (baseQueue !== null) {
                        var first = baseQueue.next;
                        var newState = current2.baseState;
                        var newBaseState = null;
                        var newBaseQueueFirst = null;
                        var newBaseQueueLast = null;
                        var update = first;
                        do {
                            var updateLane = update.lane;
                            if (!isSubsetOfLanes(renderLanes, updateLane)) {
                                var clone = {
                                    lane: updateLane,
                                    action: update.action,
                                    hasEagerState: update.hasEagerState,
                                    eagerState: update.eagerState,
                                    next: null
                                };
                                if (newBaseQueueLast === null) {
                                    newBaseQueueFirst = newBaseQueueLast = clone;
                                    newBaseState = newState;
                                } else {
                                    newBaseQueueLast = newBaseQueueLast.next = clone;
                                }
                                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                                markSkippedUpdateLanes(updateLane);
                            } else {
                                if (newBaseQueueLast !== null) {
                                    var _clone = {
                                        // This update is going to be committed so we never want uncommit
                                        // it. Using NoLane works because 0 is a subset of all bitmasks, so
                                        // this will never be skipped by the check above.
                                        lane: NoLane,
                                        action: update.action,
                                        hasEagerState: update.hasEagerState,
                                        eagerState: update.eagerState,
                                        next: null
                                    };
                                    newBaseQueueLast = newBaseQueueLast.next = _clone;
                                }
                                if (update.hasEagerState) {
                                    newState = update.eagerState;
                                } else {
                                    var action = update.action;
                                    newState = reducer(newState, action);
                                }
                            }
                            update = update.next;
                        }while (update !== null && update !== first)
                        if (newBaseQueueLast === null) {
                            newBaseState = newState;
                        } else {
                            newBaseQueueLast.next = newBaseQueueFirst;
                        }
                        if (!objectIs(newState, hook.memoizedState)) {
                            markWorkInProgressReceivedUpdate();
                        }
                        hook.memoizedState = newState;
                        hook.baseState = newBaseState;
                        hook.baseQueue = newBaseQueueLast;
                        queue.lastRenderedState = newState;
                    }
                    var lastInterleaved = queue.interleaved;
                    if (lastInterleaved !== null) {
                        var interleaved = lastInterleaved;
                        do {
                            var interleavedLane = interleaved.lane;
                            currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
                            markSkippedUpdateLanes(interleavedLane);
                            interleaved = interleaved.next;
                        }while (interleaved !== lastInterleaved)
                    } else if (baseQueue === null) {
                        queue.lanes = NoLanes;
                    }
                    var dispatch = queue.dispatch;
                    return [
                        hook.memoizedState,
                        dispatch
                    ];
                }
                function rerenderReducer(reducer, initialArg, init) {
                    var hook = updateWorkInProgressHook();
                    var queue = hook.queue;
                    if (queue === null) {
                        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
                    }
                    queue.lastRenderedReducer = reducer;
                    var dispatch = queue.dispatch;
                    var lastRenderPhaseUpdate = queue.pending;
                    var newState = hook.memoizedState;
                    if (lastRenderPhaseUpdate !== null) {
                        queue.pending = null;
                        var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
                        var update = firstRenderPhaseUpdate;
                        do {
                            var action = update.action;
                            newState = reducer(newState, action);
                            update = update.next;
                        }while (update !== firstRenderPhaseUpdate)
                        if (!objectIs(newState, hook.memoizedState)) {
                            markWorkInProgressReceivedUpdate();
                        }
                        hook.memoizedState = newState;
                        if (hook.baseQueue === null) {
                            hook.baseState = newState;
                        }
                        queue.lastRenderedState = newState;
                    }
                    return [
                        newState,
                        dispatch
                    ];
                }
                function mountMutableSource(source, getSnapshot, subscribe) {
                    {
                        return void 0;
                    }
                }
                function updateMutableSource(source, getSnapshot, subscribe) {
                    {
                        return void 0;
                    }
                }
                function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
                    var fiber = currentlyRenderingFiber$1;
                    var hook = mountWorkInProgressHook();
                    var nextSnapshot;
                    var isHydrating2 = getIsHydrating();
                    if (isHydrating2) {
                        if (getServerSnapshot === void 0) {
                            throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
                        }
                        nextSnapshot = getServerSnapshot();
                        {
                            if (!didWarnUncachedGetSnapshot) {
                                if (nextSnapshot !== getServerSnapshot()) {
                                    error("The result of getServerSnapshot should be cached to avoid an infinite loop");
                                    didWarnUncachedGetSnapshot = true;
                                }
                            }
                        }
                    } else {
                        nextSnapshot = getSnapshot();
                        {
                            if (!didWarnUncachedGetSnapshot) {
                                var cachedSnapshot = getSnapshot();
                                if (!objectIs(nextSnapshot, cachedSnapshot)) {
                                    error("The result of getSnapshot should be cached to avoid an infinite loop");
                                    didWarnUncachedGetSnapshot = true;
                                }
                            }
                        }
                        var root = getWorkInProgressRoot();
                        if (root === null) {
                            throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
                        }
                        if (!includesBlockingLane(root, renderLanes)) {
                            pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
                        }
                    }
                    hook.memoizedState = nextSnapshot;
                    var inst = {
                        value: nextSnapshot,
                        getSnapshot
                    };
                    hook.queue = inst;
                    mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
                        subscribe
                    ]);
                    fiber.flags |= Passive;
                    pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
                    return nextSnapshot;
                }
                function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
                    var fiber = currentlyRenderingFiber$1;
                    var hook = updateWorkInProgressHook();
                    var nextSnapshot = getSnapshot();
                    {
                        if (!didWarnUncachedGetSnapshot) {
                            var cachedSnapshot = getSnapshot();
                            if (!objectIs(nextSnapshot, cachedSnapshot)) {
                                error("The result of getSnapshot should be cached to avoid an infinite loop");
                                didWarnUncachedGetSnapshot = true;
                            }
                        }
                    }
                    var prevSnapshot = hook.memoizedState;
                    var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
                    if (snapshotChanged) {
                        hook.memoizedState = nextSnapshot;
                        markWorkInProgressReceivedUpdate();
                    }
                    var inst = hook.queue;
                    updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
                        subscribe
                    ]);
                    if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by
                    // checking whether we scheduled a subscription effect above.
                    workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
                        fiber.flags |= Passive;
                        pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
                        var root = getWorkInProgressRoot();
                        if (root === null) {
                            throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
                        }
                        if (!includesBlockingLane(root, renderLanes)) {
                            pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
                        }
                    }
                    return nextSnapshot;
                }
                function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
                    fiber.flags |= StoreConsistency;
                    var check = {
                        getSnapshot,
                        value: renderedSnapshot
                    };
                    var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
                    if (componentUpdateQueue === null) {
                        componentUpdateQueue = createFunctionComponentUpdateQueue();
                        currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
                        componentUpdateQueue.stores = [
                            check
                        ];
                    } else {
                        var stores = componentUpdateQueue.stores;
                        if (stores === null) {
                            componentUpdateQueue.stores = [
                                check
                            ];
                        } else {
                            stores.push(check);
                        }
                    }
                }
                function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
                    inst.value = nextSnapshot;
                    inst.getSnapshot = getSnapshot;
                    if (checkIfSnapshotChanged(inst)) {
                        forceStoreRerender(fiber);
                    }
                }
                function subscribeToStore(fiber, inst, subscribe) {
                    var handleStoreChange = function() {
                        if (checkIfSnapshotChanged(inst)) {
                            forceStoreRerender(fiber);
                        }
                    };
                    return subscribe(handleStoreChange);
                }
                function checkIfSnapshotChanged(inst) {
                    var latestGetSnapshot = inst.getSnapshot;
                    var prevValue = inst.value;
                    try {
                        var nextValue = latestGetSnapshot();
                        return !objectIs(prevValue, nextValue);
                    } catch (error2) {
                        return true;
                    }
                }
                function forceStoreRerender(fiber) {
                    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
                }
                function mountState(initialState) {
                    var hook = mountWorkInProgressHook();
                    if (typeof initialState === "function") {
                        initialState = initialState();
                    }
                    hook.memoizedState = hook.baseState = initialState;
                    var queue = {
                        pending: null,
                        interleaved: null,
                        lanes: NoLanes,
                        dispatch: null,
                        lastRenderedReducer: basicStateReducer,
                        lastRenderedState: initialState
                    };
                    hook.queue = queue;
                    var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
                    return [
                        hook.memoizedState,
                        dispatch
                    ];
                }
                function updateState(initialState) {
                    return updateReducer2(basicStateReducer);
                }
                function rerenderState(initialState) {
                    return rerenderReducer(basicStateReducer);
                }
                function pushEffect(tag, create, destroy, deps) {
                    var effect = {
                        tag,
                        create,
                        destroy,
                        deps,
                        // Circular
                        next: null
                    };
                    var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
                    if (componentUpdateQueue === null) {
                        componentUpdateQueue = createFunctionComponentUpdateQueue();
                        currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
                        componentUpdateQueue.lastEffect = effect.next = effect;
                    } else {
                        var lastEffect = componentUpdateQueue.lastEffect;
                        if (lastEffect === null) {
                            componentUpdateQueue.lastEffect = effect.next = effect;
                        } else {
                            var firstEffect = lastEffect.next;
                            lastEffect.next = effect;
                            effect.next = firstEffect;
                            componentUpdateQueue.lastEffect = effect;
                        }
                    }
                    return effect;
                }
                function mountRef(initialValue) {
                    var hook = mountWorkInProgressHook();
                    {
                        var _ref2 = {
                            current: initialValue
                        };
                        hook.memoizedState = _ref2;
                        return _ref2;
                    }
                }
                function updateRef(initialValue) {
                    var hook = updateWorkInProgressHook();
                    return hook.memoizedState;
                }
                function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
                    var hook = mountWorkInProgressHook();
                    var nextDeps = deps === void 0 ? null : deps;
                    currentlyRenderingFiber$1.flags |= fiberFlags;
                    hook.memoizedState = pushEffect(HasEffect | hookFlags, create, void 0, nextDeps);
                }
                function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
                    var hook = updateWorkInProgressHook();
                    var nextDeps = deps === void 0 ? null : deps;
                    var destroy = void 0;
                    if (currentHook !== null) {
                        var prevEffect = currentHook.memoizedState;
                        destroy = prevEffect.destroy;
                        if (nextDeps !== null) {
                            var prevDeps = prevEffect.deps;
                            if (areHookInputsEqual(nextDeps, prevDeps)) {
                                hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
                                return;
                            }
                        }
                    }
                    currentlyRenderingFiber$1.flags |= fiberFlags;
                    hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
                }
                function mountEffect(create, deps) {
                    if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
                        return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);
                    } else {
                        return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);
                    }
                }
                function updateEffect(create, deps) {
                    return updateEffectImpl(Passive, Passive$1, create, deps);
                }
                function mountInsertionEffect(create, deps) {
                    return mountEffectImpl(Update, Insertion, create, deps);
                }
                function updateInsertionEffect(create, deps) {
                    return updateEffectImpl(Update, Insertion, create, deps);
                }
                function mountLayoutEffect(create, deps) {
                    var fiberFlags = Update;
                    {
                        fiberFlags |= LayoutStatic;
                    }
                    if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
                        fiberFlags |= MountLayoutDev;
                    }
                    return mountEffectImpl(fiberFlags, Layout, create, deps);
                }
                function updateLayoutEffect(create, deps) {
                    return updateEffectImpl(Update, Layout, create, deps);
                }
                function imperativeHandleEffect(create, ref) {
                    if (typeof ref === "function") {
                        var refCallback = ref;
                        var _inst = create();
                        refCallback(_inst);
                        return function() {
                            refCallback(null);
                        };
                    } else if (ref !== null && ref !== void 0) {
                        var refObject = ref;
                        {
                            if (!refObject.hasOwnProperty("current")) {
                                error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
                            }
                        }
                        var _inst2 = create();
                        refObject.current = _inst2;
                        return function() {
                            refObject.current = null;
                        };
                    }
                }
                function mountImperativeHandle(ref, create, deps) {
                    {
                        if (typeof create !== "function") {
                            error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
                        }
                    }
                    var effectDeps = deps !== null && deps !== void 0 ? deps.concat([
                        ref
                    ]) : null;
                    var fiberFlags = Update;
                    {
                        fiberFlags |= LayoutStatic;
                    }
                    if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
                        fiberFlags |= MountLayoutDev;
                    }
                    return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
                }
                function updateImperativeHandle(ref, create, deps) {
                    {
                        if (typeof create !== "function") {
                            error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
                        }
                    }
                    var effectDeps = deps !== null && deps !== void 0 ? deps.concat([
                        ref
                    ]) : null;
                    return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
                }
                function mountDebugValue(value, formatterFn) {}
                var updateDebugValue = mountDebugValue;
                function mountCallback(callback, deps) {
                    var hook = mountWorkInProgressHook();
                    var nextDeps = deps === void 0 ? null : deps;
                    hook.memoizedState = [
                        callback,
                        nextDeps
                    ];
                    return callback;
                }
                function updateCallback(callback, deps) {
                    var hook = updateWorkInProgressHook();
                    var nextDeps = deps === void 0 ? null : deps;
                    var prevState = hook.memoizedState;
                    if (prevState !== null) {
                        if (nextDeps !== null) {
                            var prevDeps = prevState[1];
                            if (areHookInputsEqual(nextDeps, prevDeps)) {
                                return prevState[0];
                            }
                        }
                    }
                    hook.memoizedState = [
                        callback,
                        nextDeps
                    ];
                    return callback;
                }
                function mountMemo(nextCreate, deps) {
                    var hook = mountWorkInProgressHook();
                    var nextDeps = deps === void 0 ? null : deps;
                    var nextValue = nextCreate();
                    hook.memoizedState = [
                        nextValue,
                        nextDeps
                    ];
                    return nextValue;
                }
                function updateMemo(nextCreate, deps) {
                    var hook = updateWorkInProgressHook();
                    var nextDeps = deps === void 0 ? null : deps;
                    var prevState = hook.memoizedState;
                    if (prevState !== null) {
                        if (nextDeps !== null) {
                            var prevDeps = prevState[1];
                            if (areHookInputsEqual(nextDeps, prevDeps)) {
                                return prevState[0];
                            }
                        }
                    }
                    var nextValue = nextCreate();
                    hook.memoizedState = [
                        nextValue,
                        nextDeps
                    ];
                    return nextValue;
                }
                function mountDeferredValue(value) {
                    var _mountState = mountState(value), prevValue = _mountState[0], setValue = _mountState[1];
                    mountEffect(function() {
                        var prevTransition = ReactCurrentBatchConfig$1.transition;
                        ReactCurrentBatchConfig$1.transition = {};
                        try {
                            setValue(value);
                        } finally{
                            ReactCurrentBatchConfig$1.transition = prevTransition;
                        }
                    }, [
                        value
                    ]);
                    return prevValue;
                }
                function updateDeferredValue(value) {
                    var _updateState = updateState(), prevValue = _updateState[0], setValue = _updateState[1];
                    updateEffect(function() {
                        var prevTransition = ReactCurrentBatchConfig$1.transition;
                        ReactCurrentBatchConfig$1.transition = {};
                        try {
                            setValue(value);
                        } finally{
                            ReactCurrentBatchConfig$1.transition = prevTransition;
                        }
                    }, [
                        value
                    ]);
                    return prevValue;
                }
                function rerenderDeferredValue(value) {
                    var _rerenderState = rerenderState(), prevValue = _rerenderState[0], setValue = _rerenderState[1];
                    updateEffect(function() {
                        var prevTransition = ReactCurrentBatchConfig$1.transition;
                        ReactCurrentBatchConfig$1.transition = {};
                        try {
                            setValue(value);
                        } finally{
                            ReactCurrentBatchConfig$1.transition = prevTransition;
                        }
                    }, [
                        value
                    ]);
                    return prevValue;
                }
                function startTransition(setPending, callback, options) {
                    var previousPriority = getCurrentUpdatePriority();
                    setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
                    setPending(true);
                    var prevTransition = ReactCurrentBatchConfig$1.transition;
                    ReactCurrentBatchConfig$1.transition = {};
                    var currentTransition = ReactCurrentBatchConfig$1.transition;
                    {
                        ReactCurrentBatchConfig$1.transition._updatedFibers = /* @__PURE__ */ new Set();
                    }
                    try {
                        setPending(false);
                        callback();
                    } finally{
                        setCurrentUpdatePriority(previousPriority);
                        ReactCurrentBatchConfig$1.transition = prevTransition;
                        {
                            if (prevTransition === null && currentTransition._updatedFibers) {
                                var updatedFibersCount = currentTransition._updatedFibers.size;
                                if (updatedFibersCount > 10) {
                                    warn3("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                                }
                                currentTransition._updatedFibers.clear();
                            }
                        }
                    }
                }
                function mountTransition() {
                    var _mountState2 = mountState(false), isPending = _mountState2[0], setPending = _mountState2[1];
                    var start = startTransition.bind(null, setPending);
                    var hook = mountWorkInProgressHook();
                    hook.memoizedState = start;
                    return [
                        isPending,
                        start
                    ];
                }
                function updateTransition() {
                    var _updateState2 = updateState(), isPending = _updateState2[0];
                    var hook = updateWorkInProgressHook();
                    var start = hook.memoizedState;
                    return [
                        isPending,
                        start
                    ];
                }
                function rerenderTransition() {
                    var _rerenderState2 = rerenderState(), isPending = _rerenderState2[0];
                    var hook = updateWorkInProgressHook();
                    var start = hook.memoizedState;
                    return [
                        isPending,
                        start
                    ];
                }
                var isUpdatingOpaqueValueInRenderPhase = false;
                function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
                    {
                        return isUpdatingOpaqueValueInRenderPhase;
                    }
                }
                function mountId() {
                    var hook = mountWorkInProgressHook();
                    var root = getWorkInProgressRoot();
                    var identifierPrefix = root.identifierPrefix;
                    var id;
                    if (getIsHydrating()) {
                        var treeId = getTreeId();
                        id = ":" + identifierPrefix + "R" + treeId;
                        var localId = localIdCounter++;
                        if (localId > 0) {
                            id += "H" + localId.toString(32);
                        }
                        id += ":";
                    } else {
                        var globalClientId = globalClientIdCounter++;
                        id = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
                    }
                    hook.memoizedState = id;
                    return id;
                }
                function updateId() {
                    var hook = updateWorkInProgressHook();
                    var id = hook.memoizedState;
                    return id;
                }
                function dispatchReducerAction(fiber, queue, action) {
                    {
                        if (typeof arguments[3] === "function") {
                            error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
                        }
                    }
                    var lane = requestUpdateLane(fiber);
                    var update = {
                        lane,
                        action,
                        hasEagerState: false,
                        eagerState: null,
                        next: null
                    };
                    if (isRenderPhaseUpdate(fiber)) {
                        enqueueRenderPhaseUpdate(queue, update);
                    } else {
                        enqueueUpdate$1(fiber, queue, update);
                        var eventTime = requestEventTime();
                        var root = scheduleUpdateOnFiber(fiber, lane, eventTime);
                        if (root !== null) {
                            entangleTransitionUpdate(root, queue, lane);
                        }
                    }
                    markUpdateInDevTools(fiber, lane);
                }
                function dispatchSetState(fiber, queue, action) {
                    {
                        if (typeof arguments[3] === "function") {
                            error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
                        }
                    }
                    var lane = requestUpdateLane(fiber);
                    var update = {
                        lane,
                        action,
                        hasEagerState: false,
                        eagerState: null,
                        next: null
                    };
                    if (isRenderPhaseUpdate(fiber)) {
                        enqueueRenderPhaseUpdate(queue, update);
                    } else {
                        enqueueUpdate$1(fiber, queue, update);
                        var alternate = fiber.alternate;
                        if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
                            var lastRenderedReducer = queue.lastRenderedReducer;
                            if (lastRenderedReducer !== null) {
                                var prevDispatcher;
                                {
                                    prevDispatcher = ReactCurrentDispatcher$1.current;
                                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                                }
                                try {
                                    var currentState = queue.lastRenderedState;
                                    var eagerState = lastRenderedReducer(currentState, action);
                                    update.hasEagerState = true;
                                    update.eagerState = eagerState;
                                    if (objectIs(eagerState, currentState)) {
                                        return;
                                    }
                                } catch (error2) {} finally{
                                    {
                                        ReactCurrentDispatcher$1.current = prevDispatcher;
                                    }
                                }
                            }
                        }
                        var eventTime = requestEventTime();
                        var root = scheduleUpdateOnFiber(fiber, lane, eventTime);
                        if (root !== null) {
                            entangleTransitionUpdate(root, queue, lane);
                        }
                    }
                    markUpdateInDevTools(fiber, lane);
                }
                function isRenderPhaseUpdate(fiber) {
                    var alternate = fiber.alternate;
                    return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
                }
                function enqueueRenderPhaseUpdate(queue, update) {
                    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
                    var pending = queue.pending;
                    if (pending === null) {
                        update.next = update;
                    } else {
                        update.next = pending.next;
                        pending.next = update;
                    }
                    queue.pending = update;
                }
                function enqueueUpdate$1(fiber, queue, update, lane) {
                    if (isInterleavedUpdate(fiber)) {
                        var interleaved = queue.interleaved;
                        if (interleaved === null) {
                            update.next = update;
                            pushInterleavedQueue(queue);
                        } else {
                            update.next = interleaved.next;
                            interleaved.next = update;
                        }
                        queue.interleaved = update;
                    } else {
                        var pending = queue.pending;
                        if (pending === null) {
                            update.next = update;
                        } else {
                            update.next = pending.next;
                            pending.next = update;
                        }
                        queue.pending = update;
                    }
                }
                function entangleTransitionUpdate(root, queue, lane) {
                    if (isTransitionLane(lane)) {
                        var queueLanes = queue.lanes;
                        queueLanes = intersectLanes(queueLanes, root.pendingLanes);
                        var newQueueLanes = mergeLanes(queueLanes, lane);
                        queue.lanes = newQueueLanes;
                        markRootEntangled(root, newQueueLanes);
                    }
                }
                function markUpdateInDevTools(fiber, lane, action) {
                    {
                        markStateUpdateScheduled(fiber, lane);
                    }
                }
                var ContextOnlyDispatcher = {
                    readContext,
                    useCallback: throwInvalidHookError,
                    useContext: throwInvalidHookError,
                    useEffect: throwInvalidHookError,
                    useImperativeHandle: throwInvalidHookError,
                    useInsertionEffect: throwInvalidHookError,
                    useLayoutEffect: throwInvalidHookError,
                    useMemo: throwInvalidHookError,
                    useReducer: throwInvalidHookError,
                    useRef: throwInvalidHookError,
                    useState: throwInvalidHookError,
                    useDebugValue: throwInvalidHookError,
                    useDeferredValue: throwInvalidHookError,
                    useTransition: throwInvalidHookError,
                    useMutableSource: throwInvalidHookError,
                    useSyncExternalStore: throwInvalidHookError,
                    useId: throwInvalidHookError,
                    unstable_isNewReconciler: enableNewReconciler
                };
                var HooksDispatcherOnMountInDEV = null;
                var HooksDispatcherOnMountWithHookTypesInDEV = null;
                var HooksDispatcherOnUpdateInDEV = null;
                var HooksDispatcherOnRerenderInDEV = null;
                var InvalidNestedHooksDispatcherOnMountInDEV = null;
                var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
                var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
                {
                    var warnInvalidContextAccess = function() {
                        error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
                    };
                    var warnInvalidHookAccess = function() {
                        error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
                    };
                    HooksDispatcherOnMountInDEV = {
                        readContext: function(context) {
                            return readContext(context);
                        },
                        useCallback: function(callback, deps) {
                            currentHookNameInDev = "useCallback";
                            mountHookTypesDev();
                            checkDepsAreArrayDev(deps);
                            return mountCallback(callback, deps);
                        },
                        useContext: function(context) {
                            currentHookNameInDev = "useContext";
                            mountHookTypesDev();
                            return readContext(context);
                        },
                        useEffect: function(create, deps) {
                            currentHookNameInDev = "useEffect";
                            mountHookTypesDev();
                            checkDepsAreArrayDev(deps);
                            return mountEffect(create, deps);
                        },
                        useImperativeHandle: function(ref, create, deps) {
                            currentHookNameInDev = "useImperativeHandle";
                            mountHookTypesDev();
                            checkDepsAreArrayDev(deps);
                            return mountImperativeHandle(ref, create, deps);
                        },
                        useInsertionEffect: function(create, deps) {
                            currentHookNameInDev = "useInsertionEffect";
                            mountHookTypesDev();
                            checkDepsAreArrayDev(deps);
                            return mountInsertionEffect(create, deps);
                        },
                        useLayoutEffect: function(create, deps) {
                            currentHookNameInDev = "useLayoutEffect";
                            mountHookTypesDev();
                            checkDepsAreArrayDev(deps);
                            return mountLayoutEffect(create, deps);
                        },
                        useMemo: function(create, deps) {
                            currentHookNameInDev = "useMemo";
                            mountHookTypesDev();
                            checkDepsAreArrayDev(deps);
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                            try {
                                return mountMemo(create, deps);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useReducer: function(reducer, initialArg, init) {
                            currentHookNameInDev = "useReducer";
                            mountHookTypesDev();
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                            try {
                                return mountReducer(reducer, initialArg, init);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useRef: function(initialValue) {
                            currentHookNameInDev = "useRef";
                            mountHookTypesDev();
                            return mountRef(initialValue);
                        },
                        useState: function(initialState) {
                            currentHookNameInDev = "useState";
                            mountHookTypesDev();
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                            try {
                                return mountState(initialState);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useDebugValue: function(value, formatterFn) {
                            currentHookNameInDev = "useDebugValue";
                            mountHookTypesDev();
                            return mountDebugValue();
                        },
                        useDeferredValue: function(value) {
                            currentHookNameInDev = "useDeferredValue";
                            mountHookTypesDev();
                            return mountDeferredValue(value);
                        },
                        useTransition: function() {
                            currentHookNameInDev = "useTransition";
                            mountHookTypesDev();
                            return mountTransition();
                        },
                        useMutableSource: function(source, getSnapshot, subscribe) {
                            currentHookNameInDev = "useMutableSource";
                            mountHookTypesDev();
                            return mountMutableSource();
                        },
                        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                            currentHookNameInDev = "useSyncExternalStore";
                            mountHookTypesDev();
                            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
                        },
                        useId: function() {
                            currentHookNameInDev = "useId";
                            mountHookTypesDev();
                            return mountId();
                        },
                        unstable_isNewReconciler: enableNewReconciler
                    };
                    HooksDispatcherOnMountWithHookTypesInDEV = {
                        readContext: function(context) {
                            return readContext(context);
                        },
                        useCallback: function(callback, deps) {
                            currentHookNameInDev = "useCallback";
                            updateHookTypesDev();
                            return mountCallback(callback, deps);
                        },
                        useContext: function(context) {
                            currentHookNameInDev = "useContext";
                            updateHookTypesDev();
                            return readContext(context);
                        },
                        useEffect: function(create, deps) {
                            currentHookNameInDev = "useEffect";
                            updateHookTypesDev();
                            return mountEffect(create, deps);
                        },
                        useImperativeHandle: function(ref, create, deps) {
                            currentHookNameInDev = "useImperativeHandle";
                            updateHookTypesDev();
                            return mountImperativeHandle(ref, create, deps);
                        },
                        useInsertionEffect: function(create, deps) {
                            currentHookNameInDev = "useInsertionEffect";
                            updateHookTypesDev();
                            return mountInsertionEffect(create, deps);
                        },
                        useLayoutEffect: function(create, deps) {
                            currentHookNameInDev = "useLayoutEffect";
                            updateHookTypesDev();
                            return mountLayoutEffect(create, deps);
                        },
                        useMemo: function(create, deps) {
                            currentHookNameInDev = "useMemo";
                            updateHookTypesDev();
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                            try {
                                return mountMemo(create, deps);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useReducer: function(reducer, initialArg, init) {
                            currentHookNameInDev = "useReducer";
                            updateHookTypesDev();
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                            try {
                                return mountReducer(reducer, initialArg, init);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useRef: function(initialValue) {
                            currentHookNameInDev = "useRef";
                            updateHookTypesDev();
                            return mountRef(initialValue);
                        },
                        useState: function(initialState) {
                            currentHookNameInDev = "useState";
                            updateHookTypesDev();
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                            try {
                                return mountState(initialState);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useDebugValue: function(value, formatterFn) {
                            currentHookNameInDev = "useDebugValue";
                            updateHookTypesDev();
                            return mountDebugValue();
                        },
                        useDeferredValue: function(value) {
                            currentHookNameInDev = "useDeferredValue";
                            updateHookTypesDev();
                            return mountDeferredValue(value);
                        },
                        useTransition: function() {
                            currentHookNameInDev = "useTransition";
                            updateHookTypesDev();
                            return mountTransition();
                        },
                        useMutableSource: function(source, getSnapshot, subscribe) {
                            currentHookNameInDev = "useMutableSource";
                            updateHookTypesDev();
                            return mountMutableSource();
                        },
                        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                            currentHookNameInDev = "useSyncExternalStore";
                            updateHookTypesDev();
                            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
                        },
                        useId: function() {
                            currentHookNameInDev = "useId";
                            updateHookTypesDev();
                            return mountId();
                        },
                        unstable_isNewReconciler: enableNewReconciler
                    };
                    HooksDispatcherOnUpdateInDEV = {
                        readContext: function(context) {
                            return readContext(context);
                        },
                        useCallback: function(callback, deps) {
                            currentHookNameInDev = "useCallback";
                            updateHookTypesDev();
                            return updateCallback(callback, deps);
                        },
                        useContext: function(context) {
                            currentHookNameInDev = "useContext";
                            updateHookTypesDev();
                            return readContext(context);
                        },
                        useEffect: function(create, deps) {
                            currentHookNameInDev = "useEffect";
                            updateHookTypesDev();
                            return updateEffect(create, deps);
                        },
                        useImperativeHandle: function(ref, create, deps) {
                            currentHookNameInDev = "useImperativeHandle";
                            updateHookTypesDev();
                            return updateImperativeHandle(ref, create, deps);
                        },
                        useInsertionEffect: function(create, deps) {
                            currentHookNameInDev = "useInsertionEffect";
                            updateHookTypesDev();
                            return updateInsertionEffect(create, deps);
                        },
                        useLayoutEffect: function(create, deps) {
                            currentHookNameInDev = "useLayoutEffect";
                            updateHookTypesDev();
                            return updateLayoutEffect(create, deps);
                        },
                        useMemo: function(create, deps) {
                            currentHookNameInDev = "useMemo";
                            updateHookTypesDev();
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                            try {
                                return updateMemo(create, deps);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useReducer: function(reducer, initialArg, init) {
                            currentHookNameInDev = "useReducer";
                            updateHookTypesDev();
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                            try {
                                return updateReducer2(reducer, initialArg, init);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useRef: function(initialValue) {
                            currentHookNameInDev = "useRef";
                            updateHookTypesDev();
                            return updateRef();
                        },
                        useState: function(initialState) {
                            currentHookNameInDev = "useState";
                            updateHookTypesDev();
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                            try {
                                return updateState(initialState);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useDebugValue: function(value, formatterFn) {
                            currentHookNameInDev = "useDebugValue";
                            updateHookTypesDev();
                            return updateDebugValue();
                        },
                        useDeferredValue: function(value) {
                            currentHookNameInDev = "useDeferredValue";
                            updateHookTypesDev();
                            return updateDeferredValue(value);
                        },
                        useTransition: function() {
                            currentHookNameInDev = "useTransition";
                            updateHookTypesDev();
                            return updateTransition();
                        },
                        useMutableSource: function(source, getSnapshot, subscribe) {
                            currentHookNameInDev = "useMutableSource";
                            updateHookTypesDev();
                            return updateMutableSource();
                        },
                        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                            currentHookNameInDev = "useSyncExternalStore";
                            updateHookTypesDev();
                            return updateSyncExternalStore(subscribe, getSnapshot);
                        },
                        useId: function() {
                            currentHookNameInDev = "useId";
                            updateHookTypesDev();
                            return updateId();
                        },
                        unstable_isNewReconciler: enableNewReconciler
                    };
                    HooksDispatcherOnRerenderInDEV = {
                        readContext: function(context) {
                            return readContext(context);
                        },
                        useCallback: function(callback, deps) {
                            currentHookNameInDev = "useCallback";
                            updateHookTypesDev();
                            return updateCallback(callback, deps);
                        },
                        useContext: function(context) {
                            currentHookNameInDev = "useContext";
                            updateHookTypesDev();
                            return readContext(context);
                        },
                        useEffect: function(create, deps) {
                            currentHookNameInDev = "useEffect";
                            updateHookTypesDev();
                            return updateEffect(create, deps);
                        },
                        useImperativeHandle: function(ref, create, deps) {
                            currentHookNameInDev = "useImperativeHandle";
                            updateHookTypesDev();
                            return updateImperativeHandle(ref, create, deps);
                        },
                        useInsertionEffect: function(create, deps) {
                            currentHookNameInDev = "useInsertionEffect";
                            updateHookTypesDev();
                            return updateInsertionEffect(create, deps);
                        },
                        useLayoutEffect: function(create, deps) {
                            currentHookNameInDev = "useLayoutEffect";
                            updateHookTypesDev();
                            return updateLayoutEffect(create, deps);
                        },
                        useMemo: function(create, deps) {
                            currentHookNameInDev = "useMemo";
                            updateHookTypesDev();
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                            try {
                                return updateMemo(create, deps);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useReducer: function(reducer, initialArg, init) {
                            currentHookNameInDev = "useReducer";
                            updateHookTypesDev();
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                            try {
                                return rerenderReducer(reducer, initialArg, init);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useRef: function(initialValue) {
                            currentHookNameInDev = "useRef";
                            updateHookTypesDev();
                            return updateRef();
                        },
                        useState: function(initialState) {
                            currentHookNameInDev = "useState";
                            updateHookTypesDev();
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                            try {
                                return rerenderState(initialState);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useDebugValue: function(value, formatterFn) {
                            currentHookNameInDev = "useDebugValue";
                            updateHookTypesDev();
                            return updateDebugValue();
                        },
                        useDeferredValue: function(value) {
                            currentHookNameInDev = "useDeferredValue";
                            updateHookTypesDev();
                            return rerenderDeferredValue(value);
                        },
                        useTransition: function() {
                            currentHookNameInDev = "useTransition";
                            updateHookTypesDev();
                            return rerenderTransition();
                        },
                        useMutableSource: function(source, getSnapshot, subscribe) {
                            currentHookNameInDev = "useMutableSource";
                            updateHookTypesDev();
                            return updateMutableSource();
                        },
                        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                            currentHookNameInDev = "useSyncExternalStore";
                            updateHookTypesDev();
                            return updateSyncExternalStore(subscribe, getSnapshot);
                        },
                        useId: function() {
                            currentHookNameInDev = "useId";
                            updateHookTypesDev();
                            return updateId();
                        },
                        unstable_isNewReconciler: enableNewReconciler
                    };
                    InvalidNestedHooksDispatcherOnMountInDEV = {
                        readContext: function(context) {
                            warnInvalidContextAccess();
                            return readContext(context);
                        },
                        useCallback: function(callback, deps) {
                            currentHookNameInDev = "useCallback";
                            warnInvalidHookAccess();
                            mountHookTypesDev();
                            return mountCallback(callback, deps);
                        },
                        useContext: function(context) {
                            currentHookNameInDev = "useContext";
                            warnInvalidHookAccess();
                            mountHookTypesDev();
                            return readContext(context);
                        },
                        useEffect: function(create, deps) {
                            currentHookNameInDev = "useEffect";
                            warnInvalidHookAccess();
                            mountHookTypesDev();
                            return mountEffect(create, deps);
                        },
                        useImperativeHandle: function(ref, create, deps) {
                            currentHookNameInDev = "useImperativeHandle";
                            warnInvalidHookAccess();
                            mountHookTypesDev();
                            return mountImperativeHandle(ref, create, deps);
                        },
                        useInsertionEffect: function(create, deps) {
                            currentHookNameInDev = "useInsertionEffect";
                            warnInvalidHookAccess();
                            mountHookTypesDev();
                            return mountInsertionEffect(create, deps);
                        },
                        useLayoutEffect: function(create, deps) {
                            currentHookNameInDev = "useLayoutEffect";
                            warnInvalidHookAccess();
                            mountHookTypesDev();
                            return mountLayoutEffect(create, deps);
                        },
                        useMemo: function(create, deps) {
                            currentHookNameInDev = "useMemo";
                            warnInvalidHookAccess();
                            mountHookTypesDev();
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                            try {
                                return mountMemo(create, deps);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useReducer: function(reducer, initialArg, init) {
                            currentHookNameInDev = "useReducer";
                            warnInvalidHookAccess();
                            mountHookTypesDev();
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                            try {
                                return mountReducer(reducer, initialArg, init);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useRef: function(initialValue) {
                            currentHookNameInDev = "useRef";
                            warnInvalidHookAccess();
                            mountHookTypesDev();
                            return mountRef(initialValue);
                        },
                        useState: function(initialState) {
                            currentHookNameInDev = "useState";
                            warnInvalidHookAccess();
                            mountHookTypesDev();
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                            try {
                                return mountState(initialState);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useDebugValue: function(value, formatterFn) {
                            currentHookNameInDev = "useDebugValue";
                            warnInvalidHookAccess();
                            mountHookTypesDev();
                            return mountDebugValue();
                        },
                        useDeferredValue: function(value) {
                            currentHookNameInDev = "useDeferredValue";
                            warnInvalidHookAccess();
                            mountHookTypesDev();
                            return mountDeferredValue(value);
                        },
                        useTransition: function() {
                            currentHookNameInDev = "useTransition";
                            warnInvalidHookAccess();
                            mountHookTypesDev();
                            return mountTransition();
                        },
                        useMutableSource: function(source, getSnapshot, subscribe) {
                            currentHookNameInDev = "useMutableSource";
                            warnInvalidHookAccess();
                            mountHookTypesDev();
                            return mountMutableSource();
                        },
                        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                            currentHookNameInDev = "useSyncExternalStore";
                            warnInvalidHookAccess();
                            mountHookTypesDev();
                            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
                        },
                        useId: function() {
                            currentHookNameInDev = "useId";
                            warnInvalidHookAccess();
                            mountHookTypesDev();
                            return mountId();
                        },
                        unstable_isNewReconciler: enableNewReconciler
                    };
                    InvalidNestedHooksDispatcherOnUpdateInDEV = {
                        readContext: function(context) {
                            warnInvalidContextAccess();
                            return readContext(context);
                        },
                        useCallback: function(callback, deps) {
                            currentHookNameInDev = "useCallback";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateCallback(callback, deps);
                        },
                        useContext: function(context) {
                            currentHookNameInDev = "useContext";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return readContext(context);
                        },
                        useEffect: function(create, deps) {
                            currentHookNameInDev = "useEffect";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateEffect(create, deps);
                        },
                        useImperativeHandle: function(ref, create, deps) {
                            currentHookNameInDev = "useImperativeHandle";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateImperativeHandle(ref, create, deps);
                        },
                        useInsertionEffect: function(create, deps) {
                            currentHookNameInDev = "useInsertionEffect";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateInsertionEffect(create, deps);
                        },
                        useLayoutEffect: function(create, deps) {
                            currentHookNameInDev = "useLayoutEffect";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateLayoutEffect(create, deps);
                        },
                        useMemo: function(create, deps) {
                            currentHookNameInDev = "useMemo";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                            try {
                                return updateMemo(create, deps);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useReducer: function(reducer, initialArg, init) {
                            currentHookNameInDev = "useReducer";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                            try {
                                return updateReducer2(reducer, initialArg, init);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useRef: function(initialValue) {
                            currentHookNameInDev = "useRef";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateRef();
                        },
                        useState: function(initialState) {
                            currentHookNameInDev = "useState";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                            try {
                                return updateState(initialState);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useDebugValue: function(value, formatterFn) {
                            currentHookNameInDev = "useDebugValue";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateDebugValue();
                        },
                        useDeferredValue: function(value) {
                            currentHookNameInDev = "useDeferredValue";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateDeferredValue(value);
                        },
                        useTransition: function() {
                            currentHookNameInDev = "useTransition";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateTransition();
                        },
                        useMutableSource: function(source, getSnapshot, subscribe) {
                            currentHookNameInDev = "useMutableSource";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateMutableSource();
                        },
                        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                            currentHookNameInDev = "useSyncExternalStore";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateSyncExternalStore(subscribe, getSnapshot);
                        },
                        useId: function() {
                            currentHookNameInDev = "useId";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateId();
                        },
                        unstable_isNewReconciler: enableNewReconciler
                    };
                    InvalidNestedHooksDispatcherOnRerenderInDEV = {
                        readContext: function(context) {
                            warnInvalidContextAccess();
                            return readContext(context);
                        },
                        useCallback: function(callback, deps) {
                            currentHookNameInDev = "useCallback";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateCallback(callback, deps);
                        },
                        useContext: function(context) {
                            currentHookNameInDev = "useContext";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return readContext(context);
                        },
                        useEffect: function(create, deps) {
                            currentHookNameInDev = "useEffect";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateEffect(create, deps);
                        },
                        useImperativeHandle: function(ref, create, deps) {
                            currentHookNameInDev = "useImperativeHandle";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateImperativeHandle(ref, create, deps);
                        },
                        useInsertionEffect: function(create, deps) {
                            currentHookNameInDev = "useInsertionEffect";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateInsertionEffect(create, deps);
                        },
                        useLayoutEffect: function(create, deps) {
                            currentHookNameInDev = "useLayoutEffect";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateLayoutEffect(create, deps);
                        },
                        useMemo: function(create, deps) {
                            currentHookNameInDev = "useMemo";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                            try {
                                return updateMemo(create, deps);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useReducer: function(reducer, initialArg, init) {
                            currentHookNameInDev = "useReducer";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                            try {
                                return rerenderReducer(reducer, initialArg, init);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useRef: function(initialValue) {
                            currentHookNameInDev = "useRef";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateRef();
                        },
                        useState: function(initialState) {
                            currentHookNameInDev = "useState";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            var prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                            try {
                                return rerenderState(initialState);
                            } finally{
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        },
                        useDebugValue: function(value, formatterFn) {
                            currentHookNameInDev = "useDebugValue";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateDebugValue();
                        },
                        useDeferredValue: function(value) {
                            currentHookNameInDev = "useDeferredValue";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return rerenderDeferredValue(value);
                        },
                        useTransition: function() {
                            currentHookNameInDev = "useTransition";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return rerenderTransition();
                        },
                        useMutableSource: function(source, getSnapshot, subscribe) {
                            currentHookNameInDev = "useMutableSource";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateMutableSource();
                        },
                        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                            currentHookNameInDev = "useSyncExternalStore";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateSyncExternalStore(subscribe, getSnapshot);
                        },
                        useId: function() {
                            currentHookNameInDev = "useId";
                            warnInvalidHookAccess();
                            updateHookTypesDev();
                            return updateId();
                        },
                        unstable_isNewReconciler: enableNewReconciler
                    };
                }
                var now$2 = Scheduler.unstable_now;
                var commitTime = 0;
                var layoutEffectStartTime = -1;
                var profilerStartTime = -1;
                var passiveEffectStartTime = -1;
                var currentUpdateIsNested = false;
                var nestedUpdateScheduled = false;
                function isCurrentUpdateNested() {
                    return currentUpdateIsNested;
                }
                function markNestedUpdateScheduled() {
                    {
                        nestedUpdateScheduled = true;
                    }
                }
                function resetNestedUpdateFlag() {
                    {
                        currentUpdateIsNested = false;
                        nestedUpdateScheduled = false;
                    }
                }
                function syncNestedUpdateFlag() {
                    {
                        currentUpdateIsNested = nestedUpdateScheduled;
                        nestedUpdateScheduled = false;
                    }
                }
                function getCommitTime() {
                    return commitTime;
                }
                function recordCommitTime() {
                    commitTime = now$2();
                }
                function startProfilerTimer(fiber) {
                    profilerStartTime = now$2();
                    if (fiber.actualStartTime < 0) {
                        fiber.actualStartTime = now$2();
                    }
                }
                function stopProfilerTimerIfRunning(fiber) {
                    profilerStartTime = -1;
                }
                function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
                    if (profilerStartTime >= 0) {
                        var elapsedTime = now$2() - profilerStartTime;
                        fiber.actualDuration += elapsedTime;
                        if (overrideBaseTime) {
                            fiber.selfBaseDuration = elapsedTime;
                        }
                        profilerStartTime = -1;
                    }
                }
                function recordLayoutEffectDuration(fiber) {
                    if (layoutEffectStartTime >= 0) {
                        var elapsedTime = now$2() - layoutEffectStartTime;
                        layoutEffectStartTime = -1;
                        var parentFiber = fiber.return;
                        while(parentFiber !== null){
                            switch(parentFiber.tag){
                                case HostRoot2:
                                    var root = parentFiber.stateNode;
                                    root.effectDuration += elapsedTime;
                                    return;
                                case Profiler:
                                    var parentStateNode = parentFiber.stateNode;
                                    parentStateNode.effectDuration += elapsedTime;
                                    return;
                            }
                            parentFiber = parentFiber.return;
                        }
                    }
                }
                function recordPassiveEffectDuration(fiber) {
                    if (passiveEffectStartTime >= 0) {
                        var elapsedTime = now$2() - passiveEffectStartTime;
                        passiveEffectStartTime = -1;
                        var parentFiber = fiber.return;
                        while(parentFiber !== null){
                            switch(parentFiber.tag){
                                case HostRoot2:
                                    var root = parentFiber.stateNode;
                                    if (root !== null) {
                                        root.passiveEffectDuration += elapsedTime;
                                    }
                                    return;
                                case Profiler:
                                    var parentStateNode = parentFiber.stateNode;
                                    if (parentStateNode !== null) {
                                        parentStateNode.passiveEffectDuration += elapsedTime;
                                    }
                                    return;
                            }
                            parentFiber = parentFiber.return;
                        }
                    }
                }
                function startLayoutEffectTimer() {
                    layoutEffectStartTime = now$2();
                }
                function startPassiveEffectTimer() {
                    passiveEffectStartTime = now$2();
                }
                function transferActualDuration(fiber) {
                    var child = fiber.child;
                    while(child){
                        fiber.actualDuration += child.actualDuration;
                        child = child.sibling;
                    }
                }
                function createCapturedValue(value, source) {
                    return {
                        value,
                        source,
                        stack: getStackByFiberInDevAndProd(source)
                    };
                }
                function showErrorDialog(boundary, errorInfo) {
                    return true;
                }
                function logCapturedError(boundary, errorInfo) {
                    try {
                        var logError = showErrorDialog(boundary, errorInfo);
                        if (logError === false) {
                            return;
                        }
                        var error2 = errorInfo.value;
                        if (true) {
                            var source = errorInfo.source;
                            var stack = errorInfo.stack;
                            var componentStack = stack !== null ? stack : "";
                            if (error2 != null && error2._suppressLogging) {
                                if (boundary.tag === ClassComponent) {
                                    return;
                                }
                                console["error"](error2);
                            }
                            var componentName = source ? getComponentNameFromFiber(source) : null;
                            var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
                            var errorBoundaryMessage;
                            if (boundary.tag === HostRoot2) {
                                errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
                            } else {
                                var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
                                errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
                            }
                            var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
                            console["error"](combinedMessage);
                        } else {
                            console["error"](error2);
                        }
                    } catch (e) {
                        setTimeout(function() {
                            throw e;
                        });
                    }
                }
                var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
                function createRootErrorUpdate(fiber, errorInfo, lane) {
                    var update = createUpdate(NoTimestamp, lane);
                    update.tag = CaptureUpdate;
                    update.payload = {
                        element: null
                    };
                    var error2 = errorInfo.value;
                    update.callback = function() {
                        onUncaughtError(error2);
                        logCapturedError(fiber, errorInfo);
                    };
                    return update;
                }
                function createClassErrorUpdate(fiber, errorInfo, lane) {
                    var update = createUpdate(NoTimestamp, lane);
                    update.tag = CaptureUpdate;
                    var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
                    if (typeof getDerivedStateFromError === "function") {
                        var error$1 = errorInfo.value;
                        update.payload = function() {
                            return getDerivedStateFromError(error$1);
                        };
                        update.callback = function() {
                            {
                                markFailedErrorBoundaryForHotReloading(fiber);
                            }
                            logCapturedError(fiber, errorInfo);
                        };
                    }
                    var inst = fiber.stateNode;
                    if (inst !== null && typeof inst.componentDidCatch === "function") {
                        update.callback = function callback() {
                            {
                                markFailedErrorBoundaryForHotReloading(fiber);
                            }
                            logCapturedError(fiber, errorInfo);
                            if (typeof getDerivedStateFromError !== "function") {
                                markLegacyErrorBoundaryAsFailed(this);
                            }
                            var error$12 = errorInfo.value;
                            var stack = errorInfo.stack;
                            this.componentDidCatch(error$12, {
                                componentStack: stack !== null ? stack : ""
                            });
                            {
                                if (typeof getDerivedStateFromError !== "function") {
                                    if (!includesSomeLane(fiber.lanes, SyncLane)) {
                                        error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
                                    }
                                }
                            }
                        };
                    }
                    return update;
                }
                function attachPingListener(root, wakeable, lanes) {
                    var pingCache = root.pingCache;
                    var threadIDs;
                    if (pingCache === null) {
                        pingCache = root.pingCache = new PossiblyWeakMap$1();
                        threadIDs = /* @__PURE__ */ new Set();
                        pingCache.set(wakeable, threadIDs);
                    } else {
                        threadIDs = pingCache.get(wakeable);
                        if (threadIDs === void 0) {
                            threadIDs = /* @__PURE__ */ new Set();
                            pingCache.set(wakeable, threadIDs);
                        }
                    }
                    if (!threadIDs.has(lanes)) {
                        threadIDs.add(lanes);
                        var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);
                        {
                            if (isDevToolsPresent) {
                                restorePendingUpdaters(root, lanes);
                            }
                        }
                        wakeable.then(ping, ping);
                    }
                }
                function attachRetryListener(suspenseBoundary, root, wakeable, lanes) {
                    var wakeables = suspenseBoundary.updateQueue;
                    if (wakeables === null) {
                        var updateQueue = /* @__PURE__ */ new Set();
                        updateQueue.add(wakeable);
                        suspenseBoundary.updateQueue = updateQueue;
                    } else {
                        wakeables.add(wakeable);
                    }
                }
                function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
                    var tag = sourceFiber.tag;
                    if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
                        var currentSource = sourceFiber.alternate;
                        if (currentSource) {
                            sourceFiber.updateQueue = currentSource.updateQueue;
                            sourceFiber.memoizedState = currentSource.memoizedState;
                            sourceFiber.lanes = currentSource.lanes;
                        } else {
                            sourceFiber.updateQueue = null;
                            sourceFiber.memoizedState = null;
                        }
                    }
                }
                function getNearestSuspenseBoundaryToCapture(returnFiber) {
                    var node = returnFiber;
                    do {
                        if (node.tag === SuspenseComponent2 && shouldCaptureSuspense(node)) {
                            return node;
                        }
                        node = node.return;
                    }while (node !== null)
                    return null;
                }
                function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes) {
                    if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
                        if (suspenseBoundary === returnFiber) {
                            suspenseBoundary.flags |= ShouldCapture;
                        } else {
                            suspenseBoundary.flags |= DidCapture;
                            sourceFiber.flags |= ForceUpdateForLegacySuspense;
                            sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
                            if (supportsPersistence && enablePersistentOffscreenHostContainer) {
                                var currentSuspenseBoundary = suspenseBoundary.alternate;
                                if (currentSuspenseBoundary === null) {
                                    var offscreenFiber = suspenseBoundary.child;
                                    var offscreenContainer = offscreenFiber.child;
                                    if (offscreenContainer !== null) {
                                        var children2 = offscreenContainer.memoizedProps.children;
                                        var containerProps = getOffscreenContainerProps("hidden", children2);
                                        offscreenContainer.pendingProps = containerProps;
                                        offscreenContainer.memoizedProps = containerProps;
                                    }
                                }
                            }
                            if (sourceFiber.tag === ClassComponent) {
                                var currentSourceFiber = sourceFiber.alternate;
                                if (currentSourceFiber === null) {
                                    sourceFiber.tag = IncompleteClassComponent;
                                } else {
                                    var update = createUpdate(NoTimestamp, SyncLane);
                                    update.tag = ForceUpdate;
                                    enqueueUpdate(sourceFiber, update);
                                }
                            }
                            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
                        }
                        return suspenseBoundary;
                    }
                    suspenseBoundary.flags |= ShouldCapture;
                    suspenseBoundary.lanes = rootRenderLanes;
                    return suspenseBoundary;
                }
                function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
                    sourceFiber.flags |= Incomplete;
                    {
                        if (isDevToolsPresent) {
                            restorePendingUpdaters(root, rootRenderLanes);
                        }
                    }
                    if (value !== null && typeof value === "object" && typeof value.then === "function") {
                        var wakeable = value;
                        resetSuspendedComponent(sourceFiber);
                        var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
                        if (suspenseBoundary !== null) {
                            suspenseBoundary.flags &= ~ForceClientRender;
                            markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes);
                            if (suspenseBoundary.mode & ConcurrentMode) {
                                attachPingListener(root, wakeable, rootRenderLanes);
                            }
                            attachRetryListener(suspenseBoundary, root, wakeable);
                            return;
                        } else {
                            if (!includesSyncLane(rootRenderLanes)) {
                                attachPingListener(root, wakeable, rootRenderLanes);
                                renderDidSuspendDelayIfPossible();
                                return;
                            }
                            var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
                            value = uncaughtSuspenseError;
                        }
                    } else {
                        if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                            markDidSuspendWhileHydratingDEV();
                            var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
                            if (_suspenseBoundary !== null) {
                                if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                                    _suspenseBoundary.flags |= ForceClientRender;
                                }
                                markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes);
                                queueHydrationError(value);
                                return;
                            }
                        }
                    }
                    renderDidError(value);
                    value = createCapturedValue(value, sourceFiber);
                    var workInProgress2 = returnFiber;
                    do {
                        switch(workInProgress2.tag){
                            case HostRoot2:
                                {
                                    var _errorInfo = value;
                                    workInProgress2.flags |= ShouldCapture;
                                    var lane = pickArbitraryLane(rootRenderLanes);
                                    workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                                    var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
                                    enqueueCapturedUpdate(workInProgress2, update);
                                    return;
                                }
                            case ClassComponent:
                                var errorInfo = value;
                                var ctor = workInProgress2.type;
                                var instance = workInProgress2.stateNode;
                                if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                                    workInProgress2.flags |= ShouldCapture;
                                    var _lane = pickArbitraryLane(rootRenderLanes);
                                    workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                                    var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                                    enqueueCapturedUpdate(workInProgress2, _update);
                                    return;
                                }
                                break;
                        }
                        workInProgress2 = workInProgress2.return;
                    }while (workInProgress2 !== null)
                }
                function getSuspendedCache() {
                    {
                        return null;
                    }
                }
                function markUpdate(workInProgress2) {
                    workInProgress2.flags |= Update;
                }
                function markRef(workInProgress2) {
                    workInProgress2.flags |= Ref;
                    {
                        workInProgress2.flags |= RefStatic;
                    }
                }
                function hadNoMutationsEffects(current2, completedWork) {
                    var didBailout = current2 !== null && current2.child === completedWork.child;
                    if (didBailout) {
                        return true;
                    }
                    if ((completedWork.flags & ChildDeletion) !== NoFlags) {
                        return false;
                    }
                    var child = completedWork.child;
                    while(child !== null){
                        if ((child.flags & MutationMask) !== NoFlags || (child.subtreeFlags & MutationMask) !== NoFlags) {
                            return false;
                        }
                        child = child.sibling;
                    }
                    return true;
                }
                var appendAllChildren;
                var updateHostContainer;
                var updateHostComponent;
                var updateHostText;
                if (supportsMutation) {
                    appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
                        var node = workInProgress2.child;
                        while(node !== null){
                            if (node.tag === HostComponent2 || node.tag === HostText2) {
                                appendInitialChild(parent, node.stateNode);
                            } else if (node.tag === HostPortal) ;
                            else if (node.child !== null) {
                                node.child.return = node;
                                node = node.child;
                                continue;
                            }
                            if (node === workInProgress2) {
                                return;
                            }
                            while(node.sibling === null){
                                if (node.return === null || node.return === workInProgress2) {
                                    return;
                                }
                                node = node.return;
                            }
                            node.sibling.return = node.return;
                            node = node.sibling;
                        }
                    };
                    updateHostContainer = function(current2, workInProgress2) {};
                    updateHostComponent = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
                        var oldProps = current2.memoizedProps;
                        if (oldProps === newProps) {
                            return;
                        }
                        var instance = workInProgress2.stateNode;
                        var currentHostContext = getHostContext();
                        var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
                        workInProgress2.updateQueue = updatePayload;
                        if (updatePayload) {
                            markUpdate(workInProgress2);
                        }
                    };
                    updateHostText = function(current2, workInProgress2, oldText, newText) {
                        if (oldText !== newText) {
                            markUpdate(workInProgress2);
                        }
                    };
                } else if (supportsPersistence) {
                    appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
                        var node = workInProgress2.child;
                        while(node !== null){
                            if (node.tag === HostComponent2) {
                                var instance = node.stateNode;
                                if (needsVisibilityToggle && isHidden) {
                                    var props = node.memoizedProps;
                                    var type = node.type;
                                    instance = cloneHiddenInstance(instance, type, props, node);
                                }
                                appendInitialChild(parent, instance);
                            } else if (node.tag === HostText2) {
                                var _instance = node.stateNode;
                                if (needsVisibilityToggle && isHidden) {
                                    var text = node.memoizedProps;
                                    _instance = cloneHiddenTextInstance(_instance, text, node);
                                }
                                appendInitialChild(parent, _instance);
                            } else if (node.tag === HostPortal) ;
                            else if (node.tag === OffscreenComponent && node.memoizedState !== null) {
                                var child = node.child;
                                if (child !== null) {
                                    child.return = node;
                                }
                                {
                                    appendAllChildren(parent, node, true, true);
                                }
                            } else if (node.child !== null) {
                                node.child.return = node;
                                node = node.child;
                                continue;
                            }
                            node = node;
                            if (node === workInProgress2) {
                                return;
                            }
                            while(node.sibling === null){
                                if (node.return === null || node.return === workInProgress2) {
                                    return;
                                }
                                node = node.return;
                            }
                            node.sibling.return = node.return;
                            node = node.sibling;
                        }
                    };
                    var appendAllChildrenToContainer = function(containerChildSet, workInProgress2, needsVisibilityToggle, isHidden) {
                        var node = workInProgress2.child;
                        while(node !== null){
                            if (node.tag === HostComponent2) {
                                var instance = node.stateNode;
                                if (needsVisibilityToggle && isHidden) {
                                    var props = node.memoizedProps;
                                    var type = node.type;
                                    instance = cloneHiddenInstance(instance, type, props, node);
                                }
                                appendChildToContainerChildSet(containerChildSet, instance);
                            } else if (node.tag === HostText2) {
                                var _instance2 = node.stateNode;
                                if (needsVisibilityToggle && isHidden) {
                                    var text = node.memoizedProps;
                                    _instance2 = cloneHiddenTextInstance(_instance2, text, node);
                                }
                                appendChildToContainerChildSet(containerChildSet, _instance2);
                            } else if (node.tag === HostPortal) ;
                            else if (node.tag === OffscreenComponent && node.memoizedState !== null) {
                                var child = node.child;
                                if (child !== null) {
                                    child.return = node;
                                }
                                {
                                    appendAllChildrenToContainer(containerChildSet, node, true, true);
                                }
                            } else if (node.child !== null) {
                                node.child.return = node;
                                node = node.child;
                                continue;
                            }
                            node = node;
                            if (node === workInProgress2) {
                                return;
                            }
                            while(node.sibling === null){
                                if (node.return === null || node.return === workInProgress2) {
                                    return;
                                }
                                node = node.return;
                            }
                            node.sibling.return = node.return;
                            node = node.sibling;
                        }
                    };
                    updateHostContainer = function(current2, workInProgress2) {
                        var portalOrRoot = workInProgress2.stateNode;
                        var childrenUnchanged = hadNoMutationsEffects(current2, workInProgress2);
                        if (childrenUnchanged) ;
                        else {
                            var container = portalOrRoot.containerInfo;
                            var newChildSet = createContainerChildSet(container);
                            appendAllChildrenToContainer(newChildSet, workInProgress2, false, false);
                            portalOrRoot.pendingChildren = newChildSet;
                            markUpdate(workInProgress2);
                            finalizeContainerChildren(container, newChildSet);
                        }
                    };
                    updateHostComponent = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
                        var currentInstance = current2.stateNode;
                        var oldProps = current2.memoizedProps;
                        var childrenUnchanged = hadNoMutationsEffects(current2, workInProgress2);
                        if (childrenUnchanged && oldProps === newProps) {
                            workInProgress2.stateNode = currentInstance;
                            return;
                        }
                        var recyclableInstance = workInProgress2.stateNode;
                        var currentHostContext = getHostContext();
                        var updatePayload = null;
                        if (oldProps !== newProps) {
                            updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
                        }
                        if (childrenUnchanged && updatePayload === null) {
                            workInProgress2.stateNode = currentInstance;
                            return;
                        }
                        var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress2, childrenUnchanged, recyclableInstance);
                        if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {
                            markUpdate(workInProgress2);
                        }
                        workInProgress2.stateNode = newInstance;
                        if (childrenUnchanged) {
                            markUpdate(workInProgress2);
                        } else {
                            appendAllChildren(newInstance, workInProgress2, false, false);
                        }
                    };
                    updateHostText = function(current2, workInProgress2, oldText, newText) {
                        if (oldText !== newText) {
                            var rootContainerInstance = getRootHostContainer();
                            var currentHostContext = getHostContext();
                            workInProgress2.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress2);
                            markUpdate(workInProgress2);
                        } else {
                            workInProgress2.stateNode = current2.stateNode;
                        }
                    };
                } else {
                    updateHostContainer = function(current2, workInProgress2) {};
                    updateHostComponent = function(current2, workInProgress2, type, newProps, rootContainerInstance) {};
                    updateHostText = function(current2, workInProgress2, oldText, newText) {};
                }
                function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
                    if (getIsHydrating()) {
                        return;
                    }
                    switch(renderState.tailMode){
                        case "hidden":
                            {
                                var tailNode = renderState.tail;
                                var lastTailNode = null;
                                while(tailNode !== null){
                                    if (tailNode.alternate !== null) {
                                        lastTailNode = tailNode;
                                    }
                                    tailNode = tailNode.sibling;
                                }
                                if (lastTailNode === null) {
                                    renderState.tail = null;
                                } else {
                                    lastTailNode.sibling = null;
                                }
                                break;
                            }
                        case "collapsed":
                            {
                                var _tailNode = renderState.tail;
                                var _lastTailNode = null;
                                while(_tailNode !== null){
                                    if (_tailNode.alternate !== null) {
                                        _lastTailNode = _tailNode;
                                    }
                                    _tailNode = _tailNode.sibling;
                                }
                                if (_lastTailNode === null) {
                                    if (!hasRenderedATailFallback && renderState.tail !== null) {
                                        renderState.tail.sibling = null;
                                    } else {
                                        renderState.tail = null;
                                    }
                                } else {
                                    _lastTailNode.sibling = null;
                                }
                                break;
                            }
                    }
                }
                function bubbleProperties(completedWork) {
                    var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
                    var newChildLanes = NoLanes;
                    var subtreeFlags = NoFlags;
                    if (!didBailout) {
                        if ((completedWork.mode & ProfileMode) !== NoMode) {
                            var actualDuration = completedWork.actualDuration;
                            var treeBaseDuration = completedWork.selfBaseDuration;
                            var child = completedWork.child;
                            while(child !== null){
                                newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                                subtreeFlags |= child.subtreeFlags;
                                subtreeFlags |= child.flags;
                                actualDuration += child.actualDuration;
                                treeBaseDuration += child.treeBaseDuration;
                                child = child.sibling;
                            }
                            completedWork.actualDuration = actualDuration;
                            completedWork.treeBaseDuration = treeBaseDuration;
                        } else {
                            var _child = completedWork.child;
                            while(_child !== null){
                                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                                subtreeFlags |= _child.subtreeFlags;
                                subtreeFlags |= _child.flags;
                                _child.return = completedWork;
                                _child = _child.sibling;
                            }
                        }
                        completedWork.subtreeFlags |= subtreeFlags;
                    } else {
                        if ((completedWork.mode & ProfileMode) !== NoMode) {
                            var _treeBaseDuration = completedWork.selfBaseDuration;
                            var _child2 = completedWork.child;
                            while(_child2 !== null){
                                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
                                subtreeFlags |= _child2.subtreeFlags & StaticMask;
                                subtreeFlags |= _child2.flags & StaticMask;
                                _treeBaseDuration += _child2.treeBaseDuration;
                                _child2 = _child2.sibling;
                            }
                            completedWork.treeBaseDuration = _treeBaseDuration;
                        } else {
                            var _child3 = completedWork.child;
                            while(_child3 !== null){
                                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
                                subtreeFlags |= _child3.subtreeFlags & StaticMask;
                                subtreeFlags |= _child3.flags & StaticMask;
                                _child3.return = completedWork;
                                _child3 = _child3.sibling;
                            }
                        }
                        completedWork.subtreeFlags |= subtreeFlags;
                    }
                    completedWork.childLanes = newChildLanes;
                    return didBailout;
                }
                function completeWork(current2, workInProgress2, renderLanes2) {
                    var newProps = workInProgress2.pendingProps;
                    popTreeContext(workInProgress2);
                    switch(workInProgress2.tag){
                        case IndeterminateComponent:
                        case LazyComponent:
                        case SimpleMemoComponent:
                        case FunctionComponent:
                        case ForwardRef:
                        case Fragment20:
                        case Mode:
                        case Profiler:
                        case ContextConsumer:
                        case MemoComponent:
                            bubbleProperties(workInProgress2);
                            return null;
                        case ClassComponent:
                            {
                                var Component = workInProgress2.type;
                                if (isContextProvider(Component)) {
                                    popContext(workInProgress2);
                                }
                                bubbleProperties(workInProgress2);
                                return null;
                            }
                        case HostRoot2:
                            {
                                var fiberRoot = workInProgress2.stateNode;
                                popHostContainer(workInProgress2);
                                popTopLevelContextObject(workInProgress2);
                                resetWorkInProgressVersions();
                                if (fiberRoot.pendingContext) {
                                    fiberRoot.context = fiberRoot.pendingContext;
                                    fiberRoot.pendingContext = null;
                                }
                                if (current2 === null || current2.child === null) {
                                    var wasHydrated = popHydrationState(workInProgress2);
                                    if (wasHydrated) {
                                        markUpdate(workInProgress2);
                                    } else {
                                        if (current2 !== null) {
                                            var prevState = current2.memoizedState;
                                            if (// Check if this is a client root
                                            !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
                                            (workInProgress2.flags & ForceClientRender) !== NoFlags) {
                                                workInProgress2.flags |= Snapshot;
                                                upgradeHydrationErrorsToRecoverable();
                                            }
                                        }
                                    }
                                }
                                updateHostContainer(current2, workInProgress2);
                                bubbleProperties(workInProgress2);
                                return null;
                            }
                        case HostComponent2:
                            {
                                popHostContext(workInProgress2);
                                var rootContainerInstance = getRootHostContainer();
                                var type = workInProgress2.type;
                                if (current2 !== null && workInProgress2.stateNode != null) {
                                    updateHostComponent(current2, workInProgress2, type, newProps, rootContainerInstance);
                                    if (current2.ref !== workInProgress2.ref) {
                                        markRef(workInProgress2);
                                    }
                                } else {
                                    if (!newProps) {
                                        if (workInProgress2.stateNode === null) {
                                            throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                                        }
                                        bubbleProperties(workInProgress2);
                                        return null;
                                    }
                                    var currentHostContext = getHostContext();
                                    var _wasHydrated = popHydrationState(workInProgress2);
                                    if (_wasHydrated) {
                                        if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                                            markUpdate(workInProgress2);
                                        }
                                    } else {
                                        var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                                        appendAllChildren(instance, workInProgress2, false, false);
                                        workInProgress2.stateNode = instance;
                                        if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {
                                            markUpdate(workInProgress2);
                                        }
                                    }
                                    if (workInProgress2.ref !== null) {
                                        markRef(workInProgress2);
                                    }
                                }
                                bubbleProperties(workInProgress2);
                                return null;
                            }
                        case HostText2:
                            {
                                var newText = newProps;
                                if (current2 && workInProgress2.stateNode != null) {
                                    var oldText = current2.memoizedProps;
                                    updateHostText(current2, workInProgress2, oldText, newText);
                                } else {
                                    if (typeof newText !== "string") {
                                        if (workInProgress2.stateNode === null) {
                                            throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                                        }
                                    }
                                    var _rootContainerInstance = getRootHostContainer();
                                    var _currentHostContext = getHostContext();
                                    var _wasHydrated2 = popHydrationState(workInProgress2);
                                    if (_wasHydrated2) {
                                        if (prepareToHydrateHostTextInstance(workInProgress2)) {
                                            markUpdate(workInProgress2);
                                        }
                                    } else {
                                        workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                                    }
                                }
                                bubbleProperties(workInProgress2);
                                return null;
                            }
                        case SuspenseComponent2:
                            {
                                popSuspenseContext(workInProgress2);
                                var nextState = workInProgress2.memoizedState;
                                {
                                    if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {
                                        warnIfUnhydratedTailNodes(workInProgress2);
                                        resetHydrationState();
                                        workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;
                                        return workInProgress2;
                                    }
                                    if (nextState !== null && nextState.dehydrated !== null) {
                                        var _wasHydrated3 = popHydrationState(workInProgress2);
                                        if (current2 === null) {
                                            if (!_wasHydrated3) {
                                                throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                                            }
                                            prepareToHydrateHostSuspenseInstance(workInProgress2);
                                            bubbleProperties(workInProgress2);
                                            {
                                                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                                                    var isTimedOutSuspense = nextState !== null;
                                                    if (isTimedOutSuspense) {
                                                        var primaryChildFragment = workInProgress2.child;
                                                        if (primaryChildFragment !== null) {
                                                            workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                                                        }
                                                    }
                                                }
                                            }
                                            return null;
                                        } else {
                                            resetHydrationState();
                                            if ((workInProgress2.flags & DidCapture) === NoFlags) {
                                                workInProgress2.memoizedState = null;
                                            }
                                            workInProgress2.flags |= Update;
                                            bubbleProperties(workInProgress2);
                                            {
                                                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                                                    var _isTimedOutSuspense = nextState !== null;
                                                    if (_isTimedOutSuspense) {
                                                        var _primaryChildFragment = workInProgress2.child;
                                                        if (_primaryChildFragment !== null) {
                                                            workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                                                        }
                                                    }
                                                }
                                            }
                                            return null;
                                        }
                                    }
                                    upgradeHydrationErrorsToRecoverable();
                                }
                                if ((workInProgress2.flags & DidCapture) !== NoFlags) {
                                    workInProgress2.lanes = renderLanes2;
                                    if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                                        transferActualDuration(workInProgress2);
                                    }
                                    return workInProgress2;
                                }
                                var nextDidTimeout = nextState !== null;
                                var prevDidTimeout = false;
                                if (current2 === null) {
                                    popHydrationState(workInProgress2);
                                } else {
                                    var _prevState = current2.memoizedState;
                                    prevDidTimeout = _prevState !== null;
                                }
                                if (nextDidTimeout && !prevDidTimeout) {
                                    var _offscreenFiber = workInProgress2.child;
                                    _offscreenFiber.flags |= Visibility;
                                    if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                                        var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);
                                        if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                                            renderDidSuspend();
                                        } else {
                                            renderDidSuspendDelayIfPossible();
                                        }
                                    }
                                }
                                var wakeables = workInProgress2.updateQueue;
                                if (wakeables !== null) {
                                    workInProgress2.flags |= Update;
                                }
                                bubbleProperties(workInProgress2);
                                {
                                    if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                                        if (nextDidTimeout) {
                                            var _primaryChildFragment2 = workInProgress2.child;
                                            if (_primaryChildFragment2 !== null) {
                                                workInProgress2.treeBaseDuration -= _primaryChildFragment2.treeBaseDuration;
                                            }
                                        }
                                    }
                                }
                                return null;
                            }
                        case HostPortal:
                            popHostContainer(workInProgress2);
                            updateHostContainer(current2, workInProgress2);
                            if (current2 === null) {
                                preparePortalMount(workInProgress2.stateNode.containerInfo);
                            }
                            bubbleProperties(workInProgress2);
                            return null;
                        case ContextProvider:
                            var context = workInProgress2.type._context;
                            popProvider(context, workInProgress2);
                            bubbleProperties(workInProgress2);
                            return null;
                        case IncompleteClassComponent:
                            {
                                var _Component = workInProgress2.type;
                                if (isContextProvider(_Component)) {
                                    popContext(workInProgress2);
                                }
                                bubbleProperties(workInProgress2);
                                return null;
                            }
                        case SuspenseListComponent:
                            {
                                popSuspenseContext(workInProgress2);
                                var renderState = workInProgress2.memoizedState;
                                if (renderState === null) {
                                    bubbleProperties(workInProgress2);
                                    return null;
                                }
                                var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
                                var renderedTail = renderState.rendering;
                                if (renderedTail === null) {
                                    if (!didSuspendAlready) {
                                        var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                                        if (!cannotBeSuspended) {
                                            var row = workInProgress2.child;
                                            while(row !== null){
                                                var suspended = findFirstSuspended(row);
                                                if (suspended !== null) {
                                                    didSuspendAlready = true;
                                                    workInProgress2.flags |= DidCapture;
                                                    cutOffTailIfNeeded(renderState, false);
                                                    var newThenables = suspended.updateQueue;
                                                    if (newThenables !== null) {
                                                        workInProgress2.updateQueue = newThenables;
                                                        workInProgress2.flags |= Update;
                                                    }
                                                    workInProgress2.subtreeFlags = NoFlags;
                                                    resetChildFibers(workInProgress2, renderLanes2);
                                                    pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                                                    return workInProgress2.child;
                                                }
                                                row = row.sibling;
                                            }
                                        }
                                        if (renderState.tail !== null && now$1() > getRenderTargetTime()) {
                                            workInProgress2.flags |= DidCapture;
                                            didSuspendAlready = true;
                                            cutOffTailIfNeeded(renderState, false);
                                            workInProgress2.lanes = SomeRetryLane;
                                        }
                                    } else {
                                        cutOffTailIfNeeded(renderState, false);
                                    }
                                } else {
                                    if (!didSuspendAlready) {
                                        var _suspended = findFirstSuspended(renderedTail);
                                        if (_suspended !== null) {
                                            workInProgress2.flags |= DidCapture;
                                            didSuspendAlready = true;
                                            var _newThenables = _suspended.updateQueue;
                                            if (_newThenables !== null) {
                                                workInProgress2.updateQueue = _newThenables;
                                                workInProgress2.flags |= Update;
                                            }
                                            cutOffTailIfNeeded(renderState, true);
                                            if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                                                bubbleProperties(workInProgress2);
                                                return null;
                                            }
                                        } else if (// The time it took to render last row is greater than the remaining
                                        // time we have to render. So rendering one more row would likely
                                        // exceed it.
                                        now$1() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane) {
                                            workInProgress2.flags |= DidCapture;
                                            didSuspendAlready = true;
                                            cutOffTailIfNeeded(renderState, false);
                                            workInProgress2.lanes = SomeRetryLane;
                                        }
                                    }
                                    if (renderState.isBackwards) {
                                        renderedTail.sibling = workInProgress2.child;
                                        workInProgress2.child = renderedTail;
                                    } else {
                                        var previousSibling = renderState.last;
                                        if (previousSibling !== null) {
                                            previousSibling.sibling = renderedTail;
                                        } else {
                                            workInProgress2.child = renderedTail;
                                        }
                                        renderState.last = renderedTail;
                                    }
                                }
                                if (renderState.tail !== null) {
                                    var next = renderState.tail;
                                    renderState.rendering = next;
                                    renderState.tail = next.sibling;
                                    renderState.renderingStartTime = now$1();
                                    next.sibling = null;
                                    var suspenseContext = suspenseStackCursor.current;
                                    if (didSuspendAlready) {
                                        suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                                    } else {
                                        suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                                    }
                                    pushSuspenseContext(workInProgress2, suspenseContext);
                                    return next;
                                }
                                bubbleProperties(workInProgress2);
                                return null;
                            }
                        case ScopeComponent:
                            {
                                break;
                            }
                        case OffscreenComponent:
                        case LegacyHiddenComponent:
                            {
                                popRenderLanes(workInProgress2);
                                var _nextState = workInProgress2.memoizedState;
                                var nextIsHidden = _nextState !== null;
                                if (current2 !== null) {
                                    var _prevState2 = current2.memoizedState;
                                    var prevIsHidden = _prevState2 !== null;
                                    if (prevIsHidden !== nextIsHidden && // LegacyHidden doesn't do any hiding  it only pre-renders.
                                    !enableLegacyHidden) {
                                        workInProgress2.flags |= Visibility;
                                    }
                                }
                                if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
                                    bubbleProperties(workInProgress2);
                                } else {
                                    if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                                        bubbleProperties(workInProgress2);
                                        if (supportsMutation) {
                                            if (workInProgress2.subtreeFlags & (Placement | Update)) {
                                                workInProgress2.flags |= Visibility;
                                            }
                                        }
                                    }
                                }
                                return null;
                            }
                        case CacheComponent:
                            {
                                return null;
                            }
                        case TracingMarkerComponent:
                            {
                                return null;
                            }
                    }
                    throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
                }
                var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
                var didReceiveUpdate = false;
                var didWarnAboutBadClass;
                var didWarnAboutModulePatternComponent;
                var didWarnAboutContextTypeOnFunctionComponent;
                var didWarnAboutGetDerivedStateOnFunctionComponent;
                var didWarnAboutFunctionRefs;
                var didWarnAboutReassigningProps;
                var didWarnAboutRevealOrder;
                var didWarnAboutTailOptions;
                {
                    didWarnAboutBadClass = {};
                    didWarnAboutModulePatternComponent = {};
                    didWarnAboutContextTypeOnFunctionComponent = {};
                    didWarnAboutGetDerivedStateOnFunctionComponent = {};
                    didWarnAboutFunctionRefs = {};
                    didWarnAboutReassigningProps = false;
                    didWarnAboutRevealOrder = {};
                    didWarnAboutTailOptions = {};
                }
                function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
                    if (current2 === null) {
                        workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
                    } else {
                        workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
                    }
                }
                function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
                    workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
                    workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
                }
                function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
                    {
                        if (workInProgress2.type !== workInProgress2.elementType) {
                            var innerPropTypes = Component.propTypes;
                            if (innerPropTypes) {
                                checkPropTypes(innerPropTypes, nextProps, // Resolved props
                                "prop", getComponentNameFromType(Component));
                            }
                        }
                    }
                    var render2 = Component.render;
                    var ref = workInProgress2.ref;
                    var nextChildren;
                    var hasId;
                    prepareToReadContext(workInProgress2, renderLanes2);
                    {
                        markComponentRenderStarted(workInProgress2);
                    }
                    {
                        ReactCurrentOwner$1.current = workInProgress2;
                        setIsRendering(true);
                        nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
                        hasId = checkDidRenderIdHook();
                        if (workInProgress2.mode & StrictLegacyMode) {
                            setIsStrictModeForDevtools(true);
                            try {
                                nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
                                hasId = checkDidRenderIdHook();
                            } finally{
                                setIsStrictModeForDevtools(false);
                            }
                        }
                        setIsRendering(false);
                    }
                    {
                        markComponentRenderStopped();
                    }
                    if (current2 !== null && !didReceiveUpdate) {
                        bailoutHooks(current2, workInProgress2, renderLanes2);
                        return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                    }
                    if (getIsHydrating() && hasId) {
                        pushMaterializedTreeId(workInProgress2);
                    }
                    workInProgress2.flags |= PerformedWork;
                    reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
                    return workInProgress2.child;
                }
                function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
                    if (current2 === null) {
                        var type = Component.type;
                        if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
                        Component.defaultProps === void 0) {
                            var resolvedType = type;
                            {
                                resolvedType = resolveFunctionForHotReloading(type);
                            }
                            workInProgress2.tag = SimpleMemoComponent;
                            workInProgress2.type = resolvedType;
                            {
                                validateFunctionComponentInDev(workInProgress2, type);
                            }
                            return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);
                        }
                        {
                            var innerPropTypes = type.propTypes;
                            if (innerPropTypes) {
                                checkPropTypes(innerPropTypes, nextProps, // Resolved props
                                "prop", getComponentNameFromType(type));
                            }
                        }
                        var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
                        child.ref = workInProgress2.ref;
                        child.return = workInProgress2;
                        workInProgress2.child = child;
                        return child;
                    }
                    {
                        var _type = Component.type;
                        var _innerPropTypes = _type.propTypes;
                        if (_innerPropTypes) {
                            checkPropTypes(_innerPropTypes, nextProps, // Resolved props
                            "prop", getComponentNameFromType(_type));
                        }
                    }
                    var currentChild = current2.child;
                    var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
                    if (!hasScheduledUpdateOrContext) {
                        var prevProps = currentChild.memoizedProps;
                        var compare = Component.compare;
                        compare = compare !== null ? compare : shallowEqual;
                        if (compare(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
                            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                        }
                    }
                    workInProgress2.flags |= PerformedWork;
                    var newChild = createWorkInProgress(currentChild, nextProps);
                    newChild.ref = workInProgress2.ref;
                    newChild.return = workInProgress2;
                    workInProgress2.child = newChild;
                    return newChild;
                }
                function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
                    {
                        if (workInProgress2.type !== workInProgress2.elementType) {
                            var outerMemoType = workInProgress2.elementType;
                            if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                                var lazyComponent = outerMemoType;
                                var payload = lazyComponent._payload;
                                var init = lazyComponent._init;
                                try {
                                    outerMemoType = init(payload);
                                } catch (x) {
                                    outerMemoType = null;
                                }
                                var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                                if (outerPropTypes) {
                                    checkPropTypes(outerPropTypes, nextProps, // Resolved (SimpleMemoComponent has no defaultProps)
                                    "prop", getComponentNameFromType(outerMemoType));
                                }
                            }
                        }
                    }
                    if (current2 !== null) {
                        var prevProps = current2.memoizedProps;
                        if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && // Prevent bailout if the implementation changed due to hot reload.
                        workInProgress2.type === current2.type) {
                            didReceiveUpdate = false;
                            if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
                                workInProgress2.lanes = current2.lanes;
                                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                            } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                                didReceiveUpdate = true;
                            }
                        }
                    }
                    return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
                }
                function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
                    var nextProps = workInProgress2.pendingProps;
                    var nextChildren = nextProps.children;
                    var prevState = current2 !== null ? current2.memoizedState : null;
                    if (nextProps.mode === "hidden" || enableLegacyHidden) {
                        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                            var nextState = {
                                baseLanes: NoLanes,
                                cachePool: null
                            };
                            workInProgress2.memoizedState = nextState;
                            pushRenderLanes(workInProgress2, renderLanes2);
                        } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
                            var spawnedCachePool = null;
                            var nextBaseLanes;
                            if (prevState !== null) {
                                var prevBaseLanes = prevState.baseLanes;
                                nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
                            } else {
                                nextBaseLanes = renderLanes2;
                            }
                            workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
                            var _nextState = {
                                baseLanes: nextBaseLanes,
                                cachePool: spawnedCachePool
                            };
                            workInProgress2.memoizedState = _nextState;
                            workInProgress2.updateQueue = null;
                            pushRenderLanes(workInProgress2, nextBaseLanes);
                            return null;
                        } else {
                            var _nextState2 = {
                                baseLanes: NoLanes,
                                cachePool: null
                            };
                            workInProgress2.memoizedState = _nextState2;
                            var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
                            pushRenderLanes(workInProgress2, subtreeRenderLanes2);
                        }
                    } else {
                        var _subtreeRenderLanes;
                        if (prevState !== null) {
                            _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
                            workInProgress2.memoizedState = null;
                        } else {
                            _subtreeRenderLanes = renderLanes2;
                        }
                        pushRenderLanes(workInProgress2, _subtreeRenderLanes);
                    }
                    {
                        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
                        return workInProgress2.child;
                    }
                }
                function updateFragment(current2, workInProgress2, renderLanes2) {
                    var nextChildren = workInProgress2.pendingProps;
                    reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
                    return workInProgress2.child;
                }
                function updateMode(current2, workInProgress2, renderLanes2) {
                    var nextChildren = workInProgress2.pendingProps.children;
                    reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
                    return workInProgress2.child;
                }
                function updateProfiler(current2, workInProgress2, renderLanes2) {
                    {
                        workInProgress2.flags |= Update;
                        {
                            var stateNode = workInProgress2.stateNode;
                            stateNode.effectDuration = 0;
                            stateNode.passiveEffectDuration = 0;
                        }
                    }
                    var nextProps = workInProgress2.pendingProps;
                    var nextChildren = nextProps.children;
                    reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
                    return workInProgress2.child;
                }
                function markRef$1(current2, workInProgress2) {
                    var ref = workInProgress2.ref;
                    if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {
                        workInProgress2.flags |= Ref;
                        {
                            workInProgress2.flags |= RefStatic;
                        }
                    }
                }
                function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
                    {
                        if (workInProgress2.type !== workInProgress2.elementType) {
                            var innerPropTypes = Component.propTypes;
                            if (innerPropTypes) {
                                checkPropTypes(innerPropTypes, nextProps, // Resolved props
                                "prop", getComponentNameFromType(Component));
                            }
                        }
                    }
                    var context;
                    {
                        var unmaskedContext = getUnmaskedContext(workInProgress2, Component, true);
                        context = getMaskedContext(workInProgress2, unmaskedContext);
                    }
                    var nextChildren;
                    var hasId;
                    prepareToReadContext(workInProgress2, renderLanes2);
                    {
                        markComponentRenderStarted(workInProgress2);
                    }
                    {
                        ReactCurrentOwner$1.current = workInProgress2;
                        setIsRendering(true);
                        nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
                        hasId = checkDidRenderIdHook();
                        if (workInProgress2.mode & StrictLegacyMode) {
                            setIsStrictModeForDevtools(true);
                            try {
                                nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
                                hasId = checkDidRenderIdHook();
                            } finally{
                                setIsStrictModeForDevtools(false);
                            }
                        }
                        setIsRendering(false);
                    }
                    {
                        markComponentRenderStopped();
                    }
                    if (current2 !== null && !didReceiveUpdate) {
                        bailoutHooks(current2, workInProgress2, renderLanes2);
                        return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                    }
                    if (getIsHydrating() && hasId) {
                        pushMaterializedTreeId(workInProgress2);
                    }
                    workInProgress2.flags |= PerformedWork;
                    reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
                    return workInProgress2.child;
                }
                function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
                    {
                        switch(shouldError(workInProgress2)){
                            case false:
                                {
                                    var _instance = workInProgress2.stateNode;
                                    var ctor = workInProgress2.type;
                                    var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);
                                    var state = tempInstance.state;
                                    _instance.updater.enqueueSetState(_instance, state, null);
                                    break;
                                }
                            case true:
                                {
                                    workInProgress2.flags |= DidCapture;
                                    workInProgress2.flags |= ShouldCapture;
                                    var error$1 = new Error("Simulated error coming from DevTools");
                                    var lane = pickArbitraryLane(renderLanes2);
                                    workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                                    var update = createClassErrorUpdate(workInProgress2, createCapturedValue(error$1, workInProgress2), lane);
                                    enqueueCapturedUpdate(workInProgress2, update);
                                    break;
                                }
                        }
                        if (workInProgress2.type !== workInProgress2.elementType) {
                            var innerPropTypes = Component.propTypes;
                            if (innerPropTypes) {
                                checkPropTypes(innerPropTypes, nextProps, // Resolved props
                                "prop", getComponentNameFromType(Component));
                            }
                        }
                    }
                    var hasContext;
                    if (isContextProvider(Component)) {
                        hasContext = true;
                        pushContextProvider(workInProgress2);
                    } else {
                        hasContext = false;
                    }
                    prepareToReadContext(workInProgress2, renderLanes2);
                    var instance = workInProgress2.stateNode;
                    var shouldUpdate;
                    if (instance === null) {
                        if (current2 !== null) {
                            current2.alternate = null;
                            workInProgress2.alternate = null;
                            workInProgress2.flags |= Placement;
                        }
                        constructClassInstance(workInProgress2, Component, nextProps);
                        mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
                        shouldUpdate = true;
                    } else if (current2 === null) {
                        shouldUpdate = resumeMountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
                    } else {
                        shouldUpdate = updateClassInstance(current2, workInProgress2, Component, nextProps, renderLanes2);
                    }
                    var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2);
                    {
                        var inst = workInProgress2.stateNode;
                        if (shouldUpdate && inst.props !== nextProps) {
                            if (!didWarnAboutReassigningProps) {
                                error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component");
                            }
                            didWarnAboutReassigningProps = true;
                        }
                    }
                    return nextUnitOfWork;
                }
                function finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2) {
                    markRef$1(current2, workInProgress2);
                    var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
                    if (!shouldUpdate && !didCaptureError) {
                        if (hasContext) {
                            invalidateContextProvider(workInProgress2, Component, false);
                        }
                        return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                    }
                    var instance = workInProgress2.stateNode;
                    ReactCurrentOwner$1.current = workInProgress2;
                    var nextChildren;
                    if (didCaptureError && typeof Component.getDerivedStateFromError !== "function") {
                        nextChildren = null;
                        {
                            stopProfilerTimerIfRunning();
                        }
                    } else {
                        {
                            markComponentRenderStarted(workInProgress2);
                        }
                        {
                            setIsRendering(true);
                            nextChildren = instance.render();
                            if (workInProgress2.mode & StrictLegacyMode) {
                                setIsStrictModeForDevtools(true);
                                try {
                                    instance.render();
                                } finally{
                                    setIsStrictModeForDevtools(false);
                                }
                            }
                            setIsRendering(false);
                        }
                        {
                            markComponentRenderStopped();
                        }
                    }
                    workInProgress2.flags |= PerformedWork;
                    if (current2 !== null && didCaptureError) {
                        forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
                    } else {
                        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
                    }
                    workInProgress2.memoizedState = instance.state;
                    if (hasContext) {
                        invalidateContextProvider(workInProgress2, Component, true);
                    }
                    return workInProgress2.child;
                }
                function pushHostRootContext(workInProgress2) {
                    var root = workInProgress2.stateNode;
                    if (root.pendingContext) {
                        pushTopLevelContextObject(workInProgress2, root.pendingContext, root.pendingContext !== root.context);
                    } else if (root.context) {
                        pushTopLevelContextObject(workInProgress2, root.context, false);
                    }
                    pushHostContainer(workInProgress2, root.containerInfo);
                }
                function updateHostRoot(current2, workInProgress2, renderLanes2) {
                    pushHostRootContext(workInProgress2);
                    if (current2 === null) {
                        throw new Error("Should have a current fiber. This is a bug in React.");
                    }
                    var nextProps = workInProgress2.pendingProps;
                    var prevState = workInProgress2.memoizedState;
                    var prevChildren = prevState.element;
                    cloneUpdateQueue(current2, workInProgress2);
                    processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
                    var nextState = workInProgress2.memoizedState;
                    var root = workInProgress2.stateNode;
                    var nextChildren = nextState.element;
                    if (supportsHydration && prevState.isDehydrated) {
                        var overrideState = {
                            element: nextChildren,
                            isDehydrated: false,
                            cache: nextState.cache,
                            transitions: nextState.transitions
                        };
                        var updateQueue = workInProgress2.updateQueue;
                        updateQueue.baseState = overrideState;
                        workInProgress2.memoizedState = overrideState;
                        if (workInProgress2.flags & ForceClientRender) {
                            var recoverableError = new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering.");
                            return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);
                        } else if (nextChildren !== prevChildren) {
                            var _recoverableError = new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.");
                            return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);
                        } else {
                            enterHydrationState(workInProgress2);
                            var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
                            workInProgress2.child = child;
                            var node = child;
                            while(node){
                                node.flags = node.flags & ~Placement | Hydrating;
                                node = node.sibling;
                            }
                        }
                    } else {
                        resetHydrationState();
                        if (nextChildren === prevChildren) {
                            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                        }
                        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
                    }
                    return workInProgress2.child;
                }
                function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {
                    resetHydrationState();
                    queueHydrationError(recoverableError);
                    workInProgress2.flags |= ForceClientRender;
                    reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
                    return workInProgress2.child;
                }
                function updateHostComponent$1(current2, workInProgress2, renderLanes2) {
                    pushHostContext(workInProgress2);
                    if (current2 === null) {
                        tryToClaimNextHydratableInstance(workInProgress2);
                    }
                    var type = workInProgress2.type;
                    var nextProps = workInProgress2.pendingProps;
                    var prevProps = current2 !== null ? current2.memoizedProps : null;
                    var nextChildren = nextProps.children;
                    var isDirectTextChild = shouldSetTextContent(type, nextProps);
                    if (isDirectTextChild) {
                        nextChildren = null;
                    } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
                        workInProgress2.flags |= ContentReset;
                    }
                    markRef$1(current2, workInProgress2);
                    reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
                    return workInProgress2.child;
                }
                function updateHostText$1(current2, workInProgress2) {
                    if (current2 === null) {
                        tryToClaimNextHydratableInstance(workInProgress2);
                    }
                    return null;
                }
                function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
                    if (_current !== null) {
                        _current.alternate = null;
                        workInProgress2.alternate = null;
                        workInProgress2.flags |= Placement;
                    }
                    var props = workInProgress2.pendingProps;
                    var lazyComponent = elementType;
                    var payload = lazyComponent._payload;
                    var init = lazyComponent._init;
                    var Component = init(payload);
                    workInProgress2.type = Component;
                    var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component);
                    var resolvedProps = resolveDefaultProps(Component, props);
                    var child;
                    switch(resolvedTag){
                        case FunctionComponent:
                            {
                                {
                                    validateFunctionComponentInDev(workInProgress2, Component);
                                    workInProgress2.type = Component = resolveFunctionForHotReloading(Component);
                                }
                                child = updateFunctionComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
                                return child;
                            }
                        case ClassComponent:
                            {
                                {
                                    workInProgress2.type = Component = resolveClassForHotReloading(Component);
                                }
                                child = updateClassComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
                                return child;
                            }
                        case ForwardRef:
                            {
                                {
                                    workInProgress2.type = Component = resolveForwardRefForHotReloading(Component);
                                }
                                child = updateForwardRef(null, workInProgress2, Component, resolvedProps, renderLanes2);
                                return child;
                            }
                        case MemoComponent:
                            {
                                {
                                    if (workInProgress2.type !== workInProgress2.elementType) {
                                        var outerPropTypes = Component.propTypes;
                                        if (outerPropTypes) {
                                            checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only
                                            "prop", getComponentNameFromType(Component));
                                        }
                                    }
                                }
                                child = updateMemoComponent(null, workInProgress2, Component, resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too
                                renderLanes2);
                                return child;
                            }
                    }
                    var hint = "";
                    {
                        if (Component !== null && typeof Component === "object" && Component.$$typeof === REACT_LAZY_TYPE) {
                            hint = " Did you wrap a component in React.lazy() more than once?";
                        }
                    }
                    throw new Error("Element type is invalid. Received a promise that resolves to: " + Component + ". " + ("Lazy element type must resolve to a class or function." + hint));
                }
                function mountIncompleteClassComponent(_current, workInProgress2, Component, nextProps, renderLanes2) {
                    if (_current !== null) {
                        _current.alternate = null;
                        workInProgress2.alternate = null;
                        workInProgress2.flags |= Placement;
                    }
                    workInProgress2.tag = ClassComponent;
                    var hasContext;
                    if (isContextProvider(Component)) {
                        hasContext = true;
                        pushContextProvider(workInProgress2);
                    } else {
                        hasContext = false;
                    }
                    prepareToReadContext(workInProgress2, renderLanes2);
                    constructClassInstance(workInProgress2, Component, nextProps);
                    mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
                    return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
                }
                function mountIndeterminateComponent(_current, workInProgress2, Component, renderLanes2) {
                    if (_current !== null) {
                        _current.alternate = null;
                        workInProgress2.alternate = null;
                        workInProgress2.flags |= Placement;
                    }
                    var props = workInProgress2.pendingProps;
                    var context;
                    {
                        var unmaskedContext = getUnmaskedContext(workInProgress2, Component, false);
                        context = getMaskedContext(workInProgress2, unmaskedContext);
                    }
                    prepareToReadContext(workInProgress2, renderLanes2);
                    var value;
                    var hasId;
                    {
                        markComponentRenderStarted(workInProgress2);
                    }
                    {
                        if (Component.prototype && typeof Component.prototype.render === "function") {
                            var componentName = getComponentNameFromType(Component) || "Unknown";
                            if (!didWarnAboutBadClass[componentName]) {
                                error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                                didWarnAboutBadClass[componentName] = true;
                            }
                        }
                        if (workInProgress2.mode & StrictLegacyMode) {
                            ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
                        }
                        setIsRendering(true);
                        ReactCurrentOwner$1.current = workInProgress2;
                        value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
                        hasId = checkDidRenderIdHook();
                        setIsRendering(false);
                    }
                    {
                        markComponentRenderStopped();
                    }
                    workInProgress2.flags |= PerformedWork;
                    {
                        if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
                            var _componentName = getComponentNameFromType(Component) || "Unknown";
                            if (!didWarnAboutModulePatternComponent[_componentName]) {
                                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                                didWarnAboutModulePatternComponent[_componentName] = true;
                            }
                        }
                    }
                    if (// Run these checks in production only if the flag is off.
                    // Eventually we'll delete this branch altogether.
                    typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
                        {
                            var _componentName2 = getComponentNameFromType(Component) || "Unknown";
                            if (!didWarnAboutModulePatternComponent[_componentName2]) {
                                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                                didWarnAboutModulePatternComponent[_componentName2] = true;
                            }
                        }
                        workInProgress2.tag = ClassComponent;
                        workInProgress2.memoizedState = null;
                        workInProgress2.updateQueue = null;
                        var hasContext = false;
                        if (isContextProvider(Component)) {
                            hasContext = true;
                            pushContextProvider(workInProgress2);
                        } else {
                            hasContext = false;
                        }
                        workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
                        initializeUpdateQueue(workInProgress2);
                        adoptClassInstance(workInProgress2, value);
                        mountClassInstance(workInProgress2, Component, props, renderLanes2);
                        return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
                    } else {
                        workInProgress2.tag = FunctionComponent;
                        {
                            if (workInProgress2.mode & StrictLegacyMode) {
                                setIsStrictModeForDevtools(true);
                                try {
                                    value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
                                    hasId = checkDidRenderIdHook();
                                } finally{
                                    setIsStrictModeForDevtools(false);
                                }
                            }
                        }
                        if (getIsHydrating() && hasId) {
                            pushMaterializedTreeId(workInProgress2);
                        }
                        reconcileChildren(null, workInProgress2, value, renderLanes2);
                        {
                            validateFunctionComponentInDev(workInProgress2, Component);
                        }
                        return workInProgress2.child;
                    }
                }
                function validateFunctionComponentInDev(workInProgress2, Component) {
                    {
                        if (Component) {
                            if (Component.childContextTypes) {
                                error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
                            }
                        }
                        if (workInProgress2.ref !== null) {
                            var info = "";
                            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
                            if (ownerName) {
                                info += "\n\nCheck the render method of `" + ownerName + "`.";
                            }
                            var warningKey = ownerName || "";
                            var debugSource = workInProgress2._debugSource;
                            if (debugSource) {
                                warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
                            }
                            if (!didWarnAboutFunctionRefs[warningKey]) {
                                didWarnAboutFunctionRefs[warningKey] = true;
                                error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
                            }
                        }
                        if (typeof Component.getDerivedStateFromProps === "function") {
                            var _componentName3 = getComponentNameFromType(Component) || "Unknown";
                            if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                                error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
                            }
                        }
                        if (typeof Component.contextType === "object" && Component.contextType !== null) {
                            var _componentName4 = getComponentNameFromType(Component) || "Unknown";
                            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                                error("%s: Function components do not support contextType.", _componentName4);
                                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
                            }
                        }
                    }
                }
                var SUSPENDED_MARKER = {
                    dehydrated: null,
                    treeContext: null,
                    retryLane: NoLane
                };
                function mountSuspenseOffscreenState(renderLanes2) {
                    return {
                        baseLanes: renderLanes2,
                        cachePool: getSuspendedCache()
                    };
                }
                function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
                    var cachePool = null;
                    return {
                        baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
                        cachePool
                    };
                }
                function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
                    if (current2 !== null) {
                        var suspenseState = current2.memoizedState;
                        if (suspenseState === null) {
                            return false;
                        }
                    }
                    return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
                }
                function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
                    return removeLanes(current2.childLanes, renderLanes2);
                }
                function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
                    var nextProps = workInProgress2.pendingProps;
                    {
                        if (shouldSuspend(workInProgress2)) {
                            workInProgress2.flags |= DidCapture;
                        }
                    }
                    var suspenseContext = suspenseStackCursor.current;
                    var showFallback = false;
                    var didSuspend2 = (workInProgress2.flags & DidCapture) !== NoFlags;
                    if (didSuspend2 || shouldRemainOnFallback(suspenseContext, current2)) {
                        showFallback = true;
                        workInProgress2.flags &= ~DidCapture;
                    } else {
                        if (current2 === null || current2.memoizedState !== null) {
                            {
                                suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
                            }
                        }
                    }
                    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                    pushSuspenseContext(workInProgress2, suspenseContext);
                    if (current2 === null) {
                        tryToClaimNextHydratableInstance(workInProgress2);
                        {
                            var suspenseState = workInProgress2.memoizedState;
                            if (suspenseState !== null) {
                                var dehydrated = suspenseState.dehydrated;
                                if (dehydrated !== null) {
                                    return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
                                }
                            }
                        }
                        var nextPrimaryChildren = nextProps.children;
                        var nextFallbackChildren = nextProps.fallback;
                        if (showFallback) {
                            var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                            var primaryChildFragment = workInProgress2.child;
                            primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                            workInProgress2.memoizedState = SUSPENDED_MARKER;
                            return fallbackFragment;
                        } else {
                            return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
                        }
                    } else {
                        var prevState = current2.memoizedState;
                        if (prevState !== null) {
                            {
                                var _dehydrated = prevState.dehydrated;
                                if (_dehydrated !== null) {
                                    if (!didSuspend2) {
                                        return updateDehydratedSuspenseComponent(current2, workInProgress2, _dehydrated, prevState, renderLanes2);
                                    } else if (workInProgress2.flags & ForceClientRender) {
                                        workInProgress2.flags &= ~ForceClientRender;
                                        return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                                    } else if (workInProgress2.memoizedState !== null) {
                                        workInProgress2.child = current2.child;
                                        workInProgress2.flags |= DidCapture;
                                        return null;
                                    } else {
                                        var _nextPrimaryChildren = nextProps.children;
                                        var _nextFallbackChildren = nextProps.fallback;
                                        var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);
                                        var _primaryChildFragment2 = workInProgress2.child;
                                        _primaryChildFragment2.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                                        workInProgress2.memoizedState = SUSPENDED_MARKER;
                                        return fallbackChildFragment;
                                    }
                                }
                            }
                            if (showFallback) {
                                var _nextFallbackChildren2 = nextProps.fallback;
                                var _nextPrimaryChildren2 = nextProps.children;
                                var _fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren2, _nextFallbackChildren2, renderLanes2);
                                var _primaryChildFragment3 = workInProgress2.child;
                                var prevOffscreenState = current2.child.memoizedState;
                                _primaryChildFragment3.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
                                _primaryChildFragment3.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
                                workInProgress2.memoizedState = SUSPENDED_MARKER;
                                return _fallbackChildFragment;
                            } else {
                                var _nextPrimaryChildren3 = nextProps.children;
                                var _primaryChildFragment4 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren3, renderLanes2);
                                workInProgress2.memoizedState = null;
                                return _primaryChildFragment4;
                            }
                        } else {
                            if (showFallback) {
                                var _nextFallbackChildren3 = nextProps.fallback;
                                var _nextPrimaryChildren4 = nextProps.children;
                                var _fallbackChildFragment2 = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren4, _nextFallbackChildren3, renderLanes2);
                                var _primaryChildFragment5 = workInProgress2.child;
                                var _prevOffscreenState = current2.child.memoizedState;
                                _primaryChildFragment5.memoizedState = _prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(_prevOffscreenState, renderLanes2);
                                _primaryChildFragment5.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
                                workInProgress2.memoizedState = SUSPENDED_MARKER;
                                return _fallbackChildFragment2;
                            } else {
                                var _nextPrimaryChildren5 = nextProps.children;
                                var _primaryChildFragment6 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren5, renderLanes2);
                                workInProgress2.memoizedState = null;
                                return _primaryChildFragment6;
                            }
                        }
                    }
                }
                function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
                    var mode = workInProgress2.mode;
                    var primaryChildProps = {
                        mode: "visible",
                        children: primaryChildren
                    };
                    var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
                    primaryChildFragment.return = workInProgress2;
                    workInProgress2.child = primaryChildFragment;
                    return primaryChildFragment;
                }
                function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
                    var mode = workInProgress2.mode;
                    var progressedPrimaryFragment = workInProgress2.child;
                    var primaryChildProps = {
                        mode: "hidden",
                        children: primaryChildren
                    };
                    var primaryChildFragment;
                    var fallbackChildFragment;
                    if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
                        primaryChildFragment = progressedPrimaryFragment;
                        primaryChildFragment.childLanes = NoLanes;
                        primaryChildFragment.pendingProps = primaryChildProps;
                        if (workInProgress2.mode & ProfileMode) {
                            primaryChildFragment.actualDuration = 0;
                            primaryChildFragment.actualStartTime = -1;
                            primaryChildFragment.selfBaseDuration = 0;
                            primaryChildFragment.treeBaseDuration = 0;
                        }
                        fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
                    } else {
                        primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
                        fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
                    }
                    primaryChildFragment.return = workInProgress2;
                    fallbackChildFragment.return = workInProgress2;
                    primaryChildFragment.sibling = fallbackChildFragment;
                    workInProgress2.child = primaryChildFragment;
                    return fallbackChildFragment;
                }
                function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
                    return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
                }
                function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
                    return createWorkInProgress(current2, offscreenProps);
                }
                function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
                    var currentPrimaryChildFragment = current2.child;
                    var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
                    var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
                        mode: "visible",
                        children: primaryChildren
                    });
                    if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                        primaryChildFragment.lanes = renderLanes2;
                    }
                    primaryChildFragment.return = workInProgress2;
                    primaryChildFragment.sibling = null;
                    if (currentFallbackChildFragment !== null) {
                        var deletions = workInProgress2.deletions;
                        if (deletions === null) {
                            workInProgress2.deletions = [
                                currentFallbackChildFragment
                            ];
                            workInProgress2.flags |= ChildDeletion;
                        } else {
                            deletions.push(currentFallbackChildFragment);
                        }
                    }
                    workInProgress2.child = primaryChildFragment;
                    return primaryChildFragment;
                }
                function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
                    var mode = workInProgress2.mode;
                    var currentPrimaryChildFragment = current2.child;
                    var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
                    var primaryChildProps = {
                        mode: "hidden",
                        children: primaryChildren
                    };
                    var primaryChildFragment;
                    if (// In legacy mode, we commit the primary tree as if it successfully
                    // completed, even though it's in an inconsistent state.
                    (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
                    // already cloned. In legacy mode, the only case where this isn't true is
                    // when DevTools forces us to display a fallback; we skip the first render
                    // pass entirely and go straight to rendering the fallback. (In Concurrent
                    // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
                    // only codepath.)
                    workInProgress2.child !== currentPrimaryChildFragment) {
                        var progressedPrimaryFragment = workInProgress2.child;
                        primaryChildFragment = progressedPrimaryFragment;
                        primaryChildFragment.childLanes = NoLanes;
                        primaryChildFragment.pendingProps = primaryChildProps;
                        if (workInProgress2.mode & ProfileMode) {
                            primaryChildFragment.actualDuration = 0;
                            primaryChildFragment.actualStartTime = -1;
                            primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
                            primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
                        }
                        workInProgress2.deletions = null;
                    } else {
                        primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
                        primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
                    }
                    var fallbackChildFragment;
                    if (currentFallbackChildFragment !== null) {
                        fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
                    } else {
                        fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
                        fallbackChildFragment.flags |= Placement;
                    }
                    fallbackChildFragment.return = workInProgress2;
                    primaryChildFragment.return = workInProgress2;
                    primaryChildFragment.sibling = fallbackChildFragment;
                    workInProgress2.child = primaryChildFragment;
                    return fallbackChildFragment;
                }
                function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {
                    if (recoverableError !== null) {
                        queueHydrationError(recoverableError);
                    }
                    reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
                    var nextProps = workInProgress2.pendingProps;
                    var primaryChildren = nextProps.children;
                    var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
                    primaryChildFragment.flags |= Placement;
                    workInProgress2.memoizedState = null;
                    return primaryChildFragment;
                }
                function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
                    var fiberMode = workInProgress2.mode;
                    var primaryChildProps = {
                        mode: "visible",
                        children: primaryChildren
                    };
                    var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
                    var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
                    fallbackChildFragment.flags |= Placement;
                    primaryChildFragment.return = workInProgress2;
                    fallbackChildFragment.return = workInProgress2;
                    primaryChildFragment.sibling = fallbackChildFragment;
                    workInProgress2.child = primaryChildFragment;
                    if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                        reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
                    }
                    return fallbackChildFragment;
                }
                function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
                    if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                        {
                            error("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.");
                        }
                        workInProgress2.lanes = laneToLanes(SyncLane);
                    } else if (isSuspenseInstanceFallback(suspenseInstance)) {
                        workInProgress2.lanes = laneToLanes(DefaultHydrationLane);
                    } else {
                        workInProgress2.lanes = laneToLanes(OffscreenLane);
                    }
                    return null;
                }
                function updateDehydratedSuspenseComponent(current2, workInProgress2, suspenseInstance, suspenseState, renderLanes2) {
                    warnIfHydrating();
                    if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                        return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, // TODO: When we delete legacy mode, we should make this error argument
                        // required  every concurrent mode path that causes hydration to
                        // de-opt to client rendering should have an error message.
                        null);
                    }
                    if (isSuspenseInstanceFallback(suspenseInstance)) {
                        return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, // TODO: The server should serialize the error message so we can log it
                        // here on the client. Or, in production, a hash/id that corresponds to
                        // the error.
                        new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."));
                    }
                    var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
                    if (didReceiveUpdate || hasContextChanged2) {
                        var root = getWorkInProgressRoot();
                        if (root !== null) {
                            var attemptHydrationAtLane = getBumpedLaneForHydration(root, renderLanes2);
                            if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                                suspenseState.retryLane = attemptHydrationAtLane;
                                var eventTime = NoTimestamp;
                                scheduleUpdateOnFiber(current2, attemptHydrationAtLane, eventTime);
                            }
                        }
                        renderDidSuspendDelayIfPossible();
                        return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
                    } else if (isSuspenseInstancePending(suspenseInstance)) {
                        workInProgress2.flags |= DidCapture;
                        workInProgress2.child = current2.child;
                        var retry = retryDehydratedSuspenseBoundary.bind(null, current2);
                        registerSuspenseInstanceRetry(suspenseInstance, retry);
                        return null;
                    } else {
                        reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
                        var nextProps = workInProgress2.pendingProps;
                        var primaryChildren = nextProps.children;
                        var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
                        primaryChildFragment.flags |= Hydrating;
                        return primaryChildFragment;
                    }
                }
                function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
                    fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                    var alternate = fiber.alternate;
                    if (alternate !== null) {
                        alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                    }
                    scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
                }
                function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
                    var node = firstChild;
                    while(node !== null){
                        if (node.tag === SuspenseComponent2) {
                            var state = node.memoizedState;
                            if (state !== null) {
                                scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
                            }
                        } else if (node.tag === SuspenseListComponent) {
                            scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
                        } else if (node.child !== null) {
                            node.child.return = node;
                            node = node.child;
                            continue;
                        }
                        if (node === workInProgress2) {
                            return;
                        }
                        while(node.sibling === null){
                            if (node.return === null || node.return === workInProgress2) {
                                return;
                            }
                            node = node.return;
                        }
                        node.sibling.return = node.return;
                        node = node.sibling;
                    }
                }
                function findLastContentRow(firstChild) {
                    var row = firstChild;
                    var lastContentRow = null;
                    while(row !== null){
                        var currentRow = row.alternate;
                        if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                            lastContentRow = row;
                        }
                        row = row.sibling;
                    }
                    return lastContentRow;
                }
                function validateRevealOrder(revealOrder) {
                    {
                        if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
                            didWarnAboutRevealOrder[revealOrder] = true;
                            if (typeof revealOrder === "string") {
                                switch(revealOrder.toLowerCase()){
                                    case "together":
                                    case "forwards":
                                    case "backwards":
                                        {
                                            error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                                            break;
                                        }
                                    case "forward":
                                    case "backward":
                                        {
                                            error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                                            break;
                                        }
                                    default:
                                        error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                                        break;
                                }
                            } else {
                                error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                            }
                        }
                    }
                }
                function validateTailOptions(tailMode, revealOrder) {
                    {
                        if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
                            if (tailMode !== "collapsed" && tailMode !== "hidden") {
                                didWarnAboutTailOptions[tailMode] = true;
                                error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
                            } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                                didWarnAboutTailOptions[tailMode] = true;
                                error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
                            }
                        }
                    }
                }
                function validateSuspenseListNestedChild(childSlot, index2) {
                    {
                        var isAnArray = isArray(childSlot);
                        var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === "function";
                        if (isAnArray || isIterable) {
                            var type = isAnArray ? "array" : "iterable";
                            error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index2, type);
                            return false;
                        }
                    }
                    return true;
                }
                function validateSuspenseListChildren(children2, revealOrder) {
                    {
                        if ((revealOrder === "forwards" || revealOrder === "backwards") && children2 !== void 0 && children2 !== null && children2 !== false) {
                            if (isArray(children2)) {
                                for(var i = 0; i < children2.length; i++){
                                    if (!validateSuspenseListNestedChild(children2[i], i)) {
                                        return;
                                    }
                                }
                            } else {
                                var iteratorFn = getIteratorFn(children2);
                                if (typeof iteratorFn === "function") {
                                    var childrenIterator = iteratorFn.call(children2);
                                    if (childrenIterator) {
                                        var step = childrenIterator.next();
                                        var _i = 0;
                                        for(; !step.done; step = childrenIterator.next()){
                                            if (!validateSuspenseListNestedChild(step.value, _i)) {
                                                return;
                                            }
                                            _i++;
                                        }
                                    }
                                } else {
                                    error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                                }
                            }
                        }
                    }
                }
                function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
                    var renderState = workInProgress2.memoizedState;
                    if (renderState === null) {
                        workInProgress2.memoizedState = {
                            isBackwards,
                            rendering: null,
                            renderingStartTime: 0,
                            last: lastContentRow,
                            tail,
                            tailMode
                        };
                    } else {
                        renderState.isBackwards = isBackwards;
                        renderState.rendering = null;
                        renderState.renderingStartTime = 0;
                        renderState.last = lastContentRow;
                        renderState.tail = tail;
                        renderState.tailMode = tailMode;
                    }
                }
                function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
                    var nextProps = workInProgress2.pendingProps;
                    var revealOrder = nextProps.revealOrder;
                    var tailMode = nextProps.tail;
                    var newChildren = nextProps.children;
                    validateRevealOrder(revealOrder);
                    validateTailOptions(tailMode, revealOrder);
                    validateSuspenseListChildren(newChildren, revealOrder);
                    reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
                    var suspenseContext = suspenseStackCursor.current;
                    var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
                    if (shouldForceFallback) {
                        suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                        workInProgress2.flags |= DidCapture;
                    } else {
                        var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
                        if (didSuspendBefore) {
                            propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
                        }
                        suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                    }
                    pushSuspenseContext(workInProgress2, suspenseContext);
                    if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                        workInProgress2.memoizedState = null;
                    } else {
                        switch(revealOrder){
                            case "forwards":
                                {
                                    var lastContentRow = findLastContentRow(workInProgress2.child);
                                    var tail;
                                    if (lastContentRow === null) {
                                        tail = workInProgress2.child;
                                        workInProgress2.child = null;
                                    } else {
                                        tail = lastContentRow.sibling;
                                        lastContentRow.sibling = null;
                                    }
                                    initSuspenseListRenderState(workInProgress2, false, // isBackwards
                                    tail, lastContentRow, tailMode);
                                    break;
                                }
                            case "backwards":
                                {
                                    var _tail = null;
                                    var row = workInProgress2.child;
                                    workInProgress2.child = null;
                                    while(row !== null){
                                        var currentRow = row.alternate;
                                        if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                                            workInProgress2.child = row;
                                            break;
                                        }
                                        var nextRow = row.sibling;
                                        row.sibling = _tail;
                                        _tail = row;
                                        row = nextRow;
                                    }
                                    initSuspenseListRenderState(workInProgress2, true, // isBackwards
                                    _tail, null, // last
                                    tailMode);
                                    break;
                                }
                            case "together":
                                {
                                    initSuspenseListRenderState(workInProgress2, false, // isBackwards
                                    null, // tail
                                    null, // last
                                    void 0);
                                    break;
                                }
                            default:
                                {
                                    workInProgress2.memoizedState = null;
                                }
                        }
                    }
                    return workInProgress2.child;
                }
                function updatePortalComponent(current2, workInProgress2, renderLanes2) {
                    pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
                    var nextChildren = workInProgress2.pendingProps;
                    if (current2 === null) {
                        workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
                    } else {
                        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
                    }
                    return workInProgress2.child;
                }
                var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
                function updateContextProvider(current2, workInProgress2, renderLanes2) {
                    var providerType = workInProgress2.type;
                    var context = providerType._context;
                    var newProps = workInProgress2.pendingProps;
                    var oldProps = workInProgress2.memoizedProps;
                    var newValue = newProps.value;
                    {
                        if (!("value" in newProps)) {
                            if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                                hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                                error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
                            }
                        }
                        var providerPropTypes = workInProgress2.type.propTypes;
                        if (providerPropTypes) {
                            checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
                        }
                    }
                    pushProvider(workInProgress2, context, newValue);
                    {
                        if (oldProps !== null) {
                            var oldValue = oldProps.value;
                            if (objectIs(oldValue, newValue)) {
                                if (oldProps.children === newProps.children && !hasContextChanged()) {
                                    return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                                }
                            } else {
                                propagateContextChange(workInProgress2, context, renderLanes2);
                            }
                        }
                    }
                    var newChildren = newProps.children;
                    reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
                    return workInProgress2.child;
                }
                var hasWarnedAboutUsingContextAsConsumer = false;
                function updateContextConsumer(current2, workInProgress2, renderLanes2) {
                    var context = workInProgress2.type;
                    {
                        if (context._context === void 0) {
                            if (context !== context.Consumer) {
                                if (!hasWarnedAboutUsingContextAsConsumer) {
                                    hasWarnedAboutUsingContextAsConsumer = true;
                                    error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                                }
                            }
                        } else {
                            context = context._context;
                        }
                    }
                    var newProps = workInProgress2.pendingProps;
                    var render2 = newProps.children;
                    {
                        if (typeof render2 !== "function") {
                            error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
                        }
                    }
                    prepareToReadContext(workInProgress2, renderLanes2);
                    var newValue = readContext(context);
                    {
                        markComponentRenderStarted(workInProgress2);
                    }
                    var newChildren;
                    {
                        ReactCurrentOwner$1.current = workInProgress2;
                        setIsRendering(true);
                        newChildren = render2(newValue);
                        setIsRendering(false);
                    }
                    {
                        markComponentRenderStopped();
                    }
                    workInProgress2.flags |= PerformedWork;
                    reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
                    return workInProgress2.child;
                }
                function markWorkInProgressReceivedUpdate() {
                    didReceiveUpdate = true;
                }
                function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
                    if (current2 !== null) {
                        workInProgress2.dependencies = current2.dependencies;
                    }
                    {
                        stopProfilerTimerIfRunning();
                    }
                    markSkippedUpdateLanes(workInProgress2.lanes);
                    if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
                        {
                            return null;
                        }
                    }
                    cloneChildFibers(current2, workInProgress2);
                    return workInProgress2.child;
                }
                function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
                    {
                        var returnFiber = oldWorkInProgress.return;
                        if (returnFiber === null) {
                            throw new Error("Cannot swap the root fiber.");
                        }
                        current2.alternate = null;
                        oldWorkInProgress.alternate = null;
                        newWorkInProgress.index = oldWorkInProgress.index;
                        newWorkInProgress.sibling = oldWorkInProgress.sibling;
                        newWorkInProgress.return = oldWorkInProgress.return;
                        newWorkInProgress.ref = oldWorkInProgress.ref;
                        if (oldWorkInProgress === returnFiber.child) {
                            returnFiber.child = newWorkInProgress;
                        } else {
                            var prevSibling = returnFiber.child;
                            if (prevSibling === null) {
                                throw new Error("Expected parent to have a child.");
                            }
                            while(prevSibling.sibling !== oldWorkInProgress){
                                prevSibling = prevSibling.sibling;
                                if (prevSibling === null) {
                                    throw new Error("Expected to find the previous sibling.");
                                }
                            }
                            prevSibling.sibling = newWorkInProgress;
                        }
                        var deletions = returnFiber.deletions;
                        if (deletions === null) {
                            returnFiber.deletions = [
                                current2
                            ];
                            returnFiber.flags |= ChildDeletion;
                        } else {
                            deletions.push(current2);
                        }
                        newWorkInProgress.flags |= Placement;
                        return newWorkInProgress;
                    }
                }
                function checkScheduledUpdateOrContext(current2, renderLanes2) {
                    var updateLanes = current2.lanes;
                    if (includesSomeLane(updateLanes, renderLanes2)) {
                        return true;
                    }
                    return false;
                }
                function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
                    switch(workInProgress2.tag){
                        case HostRoot2:
                            pushHostRootContext(workInProgress2);
                            var root = workInProgress2.stateNode;
                            resetHydrationState();
                            break;
                        case HostComponent2:
                            pushHostContext(workInProgress2);
                            break;
                        case ClassComponent:
                            {
                                var Component = workInProgress2.type;
                                if (isContextProvider(Component)) {
                                    pushContextProvider(workInProgress2);
                                }
                                break;
                            }
                        case HostPortal:
                            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
                            break;
                        case ContextProvider:
                            {
                                var newValue = workInProgress2.memoizedProps.value;
                                var context = workInProgress2.type._context;
                                pushProvider(workInProgress2, context, newValue);
                                break;
                            }
                        case Profiler:
                            {
                                var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                                if (hasChildWork) {
                                    workInProgress2.flags |= Update;
                                }
                                {
                                    var stateNode = workInProgress2.stateNode;
                                    stateNode.effectDuration = 0;
                                    stateNode.passiveEffectDuration = 0;
                                }
                            }
                            break;
                        case SuspenseComponent2:
                            {
                                var state = workInProgress2.memoizedState;
                                if (state !== null) {
                                    {
                                        if (state.dehydrated !== null) {
                                            pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                                            workInProgress2.flags |= DidCapture;
                                            return null;
                                        }
                                    }
                                    var primaryChildFragment = workInProgress2.child;
                                    var primaryChildLanes = primaryChildFragment.childLanes;
                                    if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                                        return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
                                    } else {
                                        pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                                        var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                                        if (child !== null) {
                                            return child.sibling;
                                        } else {
                                            return null;
                                        }
                                    }
                                } else {
                                    pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                                }
                                break;
                            }
                        case SuspenseListComponent:
                            {
                                var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
                                var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                                if (didSuspendBefore) {
                                    if (_hasChildWork) {
                                        return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
                                    }
                                    workInProgress2.flags |= DidCapture;
                                }
                                var renderState = workInProgress2.memoizedState;
                                if (renderState !== null) {
                                    renderState.rendering = null;
                                    renderState.tail = null;
                                    renderState.lastEffect = null;
                                }
                                pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
                                if (_hasChildWork) {
                                    break;
                                } else {
                                    return null;
                                }
                            }
                        case OffscreenComponent:
                        case LegacyHiddenComponent:
                            {
                                workInProgress2.lanes = NoLanes;
                                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
                            }
                    }
                    return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                }
                function beginWork(current2, workInProgress2, renderLanes2) {
                    {
                        if (workInProgress2._debugNeedsRemount && current2 !== null) {
                            return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
                        }
                    }
                    if (current2 !== null) {
                        var oldProps = current2.memoizedProps;
                        var newProps = workInProgress2.pendingProps;
                        if (oldProps !== newProps || hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:
                        workInProgress2.type !== current2.type) {
                            didReceiveUpdate = true;
                        } else {
                            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
                            if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there
                            // may not be work scheduled on `current`, so we check for this flag.
                            (workInProgress2.flags & DidCapture) === NoFlags) {
                                didReceiveUpdate = false;
                                return attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
                            }
                            if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                                didReceiveUpdate = true;
                            } else {
                                didReceiveUpdate = false;
                            }
                        }
                    } else {
                        didReceiveUpdate = false;
                        if (getIsHydrating() && isForkedChild(workInProgress2)) {
                            var slotIndex = workInProgress2.index;
                            var numberOfForks = getForksAtLevel();
                            pushTreeId(workInProgress2, numberOfForks, slotIndex);
                        }
                    }
                    workInProgress2.lanes = NoLanes;
                    switch(workInProgress2.tag){
                        case IndeterminateComponent:
                            {
                                return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
                            }
                        case LazyComponent:
                            {
                                var elementType = workInProgress2.elementType;
                                return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);
                            }
                        case FunctionComponent:
                            {
                                var Component = workInProgress2.type;
                                var unresolvedProps = workInProgress2.pendingProps;
                                var resolvedProps = workInProgress2.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);
                                return updateFunctionComponent(current2, workInProgress2, Component, resolvedProps, renderLanes2);
                            }
                        case ClassComponent:
                            {
                                var _Component = workInProgress2.type;
                                var _unresolvedProps = workInProgress2.pendingProps;
                                var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
                                return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);
                            }
                        case HostRoot2:
                            return updateHostRoot(current2, workInProgress2, renderLanes2);
                        case HostComponent2:
                            return updateHostComponent$1(current2, workInProgress2, renderLanes2);
                        case HostText2:
                            return updateHostText$1(current2, workInProgress2);
                        case SuspenseComponent2:
                            return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
                        case HostPortal:
                            return updatePortalComponent(current2, workInProgress2, renderLanes2);
                        case ForwardRef:
                            {
                                var type = workInProgress2.type;
                                var _unresolvedProps2 = workInProgress2.pendingProps;
                                var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
                                return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);
                            }
                        case Fragment20:
                            return updateFragment(current2, workInProgress2, renderLanes2);
                        case Mode:
                            return updateMode(current2, workInProgress2, renderLanes2);
                        case Profiler:
                            return updateProfiler(current2, workInProgress2, renderLanes2);
                        case ContextProvider:
                            return updateContextProvider(current2, workInProgress2, renderLanes2);
                        case ContextConsumer:
                            return updateContextConsumer(current2, workInProgress2, renderLanes2);
                        case MemoComponent:
                            {
                                var _type2 = workInProgress2.type;
                                var _unresolvedProps3 = workInProgress2.pendingProps;
                                var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
                                {
                                    if (workInProgress2.type !== workInProgress2.elementType) {
                                        var outerPropTypes = _type2.propTypes;
                                        if (outerPropTypes) {
                                            checkPropTypes(outerPropTypes, _resolvedProps3, // Resolved for outer only
                                            "prop", getComponentNameFromType(_type2));
                                        }
                                    }
                                }
                                _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
                                return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);
                            }
                        case SimpleMemoComponent:
                            {
                                return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
                            }
                        case IncompleteClassComponent:
                            {
                                var _Component2 = workInProgress2.type;
                                var _unresolvedProps4 = workInProgress2.pendingProps;
                                var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
                                return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
                            }
                        case SuspenseListComponent:
                            {
                                return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
                            }
                        case ScopeComponent:
                            {
                                break;
                            }
                        case OffscreenComponent:
                            {
                                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
                            }
                    }
                    throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
                }
                function unwindWork(current2, workInProgress2, renderLanes2) {
                    popTreeContext(workInProgress2);
                    switch(workInProgress2.tag){
                        case ClassComponent:
                            {
                                var Component = workInProgress2.type;
                                if (isContextProvider(Component)) {
                                    popContext(workInProgress2);
                                }
                                var flags = workInProgress2.flags;
                                if (flags & ShouldCapture) {
                                    workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
                                    if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                                        transferActualDuration(workInProgress2);
                                    }
                                    return workInProgress2;
                                }
                                return null;
                            }
                        case HostRoot2:
                            {
                                popHostContainer(workInProgress2);
                                popTopLevelContextObject(workInProgress2);
                                resetWorkInProgressVersions();
                                var _flags = workInProgress2.flags;
                                if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
                                    workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
                                    return workInProgress2;
                                }
                                return null;
                            }
                        case HostComponent2:
                            {
                                popHostContext(workInProgress2);
                                return null;
                            }
                        case SuspenseComponent2:
                            {
                                popSuspenseContext(workInProgress2);
                                {
                                    var suspenseState = workInProgress2.memoizedState;
                                    if (suspenseState !== null && suspenseState.dehydrated !== null) {
                                        if (workInProgress2.alternate === null) {
                                            throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
                                        }
                                        resetHydrationState();
                                    }
                                }
                                var _flags2 = workInProgress2.flags;
                                if (_flags2 & ShouldCapture) {
                                    workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
                                    if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                                        transferActualDuration(workInProgress2);
                                    }
                                    return workInProgress2;
                                }
                                return null;
                            }
                        case SuspenseListComponent:
                            {
                                popSuspenseContext(workInProgress2);
                                return null;
                            }
                        case HostPortal:
                            popHostContainer(workInProgress2);
                            return null;
                        case ContextProvider:
                            var context = workInProgress2.type._context;
                            popProvider(context, workInProgress2);
                            return null;
                        case OffscreenComponent:
                        case LegacyHiddenComponent:
                            popRenderLanes(workInProgress2);
                            return null;
                        case CacheComponent:
                            return null;
                        default:
                            return null;
                    }
                }
                function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
                    popTreeContext(interruptedWork);
                    switch(interruptedWork.tag){
                        case ClassComponent:
                            {
                                var childContextTypes = interruptedWork.type.childContextTypes;
                                if (childContextTypes !== null && childContextTypes !== void 0) {
                                    popContext(interruptedWork);
                                }
                                break;
                            }
                        case HostRoot2:
                            {
                                popHostContainer(interruptedWork);
                                popTopLevelContextObject(interruptedWork);
                                resetWorkInProgressVersions();
                                break;
                            }
                        case HostComponent2:
                            {
                                popHostContext(interruptedWork);
                                break;
                            }
                        case HostPortal:
                            popHostContainer(interruptedWork);
                            break;
                        case SuspenseComponent2:
                            popSuspenseContext(interruptedWork);
                            break;
                        case SuspenseListComponent:
                            popSuspenseContext(interruptedWork);
                            break;
                        case ContextProvider:
                            var context = interruptedWork.type._context;
                            popProvider(context, interruptedWork);
                            break;
                        case OffscreenComponent:
                        case LegacyHiddenComponent:
                            popRenderLanes(interruptedWork);
                            break;
                    }
                }
                function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {
                    var funcArgs = Array.prototype.slice.call(arguments, 3);
                    try {
                        func.apply(context, funcArgs);
                    } catch (error2) {
                        this.onError(error2);
                    }
                }
                var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
                {
                    if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
                        var fakeNode = document.createElement("react");
                        invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
                            if (typeof document === "undefined" || document === null) {
                                throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
                            }
                            var evt = document.createEvent("Event");
                            var didCall = false;
                            var didError = true;
                            var windowEvent = window.event;
                            var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
                            function restoreAfterDispatch() {
                                fakeNode.removeEventListener(evtType, callCallback2, false);
                                if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                                    window.event = windowEvent;
                                }
                            }
                            var funcArgs = Array.prototype.slice.call(arguments, 3);
                            function callCallback2() {
                                didCall = true;
                                restoreAfterDispatch();
                                func.apply(context, funcArgs);
                                didError = false;
                            }
                            var error2;
                            var didSetError = false;
                            var isCrossOriginError = false;
                            function handleWindowError(event) {
                                error2 = event.error;
                                didSetError = true;
                                if (error2 === null && event.colno === 0 && event.lineno === 0) {
                                    isCrossOriginError = true;
                                }
                                if (event.defaultPrevented) {
                                    if (error2 != null && typeof error2 === "object") {
                                        try {
                                            error2._suppressLogging = true;
                                        } catch (inner) {}
                                    }
                                }
                            }
                            var evtType = "react-" + (name ? name : "invokeguardedcallback");
                            window.addEventListener("error", handleWindowError);
                            fakeNode.addEventListener(evtType, callCallback2, false);
                            evt.initEvent(evtType, false, false);
                            fakeNode.dispatchEvent(evt);
                            if (windowEventDescriptor) {
                                Object.defineProperty(window, "event", windowEventDescriptor);
                            }
                            if (didCall && didError) {
                                if (!didSetError) {
                                    error2 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                                } else if (isCrossOriginError) {
                                    error2 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                                }
                                this.onError(error2);
                            }
                            window.removeEventListener("error", handleWindowError);
                            if (!didCall) {
                                restoreAfterDispatch();
                                return invokeGuardedCallbackProd.apply(this, arguments);
                            }
                        };
                    }
                }
                var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
                var hasError = false;
                var caughtError = null;
                var reporter = {
                    onError: function(error2) {
                        hasError = true;
                        caughtError = error2;
                    }
                };
                function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
                    hasError = false;
                    caughtError = null;
                    invokeGuardedCallbackImpl$1.apply(reporter, arguments);
                }
                function hasCaughtError() {
                    return hasError;
                }
                function clearCaughtError() {
                    if (hasError) {
                        var error2 = caughtError;
                        hasError = false;
                        caughtError = null;
                        return error2;
                    } else {
                        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
                    }
                }
                var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
                {
                    didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
                }
                var offscreenSubtreeIsHidden = false;
                var offscreenSubtreeWasHidden = false;
                var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
                var nextEffect = null;
                var inProgressLanes = null;
                var inProgressRoot = null;
                function reportUncaughtErrorInDEV(error2) {
                    {
                        invokeGuardedCallback(null, function() {
                            throw error2;
                        });
                        clearCaughtError();
                    }
                }
                var callComponentWillUnmountWithTimer = function(current2, instance) {
                    instance.props = current2.memoizedProps;
                    instance.state = current2.memoizedState;
                    if (current2.mode & ProfileMode) {
                        try {
                            startLayoutEffectTimer();
                            instance.componentWillUnmount();
                        } finally{
                            recordLayoutEffectDuration(current2);
                        }
                    } else {
                        instance.componentWillUnmount();
                    }
                };
                function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {
                    try {
                        commitHookEffectListMount(Layout, current2);
                    } catch (error2) {
                        reportUncaughtErrorInDEV(error2);
                        captureCommitPhaseError(current2, nearestMountedAncestor, error2);
                    }
                }
                function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
                    try {
                        callComponentWillUnmountWithTimer(current2, instance);
                    } catch (error2) {
                        reportUncaughtErrorInDEV(error2);
                        captureCommitPhaseError(current2, nearestMountedAncestor, error2);
                    }
                }
                function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {
                    try {
                        instance.componentDidMount();
                    } catch (error2) {
                        reportUncaughtErrorInDEV(error2);
                        captureCommitPhaseError(current2, nearestMountedAncestor, error2);
                    }
                }
                function safelyAttachRef(current2, nearestMountedAncestor) {
                    try {
                        commitAttachRef(current2);
                    } catch (error2) {
                        reportUncaughtErrorInDEV(error2);
                        captureCommitPhaseError(current2, nearestMountedAncestor, error2);
                    }
                }
                function safelyDetachRef(current2, nearestMountedAncestor) {
                    var ref = current2.ref;
                    if (ref !== null) {
                        if (typeof ref === "function") {
                            var retVal;
                            try {
                                if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode) {
                                    try {
                                        startLayoutEffectTimer();
                                        retVal = ref(null);
                                    } finally{
                                        recordLayoutEffectDuration(current2);
                                    }
                                } else {
                                    retVal = ref(null);
                                }
                            } catch (error2) {
                                reportUncaughtErrorInDEV(error2);
                                captureCommitPhaseError(current2, nearestMountedAncestor, error2);
                            }
                            {
                                if (typeof retVal === "function") {
                                    error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current2));
                                }
                            }
                        } else {
                            ref.current = null;
                        }
                    }
                }
                function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {
                    try {
                        destroy();
                    } catch (error2) {
                        reportUncaughtErrorInDEV(error2);
                        captureCommitPhaseError(current2, nearestMountedAncestor, error2);
                    }
                }
                var focusedInstanceHandle = null;
                var shouldFireAfterActiveInstanceBlur = false;
                function commitBeforeMutationEffects(root, firstChild) {
                    focusedInstanceHandle = prepareForCommit(root.containerInfo);
                    nextEffect = firstChild;
                    commitBeforeMutationEffects_begin();
                    var shouldFire = shouldFireAfterActiveInstanceBlur;
                    shouldFireAfterActiveInstanceBlur = false;
                    focusedInstanceHandle = null;
                    return shouldFire;
                }
                function commitBeforeMutationEffects_begin() {
                    while(nextEffect !== null){
                        var fiber = nextEffect;
                        var child = fiber.child;
                        if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
                            ensureCorrectReturnPointer(child, fiber);
                            nextEffect = child;
                        } else {
                            commitBeforeMutationEffects_complete();
                        }
                    }
                }
                function commitBeforeMutationEffects_complete() {
                    while(nextEffect !== null){
                        var fiber = nextEffect;
                        setCurrentFiber(fiber);
                        try {
                            commitBeforeMutationEffectsOnFiber(fiber);
                        } catch (error2) {
                            reportUncaughtErrorInDEV(error2);
                            captureCommitPhaseError(fiber, fiber.return, error2);
                        }
                        resetCurrentFiber();
                        var sibling = fiber.sibling;
                        if (sibling !== null) {
                            ensureCorrectReturnPointer(sibling, fiber.return);
                            nextEffect = sibling;
                            return;
                        }
                        nextEffect = fiber.return;
                    }
                }
                function commitBeforeMutationEffectsOnFiber(finishedWork) {
                    var current2 = finishedWork.alternate;
                    var flags = finishedWork.flags;
                    if ((flags & Snapshot) !== NoFlags) {
                        setCurrentFiber(finishedWork);
                        switch(finishedWork.tag){
                            case FunctionComponent:
                            case ForwardRef:
                            case SimpleMemoComponent:
                                {
                                    break;
                                }
                            case ClassComponent:
                                {
                                    if (current2 !== null) {
                                        var prevProps = current2.memoizedProps;
                                        var prevState = current2.memoizedState;
                                        var instance = finishedWork.stateNode;
                                        {
                                            if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                                                if (instance.props !== finishedWork.memoizedProps) {
                                                    error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                                                }
                                                if (instance.state !== finishedWork.memoizedState) {
                                                    error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                                                }
                                            }
                                        }
                                        var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                                        {
                                            var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                                            if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                                                didWarnSet.add(finishedWork.type);
                                                error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
                                            }
                                        }
                                        instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                                    }
                                    break;
                                }
                            case HostRoot2:
                                {
                                    if (supportsMutation) {
                                        var root = finishedWork.stateNode;
                                        clearContainer(root.containerInfo);
                                    }
                                    break;
                                }
                            case HostComponent2:
                            case HostText2:
                            case HostPortal:
                            case IncompleteClassComponent:
                                break;
                            default:
                                {
                                    throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
                                }
                        }
                        resetCurrentFiber();
                    }
                }
                function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
                    var updateQueue = finishedWork.updateQueue;
                    var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
                    if (lastEffect !== null) {
                        var firstEffect = lastEffect.next;
                        var effect = firstEffect;
                        do {
                            if ((effect.tag & flags) === flags) {
                                var destroy = effect.destroy;
                                effect.destroy = void 0;
                                if (destroy !== void 0) {
                                    {
                                        if ((flags & Passive$1) !== NoFlags$1) {
                                            markComponentPassiveEffectUnmountStarted(finishedWork);
                                        } else if ((flags & Layout) !== NoFlags$1) {
                                            markComponentLayoutEffectUnmountStarted(finishedWork);
                                        }
                                    }
                                    safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                                    {
                                        if ((flags & Passive$1) !== NoFlags$1) {
                                            markComponentPassiveEffectUnmountStopped();
                                        } else if ((flags & Layout) !== NoFlags$1) {
                                            markComponentLayoutEffectUnmountStopped();
                                        }
                                    }
                                }
                            }
                            effect = effect.next;
                        }while (effect !== firstEffect)
                    }
                }
                function commitHookEffectListMount(flags, finishedWork) {
                    var updateQueue = finishedWork.updateQueue;
                    var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
                    if (lastEffect !== null) {
                        var firstEffect = lastEffect.next;
                        var effect = firstEffect;
                        do {
                            if ((effect.tag & flags) === flags) {
                                {
                                    if ((flags & Passive$1) !== NoFlags$1) {
                                        markComponentPassiveEffectMountStarted(finishedWork);
                                    } else if ((flags & Layout) !== NoFlags$1) {
                                        markComponentLayoutEffectMountStarted(finishedWork);
                                    }
                                }
                                var create = effect.create;
                                effect.destroy = create();
                                {
                                    if ((flags & Passive$1) !== NoFlags$1) {
                                        markComponentPassiveEffectMountStopped();
                                    } else if ((flags & Layout) !== NoFlags$1) {
                                        markComponentLayoutEffectMountStopped();
                                    }
                                }
                                {
                                    var destroy = effect.destroy;
                                    if (destroy !== void 0 && typeof destroy !== "function") {
                                        var hookName = void 0;
                                        if ((effect.tag & Layout) !== NoFlags) {
                                            hookName = "useLayoutEffect";
                                        } else if ((effect.tag & Insertion) !== NoFlags) {
                                            hookName = "useInsertionEffect";
                                        } else {
                                            hookName = "useEffect";
                                        }
                                        var addendum = void 0;
                                        if (destroy === null) {
                                            addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                                        } else if (typeof destroy.then === "function") {
                                            addendum = "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                                        } else {
                                            addendum = " You returned: " + destroy;
                                        }
                                        error("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
                                    }
                                }
                            }
                            effect = effect.next;
                        }while (effect !== firstEffect)
                    }
                }
                function commitPassiveEffectDurations(finishedRoot, finishedWork) {
                    {
                        if ((finishedWork.flags & Update) !== NoFlags) {
                            switch(finishedWork.tag){
                                case Profiler:
                                    {
                                        var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                                        var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                                        var commitTime2 = getCommitTime();
                                        var phase = finishedWork.alternate === null ? "mount" : "update";
                                        {
                                            if (isCurrentUpdateNested()) {
                                                phase = "nested-update";
                                            }
                                        }
                                        if (typeof onPostCommit === "function") {
                                            onPostCommit(id, phase, passiveEffectDuration, commitTime2);
                                        }
                                        var parentFiber = finishedWork.return;
                                        outer: while(parentFiber !== null){
                                            switch(parentFiber.tag){
                                                case HostRoot2:
                                                    var root = parentFiber.stateNode;
                                                    root.passiveEffectDuration += passiveEffectDuration;
                                                    break outer;
                                                case Profiler:
                                                    var parentStateNode = parentFiber.stateNode;
                                                    parentStateNode.passiveEffectDuration += passiveEffectDuration;
                                                    break outer;
                                            }
                                            parentFiber = parentFiber.return;
                                        }
                                        break;
                                    }
                            }
                        }
                    }
                }
                function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
                    if ((finishedWork.flags & LayoutMask) !== NoFlags) {
                        switch(finishedWork.tag){
                            case FunctionComponent:
                            case ForwardRef:
                            case SimpleMemoComponent:
                                {
                                    if (!offscreenSubtreeWasHidden) {
                                        if (finishedWork.mode & ProfileMode) {
                                            try {
                                                startLayoutEffectTimer();
                                                commitHookEffectListMount(Layout | HasEffect, finishedWork);
                                            } finally{
                                                recordLayoutEffectDuration(finishedWork);
                                            }
                                        } else {
                                            commitHookEffectListMount(Layout | HasEffect, finishedWork);
                                        }
                                    }
                                    break;
                                }
                            case ClassComponent:
                                {
                                    var instance = finishedWork.stateNode;
                                    if (finishedWork.flags & Update) {
                                        if (!offscreenSubtreeWasHidden) {
                                            if (current2 === null) {
                                                {
                                                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                                                        if (instance.props !== finishedWork.memoizedProps) {
                                                            error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                                                        }
                                                        if (instance.state !== finishedWork.memoizedState) {
                                                            error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                                                        }
                                                    }
                                                }
                                                if (finishedWork.mode & ProfileMode) {
                                                    try {
                                                        startLayoutEffectTimer();
                                                        instance.componentDidMount();
                                                    } finally{
                                                        recordLayoutEffectDuration(finishedWork);
                                                    }
                                                } else {
                                                    instance.componentDidMount();
                                                }
                                            } else {
                                                var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                                                var prevState = current2.memoizedState;
                                                {
                                                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                                                        if (instance.props !== finishedWork.memoizedProps) {
                                                            error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                                                        }
                                                        if (instance.state !== finishedWork.memoizedState) {
                                                            error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                                                        }
                                                    }
                                                }
                                                if (finishedWork.mode & ProfileMode) {
                                                    try {
                                                        startLayoutEffectTimer();
                                                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                                                    } finally{
                                                        recordLayoutEffectDuration(finishedWork);
                                                    }
                                                } else {
                                                    instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                                                }
                                            }
                                        }
                                    }
                                    var updateQueue = finishedWork.updateQueue;
                                    if (updateQueue !== null) {
                                        {
                                            if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                                                if (instance.props !== finishedWork.memoizedProps) {
                                                    error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                                                }
                                                if (instance.state !== finishedWork.memoizedState) {
                                                    error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                                                }
                                            }
                                        }
                                        commitUpdateQueue(finishedWork, updateQueue, instance);
                                    }
                                    break;
                                }
                            case HostRoot2:
                                {
                                    var _updateQueue = finishedWork.updateQueue;
                                    if (_updateQueue !== null) {
                                        var _instance = null;
                                        if (finishedWork.child !== null) {
                                            switch(finishedWork.child.tag){
                                                case HostComponent2:
                                                    _instance = getPublicInstance(finishedWork.child.stateNode);
                                                    break;
                                                case ClassComponent:
                                                    _instance = finishedWork.child.stateNode;
                                                    break;
                                            }
                                        }
                                        commitUpdateQueue(finishedWork, _updateQueue, _instance);
                                    }
                                    break;
                                }
                            case HostComponent2:
                                {
                                    var _instance2 = finishedWork.stateNode;
                                    if (current2 === null && finishedWork.flags & Update) {
                                        var type = finishedWork.type;
                                        var props = finishedWork.memoizedProps;
                                        commitMount(_instance2, type, props, finishedWork);
                                    }
                                    break;
                                }
                            case HostText2:
                                {
                                    break;
                                }
                            case HostPortal:
                                {
                                    break;
                                }
                            case Profiler:
                                {
                                    {
                                        var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                                        var effectDuration = finishedWork.stateNode.effectDuration;
                                        var commitTime2 = getCommitTime();
                                        var phase = current2 === null ? "mount" : "update";
                                        {
                                            if (isCurrentUpdateNested()) {
                                                phase = "nested-update";
                                            }
                                        }
                                        if (typeof onRender === "function") {
                                            onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                                        }
                                        {
                                            if (typeof onCommit === "function") {
                                                onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);
                                            }
                                            enqueuePendingPassiveProfilerEffect(finishedWork);
                                            var parentFiber = finishedWork.return;
                                            outer: while(parentFiber !== null){
                                                switch(parentFiber.tag){
                                                    case HostRoot2:
                                                        var root = parentFiber.stateNode;
                                                        root.effectDuration += effectDuration;
                                                        break outer;
                                                    case Profiler:
                                                        var parentStateNode = parentFiber.stateNode;
                                                        parentStateNode.effectDuration += effectDuration;
                                                        break outer;
                                                }
                                                parentFiber = parentFiber.return;
                                            }
                                        }
                                    }
                                    break;
                                }
                            case SuspenseComponent2:
                                {
                                    commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                                    break;
                                }
                            case SuspenseListComponent:
                            case IncompleteClassComponent:
                            case ScopeComponent:
                            case OffscreenComponent:
                            case LegacyHiddenComponent:
                                {
                                    break;
                                }
                            default:
                                throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
                        }
                    }
                    if (!offscreenSubtreeWasHidden) {
                        {
                            if (finishedWork.flags & Ref) {
                                commitAttachRef(finishedWork);
                            }
                        }
                    }
                }
                function reappearLayoutEffectsOnFiber(node) {
                    switch(node.tag){
                        case FunctionComponent:
                        case ForwardRef:
                        case SimpleMemoComponent:
                            {
                                if (node.mode & ProfileMode) {
                                    try {
                                        startLayoutEffectTimer();
                                        safelyCallCommitHookLayoutEffectListMount(node, node.return);
                                    } finally{
                                        recordLayoutEffectDuration(node);
                                    }
                                } else {
                                    safelyCallCommitHookLayoutEffectListMount(node, node.return);
                                }
                                break;
                            }
                        case ClassComponent:
                            {
                                var instance = node.stateNode;
                                if (typeof instance.componentDidMount === "function") {
                                    safelyCallComponentDidMount(node, node.return, instance);
                                }
                                safelyAttachRef(node, node.return);
                                break;
                            }
                        case HostComponent2:
                            {
                                safelyAttachRef(node, node.return);
                                break;
                            }
                    }
                }
                function hideOrUnhideAllChildren(finishedWork, isHidden) {
                    var hostSubtreeRoot = null;
                    if (supportsMutation) {
                        var node = finishedWork;
                        while(true){
                            if (node.tag === HostComponent2) {
                                if (hostSubtreeRoot === null) {
                                    hostSubtreeRoot = node;
                                    var instance = node.stateNode;
                                    if (isHidden) {
                                        hideInstance(instance);
                                    } else {
                                        unhideInstance(node.stateNode, node.memoizedProps);
                                    }
                                }
                            } else if (node.tag === HostText2) {
                                if (hostSubtreeRoot === null) {
                                    var _instance3 = node.stateNode;
                                    if (isHidden) {
                                        hideTextInstance(_instance3);
                                    } else {
                                        unhideTextInstance(_instance3, node.memoizedProps);
                                    }
                                }
                            } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ;
                            else if (node.child !== null) {
                                node.child.return = node;
                                node = node.child;
                                continue;
                            }
                            if (node === finishedWork) {
                                return;
                            }
                            while(node.sibling === null){
                                if (node.return === null || node.return === finishedWork) {
                                    return;
                                }
                                if (hostSubtreeRoot === node) {
                                    hostSubtreeRoot = null;
                                }
                                node = node.return;
                            }
                            if (hostSubtreeRoot === node) {
                                hostSubtreeRoot = null;
                            }
                            node.sibling.return = node.return;
                            node = node.sibling;
                        }
                    }
                }
                function commitAttachRef(finishedWork) {
                    var ref = finishedWork.ref;
                    if (ref !== null) {
                        var instance = finishedWork.stateNode;
                        var instanceToUse;
                        switch(finishedWork.tag){
                            case HostComponent2:
                                instanceToUse = getPublicInstance(instance);
                                break;
                            default:
                                instanceToUse = instance;
                        }
                        if (typeof ref === "function") {
                            var retVal;
                            if (finishedWork.mode & ProfileMode) {
                                try {
                                    startLayoutEffectTimer();
                                    retVal = ref(instanceToUse);
                                } finally{
                                    recordLayoutEffectDuration(finishedWork);
                                }
                            } else {
                                retVal = ref(instanceToUse);
                            }
                            {
                                if (typeof retVal === "function") {
                                    error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
                                }
                            }
                        } else {
                            {
                                if (!ref.hasOwnProperty("current")) {
                                    error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork));
                                }
                            }
                            ref.current = instanceToUse;
                        }
                    }
                }
                function commitDetachRef(current2) {
                    var currentRef = current2.ref;
                    if (currentRef !== null) {
                        if (typeof currentRef === "function") {
                            if (current2.mode & ProfileMode) {
                                try {
                                    startLayoutEffectTimer();
                                    currentRef(null);
                                } finally{
                                    recordLayoutEffectDuration(current2);
                                }
                            } else {
                                currentRef(null);
                            }
                        } else {
                            currentRef.current = null;
                        }
                    }
                }
                function commitUnmount(finishedRoot, current2, nearestMountedAncestor) {
                    onCommitUnmount(current2);
                    switch(current2.tag){
                        case FunctionComponent:
                        case ForwardRef:
                        case MemoComponent:
                        case SimpleMemoComponent:
                            {
                                var updateQueue = current2.updateQueue;
                                if (updateQueue !== null) {
                                    var lastEffect = updateQueue.lastEffect;
                                    if (lastEffect !== null) {
                                        var firstEffect = lastEffect.next;
                                        var effect = firstEffect;
                                        do {
                                            var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;
                                            if (destroy !== void 0) {
                                                if ((tag & Insertion) !== NoFlags$1) {
                                                    safelyCallDestroy(current2, nearestMountedAncestor, destroy);
                                                } else if ((tag & Layout) !== NoFlags$1) {
                                                    {
                                                        markComponentLayoutEffectUnmountStarted(current2);
                                                    }
                                                    if (current2.mode & ProfileMode) {
                                                        startLayoutEffectTimer();
                                                        safelyCallDestroy(current2, nearestMountedAncestor, destroy);
                                                        recordLayoutEffectDuration(current2);
                                                    } else {
                                                        safelyCallDestroy(current2, nearestMountedAncestor, destroy);
                                                    }
                                                    {
                                                        markComponentLayoutEffectUnmountStopped();
                                                    }
                                                }
                                            }
                                            effect = effect.next;
                                        }while (effect !== firstEffect)
                                    }
                                }
                                return;
                            }
                        case ClassComponent:
                            {
                                safelyDetachRef(current2, nearestMountedAncestor);
                                var instance = current2.stateNode;
                                if (typeof instance.componentWillUnmount === "function") {
                                    safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance);
                                }
                                return;
                            }
                        case HostComponent2:
                            {
                                safelyDetachRef(current2, nearestMountedAncestor);
                                return;
                            }
                        case HostPortal:
                            {
                                if (supportsMutation) {
                                    unmountHostComponents(finishedRoot, current2, nearestMountedAncestor);
                                } else if (supportsPersistence) {
                                    emptyPortalContainer(current2);
                                }
                                return;
                            }
                        case DehydratedFragment:
                            {
                                return;
                            }
                        case ScopeComponent:
                            {
                                return;
                            }
                    }
                }
                function commitNestedUnmounts(finishedRoot, root, nearestMountedAncestor) {
                    var node = root;
                    while(true){
                        commitUnmount(finishedRoot, node, nearestMountedAncestor);
                        if (node.child !== null && // If we use mutation we drill down into portals using commitUnmount above.
                        // If we don't use mutation we drill down into portals here instead.
                        (!supportsMutation || node.tag !== HostPortal)) {
                            node.child.return = node;
                            node = node.child;
                            continue;
                        }
                        if (node === root) {
                            return;
                        }
                        while(node.sibling === null){
                            if (node.return === null || node.return === root) {
                                return;
                            }
                            node = node.return;
                        }
                        node.sibling.return = node.return;
                        node = node.sibling;
                    }
                }
                function detachFiberMutation(fiber) {
                    var alternate = fiber.alternate;
                    if (alternate !== null) {
                        alternate.return = null;
                    }
                    fiber.return = null;
                }
                function detachFiberAfterEffects(fiber) {
                    var alternate = fiber.alternate;
                    if (alternate !== null) {
                        fiber.alternate = null;
                        detachFiberAfterEffects(alternate);
                    }
                    {
                        fiber.child = null;
                        fiber.deletions = null;
                        fiber.sibling = null;
                        if (fiber.tag === HostComponent2) {
                            var hostInstance = fiber.stateNode;
                            if (hostInstance !== null) {
                                detachDeletedInstance(hostInstance);
                            }
                        }
                        fiber.stateNode = null;
                        {
                            fiber._debugOwner = null;
                        }
                        {
                            fiber.return = null;
                            fiber.dependencies = null;
                            fiber.memoizedProps = null;
                            fiber.memoizedState = null;
                            fiber.pendingProps = null;
                            fiber.stateNode = null;
                            fiber.updateQueue = null;
                        }
                    }
                }
                function emptyPortalContainer(current2) {
                    if (!supportsPersistence) {
                        return;
                    }
                    var portal = current2.stateNode;
                    var containerInfo = portal.containerInfo;
                    var emptyChildSet = createContainerChildSet(containerInfo);
                    replaceContainerChildren(containerInfo, emptyChildSet);
                }
                function commitContainer(finishedWork) {
                    if (!supportsPersistence) {
                        return;
                    }
                    switch(finishedWork.tag){
                        case ClassComponent:
                        case HostComponent2:
                        case HostText2:
                            {
                                return;
                            }
                        case HostRoot2:
                        case HostPortal:
                            {
                                var portalOrRoot = finishedWork.stateNode;
                                var containerInfo = portalOrRoot.containerInfo, pendingChildren = portalOrRoot.pendingChildren;
                                replaceContainerChildren(containerInfo, pendingChildren);
                                return;
                            }
                    }
                    throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
                }
                function getHostParentFiber(fiber) {
                    var parent = fiber.return;
                    while(parent !== null){
                        if (isHostParent(parent)) {
                            return parent;
                        }
                        parent = parent.return;
                    }
                    throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
                }
                function isHostParent(fiber) {
                    return fiber.tag === HostComponent2 || fiber.tag === HostRoot2 || fiber.tag === HostPortal;
                }
                function getHostSibling(fiber) {
                    var node = fiber;
                    siblings: while(true){
                        while(node.sibling === null){
                            if (node.return === null || isHostParent(node.return)) {
                                return null;
                            }
                            node = node.return;
                        }
                        node.sibling.return = node.return;
                        node = node.sibling;
                        while(node.tag !== HostComponent2 && node.tag !== HostText2 && node.tag !== DehydratedFragment){
                            if (node.flags & Placement) {
                                continue siblings;
                            }
                            if (node.child === null || node.tag === HostPortal) {
                                continue siblings;
                            } else {
                                node.child.return = node;
                                node = node.child;
                            }
                        }
                        if (!(node.flags & Placement)) {
                            return node.stateNode;
                        }
                    }
                }
                function commitPlacement(finishedWork) {
                    if (!supportsMutation) {
                        return;
                    }
                    var parentFiber = getHostParentFiber(finishedWork);
                    switch(parentFiber.tag){
                        case HostComponent2:
                            {
                                var parent = parentFiber.stateNode;
                                if (parentFiber.flags & ContentReset) {
                                    resetTextContent(parent);
                                    parentFiber.flags &= ~ContentReset;
                                }
                                var before = getHostSibling(finishedWork);
                                insertOrAppendPlacementNode(finishedWork, before, parent);
                                break;
                            }
                        case HostRoot2:
                        case HostPortal:
                            {
                                var _parent = parentFiber.stateNode.containerInfo;
                                var _before = getHostSibling(finishedWork);
                                insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
                                break;
                            }
                        default:
                            throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
                    }
                }
                function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
                    var tag = node.tag;
                    var isHost = tag === HostComponent2 || tag === HostText2;
                    if (isHost) {
                        var stateNode = node.stateNode;
                        if (before) {
                            insertInContainerBefore(parent, stateNode, before);
                        } else {
                            appendChildToContainer(parent, stateNode);
                        }
                    } else if (tag === HostPortal) ;
                    else {
                        var child = node.child;
                        if (child !== null) {
                            insertOrAppendPlacementNodeIntoContainer(child, before, parent);
                            var sibling = child.sibling;
                            while(sibling !== null){
                                insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                                sibling = sibling.sibling;
                            }
                        }
                    }
                }
                function insertOrAppendPlacementNode(node, before, parent) {
                    var tag = node.tag;
                    var isHost = tag === HostComponent2 || tag === HostText2;
                    if (isHost) {
                        var stateNode = node.stateNode;
                        if (before) {
                            insertBefore(parent, stateNode, before);
                        } else {
                            appendChild(parent, stateNode);
                        }
                    } else if (tag === HostPortal) ;
                    else {
                        var child = node.child;
                        if (child !== null) {
                            insertOrAppendPlacementNode(child, before, parent);
                            var sibling = child.sibling;
                            while(sibling !== null){
                                insertOrAppendPlacementNode(sibling, before, parent);
                                sibling = sibling.sibling;
                            }
                        }
                    }
                }
                function unmountHostComponents(finishedRoot, current2, nearestMountedAncestor) {
                    var node = current2;
                    var currentParentIsValid = false;
                    var currentParent;
                    var currentParentIsContainer;
                    while(true){
                        if (!currentParentIsValid) {
                            var parent = node.return;
                            findParent: while(true){
                                if (parent === null) {
                                    throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
                                }
                                var parentStateNode = parent.stateNode;
                                switch(parent.tag){
                                    case HostComponent2:
                                        currentParent = parentStateNode;
                                        currentParentIsContainer = false;
                                        break findParent;
                                    case HostRoot2:
                                        currentParent = parentStateNode.containerInfo;
                                        currentParentIsContainer = true;
                                        break findParent;
                                    case HostPortal:
                                        currentParent = parentStateNode.containerInfo;
                                        currentParentIsContainer = true;
                                        break findParent;
                                }
                                parent = parent.return;
                            }
                            currentParentIsValid = true;
                        }
                        if (node.tag === HostComponent2 || node.tag === HostText2) {
                            commitNestedUnmounts(finishedRoot, node, nearestMountedAncestor);
                            if (currentParentIsContainer) {
                                removeChildFromContainer(currentParent, node.stateNode);
                            } else {
                                removeChild(currentParent, node.stateNode);
                            }
                        } else if (node.tag === DehydratedFragment) {
                            if (currentParentIsContainer) {
                                clearSuspenseBoundaryFromContainer(currentParent, node.stateNode);
                            } else {
                                clearSuspenseBoundary(currentParent, node.stateNode);
                            }
                        } else if (node.tag === HostPortal) {
                            if (node.child !== null) {
                                currentParent = node.stateNode.containerInfo;
                                currentParentIsContainer = true;
                                node.child.return = node;
                                node = node.child;
                                continue;
                            }
                        } else {
                            commitUnmount(finishedRoot, node, nearestMountedAncestor);
                            if (node.child !== null) {
                                node.child.return = node;
                                node = node.child;
                                continue;
                            }
                        }
                        if (node === current2) {
                            return;
                        }
                        while(node.sibling === null){
                            if (node.return === null || node.return === current2) {
                                return;
                            }
                            node = node.return;
                            if (node.tag === HostPortal) {
                                currentParentIsValid = false;
                            }
                        }
                        node.sibling.return = node.return;
                        node = node.sibling;
                    }
                }
                function commitDeletion(finishedRoot, current2, nearestMountedAncestor) {
                    if (supportsMutation) {
                        unmountHostComponents(finishedRoot, current2, nearestMountedAncestor);
                    } else {
                        commitNestedUnmounts(finishedRoot, current2, nearestMountedAncestor);
                    }
                    detachFiberMutation(current2);
                }
                function commitWork(current2, finishedWork) {
                    if (!supportsMutation) {
                        switch(finishedWork.tag){
                            case FunctionComponent:
                            case ForwardRef:
                            case MemoComponent:
                            case SimpleMemoComponent:
                                {
                                    commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                                    commitHookEffectListMount(Insertion | HasEffect, finishedWork);
                                    if (finishedWork.mode & ProfileMode) {
                                        try {
                                            startLayoutEffectTimer();
                                            commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                                        } finally{
                                            recordLayoutEffectDuration(finishedWork);
                                        }
                                    } else {
                                        commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                                    }
                                    return;
                                }
                            case Profiler:
                                {
                                    return;
                                }
                            case SuspenseComponent2:
                                {
                                    commitSuspenseCallback(finishedWork);
                                    attachSuspenseRetryListeners(finishedWork);
                                    return;
                                }
                            case SuspenseListComponent:
                                {
                                    attachSuspenseRetryListeners(finishedWork);
                                    return;
                                }
                            case HostRoot2:
                                {
                                    if (supportsHydration) {
                                        if (current2 !== null) {
                                            var prevRootState = current2.memoizedState;
                                            if (prevRootState.isDehydrated) {
                                                var root = finishedWork.stateNode;
                                                commitHydratedContainer(root.containerInfo);
                                            }
                                        }
                                    }
                                    break;
                                }
                            case OffscreenComponent:
                            case LegacyHiddenComponent:
                                {
                                    return;
                                }
                        }
                        commitContainer(finishedWork);
                        return;
                    }
                    switch(finishedWork.tag){
                        case FunctionComponent:
                        case ForwardRef:
                        case MemoComponent:
                        case SimpleMemoComponent:
                            {
                                commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                                commitHookEffectListMount(Insertion | HasEffect, finishedWork);
                                if (finishedWork.mode & ProfileMode) {
                                    try {
                                        startLayoutEffectTimer();
                                        commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                                    } finally{
                                        recordLayoutEffectDuration(finishedWork);
                                    }
                                } else {
                                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                                }
                                return;
                            }
                        case ClassComponent:
                            {
                                return;
                            }
                        case HostComponent2:
                            {
                                var instance = finishedWork.stateNode;
                                if (instance != null) {
                                    var newProps = finishedWork.memoizedProps;
                                    var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                                    var type = finishedWork.type;
                                    var updatePayload = finishedWork.updateQueue;
                                    finishedWork.updateQueue = null;
                                    if (updatePayload !== null) {
                                        commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
                                    }
                                }
                                return;
                            }
                        case HostText2:
                            {
                                if (finishedWork.stateNode === null) {
                                    throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                                }
                                var textInstance = finishedWork.stateNode;
                                var newText = finishedWork.memoizedProps;
                                var oldText = current2 !== null ? current2.memoizedProps : newText;
                                commitTextUpdate(textInstance, oldText, newText);
                                return;
                            }
                        case HostRoot2:
                            {
                                if (supportsHydration) {
                                    if (current2 !== null) {
                                        var _prevRootState = current2.memoizedState;
                                        if (_prevRootState.isDehydrated) {
                                            var _root = finishedWork.stateNode;
                                            commitHydratedContainer(_root.containerInfo);
                                        }
                                    }
                                }
                                return;
                            }
                        case Profiler:
                            {
                                return;
                            }
                        case SuspenseComponent2:
                            {
                                commitSuspenseCallback(finishedWork);
                                attachSuspenseRetryListeners(finishedWork);
                                return;
                            }
                        case SuspenseListComponent:
                            {
                                attachSuspenseRetryListeners(finishedWork);
                                return;
                            }
                        case IncompleteClassComponent:
                            {
                                return;
                            }
                    }
                    throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
                }
                function commitSuspenseCallback(finishedWork) {
                    var newState = finishedWork.memoizedState;
                }
                function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
                    if (!supportsHydration) {
                        return;
                    }
                    var newState = finishedWork.memoizedState;
                    if (newState === null) {
                        var current2 = finishedWork.alternate;
                        if (current2 !== null) {
                            var prevState = current2.memoizedState;
                            if (prevState !== null) {
                                var suspenseInstance = prevState.dehydrated;
                                if (suspenseInstance !== null) {
                                    commitHydratedSuspenseInstance(suspenseInstance);
                                }
                            }
                        }
                    }
                }
                function attachSuspenseRetryListeners(finishedWork) {
                    var wakeables = finishedWork.updateQueue;
                    if (wakeables !== null) {
                        finishedWork.updateQueue = null;
                        var retryCache = finishedWork.stateNode;
                        if (retryCache === null) {
                            retryCache = finishedWork.stateNode = new PossiblyWeakSet();
                        }
                        wakeables.forEach(function(wakeable) {
                            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
                            if (!retryCache.has(wakeable)) {
                                retryCache.add(wakeable);
                                {
                                    if (isDevToolsPresent) {
                                        if (inProgressLanes !== null && inProgressRoot !== null) {
                                            restorePendingUpdaters(inProgressRoot, inProgressLanes);
                                        } else {
                                            throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                                        }
                                    }
                                }
                                wakeable.then(retry, retry);
                            }
                        });
                    }
                }
                function commitResetTextContent(current2) {
                    if (!supportsMutation) {
                        return;
                    }
                    resetTextContent(current2.stateNode);
                }
                function commitMutationEffects(root, firstChild, committedLanes) {
                    inProgressLanes = committedLanes;
                    inProgressRoot = root;
                    nextEffect = firstChild;
                    commitMutationEffects_begin(root, committedLanes);
                    inProgressLanes = null;
                    inProgressRoot = null;
                }
                function commitMutationEffects_begin(root, lanes) {
                    while(nextEffect !== null){
                        var fiber = nextEffect;
                        var deletions = fiber.deletions;
                        if (deletions !== null) {
                            for(var i = 0; i < deletions.length; i++){
                                var childToDelete = deletions[i];
                                try {
                                    commitDeletion(root, childToDelete, fiber);
                                } catch (error2) {
                                    reportUncaughtErrorInDEV(error2);
                                    captureCommitPhaseError(childToDelete, fiber, error2);
                                }
                            }
                        }
                        var child = fiber.child;
                        if ((fiber.subtreeFlags & MutationMask) !== NoFlags && child !== null) {
                            ensureCorrectReturnPointer(child, fiber);
                            nextEffect = child;
                        } else {
                            commitMutationEffects_complete(root, lanes);
                        }
                    }
                }
                function commitMutationEffects_complete(root, lanes) {
                    while(nextEffect !== null){
                        var fiber = nextEffect;
                        setCurrentFiber(fiber);
                        try {
                            commitMutationEffectsOnFiber(fiber, root, lanes);
                        } catch (error2) {
                            reportUncaughtErrorInDEV(error2);
                            captureCommitPhaseError(fiber, fiber.return, error2);
                        }
                        resetCurrentFiber();
                        var sibling = fiber.sibling;
                        if (sibling !== null) {
                            ensureCorrectReturnPointer(sibling, fiber.return);
                            nextEffect = sibling;
                            return;
                        }
                        nextEffect = fiber.return;
                    }
                }
                function commitMutationEffectsOnFiber(finishedWork, root, lanes) {
                    var flags = finishedWork.flags;
                    if (flags & ContentReset) {
                        commitResetTextContent(finishedWork);
                    }
                    if (flags & Ref) {
                        var current2 = finishedWork.alternate;
                        if (current2 !== null) {
                            commitDetachRef(current2);
                        }
                    }
                    if (flags & Visibility) {
                        switch(finishedWork.tag){
                            case SuspenseComponent2:
                                {
                                    var newState = finishedWork.memoizedState;
                                    var isHidden = newState !== null;
                                    if (isHidden) {
                                        var _current = finishedWork.alternate;
                                        var wasHidden = _current !== null && _current.memoizedState !== null;
                                        if (!wasHidden) {
                                            markCommitTimeOfFallback();
                                        }
                                    }
                                    break;
                                }
                            case OffscreenComponent:
                                {
                                    var _newState = finishedWork.memoizedState;
                                    var _isHidden = _newState !== null;
                                    var _current2 = finishedWork.alternate;
                                    var _wasHidden = _current2 !== null && _current2.memoizedState !== null;
                                    var offscreenBoundary = finishedWork;
                                    if (supportsMutation) {
                                        hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
                                    }
                                    {
                                        if (_isHidden) {
                                            if (!_wasHidden) {
                                                if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                                                    nextEffect = offscreenBoundary;
                                                    var offscreenChild = offscreenBoundary.child;
                                                    while(offscreenChild !== null){
                                                        nextEffect = offscreenChild;
                                                        disappearLayoutEffects_begin(offscreenChild);
                                                        offscreenChild = offscreenChild.sibling;
                                                    }
                                                }
                                            }
                                        }
                                        break;
                                    }
                                }
                        }
                    }
                    var primaryFlags = flags & (Placement | Update | Hydrating);
                    switch(primaryFlags){
                        case Placement:
                            {
                                commitPlacement(finishedWork);
                                finishedWork.flags &= ~Placement;
                                break;
                            }
                        case PlacementAndUpdate:
                            {
                                commitPlacement(finishedWork);
                                finishedWork.flags &= ~Placement;
                                var _current3 = finishedWork.alternate;
                                commitWork(_current3, finishedWork);
                                break;
                            }
                        case Hydrating:
                            {
                                finishedWork.flags &= ~Hydrating;
                                break;
                            }
                        case HydratingAndUpdate:
                            {
                                finishedWork.flags &= ~Hydrating;
                                var _current4 = finishedWork.alternate;
                                commitWork(_current4, finishedWork);
                                break;
                            }
                        case Update:
                            {
                                var _current5 = finishedWork.alternate;
                                commitWork(_current5, finishedWork);
                                break;
                            }
                    }
                }
                function commitLayoutEffects(finishedWork, root, committedLanes) {
                    inProgressLanes = committedLanes;
                    inProgressRoot = root;
                    nextEffect = finishedWork;
                    commitLayoutEffects_begin(finishedWork, root, committedLanes);
                    inProgressLanes = null;
                    inProgressRoot = null;
                }
                function commitLayoutEffects_begin(subtreeRoot, root, committedLanes) {
                    var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
                    while(nextEffect !== null){
                        var fiber = nextEffect;
                        var firstChild = fiber.child;
                        if (fiber.tag === OffscreenComponent && isModernRoot) {
                            var isHidden = fiber.memoizedState !== null;
                            var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;
                            if (newOffscreenSubtreeIsHidden) {
                                commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);
                                continue;
                            } else {
                                var current2 = fiber.alternate;
                                var wasHidden = current2 !== null && current2.memoizedState !== null;
                                var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
                                var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
                                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                                offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
                                offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
                                if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                                    nextEffect = fiber;
                                    reappearLayoutEffects_begin(fiber);
                                }
                                var child = firstChild;
                                while(child !== null){
                                    nextEffect = child;
                                    commitLayoutEffects_begin(child, // New root; bubble back up to here and stop.
                                    root, committedLanes);
                                    child = child.sibling;
                                }
                                nextEffect = fiber;
                                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                                commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);
                                continue;
                            }
                        }
                        if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
                            ensureCorrectReturnPointer(firstChild, fiber);
                            nextEffect = firstChild;
                        } else {
                            commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);
                        }
                    }
                }
                function commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes) {
                    while(nextEffect !== null){
                        var fiber = nextEffect;
                        if ((fiber.flags & LayoutMask) !== NoFlags) {
                            var current2 = fiber.alternate;
                            setCurrentFiber(fiber);
                            try {
                                commitLayoutEffectOnFiber(root, current2, fiber, committedLanes);
                            } catch (error2) {
                                reportUncaughtErrorInDEV(error2);
                                captureCommitPhaseError(fiber, fiber.return, error2);
                            }
                            resetCurrentFiber();
                        }
                        if (fiber === subtreeRoot) {
                            nextEffect = null;
                            return;
                        }
                        var sibling = fiber.sibling;
                        if (sibling !== null) {
                            ensureCorrectReturnPointer(sibling, fiber.return);
                            nextEffect = sibling;
                            return;
                        }
                        nextEffect = fiber.return;
                    }
                }
                function disappearLayoutEffects_begin(subtreeRoot) {
                    while(nextEffect !== null){
                        var fiber = nextEffect;
                        var firstChild = fiber.child;
                        switch(fiber.tag){
                            case FunctionComponent:
                            case ForwardRef:
                            case MemoComponent:
                            case SimpleMemoComponent:
                                {
                                    if (fiber.mode & ProfileMode) {
                                        try {
                                            startLayoutEffectTimer();
                                            commitHookEffectListUnmount(Layout, fiber, fiber.return);
                                        } finally{
                                            recordLayoutEffectDuration(fiber);
                                        }
                                    } else {
                                        commitHookEffectListUnmount(Layout, fiber, fiber.return);
                                    }
                                    break;
                                }
                            case ClassComponent:
                                {
                                    safelyDetachRef(fiber, fiber.return);
                                    var instance = fiber.stateNode;
                                    if (typeof instance.componentWillUnmount === "function") {
                                        safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                                    }
                                    break;
                                }
                            case HostComponent2:
                                {
                                    safelyDetachRef(fiber, fiber.return);
                                    break;
                                }
                            case OffscreenComponent:
                                {
                                    var isHidden = fiber.memoizedState !== null;
                                    if (isHidden) {
                                        disappearLayoutEffects_complete(subtreeRoot);
                                        continue;
                                    }
                                    break;
                                }
                        }
                        if (firstChild !== null) {
                            firstChild.return = fiber;
                            nextEffect = firstChild;
                        } else {
                            disappearLayoutEffects_complete(subtreeRoot);
                        }
                    }
                }
                function disappearLayoutEffects_complete(subtreeRoot) {
                    while(nextEffect !== null){
                        var fiber = nextEffect;
                        if (fiber === subtreeRoot) {
                            nextEffect = null;
                            return;
                        }
                        var sibling = fiber.sibling;
                        if (sibling !== null) {
                            sibling.return = fiber.return;
                            nextEffect = sibling;
                            return;
                        }
                        nextEffect = fiber.return;
                    }
                }
                function reappearLayoutEffects_begin(subtreeRoot) {
                    while(nextEffect !== null){
                        var fiber = nextEffect;
                        var firstChild = fiber.child;
                        if (fiber.tag === OffscreenComponent) {
                            var isHidden = fiber.memoizedState !== null;
                            if (isHidden) {
                                reappearLayoutEffects_complete(subtreeRoot);
                                continue;
                            }
                        }
                        if (firstChild !== null) {
                            firstChild.return = fiber;
                            nextEffect = firstChild;
                        } else {
                            reappearLayoutEffects_complete(subtreeRoot);
                        }
                    }
                }
                function reappearLayoutEffects_complete(subtreeRoot) {
                    while(nextEffect !== null){
                        var fiber = nextEffect;
                        setCurrentFiber(fiber);
                        try {
                            reappearLayoutEffectsOnFiber(fiber);
                        } catch (error2) {
                            reportUncaughtErrorInDEV(error2);
                            captureCommitPhaseError(fiber, fiber.return, error2);
                        }
                        resetCurrentFiber();
                        if (fiber === subtreeRoot) {
                            nextEffect = null;
                            return;
                        }
                        var sibling = fiber.sibling;
                        if (sibling !== null) {
                            sibling.return = fiber.return;
                            nextEffect = sibling;
                            return;
                        }
                        nextEffect = fiber.return;
                    }
                }
                function commitPassiveMountEffects(root, finishedWork) {
                    nextEffect = finishedWork;
                    commitPassiveMountEffects_begin(finishedWork, root);
                }
                function commitPassiveMountEffects_begin(subtreeRoot, root) {
                    while(nextEffect !== null){
                        var fiber = nextEffect;
                        var firstChild = fiber.child;
                        if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
                            ensureCorrectReturnPointer(firstChild, fiber);
                            nextEffect = firstChild;
                        } else {
                            commitPassiveMountEffects_complete(subtreeRoot, root);
                        }
                    }
                }
                function commitPassiveMountEffects_complete(subtreeRoot, root) {
                    while(nextEffect !== null){
                        var fiber = nextEffect;
                        if ((fiber.flags & Passive) !== NoFlags) {
                            setCurrentFiber(fiber);
                            try {
                                commitPassiveMountOnFiber(root, fiber);
                            } catch (error2) {
                                reportUncaughtErrorInDEV(error2);
                                captureCommitPhaseError(fiber, fiber.return, error2);
                            }
                            resetCurrentFiber();
                        }
                        if (fiber === subtreeRoot) {
                            nextEffect = null;
                            return;
                        }
                        var sibling = fiber.sibling;
                        if (sibling !== null) {
                            ensureCorrectReturnPointer(sibling, fiber.return);
                            nextEffect = sibling;
                            return;
                        }
                        nextEffect = fiber.return;
                    }
                }
                function commitPassiveMountOnFiber(finishedRoot, finishedWork) {
                    switch(finishedWork.tag){
                        case FunctionComponent:
                        case ForwardRef:
                        case SimpleMemoComponent:
                            {
                                if (finishedWork.mode & ProfileMode) {
                                    startPassiveEffectTimer();
                                    try {
                                        commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                                    } finally{
                                        recordPassiveEffectDuration(finishedWork);
                                    }
                                } else {
                                    commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                                }
                                break;
                            }
                    }
                }
                function commitPassiveUnmountEffects(firstChild) {
                    nextEffect = firstChild;
                    commitPassiveUnmountEffects_begin();
                }
                function commitPassiveUnmountEffects_begin() {
                    while(nextEffect !== null){
                        var fiber = nextEffect;
                        var child = fiber.child;
                        if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
                            var deletions = fiber.deletions;
                            if (deletions !== null) {
                                for(var i = 0; i < deletions.length; i++){
                                    var fiberToDelete = deletions[i];
                                    nextEffect = fiberToDelete;
                                    commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
                                }
                                {
                                    var previousFiber = fiber.alternate;
                                    if (previousFiber !== null) {
                                        var detachedChild = previousFiber.child;
                                        if (detachedChild !== null) {
                                            previousFiber.child = null;
                                            do {
                                                var detachedSibling = detachedChild.sibling;
                                                detachedChild.sibling = null;
                                                detachedChild = detachedSibling;
                                            }while (detachedChild !== null)
                                        }
                                    }
                                }
                                nextEffect = fiber;
                            }
                        }
                        if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
                            ensureCorrectReturnPointer(child, fiber);
                            nextEffect = child;
                        } else {
                            commitPassiveUnmountEffects_complete();
                        }
                    }
                }
                function commitPassiveUnmountEffects_complete() {
                    while(nextEffect !== null){
                        var fiber = nextEffect;
                        if ((fiber.flags & Passive) !== NoFlags) {
                            setCurrentFiber(fiber);
                            commitPassiveUnmountOnFiber(fiber);
                            resetCurrentFiber();
                        }
                        var sibling = fiber.sibling;
                        if (sibling !== null) {
                            ensureCorrectReturnPointer(sibling, fiber.return);
                            nextEffect = sibling;
                            return;
                        }
                        nextEffect = fiber.return;
                    }
                }
                function commitPassiveUnmountOnFiber(finishedWork) {
                    switch(finishedWork.tag){
                        case FunctionComponent:
                        case ForwardRef:
                        case SimpleMemoComponent:
                            {
                                if (finishedWork.mode & ProfileMode) {
                                    startPassiveEffectTimer();
                                    commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                                    recordPassiveEffectDuration(finishedWork);
                                } else {
                                    commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                                }
                                break;
                            }
                    }
                }
                function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
                    while(nextEffect !== null){
                        var fiber = nextEffect;
                        setCurrentFiber(fiber);
                        commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
                        resetCurrentFiber();
                        var child = fiber.child;
                        if (child !== null) {
                            ensureCorrectReturnPointer(child, fiber);
                            nextEffect = child;
                        } else {
                            commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
                        }
                    }
                }
                function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
                    while(nextEffect !== null){
                        var fiber = nextEffect;
                        var sibling = fiber.sibling;
                        var returnFiber = fiber.return;
                        {
                            detachFiberAfterEffects(fiber);
                            if (fiber === deletedSubtreeRoot) {
                                nextEffect = null;
                                return;
                            }
                        }
                        if (sibling !== null) {
                            ensureCorrectReturnPointer(sibling, returnFiber);
                            nextEffect = sibling;
                            return;
                        }
                        nextEffect = returnFiber;
                    }
                }
                function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
                    switch(current2.tag){
                        case FunctionComponent:
                        case ForwardRef:
                        case SimpleMemoComponent:
                            {
                                if (current2.mode & ProfileMode) {
                                    startPassiveEffectTimer();
                                    commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                                    recordPassiveEffectDuration(current2);
                                } else {
                                    commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                                }
                                break;
                            }
                    }
                }
                var didWarnWrongReturnPointer = false;
                function ensureCorrectReturnPointer(fiber, expectedReturnFiber) {
                    {
                        if (!didWarnWrongReturnPointer && fiber.return !== expectedReturnFiber) {
                            didWarnWrongReturnPointer = true;
                            error("Internal React error: Return pointer is inconsistent with parent.");
                        }
                    }
                    fiber.return = expectedReturnFiber;
                }
                function invokeLayoutEffectMountInDEV(fiber) {
                    {
                        switch(fiber.tag){
                            case FunctionComponent:
                            case ForwardRef:
                            case SimpleMemoComponent:
                                {
                                    try {
                                        commitHookEffectListMount(Layout | HasEffect, fiber);
                                    } catch (error2) {
                                        reportUncaughtErrorInDEV(error2);
                                        captureCommitPhaseError(fiber, fiber.return, error2);
                                    }
                                    break;
                                }
                            case ClassComponent:
                                {
                                    var instance = fiber.stateNode;
                                    try {
                                        instance.componentDidMount();
                                    } catch (error2) {
                                        reportUncaughtErrorInDEV(error2);
                                        captureCommitPhaseError(fiber, fiber.return, error2);
                                    }
                                    break;
                                }
                        }
                    }
                }
                function invokePassiveEffectMountInDEV(fiber) {
                    {
                        switch(fiber.tag){
                            case FunctionComponent:
                            case ForwardRef:
                            case SimpleMemoComponent:
                                {
                                    try {
                                        commitHookEffectListMount(Passive$1 | HasEffect, fiber);
                                    } catch (error2) {
                                        reportUncaughtErrorInDEV(error2);
                                        captureCommitPhaseError(fiber, fiber.return, error2);
                                    }
                                    break;
                                }
                        }
                    }
                }
                function invokeLayoutEffectUnmountInDEV(fiber) {
                    {
                        switch(fiber.tag){
                            case FunctionComponent:
                            case ForwardRef:
                            case SimpleMemoComponent:
                                {
                                    try {
                                        commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
                                    } catch (error2) {
                                        reportUncaughtErrorInDEV(error2);
                                        captureCommitPhaseError(fiber, fiber.return, error2);
                                    }
                                    break;
                                }
                            case ClassComponent:
                                {
                                    var instance = fiber.stateNode;
                                    if (typeof instance.componentWillUnmount === "function") {
                                        safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                                    }
                                    break;
                                }
                        }
                    }
                }
                function invokePassiveEffectUnmountInDEV(fiber) {
                    {
                        switch(fiber.tag){
                            case FunctionComponent:
                            case ForwardRef:
                            case SimpleMemoComponent:
                                {
                                    try {
                                        commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
                                    } catch (error2) {
                                        reportUncaughtErrorInDEV(error2);
                                        captureCommitPhaseError(fiber, fiber.return, error2);
                                    }
                                }
                        }
                    }
                }
                var COMPONENT_TYPE = 0;
                var HAS_PSEUDO_CLASS_TYPE = 1;
                var ROLE_TYPE = 2;
                var TEST_NAME_TYPE = 3;
                var TEXT_TYPE = 4;
                if (typeof Symbol === "function" && Symbol.for) {
                    var symbolFor = Symbol.for;
                    COMPONENT_TYPE = symbolFor("selector.component");
                    HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
                    ROLE_TYPE = symbolFor("selector.role");
                    TEST_NAME_TYPE = symbolFor("selector.test_id");
                    TEXT_TYPE = symbolFor("selector.text");
                }
                function createComponentSelector(component) {
                    return {
                        $$typeof: COMPONENT_TYPE,
                        value: component
                    };
                }
                function createHasPseudoClassSelector(selectors) {
                    return {
                        $$typeof: HAS_PSEUDO_CLASS_TYPE,
                        value: selectors
                    };
                }
                function createRoleSelector(role) {
                    return {
                        $$typeof: ROLE_TYPE,
                        value: role
                    };
                }
                function createTextSelector(text) {
                    return {
                        $$typeof: TEXT_TYPE,
                        value: text
                    };
                }
                function createTestNameSelector(id) {
                    return {
                        $$typeof: TEST_NAME_TYPE,
                        value: id
                    };
                }
                function findFiberRootForHostRoot(hostRoot) {
                    var maybeFiber = getInstanceFromNode2(hostRoot);
                    if (maybeFiber != null) {
                        if (typeof maybeFiber.memoizedProps["data-testname"] !== "string") {
                            throw new Error("Invalid host root specified. Should be either a React container or a node with a testname attribute.");
                        }
                        return maybeFiber;
                    } else {
                        var fiberRoot = findFiberRoot(hostRoot);
                        if (fiberRoot === null) {
                            throw new Error("Could not find React container within specified host subtree.");
                        }
                        return fiberRoot.stateNode.current;
                    }
                }
                function matchSelector2(fiber, selector) {
                    switch(selector.$$typeof){
                        case COMPONENT_TYPE:
                            if (fiber.type === selector.value) {
                                return true;
                            }
                            break;
                        case HAS_PSEUDO_CLASS_TYPE:
                            return hasMatchingPaths(fiber, selector.value);
                        case ROLE_TYPE:
                            if (fiber.tag === HostComponent2) {
                                var node = fiber.stateNode;
                                if (matchAccessibilityRole(node, selector.value)) {
                                    return true;
                                }
                            }
                            break;
                        case TEXT_TYPE:
                            if (fiber.tag === HostComponent2 || fiber.tag === HostText2) {
                                var textContent = getTextContent(fiber);
                                if (textContent !== null && textContent.indexOf(selector.value) >= 0) {
                                    return true;
                                }
                            }
                            break;
                        case TEST_NAME_TYPE:
                            if (fiber.tag === HostComponent2) {
                                var dataTestID = fiber.memoizedProps["data-testname"];
                                if (typeof dataTestID === "string" && dataTestID.toLowerCase() === selector.value.toLowerCase()) {
                                    return true;
                                }
                            }
                            break;
                        default:
                            throw new Error("Invalid selector type specified.");
                    }
                    return false;
                }
                function selectorToString(selector) {
                    switch(selector.$$typeof){
                        case COMPONENT_TYPE:
                            var displayName = getComponentNameFromType(selector.value) || "Unknown";
                            return "<" + displayName + ">";
                        case HAS_PSEUDO_CLASS_TYPE:
                            return ":has(" + (selectorToString(selector) || "") + ")";
                        case ROLE_TYPE:
                            return '[role="' + selector.value + '"]';
                        case TEXT_TYPE:
                            return '"' + selector.value + '"';
                        case TEST_NAME_TYPE:
                            return '[data-testname="' + selector.value + '"]';
                        default:
                            throw new Error("Invalid selector type specified.");
                    }
                }
                function findPaths(root, selectors) {
                    var matchingFibers = [];
                    var stack = [
                        root,
                        0
                    ];
                    var index2 = 0;
                    while(index2 < stack.length){
                        var fiber = stack[index2++];
                        var selectorIndex = stack[index2++];
                        var selector = selectors[selectorIndex];
                        if (fiber.tag === HostComponent2 && isHiddenSubtree(fiber)) {
                            continue;
                        } else {
                            while(selector != null && matchSelector2(fiber, selector)){
                                selectorIndex++;
                                selector = selectors[selectorIndex];
                            }
                        }
                        if (selectorIndex === selectors.length) {
                            matchingFibers.push(fiber);
                        } else {
                            var child = fiber.child;
                            while(child !== null){
                                stack.push(child, selectorIndex);
                                child = child.sibling;
                            }
                        }
                    }
                    return matchingFibers;
                }
                function hasMatchingPaths(root, selectors) {
                    var stack = [
                        root,
                        0
                    ];
                    var index2 = 0;
                    while(index2 < stack.length){
                        var fiber = stack[index2++];
                        var selectorIndex = stack[index2++];
                        var selector = selectors[selectorIndex];
                        if (fiber.tag === HostComponent2 && isHiddenSubtree(fiber)) {
                            continue;
                        } else {
                            while(selector != null && matchSelector2(fiber, selector)){
                                selectorIndex++;
                                selector = selectors[selectorIndex];
                            }
                        }
                        if (selectorIndex === selectors.length) {
                            return true;
                        } else {
                            var child = fiber.child;
                            while(child !== null){
                                stack.push(child, selectorIndex);
                                child = child.sibling;
                            }
                        }
                    }
                    return false;
                }
                function findAllNodes(hostRoot, selectors) {
                    if (!supportsTestSelectors) {
                        throw new Error("Test selector API is not supported by this renderer.");
                    }
                    var root = findFiberRootForHostRoot(hostRoot);
                    var matchingFibers = findPaths(root, selectors);
                    var instanceRoots = [];
                    var stack = Array.from(matchingFibers);
                    var index2 = 0;
                    while(index2 < stack.length){
                        var node = stack[index2++];
                        if (node.tag === HostComponent2) {
                            if (isHiddenSubtree(node)) {
                                continue;
                            }
                            instanceRoots.push(node.stateNode);
                        } else {
                            var child = node.child;
                            while(child !== null){
                                stack.push(child);
                                child = child.sibling;
                            }
                        }
                    }
                    return instanceRoots;
                }
                function getFindAllNodesFailureDescription(hostRoot, selectors) {
                    if (!supportsTestSelectors) {
                        throw new Error("Test selector API is not supported by this renderer.");
                    }
                    var root = findFiberRootForHostRoot(hostRoot);
                    var maxSelectorIndex = 0;
                    var matchedNames = [];
                    var stack = [
                        root,
                        0
                    ];
                    var index2 = 0;
                    while(index2 < stack.length){
                        var fiber = stack[index2++];
                        var selectorIndex = stack[index2++];
                        var selector = selectors[selectorIndex];
                        if (fiber.tag === HostComponent2 && isHiddenSubtree(fiber)) {
                            continue;
                        } else if (matchSelector2(fiber, selector)) {
                            matchedNames.push(selectorToString(selector));
                            selectorIndex++;
                            if (selectorIndex > maxSelectorIndex) {
                                maxSelectorIndex = selectorIndex;
                            }
                        }
                        if (selectorIndex < selectors.length) {
                            var child = fiber.child;
                            while(child !== null){
                                stack.push(child, selectorIndex);
                                child = child.sibling;
                            }
                        }
                    }
                    if (maxSelectorIndex < selectors.length) {
                        var unmatchedNames = [];
                        for(var i = maxSelectorIndex; i < selectors.length; i++){
                            unmatchedNames.push(selectorToString(selectors[i]));
                        }
                        return "findAllNodes was able to match part of the selector:\n" + ("  " + matchedNames.join(" > ") + "\n\n") + "No matching component was found for:\n" + ("  " + unmatchedNames.join(" > "));
                    }
                    return null;
                }
                function findBoundingRects(hostRoot, selectors) {
                    if (!supportsTestSelectors) {
                        throw new Error("Test selector API is not supported by this renderer.");
                    }
                    var instanceRoots = findAllNodes(hostRoot, selectors);
                    var boundingRects = [];
                    for(var i = 0; i < instanceRoots.length; i++){
                        boundingRects.push(getBoundingRect(instanceRoots[i]));
                    }
                    for(var _i = boundingRects.length - 1; _i > 0; _i--){
                        var targetRect = boundingRects[_i];
                        var targetLeft = targetRect.x;
                        var targetRight = targetLeft + targetRect.width;
                        var targetTop = targetRect.y;
                        var targetBottom = targetTop + targetRect.height;
                        for(var j = _i - 1; j >= 0; j--){
                            if (_i !== j) {
                                var otherRect = boundingRects[j];
                                var otherLeft = otherRect.x;
                                var otherRight = otherLeft + otherRect.width;
                                var otherTop = otherRect.y;
                                var otherBottom = otherTop + otherRect.height;
                                if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {
                                    boundingRects.splice(_i, 1);
                                    break;
                                } else if (targetLeft === otherLeft && targetRect.width === otherRect.width && !(otherBottom < targetTop) && !(otherTop > targetBottom)) {
                                    if (otherTop > targetTop) {
                                        otherRect.height += otherTop - targetTop;
                                        otherRect.y = targetTop;
                                    }
                                    if (otherBottom < targetBottom) {
                                        otherRect.height = targetBottom - otherTop;
                                    }
                                    boundingRects.splice(_i, 1);
                                    break;
                                } else if (targetTop === otherTop && targetRect.height === otherRect.height && !(otherRight < targetLeft) && !(otherLeft > targetRight)) {
                                    if (otherLeft > targetLeft) {
                                        otherRect.width += otherLeft - targetLeft;
                                        otherRect.x = targetLeft;
                                    }
                                    if (otherRight < targetRight) {
                                        otherRect.width = targetRight - otherLeft;
                                    }
                                    boundingRects.splice(_i, 1);
                                    break;
                                }
                            }
                        }
                    }
                    return boundingRects;
                }
                function focusWithin(hostRoot, selectors) {
                    if (!supportsTestSelectors) {
                        throw new Error("Test selector API is not supported by this renderer.");
                    }
                    var root = findFiberRootForHostRoot(hostRoot);
                    var matchingFibers = findPaths(root, selectors);
                    var stack = Array.from(matchingFibers);
                    var index2 = 0;
                    while(index2 < stack.length){
                        var fiber = stack[index2++];
                        if (isHiddenSubtree(fiber)) {
                            continue;
                        }
                        if (fiber.tag === HostComponent2) {
                            var node = fiber.stateNode;
                            if (setFocusIfFocusable(node)) {
                                return true;
                            }
                        }
                        var child = fiber.child;
                        while(child !== null){
                            stack.push(child);
                            child = child.sibling;
                        }
                    }
                    return false;
                }
                var commitHooks = [];
                function onCommitRoot$1() {
                    if (supportsTestSelectors) {
                        commitHooks.forEach(function(commitHook) {
                            return commitHook();
                        });
                    }
                }
                function observeVisibleRects(hostRoot, selectors, callback, options) {
                    if (!supportsTestSelectors) {
                        throw new Error("Test selector API is not supported by this renderer.");
                    }
                    var instanceRoots = findAllNodes(hostRoot, selectors);
                    var _setupIntersectionObs = setupIntersectionObserver(instanceRoots, callback, options), disconnect = _setupIntersectionObs.disconnect, observe = _setupIntersectionObs.observe, unobserve = _setupIntersectionObs.unobserve;
                    var commitHook = function() {
                        var nextInstanceRoots = findAllNodes(hostRoot, selectors);
                        instanceRoots.forEach(function(target) {
                            if (nextInstanceRoots.indexOf(target) < 0) {
                                unobserve(target);
                            }
                        });
                        nextInstanceRoots.forEach(function(target) {
                            if (instanceRoots.indexOf(target) < 0) {
                                observe(target);
                            }
                        });
                    };
                    commitHooks.push(commitHook);
                    return {
                        disconnect: function() {
                            var index2 = commitHooks.indexOf(commitHook);
                            if (index2 >= 0) {
                                commitHooks.splice(index2, 1);
                            }
                            disconnect();
                        }
                    };
                }
                var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
                function isLegacyActEnvironment(fiber) {
                    {
                        var isReactActEnvironmentGlobal = // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
                        typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0;
                        var jestIsDefined = typeof jest !== "undefined";
                        return warnsIfNotActing && jestIsDefined && isReactActEnvironmentGlobal !== false;
                    }
                }
                function isConcurrentActEnvironment() {
                    {
                        var isReactActEnvironmentGlobal = // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
                        typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0;
                        if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
                            error("The current testing environment is not configured to support act(...)");
                        }
                        return isReactActEnvironmentGlobal;
                    }
                }
                var ceil = Math.ceil;
                var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
                var NoContext = /*             */ 0;
                var BatchedContext = /*               */ 1;
                var RenderContext = /*                */ 2;
                var CommitContext = /*                */ 4;
                var RootInProgress = 0;
                var RootFatalErrored = 1;
                var RootErrored = 2;
                var RootSuspended = 3;
                var RootSuspendedWithDelay = 4;
                var RootCompleted = 5;
                var RootDidNotComplete = 6;
                var executionContext = NoContext;
                var workInProgressRoot = null;
                var workInProgress = null;
                var workInProgressRootRenderLanes = NoLanes;
                var subtreeRenderLanes = NoLanes;
                var subtreeRenderLanesCursor = createCursor(NoLanes);
                var workInProgressRootExitStatus = RootInProgress;
                var workInProgressRootFatalError = null;
                var workInProgressRootIncludedLanes = NoLanes;
                var workInProgressRootSkippedLanes = NoLanes;
                var workInProgressRootInterleavedUpdatedLanes = NoLanes;
                var workInProgressRootPingedLanes = NoLanes;
                var workInProgressRootConcurrentErrors = null;
                var workInProgressRootRecoverableErrors = null;
                var globalMostRecentFallbackTime = 0;
                var FALLBACK_THROTTLE_MS = 500;
                var workInProgressRootRenderTargetTime = Infinity;
                var RENDER_TIMEOUT_MS = 500;
                function resetRenderTimer() {
                    workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
                }
                function getRenderTargetTime() {
                    return workInProgressRootRenderTargetTime;
                }
                var hasUncaughtError = false;
                var firstUncaughtError = null;
                var legacyErrorBoundariesThatAlreadyFailed = null;
                var rootDoesHavePassiveEffects = false;
                var rootWithPendingPassiveEffects = null;
                var pendingPassiveEffectsLanes = NoLanes;
                var pendingPassiveProfilerEffects = [];
                var NESTED_UPDATE_LIMIT = 50;
                var nestedUpdateCount = 0;
                var rootWithNestedUpdates = null;
                var NESTED_PASSIVE_UPDATE_LIMIT = 50;
                var nestedPassiveUpdateCount = 0;
                var currentEventTime = NoTimestamp;
                var currentEventTransitionLane = NoLanes;
                function getWorkInProgressRoot() {
                    return workInProgressRoot;
                }
                function requestEventTime() {
                    if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
                        return now$1();
                    }
                    if (currentEventTime !== NoTimestamp) {
                        return currentEventTime;
                    }
                    currentEventTime = now$1();
                    return currentEventTime;
                }
                function requestUpdateLane(fiber) {
                    var mode = fiber.mode;
                    if ((mode & ConcurrentMode) === NoMode) {
                        return SyncLane;
                    } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
                        return pickArbitraryLane(workInProgressRootRenderLanes);
                    }
                    var isTransition = requestCurrentTransition() !== NoTransition;
                    if (isTransition) {
                        if (ReactCurrentBatchConfig$2.transition !== null) {
                            var transition = ReactCurrentBatchConfig$2.transition;
                            if (!transition._updatedFibers) {
                                transition._updatedFibers = /* @__PURE__ */ new Set();
                            }
                            transition._updatedFibers.add(fiber);
                        }
                        if (currentEventTransitionLane === NoLane) {
                            currentEventTransitionLane = claimNextTransitionLane();
                        }
                        return currentEventTransitionLane;
                    }
                    var updateLane = getCurrentUpdatePriority();
                    if (updateLane !== NoLane) {
                        return updateLane;
                    }
                    var eventLane = getCurrentEventPriority();
                    return eventLane;
                }
                function requestRetryLane(fiber) {
                    var mode = fiber.mode;
                    if ((mode & ConcurrentMode) === NoMode) {
                        return SyncLane;
                    }
                    return claimNextRetryLane();
                }
                function scheduleUpdateOnFiber(fiber, lane, eventTime) {
                    checkForNestedUpdates();
                    var root = markUpdateLaneFromFiberToRoot(fiber, lane);
                    if (root === null) {
                        return null;
                    }
                    markRootUpdated(root, lane, eventTime);
                    if ((executionContext & RenderContext) !== NoLanes && root === workInProgressRoot) {
                        warnAboutRenderPhaseUpdatesInDEV(fiber);
                    } else {
                        {
                            if (isDevToolsPresent) {
                                addFiberToLanesMap(root, fiber, lane);
                            }
                        }
                        warnIfUpdatesNotWrappedWithActDEV(fiber);
                        if (root === workInProgressRoot) {
                            if ((executionContext & RenderContext) === NoContext) {
                                workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
                            }
                            if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                                markRootSuspended$1(root, workInProgressRootRenderLanes);
                            }
                        }
                        ensureRootIsScheduled(root, eventTime);
                        if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
                        !ReactCurrentActQueue$1.isBatchingLegacy) {
                            resetRenderTimer();
                            flushSyncCallbacksOnlyInLegacyMode();
                        }
                    }
                    return root;
                }
                function scheduleInitialHydrationOnRoot(root, lane, eventTime) {
                    var current2 = root.current;
                    current2.lanes = lane;
                    markRootUpdated(root, lane, eventTime);
                    ensureRootIsScheduled(root, eventTime);
                }
                function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
                    sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
                    var alternate = sourceFiber.alternate;
                    if (alternate !== null) {
                        alternate.lanes = mergeLanes(alternate.lanes, lane);
                    }
                    {
                        if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
                            warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                        }
                    }
                    var node = sourceFiber;
                    var parent = sourceFiber.return;
                    while(parent !== null){
                        parent.childLanes = mergeLanes(parent.childLanes, lane);
                        alternate = parent.alternate;
                        if (alternate !== null) {
                            alternate.childLanes = mergeLanes(alternate.childLanes, lane);
                        } else {
                            {
                                if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                                }
                            }
                        }
                        node = parent;
                        parent = parent.return;
                    }
                    if (node.tag === HostRoot2) {
                        var root = node.stateNode;
                        return root;
                    } else {
                        return null;
                    }
                }
                function isInterleavedUpdate(fiber, lane) {
                    return(// TODO: Optimize slightly by comparing to root that fiber belongs to.
                    // Requires some refactoring. Not a big deal though since it's rare for
                    // concurrent apps to have more than a single root.
                    workInProgressRoot !== null && (fiber.mode & ConcurrentMode) !== NoMode && // If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),
                    // then don't treat this as an interleaved update. This pattern is
                    // accompanied by a warning but we haven't fully deprecated it yet. We can
                    // remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.
                    (executionContext & RenderContext) === NoContext);
                }
                function ensureRootIsScheduled(root, currentTime) {
                    var existingCallbackNode = root.callbackNode;
                    markStarvedLanesAsExpired(root, currentTime);
                    var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
                    if (nextLanes === NoLanes) {
                        if (existingCallbackNode !== null) {
                            cancelCallback$1(existingCallbackNode);
                        }
                        root.callbackNode = null;
                        root.callbackPriority = NoLane;
                        return;
                    }
                    var newCallbackPriority = getHighestPriorityLane(nextLanes);
                    var existingCallbackPriority = root.callbackPriority;
                    if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a
                    // Scheduler task, rather than an `act` task, cancel it and re-scheduled
                    // on the `act` queue.
                    !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
                        {
                            if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
                                error("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
                            }
                        }
                        return;
                    }
                    if (existingCallbackNode != null) {
                        cancelCallback$1(existingCallbackNode);
                    }
                    var newCallbackNode;
                    if (newCallbackPriority === SyncLane) {
                        if (root.tag === LegacyRoot) {
                            if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
                                ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
                            }
                            scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));
                        } else {
                            scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
                        }
                        if (supportsMicrotasks) {
                            if (ReactCurrentActQueue$1.current !== null) {
                                ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
                            } else {
                                scheduleMicrotask(function() {
                                    if (executionContext === NoContext) {
                                        flushSyncCallbacks();
                                    }
                                });
                            }
                        } else {
                            scheduleCallback$1(ImmediatePriority, flushSyncCallbacks);
                        }
                        newCallbackNode = null;
                    } else {
                        var schedulerPriorityLevel;
                        switch(lanesToEventPriority(nextLanes)){
                            case DiscreteEventPriority:
                                schedulerPriorityLevel = ImmediatePriority;
                                break;
                            case ContinuousEventPriority:
                                schedulerPriorityLevel = UserBlockingPriority;
                                break;
                            case DefaultEventPriority:
                                schedulerPriorityLevel = NormalPriority;
                                break;
                            case IdleEventPriority:
                                schedulerPriorityLevel = IdlePriority;
                                break;
                            default:
                                schedulerPriorityLevel = NormalPriority;
                                break;
                        }
                        newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));
                    }
                    root.callbackPriority = newCallbackPriority;
                    root.callbackNode = newCallbackNode;
                }
                function performConcurrentWorkOnRoot(root, didTimeout) {
                    {
                        resetNestedUpdateFlag();
                    }
                    currentEventTime = NoTimestamp;
                    currentEventTransitionLane = NoLanes;
                    if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
                        throw new Error("Should not already be working.");
                    }
                    var originalCallbackNode = root.callbackNode;
                    var didFlushPassiveEffects = flushPassiveEffects();
                    if (didFlushPassiveEffects) {
                        if (root.callbackNode !== originalCallbackNode) {
                            return null;
                        }
                    }
                    var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
                    if (lanes === NoLanes) {
                        return null;
                    }
                    var shouldTimeSlice = !includesBlockingLane(root, lanes) && !includesExpiredLane(root, lanes) && !didTimeout;
                    var exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);
                    if (exitStatus !== RootInProgress) {
                        if (exitStatus === RootErrored) {
                            var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);
                            if (errorRetryLanes !== NoLanes) {
                                lanes = errorRetryLanes;
                                exitStatus = recoverFromConcurrentError(root, errorRetryLanes);
                            }
                        }
                        if (exitStatus === RootFatalErrored) {
                            var fatalError = workInProgressRootFatalError;
                            prepareFreshStack(root, NoLanes);
                            markRootSuspended$1(root, lanes);
                            ensureRootIsScheduled(root, now$1());
                            throw fatalError;
                        }
                        if (exitStatus === RootDidNotComplete) {
                            markRootSuspended$1(root, lanes);
                        } else {
                            var renderWasConcurrent = !includesBlockingLane(root, lanes);
                            var finishedWork = root.current.alternate;
                            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
                                exitStatus = renderRootSync(root, lanes);
                                if (exitStatus === RootErrored) {
                                    var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);
                                    if (_errorRetryLanes !== NoLanes) {
                                        lanes = _errorRetryLanes;
                                        exitStatus = recoverFromConcurrentError(root, _errorRetryLanes);
                                    }
                                }
                                if (exitStatus === RootFatalErrored) {
                                    var _fatalError = workInProgressRootFatalError;
                                    prepareFreshStack(root, NoLanes);
                                    markRootSuspended$1(root, lanes);
                                    ensureRootIsScheduled(root, now$1());
                                    throw _fatalError;
                                }
                            }
                            root.finishedWork = finishedWork;
                            root.finishedLanes = lanes;
                            finishConcurrentRender(root, exitStatus, lanes);
                        }
                    }
                    ensureRootIsScheduled(root, now$1());
                    if (root.callbackNode === originalCallbackNode) {
                        return performConcurrentWorkOnRoot.bind(null, root);
                    }
                    return null;
                }
                function recoverFromConcurrentError(root, errorRetryLanes) {
                    var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
                    if (isRootDehydrated(root)) {
                        var rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);
                        rootWorkInProgress.flags |= ForceClientRender;
                        {
                            errorHydratingContainer(root.containerInfo);
                        }
                    }
                    var exitStatus = renderRootSync(root, errorRetryLanes);
                    if (exitStatus !== RootErrored) {
                        var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
                        workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
                        if (errorsFromSecondAttempt !== null) {
                            queueRecoverableErrors(errorsFromSecondAttempt);
                        }
                    }
                    return exitStatus;
                }
                function queueRecoverableErrors(errors) {
                    if (workInProgressRootRecoverableErrors === null) {
                        workInProgressRootRecoverableErrors = errors;
                    } else {
                        workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
                    }
                }
                function finishConcurrentRender(root, exitStatus, lanes) {
                    switch(exitStatus){
                        case RootInProgress:
                        case RootFatalErrored:
                            {
                                throw new Error("Root did not complete. This is a bug in React.");
                            }
                        case RootErrored:
                            {
                                commitRoot(root, workInProgressRootRecoverableErrors);
                                break;
                            }
                        case RootSuspended:
                            {
                                markRootSuspended$1(root, lanes);
                                if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
                                !shouldForceFlushFallbacksInDEV()) {
                                    var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1();
                                    if (msUntilTimeout > 10) {
                                        var nextLanes = getNextLanes(root, NoLanes);
                                        if (nextLanes !== NoLanes) {
                                            break;
                                        }
                                        var suspendedLanes = root.suspendedLanes;
                                        if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                                            var eventTime = requestEventTime();
                                            markRootPinged(root, suspendedLanes);
                                            break;
                                        }
                                        root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors), msUntilTimeout);
                                        break;
                                    }
                                }
                                commitRoot(root, workInProgressRootRecoverableErrors);
                                break;
                            }
                        case RootSuspendedWithDelay:
                            {
                                markRootSuspended$1(root, lanes);
                                if (includesOnlyTransitions(lanes)) {
                                    break;
                                }
                                if (!shouldForceFlushFallbacksInDEV()) {
                                    var mostRecentEventTime = getMostRecentEventTime(root, lanes);
                                    var eventTimeMs = mostRecentEventTime;
                                    var timeElapsedMs = now$1() - eventTimeMs;
                                    var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                                    if (_msUntilTimeout > 10) {
                                        root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors), _msUntilTimeout);
                                        break;
                                    }
                                }
                                commitRoot(root, workInProgressRootRecoverableErrors);
                                break;
                            }
                        case RootCompleted:
                            {
                                commitRoot(root, workInProgressRootRecoverableErrors);
                                break;
                            }
                        default:
                            {
                                throw new Error("Unknown root exit status.");
                            }
                    }
                }
                function isRenderConsistentWithExternalStores(finishedWork) {
                    var node = finishedWork;
                    while(true){
                        if (node.flags & StoreConsistency) {
                            var updateQueue = node.updateQueue;
                            if (updateQueue !== null) {
                                var checks = updateQueue.stores;
                                if (checks !== null) {
                                    for(var i = 0; i < checks.length; i++){
                                        var check = checks[i];
                                        var getSnapshot = check.getSnapshot;
                                        var renderedValue = check.value;
                                        try {
                                            if (!objectIs(getSnapshot(), renderedValue)) {
                                                return false;
                                            }
                                        } catch (error2) {
                                            return false;
                                        }
                                    }
                                }
                            }
                        }
                        var child = node.child;
                        if (node.subtreeFlags & StoreConsistency && child !== null) {
                            child.return = node;
                            node = child;
                            continue;
                        }
                        if (node === finishedWork) {
                            return true;
                        }
                        while(node.sibling === null){
                            if (node.return === null || node.return === finishedWork) {
                                return true;
                            }
                            node = node.return;
                        }
                        node.sibling.return = node.return;
                        node = node.sibling;
                    }
                    return true;
                }
                function markRootSuspended$1(root, suspendedLanes) {
                    suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
                    suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
                    markRootSuspended(root, suspendedLanes);
                }
                function performSyncWorkOnRoot(root) {
                    {
                        syncNestedUpdateFlag();
                    }
                    if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
                        throw new Error("Should not already be working.");
                    }
                    flushPassiveEffects();
                    var lanes = getNextLanes(root, NoLanes);
                    if (!includesSomeLane(lanes, SyncLane)) {
                        ensureRootIsScheduled(root, now$1());
                        return null;
                    }
                    var exitStatus = renderRootSync(root, lanes);
                    if (root.tag !== LegacyRoot && exitStatus === RootErrored) {
                        var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);
                        if (errorRetryLanes !== NoLanes) {
                            lanes = errorRetryLanes;
                            exitStatus = recoverFromConcurrentError(root, errorRetryLanes);
                        }
                    }
                    if (exitStatus === RootFatalErrored) {
                        var fatalError = workInProgressRootFatalError;
                        prepareFreshStack(root, NoLanes);
                        markRootSuspended$1(root, lanes);
                        ensureRootIsScheduled(root, now$1());
                        throw fatalError;
                    }
                    if (exitStatus === RootDidNotComplete) {
                        throw new Error("Root did not complete. This is a bug in React.");
                    }
                    var finishedWork = root.current.alternate;
                    root.finishedWork = finishedWork;
                    root.finishedLanes = lanes;
                    commitRoot(root, workInProgressRootRecoverableErrors);
                    ensureRootIsScheduled(root, now$1());
                    return null;
                }
                function flushRoot(root, lanes) {
                    if (lanes !== NoLanes) {
                        markRootEntangled(root, mergeLanes(lanes, SyncLane));
                        ensureRootIsScheduled(root, now$1());
                        if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                            resetRenderTimer();
                            flushSyncCallbacks();
                        }
                    }
                }
                function deferredUpdates(fn) {
                    var previousPriority = getCurrentUpdatePriority();
                    var prevTransition = ReactCurrentBatchConfig$2.transition;
                    try {
                        ReactCurrentBatchConfig$2.transition = null;
                        setCurrentUpdatePriority(DefaultEventPriority);
                        return fn();
                    } finally{
                        setCurrentUpdatePriority(previousPriority);
                        ReactCurrentBatchConfig$2.transition = prevTransition;
                    }
                }
                function batchedUpdates(fn, a) {
                    var prevExecutionContext = executionContext;
                    executionContext |= BatchedContext;
                    try {
                        return fn(a);
                    } finally{
                        executionContext = prevExecutionContext;
                        if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
                        !ReactCurrentActQueue$1.isBatchingLegacy) {
                            resetRenderTimer();
                            flushSyncCallbacksOnlyInLegacyMode();
                        }
                    }
                }
                function discreteUpdates(fn, a, b, c, d) {
                    var previousPriority = getCurrentUpdatePriority();
                    var prevTransition = ReactCurrentBatchConfig$2.transition;
                    try {
                        ReactCurrentBatchConfig$2.transition = null;
                        setCurrentUpdatePriority(DiscreteEventPriority);
                        return fn(a, b, c, d);
                    } finally{
                        setCurrentUpdatePriority(previousPriority);
                        ReactCurrentBatchConfig$2.transition = prevTransition;
                        if (executionContext === NoContext) {
                            resetRenderTimer();
                        }
                    }
                }
                function flushSync(fn) {
                    if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
                        flushPassiveEffects();
                    }
                    var prevExecutionContext = executionContext;
                    executionContext |= BatchedContext;
                    var prevTransition = ReactCurrentBatchConfig$2.transition;
                    var previousPriority = getCurrentUpdatePriority();
                    try {
                        ReactCurrentBatchConfig$2.transition = null;
                        setCurrentUpdatePriority(DiscreteEventPriority);
                        if (fn) {
                            return fn();
                        } else {
                            return void 0;
                        }
                    } finally{
                        setCurrentUpdatePriority(previousPriority);
                        ReactCurrentBatchConfig$2.transition = prevTransition;
                        executionContext = prevExecutionContext;
                        if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                            flushSyncCallbacks();
                        }
                    }
                }
                function isAlreadyRendering() {
                    return (executionContext & (RenderContext | CommitContext)) !== NoContext;
                }
                function flushControlled(fn) {
                    var prevExecutionContext = executionContext;
                    executionContext |= BatchedContext;
                    var prevTransition = ReactCurrentBatchConfig$2.transition;
                    var previousPriority = getCurrentUpdatePriority();
                    try {
                        ReactCurrentBatchConfig$2.transition = null;
                        setCurrentUpdatePriority(DiscreteEventPriority);
                        fn();
                    } finally{
                        setCurrentUpdatePriority(previousPriority);
                        ReactCurrentBatchConfig$2.transition = prevTransition;
                        executionContext = prevExecutionContext;
                        if (executionContext === NoContext) {
                            resetRenderTimer();
                            flushSyncCallbacks();
                        }
                    }
                }
                function pushRenderLanes(fiber, lanes) {
                    push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
                    subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
                    workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
                }
                function popRenderLanes(fiber) {
                    subtreeRenderLanes = subtreeRenderLanesCursor.current;
                    pop(subtreeRenderLanesCursor, fiber);
                }
                function prepareFreshStack(root, lanes) {
                    root.finishedWork = null;
                    root.finishedLanes = NoLanes;
                    var timeoutHandle = root.timeoutHandle;
                    if (timeoutHandle !== noTimeout) {
                        root.timeoutHandle = noTimeout;
                        cancelTimeout(timeoutHandle);
                    }
                    if (workInProgress !== null) {
                        var interruptedWork = workInProgress.return;
                        while(interruptedWork !== null){
                            var current2 = interruptedWork.alternate;
                            unwindInterruptedWork(current2, interruptedWork);
                            interruptedWork = interruptedWork.return;
                        }
                    }
                    workInProgressRoot = root;
                    var rootWorkInProgress = createWorkInProgress(root.current, null);
                    workInProgress = rootWorkInProgress;
                    workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
                    workInProgressRootExitStatus = RootInProgress;
                    workInProgressRootFatalError = null;
                    workInProgressRootSkippedLanes = NoLanes;
                    workInProgressRootInterleavedUpdatedLanes = NoLanes;
                    workInProgressRootPingedLanes = NoLanes;
                    workInProgressRootConcurrentErrors = null;
                    workInProgressRootRecoverableErrors = null;
                    enqueueInterleavedUpdates();
                    {
                        ReactStrictModeWarnings.discardPendingWarnings();
                    }
                    return rootWorkInProgress;
                }
                function handleError(root, thrownValue) {
                    do {
                        var erroredWork = workInProgress;
                        try {
                            resetContextDependencies();
                            resetHooksAfterThrow();
                            resetCurrentFiber();
                            ReactCurrentOwner$2.current = null;
                            if (erroredWork === null || erroredWork.return === null) {
                                workInProgressRootExitStatus = RootFatalErrored;
                                workInProgressRootFatalError = thrownValue;
                                workInProgress = null;
                                return;
                            }
                            if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                                stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
                            }
                            if (enableSchedulingProfiler) {
                                markComponentRenderStopped();
                                if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
                                    var wakeable = thrownValue;
                                    markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
                                } else {
                                    markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
                                }
                            }
                            throwException(root, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
                            completeUnitOfWork(erroredWork);
                        } catch (yetAnotherThrownValue) {
                            thrownValue = yetAnotherThrownValue;
                            if (workInProgress === erroredWork && erroredWork !== null) {
                                erroredWork = erroredWork.return;
                                workInProgress = erroredWork;
                            } else {
                                erroredWork = workInProgress;
                            }
                            continue;
                        }
                        return;
                    }while (true)
                }
                function pushDispatcher() {
                    var prevDispatcher = ReactCurrentDispatcher$2.current;
                    ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
                    if (prevDispatcher === null) {
                        return ContextOnlyDispatcher;
                    } else {
                        return prevDispatcher;
                    }
                }
                function popDispatcher(prevDispatcher) {
                    ReactCurrentDispatcher$2.current = prevDispatcher;
                }
                function markCommitTimeOfFallback() {
                    globalMostRecentFallbackTime = now$1();
                }
                function markSkippedUpdateLanes(lane) {
                    workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
                }
                function renderDidSuspend() {
                    if (workInProgressRootExitStatus === RootInProgress) {
                        workInProgressRootExitStatus = RootSuspended;
                    }
                }
                function renderDidSuspendDelayIfPossible() {
                    if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
                        workInProgressRootExitStatus = RootSuspendedWithDelay;
                    }
                    if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
                        markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
                    }
                }
                function renderDidError(error2) {
                    if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
                        workInProgressRootExitStatus = RootErrored;
                    }
                    if (workInProgressRootConcurrentErrors === null) {
                        workInProgressRootConcurrentErrors = [
                            error2
                        ];
                    } else {
                        workInProgressRootConcurrentErrors.push(error2);
                    }
                }
                function renderHasNotSuspendedYet() {
                    return workInProgressRootExitStatus === RootInProgress;
                }
                function renderRootSync(root, lanes) {
                    var prevExecutionContext = executionContext;
                    executionContext |= RenderContext;
                    var prevDispatcher = pushDispatcher();
                    if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
                        {
                            if (isDevToolsPresent) {
                                var memoizedUpdaters = root.memoizedUpdaters;
                                if (memoizedUpdaters.size > 0) {
                                    restorePendingUpdaters(root, workInProgressRootRenderLanes);
                                    memoizedUpdaters.clear();
                                }
                                movePendingFibersToMemoized(root, lanes);
                            }
                        }
                        prepareFreshStack(root, lanes);
                    }
                    {
                        markRenderStarted(lanes);
                    }
                    do {
                        try {
                            workLoopSync();
                            break;
                        } catch (thrownValue) {
                            handleError(root, thrownValue);
                        }
                    }while (true)
                    resetContextDependencies();
                    executionContext = prevExecutionContext;
                    popDispatcher(prevDispatcher);
                    if (workInProgress !== null) {
                        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    {
                        markRenderStopped();
                    }
                    workInProgressRoot = null;
                    workInProgressRootRenderLanes = NoLanes;
                    return workInProgressRootExitStatus;
                }
                function workLoopSync() {
                    while(workInProgress !== null){
                        performUnitOfWork(workInProgress);
                    }
                }
                function renderRootConcurrent(root, lanes) {
                    var prevExecutionContext = executionContext;
                    executionContext |= RenderContext;
                    var prevDispatcher = pushDispatcher();
                    if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
                        {
                            if (isDevToolsPresent) {
                                var memoizedUpdaters = root.memoizedUpdaters;
                                if (memoizedUpdaters.size > 0) {
                                    restorePendingUpdaters(root, workInProgressRootRenderLanes);
                                    memoizedUpdaters.clear();
                                }
                                movePendingFibersToMemoized(root, lanes);
                            }
                        }
                        resetRenderTimer();
                        prepareFreshStack(root, lanes);
                    }
                    {
                        markRenderStarted(lanes);
                    }
                    do {
                        try {
                            workLoopConcurrent();
                            break;
                        } catch (thrownValue) {
                            handleError(root, thrownValue);
                        }
                    }while (true)
                    resetContextDependencies();
                    popDispatcher(prevDispatcher);
                    executionContext = prevExecutionContext;
                    if (workInProgress !== null) {
                        {
                            markRenderYielded();
                        }
                        return RootInProgress;
                    } else {
                        {
                            markRenderStopped();
                        }
                        workInProgressRoot = null;
                        workInProgressRootRenderLanes = NoLanes;
                        return workInProgressRootExitStatus;
                    }
                }
                function workLoopConcurrent() {
                    while(workInProgress !== null && !shouldYield()){
                        performUnitOfWork(workInProgress);
                    }
                }
                function performUnitOfWork(unitOfWork) {
                    var current2 = unitOfWork.alternate;
                    setCurrentFiber(unitOfWork);
                    var next;
                    if ((unitOfWork.mode & ProfileMode) !== NoMode) {
                        startProfilerTimer(unitOfWork);
                        next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
                        stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
                    } else {
                        next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
                    }
                    resetCurrentFiber();
                    unitOfWork.memoizedProps = unitOfWork.pendingProps;
                    if (next === null) {
                        completeUnitOfWork(unitOfWork);
                    } else {
                        workInProgress = next;
                    }
                    ReactCurrentOwner$2.current = null;
                }
                function completeUnitOfWork(unitOfWork) {
                    var completedWork = unitOfWork;
                    do {
                        var current2 = completedWork.alternate;
                        var returnFiber = completedWork.return;
                        if ((completedWork.flags & Incomplete) === NoFlags) {
                            setCurrentFiber(completedWork);
                            var next = void 0;
                            if ((completedWork.mode & ProfileMode) === NoMode) {
                                next = completeWork(current2, completedWork, subtreeRenderLanes);
                            } else {
                                startProfilerTimer(completedWork);
                                next = completeWork(current2, completedWork, subtreeRenderLanes);
                                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                            }
                            resetCurrentFiber();
                            if (next !== null) {
                                workInProgress = next;
                                return;
                            }
                        } else {
                            var _next = unwindWork(current2, completedWork);
                            if (_next !== null) {
                                _next.flags &= HostEffectMask;
                                workInProgress = _next;
                                return;
                            }
                            if ((completedWork.mode & ProfileMode) !== NoMode) {
                                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                                var actualDuration = completedWork.actualDuration;
                                var child = completedWork.child;
                                while(child !== null){
                                    actualDuration += child.actualDuration;
                                    child = child.sibling;
                                }
                                completedWork.actualDuration = actualDuration;
                            }
                            if (returnFiber !== null) {
                                returnFiber.flags |= Incomplete;
                                returnFiber.subtreeFlags = NoFlags;
                                returnFiber.deletions = null;
                            } else {
                                workInProgressRootExitStatus = RootDidNotComplete;
                                workInProgress = null;
                                return;
                            }
                        }
                        var siblingFiber = completedWork.sibling;
                        if (siblingFiber !== null) {
                            workInProgress = siblingFiber;
                            return;
                        }
                        completedWork = returnFiber;
                        workInProgress = completedWork;
                    }while (completedWork !== null)
                    if (workInProgressRootExitStatus === RootInProgress) {
                        workInProgressRootExitStatus = RootCompleted;
                    }
                }
                function commitRoot(root, recoverableErrors) {
                    var previousUpdateLanePriority = getCurrentUpdatePriority();
                    var prevTransition = ReactCurrentBatchConfig$2.transition;
                    try {
                        ReactCurrentBatchConfig$2.transition = null;
                        setCurrentUpdatePriority(DiscreteEventPriority);
                        commitRootImpl(root, recoverableErrors, previousUpdateLanePriority);
                    } finally{
                        ReactCurrentBatchConfig$2.transition = prevTransition;
                        setCurrentUpdatePriority(previousUpdateLanePriority);
                    }
                    return null;
                }
                function commitRootImpl(root, recoverableErrors, renderPriorityLevel) {
                    do {
                        flushPassiveEffects();
                    }while (rootWithPendingPassiveEffects !== null)
                    flushRenderPhaseStrictModeWarningsInDEV();
                    if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
                        throw new Error("Should not already be working.");
                    }
                    var finishedWork = root.finishedWork;
                    var lanes = root.finishedLanes;
                    {
                        markCommitStarted(lanes);
                    }
                    if (finishedWork === null) {
                        {
                            markCommitStopped();
                        }
                        return null;
                    } else {
                        {
                            if (lanes === NoLanes) {
                                error("root.finishedLanes should not be empty during a commit. This is a bug in React.");
                            }
                        }
                    }
                    root.finishedWork = null;
                    root.finishedLanes = NoLanes;
                    if (finishedWork === root.current) {
                        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    root.callbackNode = null;
                    root.callbackPriority = NoLane;
                    var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
                    markRootFinished(root, remainingLanes);
                    if (root === workInProgressRoot) {
                        workInProgressRoot = null;
                        workInProgress = null;
                        workInProgressRootRenderLanes = NoLanes;
                    }
                    if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
                        if (!rootDoesHavePassiveEffects) {
                            rootDoesHavePassiveEffects = true;
                            scheduleCallback$1(NormalPriority, function() {
                                flushPassiveEffects();
                                return null;
                            });
                        }
                    }
                    var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
                    var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
                    if (subtreeHasEffects || rootHasEffect) {
                        var prevTransition = ReactCurrentBatchConfig$2.transition;
                        ReactCurrentBatchConfig$2.transition = null;
                        var previousPriority = getCurrentUpdatePriority();
                        setCurrentUpdatePriority(DiscreteEventPriority);
                        var prevExecutionContext = executionContext;
                        executionContext |= CommitContext;
                        ReactCurrentOwner$2.current = null;
                        var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root, finishedWork);
                        {
                            recordCommitTime();
                        }
                        commitMutationEffects(root, finishedWork, lanes);
                        resetAfterCommit(root.containerInfo);
                        root.current = finishedWork;
                        {
                            markLayoutEffectsStarted(lanes);
                        }
                        commitLayoutEffects(finishedWork, root, lanes);
                        {
                            markLayoutEffectsStopped();
                        }
                        requestPaint();
                        executionContext = prevExecutionContext;
                        setCurrentUpdatePriority(previousPriority);
                        ReactCurrentBatchConfig$2.transition = prevTransition;
                    } else {
                        root.current = finishedWork;
                        {
                            recordCommitTime();
                        }
                    }
                    var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
                    if (rootDoesHavePassiveEffects) {
                        rootDoesHavePassiveEffects = false;
                        rootWithPendingPassiveEffects = root;
                        pendingPassiveEffectsLanes = lanes;
                    }
                    remainingLanes = root.pendingLanes;
                    if (remainingLanes === NoLanes) {
                        legacyErrorBoundariesThatAlreadyFailed = null;
                    }
                    {
                        if (!rootDidHavePassiveEffects) {
                            commitDoubleInvokeEffectsInDEV(root.current, false);
                        }
                    }
                    onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
                    {
                        if (isDevToolsPresent) {
                            root.memoizedUpdaters.clear();
                        }
                    }
                    {
                        onCommitRoot$1();
                    }
                    ensureRootIsScheduled(root, now$1());
                    if (recoverableErrors !== null) {
                        var onRecoverableError = root.onRecoverableError;
                        for(var i = 0; i < recoverableErrors.length; i++){
                            var recoverableError = recoverableErrors[i];
                            onRecoverableError(recoverableError);
                        }
                    }
                    if (hasUncaughtError) {
                        hasUncaughtError = false;
                        var error$1 = firstUncaughtError;
                        firstUncaughtError = null;
                        throw error$1;
                    }
                    if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root.tag !== LegacyRoot) {
                        flushPassiveEffects();
                    }
                    remainingLanes = root.pendingLanes;
                    if (includesSomeLane(remainingLanes, SyncLane)) {
                        {
                            markNestedUpdateScheduled();
                        }
                        if (root === rootWithNestedUpdates) {
                            nestedUpdateCount++;
                        } else {
                            nestedUpdateCount = 0;
                            rootWithNestedUpdates = root;
                        }
                    } else {
                        nestedUpdateCount = 0;
                    }
                    flushSyncCallbacks();
                    {
                        markCommitStopped();
                    }
                    return null;
                }
                function flushPassiveEffects() {
                    if (rootWithPendingPassiveEffects !== null) {
                        var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
                        var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
                        var prevTransition = ReactCurrentBatchConfig$2.transition;
                        var previousPriority = getCurrentUpdatePriority();
                        try {
                            ReactCurrentBatchConfig$2.transition = null;
                            setCurrentUpdatePriority(priority);
                            return flushPassiveEffectsImpl();
                        } finally{
                            setCurrentUpdatePriority(previousPriority);
                            ReactCurrentBatchConfig$2.transition = prevTransition;
                        }
                    }
                    return false;
                }
                function enqueuePendingPassiveProfilerEffect(fiber) {
                    {
                        pendingPassiveProfilerEffects.push(fiber);
                        if (!rootDoesHavePassiveEffects) {
                            rootDoesHavePassiveEffects = true;
                            scheduleCallback$1(NormalPriority, function() {
                                flushPassiveEffects();
                                return null;
                            });
                        }
                    }
                }
                function flushPassiveEffectsImpl() {
                    if (rootWithPendingPassiveEffects === null) {
                        return false;
                    }
                    var root = rootWithPendingPassiveEffects;
                    var lanes = pendingPassiveEffectsLanes;
                    rootWithPendingPassiveEffects = null;
                    pendingPassiveEffectsLanes = NoLanes;
                    if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
                        throw new Error("Cannot flush passive effects while already rendering.");
                    }
                    {
                        markPassiveEffectsStarted(lanes);
                    }
                    var prevExecutionContext = executionContext;
                    executionContext |= CommitContext;
                    commitPassiveUnmountEffects(root.current);
                    commitPassiveMountEffects(root, root.current);
                    {
                        var profilerEffects = pendingPassiveProfilerEffects;
                        pendingPassiveProfilerEffects = [];
                        for(var i = 0; i < profilerEffects.length; i++){
                            var _fiber = profilerEffects[i];
                            commitPassiveEffectDurations(root, _fiber);
                        }
                    }
                    {
                        markPassiveEffectsStopped();
                    }
                    {
                        commitDoubleInvokeEffectsInDEV(root.current, true);
                    }
                    executionContext = prevExecutionContext;
                    flushSyncCallbacks();
                    nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;
                    onPostCommitRoot(root);
                    {
                        var stateNode = root.current.stateNode;
                        stateNode.effectDuration = 0;
                        stateNode.passiveEffectDuration = 0;
                    }
                    return true;
                }
                function isAlreadyFailedLegacyErrorBoundary(instance) {
                    return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
                }
                function markLegacyErrorBoundaryAsFailed(instance) {
                    if (legacyErrorBoundariesThatAlreadyFailed === null) {
                        legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([
                            instance
                        ]);
                    } else {
                        legacyErrorBoundariesThatAlreadyFailed.add(instance);
                    }
                }
                function prepareToThrowUncaughtError(error2) {
                    if (!hasUncaughtError) {
                        hasUncaughtError = true;
                        firstUncaughtError = error2;
                    }
                }
                var onUncaughtError = prepareToThrowUncaughtError;
                function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
                    var errorInfo = createCapturedValue(error2, sourceFiber);
                    var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
                    enqueueUpdate(rootFiber, update);
                    var eventTime = requestEventTime();
                    var root = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);
                    if (root !== null) {
                        markRootUpdated(root, SyncLane, eventTime);
                        ensureRootIsScheduled(root, eventTime);
                    }
                }
                function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
                    if (sourceFiber.tag === HostRoot2) {
                        captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
                        return;
                    }
                    var fiber = null;
                    {
                        fiber = nearestMountedAncestor;
                    }
                    while(fiber !== null){
                        if (fiber.tag === HostRoot2) {
                            captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
                            return;
                        } else if (fiber.tag === ClassComponent) {
                            var ctor = fiber.type;
                            var instance = fiber.stateNode;
                            if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                                var errorInfo = createCapturedValue(error$1, sourceFiber);
                                var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                                enqueueUpdate(fiber, update);
                                var eventTime = requestEventTime();
                                var root = markUpdateLaneFromFiberToRoot(fiber, SyncLane);
                                if (root !== null) {
                                    markRootUpdated(root, SyncLane, eventTime);
                                    ensureRootIsScheduled(root, eventTime);
                                }
                                return;
                            }
                        }
                        fiber = fiber.return;
                    }
                    {
                        error("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error$1);
                    }
                }
                function pingSuspendedRoot(root, wakeable, pingedLanes) {
                    var pingCache = root.pingCache;
                    if (pingCache !== null) {
                        pingCache.delete(wakeable);
                    }
                    var eventTime = requestEventTime();
                    markRootPinged(root, pingedLanes);
                    warnIfSuspenseResolutionNotWrappedWithActDEV(root);
                    if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
                        if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
                            prepareFreshStack(root, NoLanes);
                        } else {
                            workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
                        }
                    }
                    ensureRootIsScheduled(root, eventTime);
                }
                function retryTimedOutBoundary(boundaryFiber, retryLane) {
                    if (retryLane === NoLane) {
                        retryLane = requestRetryLane(boundaryFiber);
                    }
                    var eventTime = requestEventTime();
                    var root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);
                    if (root !== null) {
                        markRootUpdated(root, retryLane, eventTime);
                        ensureRootIsScheduled(root, eventTime);
                    }
                }
                function retryDehydratedSuspenseBoundary(boundaryFiber) {
                    var suspenseState = boundaryFiber.memoizedState;
                    var retryLane = NoLane;
                    if (suspenseState !== null) {
                        retryLane = suspenseState.retryLane;
                    }
                    retryTimedOutBoundary(boundaryFiber, retryLane);
                }
                function resolveRetryWakeable(boundaryFiber, wakeable) {
                    var retryLane = NoLane;
                    var retryCache;
                    {
                        switch(boundaryFiber.tag){
                            case SuspenseComponent2:
                                retryCache = boundaryFiber.stateNode;
                                var suspenseState = boundaryFiber.memoizedState;
                                if (suspenseState !== null) {
                                    retryLane = suspenseState.retryLane;
                                }
                                break;
                            case SuspenseListComponent:
                                retryCache = boundaryFiber.stateNode;
                                break;
                            default:
                                throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
                        }
                    }
                    if (retryCache !== null) {
                        retryCache.delete(wakeable);
                    }
                    retryTimedOutBoundary(boundaryFiber, retryLane);
                }
                function jnd(timeElapsed) {
                    return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
                }
                function checkForNestedUpdates() {
                    if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
                        nestedUpdateCount = 0;
                        rootWithNestedUpdates = null;
                        throw new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
                    }
                    {
                        if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
                            nestedPassiveUpdateCount = 0;
                            error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
                        }
                    }
                }
                function flushRenderPhaseStrictModeWarningsInDEV() {
                    {
                        ReactStrictModeWarnings.flushLegacyContextWarning();
                        {
                            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
                        }
                    }
                }
                function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
                    {
                        setCurrentFiber(fiber);
                        invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
                        if (hasPassiveEffects) {
                            invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
                        }
                        invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
                        if (hasPassiveEffects) {
                            invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
                        }
                        resetCurrentFiber();
                    }
                }
                function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
                    {
                        var current2 = firstChild;
                        var subtreeRoot = null;
                        while(current2 !== null){
                            var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;
                            if (current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags) {
                                current2 = current2.child;
                            } else {
                                if ((current2.flags & fiberFlags) !== NoFlags) {
                                    invokeEffectFn(current2);
                                }
                                if (current2.sibling !== null) {
                                    current2 = current2.sibling;
                                } else {
                                    current2 = subtreeRoot = current2.return;
                                }
                            }
                        }
                    }
                }
                var didWarnStateUpdateForNotYetMountedComponent = null;
                function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
                    {
                        if ((executionContext & RenderContext) !== NoContext) {
                            return;
                        }
                        if (!(fiber.mode & ConcurrentMode)) {
                            return;
                        }
                        var tag = fiber.tag;
                        if (tag !== IndeterminateComponent && tag !== HostRoot2 && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {
                            return;
                        }
                        var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
                        if (didWarnStateUpdateForNotYetMountedComponent !== null) {
                            if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                                return;
                            }
                            didWarnStateUpdateForNotYetMountedComponent.add(componentName);
                        } else {
                            didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([
                                componentName
                            ]);
                        }
                        var previousFiber = current;
                        try {
                            setCurrentFiber(fiber);
                            error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
                        } finally{
                            if (previousFiber) {
                                setCurrentFiber(fiber);
                            } else {
                                resetCurrentFiber();
                            }
                        }
                    }
                }
                var beginWork$1;
                {
                    var dummyFiber = null;
                    beginWork$1 = function(current2, unitOfWork, lanes) {
                        var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
                        try {
                            return beginWork(current2, unitOfWork, lanes);
                        } catch (originalError) {
                            if (originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                                throw originalError;
                            }
                            resetContextDependencies();
                            resetHooksAfterThrow();
                            unwindInterruptedWork(current2, unitOfWork);
                            assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
                            if (unitOfWork.mode & ProfileMode) {
                                startProfilerTimer(unitOfWork);
                            }
                            invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
                            if (hasCaughtError()) {
                                var replayError = clearCaughtError();
                                if (typeof replayError === "object" && replayError !== null && replayError._suppressLogging && typeof originalError === "object" && originalError !== null && !originalError._suppressLogging) {
                                    originalError._suppressLogging = true;
                                }
                            }
                            throw originalError;
                        }
                    };
                }
                var didWarnAboutUpdateInRender = false;
                var didWarnAboutUpdateInRenderForAnotherComponent;
                {
                    didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
                }
                function warnAboutRenderPhaseUpdatesInDEV(fiber) {
                    {
                        if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
                            switch(fiber.tag){
                                case FunctionComponent:
                                case ForwardRef:
                                case SimpleMemoComponent:
                                    {
                                        var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                                        var dedupeKey = renderingComponentName;
                                        if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                                            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                                            var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                                            error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                                        }
                                        break;
                                    }
                                case ClassComponent:
                                    {
                                        if (!didWarnAboutUpdateInRender) {
                                            error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                                            didWarnAboutUpdateInRender = true;
                                        }
                                        break;
                                    }
                            }
                        }
                    }
                }
                function restorePendingUpdaters(root, lanes) {
                    {
                        if (isDevToolsPresent) {
                            var memoizedUpdaters = root.memoizedUpdaters;
                            memoizedUpdaters.forEach(function(schedulingFiber) {
                                addFiberToLanesMap(root, schedulingFiber, lanes);
                            });
                        }
                    }
                }
                var fakeActCallbackNode = {};
                function scheduleCallback$1(priorityLevel, callback) {
                    {
                        var actQueue = ReactCurrentActQueue$1.current;
                        if (actQueue !== null) {
                            actQueue.push(callback);
                            return fakeActCallbackNode;
                        } else {
                            return scheduleCallback(priorityLevel, callback);
                        }
                    }
                }
                function cancelCallback$1(callbackNode) {
                    if (callbackNode === fakeActCallbackNode) {
                        return;
                    }
                    return cancelCallback(callbackNode);
                }
                function shouldForceFlushFallbacksInDEV() {
                    return ReactCurrentActQueue$1.current !== null;
                }
                function warnIfUpdatesNotWrappedWithActDEV(fiber) {
                    {
                        if (fiber.mode & ConcurrentMode) {
                            if (!isConcurrentActEnvironment()) {
                                return;
                            }
                        } else {
                            if (!isLegacyActEnvironment()) {
                                return;
                            }
                            if (executionContext !== NoContext) {
                                return;
                            }
                            if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
                                return;
                            }
                        }
                        if (ReactCurrentActQueue$1.current === null) {
                            var previousFiber = current;
                            try {
                                setCurrentFiber(fiber);
                                error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
                            } finally{
                                if (previousFiber) {
                                    setCurrentFiber(fiber);
                                } else {
                                    resetCurrentFiber();
                                }
                            }
                        }
                    }
                }
                function warnIfSuspenseResolutionNotWrappedWithActDEV(root) {
                    {
                        if (root.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
                            error("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act");
                        }
                    }
                }
                var resolveFamily = null;
                var failedBoundaries = null;
                var setRefreshHandler = function(handler) {
                    {
                        resolveFamily = handler;
                    }
                };
                function resolveFunctionForHotReloading(type) {
                    {
                        if (resolveFamily === null) {
                            return type;
                        }
                        var family = resolveFamily(type);
                        if (family === void 0) {
                            return type;
                        }
                        return family.current;
                    }
                }
                function resolveClassForHotReloading(type) {
                    return resolveFunctionForHotReloading(type);
                }
                function resolveForwardRefForHotReloading(type) {
                    {
                        if (resolveFamily === null) {
                            return type;
                        }
                        var family = resolveFamily(type);
                        if (family === void 0) {
                            if (type !== null && type !== void 0 && typeof type.render === "function") {
                                var currentRender = resolveFunctionForHotReloading(type.render);
                                if (type.render !== currentRender) {
                                    var syntheticType = {
                                        $$typeof: REACT_FORWARD_REF_TYPE,
                                        render: currentRender
                                    };
                                    if (type.displayName !== void 0) {
                                        syntheticType.displayName = type.displayName;
                                    }
                                    return syntheticType;
                                }
                            }
                            return type;
                        }
                        return family.current;
                    }
                }
                function isCompatibleFamilyForHotReloading(fiber, element) {
                    {
                        if (resolveFamily === null) {
                            return false;
                        }
                        var prevType = fiber.elementType;
                        var nextType = element.type;
                        var needsCompareFamilies = false;
                        var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
                        switch(fiber.tag){
                            case ClassComponent:
                                {
                                    if (typeof nextType === "function") {
                                        needsCompareFamilies = true;
                                    }
                                    break;
                                }
                            case FunctionComponent:
                                {
                                    if (typeof nextType === "function") {
                                        needsCompareFamilies = true;
                                    } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                                        needsCompareFamilies = true;
                                    }
                                    break;
                                }
                            case ForwardRef:
                                {
                                    if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                                        needsCompareFamilies = true;
                                    } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                                        needsCompareFamilies = true;
                                    }
                                    break;
                                }
                            case MemoComponent:
                            case SimpleMemoComponent:
                                {
                                    if ($$typeofNextType === REACT_MEMO_TYPE) {
                                        needsCompareFamilies = true;
                                    } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                                        needsCompareFamilies = true;
                                    }
                                    break;
                                }
                            default:
                                return false;
                        }
                        if (needsCompareFamilies) {
                            var prevFamily = resolveFamily(prevType);
                            if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                                return true;
                            }
                        }
                        return false;
                    }
                }
                function markFailedErrorBoundaryForHotReloading(fiber) {
                    {
                        if (resolveFamily === null) {
                            return;
                        }
                        if (typeof WeakSet !== "function") {
                            return;
                        }
                        if (failedBoundaries === null) {
                            failedBoundaries = /* @__PURE__ */ new WeakSet();
                        }
                        failedBoundaries.add(fiber);
                    }
                }
                var scheduleRefresh = function(root, update) {
                    {
                        if (resolveFamily === null) {
                            return;
                        }
                        var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
                        flushPassiveEffects();
                        flushSync(function() {
                            scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);
                        });
                    }
                };
                var scheduleRoot = function(root, element) {
                    {
                        if (root.context !== emptyContextObject) {
                            return;
                        }
                        flushPassiveEffects();
                        flushSync(function() {
                            updateContainer(element, root, null, null);
                        });
                    }
                };
                function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
                    {
                        var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
                        var candidateType = null;
                        switch(tag){
                            case FunctionComponent:
                            case SimpleMemoComponent:
                            case ClassComponent:
                                candidateType = type;
                                break;
                            case ForwardRef:
                                candidateType = type.render;
                                break;
                        }
                        if (resolveFamily === null) {
                            throw new Error("Expected resolveFamily to be set during hot reload.");
                        }
                        var needsRender = false;
                        var needsRemount = false;
                        if (candidateType !== null) {
                            var family = resolveFamily(candidateType);
                            if (family !== void 0) {
                                if (staleFamilies.has(family)) {
                                    needsRemount = true;
                                } else if (updatedFamilies.has(family)) {
                                    if (tag === ClassComponent) {
                                        needsRemount = true;
                                    } else {
                                        needsRender = true;
                                    }
                                }
                            }
                        }
                        if (failedBoundaries !== null) {
                            if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                                needsRemount = true;
                            }
                        }
                        if (needsRemount) {
                            fiber._debugNeedsRemount = true;
                        }
                        if (needsRemount || needsRender) {
                            scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
                        }
                        if (child !== null && !needsRemount) {
                            scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
                        }
                        if (sibling !== null) {
                            scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
                        }
                    }
                }
                var findHostInstancesForRefresh = function(root, families) {
                    {
                        var hostInstances = /* @__PURE__ */ new Set();
                        var types = new Set(families.map(function(family) {
                            return family.current;
                        }));
                        findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);
                        return hostInstances;
                    }
                };
                function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
                    {
                        var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
                        var candidateType = null;
                        switch(tag){
                            case FunctionComponent:
                            case SimpleMemoComponent:
                            case ClassComponent:
                                candidateType = type;
                                break;
                            case ForwardRef:
                                candidateType = type.render;
                                break;
                        }
                        var didMatch = false;
                        if (candidateType !== null) {
                            if (types.has(candidateType)) {
                                didMatch = true;
                            }
                        }
                        if (didMatch) {
                            findHostInstancesForFiberShallowly(fiber, hostInstances);
                        } else {
                            if (child !== null) {
                                findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
                            }
                        }
                        if (sibling !== null) {
                            findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
                        }
                    }
                }
                function findHostInstancesForFiberShallowly(fiber, hostInstances) {
                    {
                        var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
                        if (foundHostInstances) {
                            return;
                        }
                        var node = fiber;
                        while(true){
                            switch(node.tag){
                                case HostComponent2:
                                    hostInstances.add(node.stateNode);
                                    return;
                                case HostPortal:
                                    hostInstances.add(node.stateNode.containerInfo);
                                    return;
                                case HostRoot2:
                                    hostInstances.add(node.stateNode.containerInfo);
                                    return;
                            }
                            if (node.return === null) {
                                throw new Error("Expected to reach root first.");
                            }
                            node = node.return;
                        }
                    }
                }
                function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
                    {
                        var node = fiber;
                        var foundHostInstances = false;
                        while(true){
                            if (node.tag === HostComponent2) {
                                foundHostInstances = true;
                                hostInstances.add(node.stateNode);
                            } else if (node.child !== null) {
                                node.child.return = node;
                                node = node.child;
                                continue;
                            }
                            if (node === fiber) {
                                return foundHostInstances;
                            }
                            while(node.sibling === null){
                                if (node.return === null || node.return === fiber) {
                                    return foundHostInstances;
                                }
                                node = node.return;
                            }
                            node.sibling.return = node.return;
                            node = node.sibling;
                        }
                    }
                    return false;
                }
                var hasBadMapPolyfill;
                {
                    hasBadMapPolyfill = false;
                    try {
                        var nonExtensibleObject = Object.preventExtensions({});
                        /* @__PURE__ */ new Map([
                            [
                                nonExtensibleObject,
                                null
                            ]
                        ]);
                        /* @__PURE__ */ new Set([
                            nonExtensibleObject
                        ]);
                    } catch (e) {
                        hasBadMapPolyfill = true;
                    }
                }
                function FiberNode(tag, pendingProps, key, mode) {
                    this.tag = tag;
                    this.key = key;
                    this.elementType = null;
                    this.type = null;
                    this.stateNode = null;
                    this.return = null;
                    this.child = null;
                    this.sibling = null;
                    this.index = 0;
                    this.ref = null;
                    this.pendingProps = pendingProps;
                    this.memoizedProps = null;
                    this.updateQueue = null;
                    this.memoizedState = null;
                    this.dependencies = null;
                    this.mode = mode;
                    this.flags = NoFlags;
                    this.subtreeFlags = NoFlags;
                    this.deletions = null;
                    this.lanes = NoLanes;
                    this.childLanes = NoLanes;
                    this.alternate = null;
                    {
                        this.actualDuration = Number.NaN;
                        this.actualStartTime = Number.NaN;
                        this.selfBaseDuration = Number.NaN;
                        this.treeBaseDuration = Number.NaN;
                        this.actualDuration = 0;
                        this.actualStartTime = -1;
                        this.selfBaseDuration = 0;
                        this.treeBaseDuration = 0;
                    }
                    {
                        this._debugSource = null;
                        this._debugOwner = null;
                        this._debugNeedsRemount = false;
                        this._debugHookTypes = null;
                        if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
                            Object.preventExtensions(this);
                        }
                    }
                }
                var createFiber = function(tag, pendingProps, key, mode) {
                    return new FiberNode(tag, pendingProps, key, mode);
                };
                function shouldConstruct$1(Component) {
                    var prototype = Component.prototype;
                    return !!(prototype && prototype.isReactComponent);
                }
                function isSimpleFunctionComponent(type) {
                    return typeof type === "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
                }
                function resolveLazyComponentTag(Component) {
                    if (typeof Component === "function") {
                        return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
                    } else if (Component !== void 0 && Component !== null) {
                        var $$typeof = Component.$$typeof;
                        if ($$typeof === REACT_FORWARD_REF_TYPE) {
                            return ForwardRef;
                        }
                        if ($$typeof === REACT_MEMO_TYPE) {
                            return MemoComponent;
                        }
                    }
                    return IndeterminateComponent;
                }
                function createWorkInProgress(current2, pendingProps) {
                    var workInProgress2 = current2.alternate;
                    if (workInProgress2 === null) {
                        workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
                        workInProgress2.elementType = current2.elementType;
                        workInProgress2.type = current2.type;
                        workInProgress2.stateNode = current2.stateNode;
                        {
                            workInProgress2._debugSource = current2._debugSource;
                            workInProgress2._debugOwner = current2._debugOwner;
                            workInProgress2._debugHookTypes = current2._debugHookTypes;
                        }
                        workInProgress2.alternate = current2;
                        current2.alternate = workInProgress2;
                    } else {
                        workInProgress2.pendingProps = pendingProps;
                        workInProgress2.type = current2.type;
                        workInProgress2.flags = NoFlags;
                        workInProgress2.subtreeFlags = NoFlags;
                        workInProgress2.deletions = null;
                        {
                            workInProgress2.actualDuration = 0;
                            workInProgress2.actualStartTime = -1;
                        }
                    }
                    workInProgress2.flags = current2.flags & StaticMask;
                    workInProgress2.childLanes = current2.childLanes;
                    workInProgress2.lanes = current2.lanes;
                    workInProgress2.child = current2.child;
                    workInProgress2.memoizedProps = current2.memoizedProps;
                    workInProgress2.memoizedState = current2.memoizedState;
                    workInProgress2.updateQueue = current2.updateQueue;
                    var currentDependencies = current2.dependencies;
                    workInProgress2.dependencies = currentDependencies === null ? null : {
                        lanes: currentDependencies.lanes,
                        firstContext: currentDependencies.firstContext
                    };
                    workInProgress2.sibling = current2.sibling;
                    workInProgress2.index = current2.index;
                    workInProgress2.ref = current2.ref;
                    {
                        workInProgress2.selfBaseDuration = current2.selfBaseDuration;
                        workInProgress2.treeBaseDuration = current2.treeBaseDuration;
                    }
                    {
                        workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
                        switch(workInProgress2.tag){
                            case IndeterminateComponent:
                            case FunctionComponent:
                            case SimpleMemoComponent:
                                workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                                break;
                            case ClassComponent:
                                workInProgress2.type = resolveClassForHotReloading(current2.type);
                                break;
                            case ForwardRef:
                                workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
                                break;
                        }
                    }
                    return workInProgress2;
                }
                function resetWorkInProgress(workInProgress2, renderLanes2) {
                    workInProgress2.flags &= StaticMask | Placement;
                    var current2 = workInProgress2.alternate;
                    if (current2 === null) {
                        workInProgress2.childLanes = NoLanes;
                        workInProgress2.lanes = renderLanes2;
                        workInProgress2.child = null;
                        workInProgress2.subtreeFlags = NoFlags;
                        workInProgress2.memoizedProps = null;
                        workInProgress2.memoizedState = null;
                        workInProgress2.updateQueue = null;
                        workInProgress2.dependencies = null;
                        workInProgress2.stateNode = null;
                        {
                            workInProgress2.selfBaseDuration = 0;
                            workInProgress2.treeBaseDuration = 0;
                        }
                    } else {
                        workInProgress2.childLanes = current2.childLanes;
                        workInProgress2.lanes = current2.lanes;
                        workInProgress2.child = current2.child;
                        workInProgress2.subtreeFlags = NoFlags;
                        workInProgress2.deletions = null;
                        workInProgress2.memoizedProps = current2.memoizedProps;
                        workInProgress2.memoizedState = current2.memoizedState;
                        workInProgress2.updateQueue = current2.updateQueue;
                        workInProgress2.type = current2.type;
                        var currentDependencies = current2.dependencies;
                        workInProgress2.dependencies = currentDependencies === null ? null : {
                            lanes: currentDependencies.lanes,
                            firstContext: currentDependencies.firstContext
                        };
                        {
                            workInProgress2.selfBaseDuration = current2.selfBaseDuration;
                            workInProgress2.treeBaseDuration = current2.treeBaseDuration;
                        }
                    }
                    return workInProgress2;
                }
                function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
                    var mode;
                    if (tag === ConcurrentRoot) {
                        mode = ConcurrentMode;
                        if (isStrictMode === true) {
                            mode |= StrictLegacyMode;
                            {
                                mode |= StrictEffectsMode;
                            }
                        }
                    } else {
                        mode = NoMode;
                    }
                    if (isDevToolsPresent) {
                        mode |= ProfileMode;
                    }
                    return createFiber(HostRoot2, null, null, mode);
                }
                function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
                    var fiberTag = IndeterminateComponent;
                    var resolvedType = type;
                    if (typeof type === "function") {
                        if (shouldConstruct$1(type)) {
                            fiberTag = ClassComponent;
                            {
                                resolvedType = resolveClassForHotReloading(resolvedType);
                            }
                        } else {
                            {
                                resolvedType = resolveFunctionForHotReloading(resolvedType);
                            }
                        }
                    } else if (typeof type === "string") {
                        fiberTag = HostComponent2;
                    } else {
                        getTag: switch(type){
                            case REACT_FRAGMENT_TYPE:
                                return createFiberFromFragment(pendingProps.children, mode, lanes, key);
                            case REACT_STRICT_MODE_TYPE:
                                fiberTag = Mode;
                                mode |= StrictLegacyMode;
                                if ((mode & ConcurrentMode) !== NoMode) {
                                    mode |= StrictEffectsMode;
                                }
                                break;
                            case REACT_PROFILER_TYPE:
                                return createFiberFromProfiler(pendingProps, mode, lanes, key);
                            case REACT_SUSPENSE_TYPE:
                                return createFiberFromSuspense(pendingProps, mode, lanes, key);
                            case REACT_SUSPENSE_LIST_TYPE:
                                return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
                            case REACT_OFFSCREEN_TYPE:
                                return createFiberFromOffscreen(pendingProps, mode, lanes, key);
                            case REACT_LEGACY_HIDDEN_TYPE:
                            case REACT_SCOPE_TYPE:
                            case REACT_CACHE_TYPE:
                            case REACT_TRACING_MARKER_TYPE:
                            case REACT_DEBUG_TRACING_MODE_TYPE:
                            default:
                                {
                                    if (typeof type === "object" && type !== null) {
                                        switch(type.$$typeof){
                                            case REACT_PROVIDER_TYPE:
                                                fiberTag = ContextProvider;
                                                break getTag;
                                            case REACT_CONTEXT_TYPE:
                                                fiberTag = ContextConsumer;
                                                break getTag;
                                            case REACT_FORWARD_REF_TYPE:
                                                fiberTag = ForwardRef;
                                                {
                                                    resolvedType = resolveForwardRefForHotReloading(resolvedType);
                                                }
                                                break getTag;
                                            case REACT_MEMO_TYPE:
                                                fiberTag = MemoComponent;
                                                break getTag;
                                            case REACT_LAZY_TYPE:
                                                fiberTag = LazyComponent;
                                                resolvedType = null;
                                                break getTag;
                                        }
                                    }
                                    var info = "";
                                    {
                                        if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                                            info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                                        }
                                        var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                                        if (ownerName) {
                                            info += "\n\nCheck the render method of `" + ownerName + "`.";
                                        }
                                    }
                                    throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
                                }
                        }
                    }
                    var fiber = createFiber(fiberTag, pendingProps, key, mode);
                    fiber.elementType = type;
                    fiber.type = resolvedType;
                    fiber.lanes = lanes;
                    {
                        fiber._debugOwner = owner;
                    }
                    return fiber;
                }
                function createFiberFromElement(element, mode, lanes) {
                    var owner = null;
                    {
                        owner = element._owner;
                    }
                    var type = element.type;
                    var key = element.key;
                    var pendingProps = element.props;
                    var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);
                    {
                        fiber._debugSource = element._source;
                        fiber._debugOwner = element._owner;
                    }
                    return fiber;
                }
                function createFiberFromFragment(elements, mode, lanes, key) {
                    var fiber = createFiber(Fragment20, elements, key, mode);
                    fiber.lanes = lanes;
                    return fiber;
                }
                function createFiberFromProfiler(pendingProps, mode, lanes, key) {
                    {
                        if (typeof pendingProps.id !== "string") {
                            error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
                        }
                    }
                    var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
                    fiber.elementType = REACT_PROFILER_TYPE;
                    fiber.lanes = lanes;
                    {
                        fiber.stateNode = {
                            effectDuration: 0,
                            passiveEffectDuration: 0
                        };
                    }
                    return fiber;
                }
                function createFiberFromSuspense(pendingProps, mode, lanes, key) {
                    var fiber = createFiber(SuspenseComponent2, pendingProps, key, mode);
                    fiber.elementType = REACT_SUSPENSE_TYPE;
                    fiber.lanes = lanes;
                    return fiber;
                }
                function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
                    var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
                    fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
                    fiber.lanes = lanes;
                    return fiber;
                }
                function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
                    var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
                    fiber.elementType = REACT_OFFSCREEN_TYPE;
                    fiber.lanes = lanes;
                    var primaryChildInstance = {};
                    fiber.stateNode = primaryChildInstance;
                    return fiber;
                }
                function createFiberFromText(content, mode, lanes) {
                    var fiber = createFiber(HostText2, content, null, mode);
                    fiber.lanes = lanes;
                    return fiber;
                }
                function createFiberFromHostInstanceForDeletion() {
                    var fiber = createFiber(HostComponent2, null, null, NoMode);
                    fiber.elementType = "DELETED";
                    return fiber;
                }
                function createFiberFromDehydratedFragment(dehydratedNode) {
                    var fiber = createFiber(DehydratedFragment, null, null, NoMode);
                    fiber.stateNode = dehydratedNode;
                    return fiber;
                }
                function createFiberFromPortal(portal, mode, lanes) {
                    var pendingProps = portal.children !== null ? portal.children : [];
                    var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
                    fiber.lanes = lanes;
                    fiber.stateNode = {
                        containerInfo: portal.containerInfo,
                        pendingChildren: null,
                        // Used by persistent updates
                        implementation: portal.implementation
                    };
                    return fiber;
                }
                function assignFiberPropertiesInDEV(target, source) {
                    if (target === null) {
                        target = createFiber(IndeterminateComponent, null, null, NoMode);
                    }
                    target.tag = source.tag;
                    target.key = source.key;
                    target.elementType = source.elementType;
                    target.type = source.type;
                    target.stateNode = source.stateNode;
                    target.return = source.return;
                    target.child = source.child;
                    target.sibling = source.sibling;
                    target.index = source.index;
                    target.ref = source.ref;
                    target.pendingProps = source.pendingProps;
                    target.memoizedProps = source.memoizedProps;
                    target.updateQueue = source.updateQueue;
                    target.memoizedState = source.memoizedState;
                    target.dependencies = source.dependencies;
                    target.mode = source.mode;
                    target.flags = source.flags;
                    target.subtreeFlags = source.subtreeFlags;
                    target.deletions = source.deletions;
                    target.lanes = source.lanes;
                    target.childLanes = source.childLanes;
                    target.alternate = source.alternate;
                    {
                        target.actualDuration = source.actualDuration;
                        target.actualStartTime = source.actualStartTime;
                        target.selfBaseDuration = source.selfBaseDuration;
                        target.treeBaseDuration = source.treeBaseDuration;
                    }
                    target._debugSource = source._debugSource;
                    target._debugOwner = source._debugOwner;
                    target._debugNeedsRemount = source._debugNeedsRemount;
                    target._debugHookTypes = source._debugHookTypes;
                    return target;
                }
                function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError) {
                    this.tag = tag;
                    this.containerInfo = containerInfo;
                    this.pendingChildren = null;
                    this.current = null;
                    this.pingCache = null;
                    this.finishedWork = null;
                    this.timeoutHandle = noTimeout;
                    this.context = null;
                    this.pendingContext = null;
                    this.callbackNode = null;
                    this.callbackPriority = NoLane;
                    this.eventTimes = createLaneMap(NoLanes);
                    this.expirationTimes = createLaneMap(NoTimestamp);
                    this.pendingLanes = NoLanes;
                    this.suspendedLanes = NoLanes;
                    this.pingedLanes = NoLanes;
                    this.expiredLanes = NoLanes;
                    this.mutableReadLanes = NoLanes;
                    this.finishedLanes = NoLanes;
                    this.entangledLanes = NoLanes;
                    this.entanglements = createLaneMap(NoLanes);
                    this.identifierPrefix = identifierPrefix;
                    this.onRecoverableError = onRecoverableError;
                    if (supportsHydration) {
                        this.mutableSourceEagerHydrationData = null;
                    }
                    {
                        this.effectDuration = 0;
                        this.passiveEffectDuration = 0;
                    }
                    {
                        this.memoizedUpdaters = /* @__PURE__ */ new Set();
                        var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
                        for(var _i = 0; _i < TotalLanes; _i++){
                            pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
                        }
                    }
                    {
                        switch(tag){
                            case ConcurrentRoot:
                                this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
                                break;
                            case LegacyRoot:
                                this._debugRootType = hydrate ? "hydrate()" : "render()";
                                break;
                        }
                    }
                }
                function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
                    var root = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError);
                    var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
                    root.current = uninitializedFiber;
                    uninitializedFiber.stateNode = root;
                    {
                        var _initialState = {
                            element: initialChildren,
                            isDehydrated: hydrate,
                            cache: null,
                            // not enabled yet
                            transitions: null
                        };
                        uninitializedFiber.memoizedState = _initialState;
                    }
                    initializeUpdateQueue(uninitializedFiber);
                    return root;
                }
                var ReactVersion = "18.0.0-fc46dba67-20220329";
                function createPortal(children2, containerInfo, implementation) {
                    var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                    {
                        checkKeyStringCoercion(key);
                    }
                    return {
                        // This tag allow us to uniquely identify this as a React Portal
                        $$typeof: REACT_PORTAL_TYPE,
                        key: key == null ? null : "" + key,
                        children: children2,
                        containerInfo,
                        implementation
                    };
                }
                var didWarnAboutNestedUpdates;
                var didWarnAboutFindNodeInStrictMode;
                {
                    didWarnAboutNestedUpdates = false;
                    didWarnAboutFindNodeInStrictMode = {};
                }
                function getContextForSubtree(parentComponent) {
                    if (!parentComponent) {
                        return emptyContextObject;
                    }
                    var fiber = get(parentComponent);
                    var parentContext = findCurrentUnmaskedContext(fiber);
                    if (fiber.tag === ClassComponent) {
                        var Component = fiber.type;
                        if (isContextProvider(Component)) {
                            return processChildContext(fiber, Component, parentContext);
                        }
                    }
                    return parentContext;
                }
                function findHostInstance(component) {
                    var fiber = get(component);
                    if (fiber === void 0) {
                        if (typeof component.render === "function") {
                            throw new Error("Unable to find node on an unmounted component.");
                        } else {
                            var keys = Object.keys(component).join(",");
                            throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys);
                        }
                    }
                    var hostFiber = findCurrentHostFiber(fiber);
                    if (hostFiber === null) {
                        return null;
                    }
                    return hostFiber.stateNode;
                }
                function findHostInstanceWithWarning(component, methodName) {
                    {
                        var fiber = get(component);
                        if (fiber === void 0) {
                            if (typeof component.render === "function") {
                                throw new Error("Unable to find node on an unmounted component.");
                            } else {
                                var keys = Object.keys(component).join(",");
                                throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys);
                            }
                        }
                        var hostFiber = findCurrentHostFiber(fiber);
                        if (hostFiber === null) {
                            return null;
                        }
                        if (hostFiber.mode & StrictLegacyMode) {
                            var componentName = getComponentNameFromFiber(fiber) || "Component";
                            if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                                didWarnAboutFindNodeInStrictMode[componentName] = true;
                                var previousFiber = current;
                                try {
                                    setCurrentFiber(hostFiber);
                                    if (fiber.mode & StrictLegacyMode) {
                                        error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                                    } else {
                                        error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                                    }
                                } finally{
                                    if (previousFiber) {
                                        setCurrentFiber(previousFiber);
                                    } else {
                                        resetCurrentFiber();
                                    }
                                }
                            }
                        }
                        return hostFiber.stateNode;
                    }
                }
                function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
                    var hydrate = false;
                    var initialChildren = null;
                    return createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
                }
                function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
                    var hydrate = true;
                    var root = createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
                    root.context = getContextForSubtree(null);
                    var current2 = root.current;
                    var eventTime = requestEventTime();
                    var lane = requestUpdateLane(current2);
                    var update = createUpdate(eventTime, lane);
                    update.callback = callback !== void 0 && callback !== null ? callback : null;
                    enqueueUpdate(current2, update);
                    scheduleInitialHydrationOnRoot(root, lane, eventTime);
                    return root;
                }
                function updateContainer(element, container, parentComponent, callback) {
                    {
                        onScheduleRoot(container, element);
                    }
                    var current$1 = container.current;
                    var eventTime = requestEventTime();
                    var lane = requestUpdateLane(current$1);
                    {
                        markRenderScheduled(lane);
                    }
                    var context = getContextForSubtree(parentComponent);
                    if (container.context === null) {
                        container.context = context;
                    } else {
                        container.pendingContext = context;
                    }
                    {
                        if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
                            didWarnAboutNestedUpdates = true;
                            error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current) || "Unknown");
                        }
                    }
                    var update = createUpdate(eventTime, lane);
                    update.payload = {
                        element
                    };
                    callback = callback === void 0 ? null : callback;
                    if (callback !== null) {
                        {
                            if (typeof callback !== "function") {
                                error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
                            }
                        }
                        update.callback = callback;
                    }
                    enqueueUpdate(current$1, update);
                    var root = scheduleUpdateOnFiber(current$1, lane, eventTime);
                    if (root !== null) {
                        entangleTransitions(root, current$1, lane);
                    }
                    return lane;
                }
                function getPublicRootInstance(container) {
                    var containerFiber = container.current;
                    if (!containerFiber.child) {
                        return null;
                    }
                    switch(containerFiber.child.tag){
                        case HostComponent2:
                            return getPublicInstance(containerFiber.child.stateNode);
                        default:
                            return containerFiber.child.stateNode;
                    }
                }
                function attemptSynchronousHydration(fiber) {
                    switch(fiber.tag){
                        case HostRoot2:
                            var root = fiber.stateNode;
                            if (isRootDehydrated(root)) {
                                var lanes = getHighestPriorityPendingLanes(root);
                                flushRoot(root, lanes);
                            }
                            break;
                        case SuspenseComponent2:
                            var eventTime = requestEventTime();
                            flushSync(function() {
                                return scheduleUpdateOnFiber(fiber, SyncLane, eventTime);
                            });
                            var retryLane = SyncLane;
                            markRetryLaneIfNotHydrated(fiber, retryLane);
                            break;
                    }
                }
                function markRetryLaneImpl(fiber, retryLane) {
                    var suspenseState = fiber.memoizedState;
                    if (suspenseState !== null && suspenseState.dehydrated !== null) {
                        suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
                    }
                }
                function markRetryLaneIfNotHydrated(fiber, retryLane) {
                    markRetryLaneImpl(fiber, retryLane);
                    var alternate = fiber.alternate;
                    if (alternate) {
                        markRetryLaneImpl(alternate, retryLane);
                    }
                }
                function attemptContinuousHydration(fiber) {
                    if (fiber.tag !== SuspenseComponent2) {
                        return;
                    }
                    var eventTime = requestEventTime();
                    var lane = SelectiveHydrationLane;
                    scheduleUpdateOnFiber(fiber, lane, eventTime);
                    markRetryLaneIfNotHydrated(fiber, lane);
                }
                function attemptHydrationAtCurrentPriority(fiber) {
                    if (fiber.tag !== SuspenseComponent2) {
                        return;
                    }
                    var eventTime = requestEventTime();
                    var lane = requestUpdateLane(fiber);
                    scheduleUpdateOnFiber(fiber, lane, eventTime);
                    markRetryLaneIfNotHydrated(fiber, lane);
                }
                function findHostInstanceWithNoPortals(fiber) {
                    var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
                    if (hostFiber === null) {
                        return null;
                    }
                    return hostFiber.stateNode;
                }
                var shouldErrorImpl = function(fiber) {
                    return null;
                };
                function shouldError(fiber) {
                    return shouldErrorImpl(fiber);
                }
                var shouldSuspendImpl = function(fiber) {
                    return false;
                };
                function shouldSuspend(fiber) {
                    return shouldSuspendImpl(fiber);
                }
                var overrideHookState = null;
                var overrideHookStateDeletePath = null;
                var overrideHookStateRenamePath = null;
                var overrideProps = null;
                var overridePropsDeletePath = null;
                var overridePropsRenamePath = null;
                var scheduleUpdate = null;
                var setErrorHandler = null;
                var setSuspenseHandler = null;
                {
                    var copyWithDeleteImpl = function(obj, path, index2) {
                        var key = path[index2];
                        var updated = isArray(obj) ? obj.slice() : assign({}, obj);
                        if (index2 + 1 === path.length) {
                            if (isArray(updated)) {
                                updated.splice(key, 1);
                            } else {
                                delete updated[key];
                            }
                            return updated;
                        }
                        updated[key] = copyWithDeleteImpl(obj[key], path, index2 + 1);
                        return updated;
                    };
                    var copyWithDelete = function(obj, path) {
                        return copyWithDeleteImpl(obj, path, 0);
                    };
                    var copyWithRenameImpl = function(obj, oldPath, newPath, index2) {
                        var oldKey = oldPath[index2];
                        var updated = isArray(obj) ? obj.slice() : assign({}, obj);
                        if (index2 + 1 === oldPath.length) {
                            var newKey = newPath[index2];
                            updated[newKey] = updated[oldKey];
                            if (isArray(updated)) {
                                updated.splice(oldKey, 1);
                            } else {
                                delete updated[oldKey];
                            }
                        } else {
                            updated[oldKey] = copyWithRenameImpl(// $FlowFixMe number or string is fine here
                            obj[oldKey], oldPath, newPath, index2 + 1);
                        }
                        return updated;
                    };
                    var copyWithRename = function(obj, oldPath, newPath) {
                        if (oldPath.length !== newPath.length) {
                            warn3("copyWithRename() expects paths of the same length");
                            return;
                        } else {
                            for(var i = 0; i < newPath.length - 1; i++){
                                if (oldPath[i] !== newPath[i]) {
                                    warn3("copyWithRename() expects paths to be the same except for the deepest key");
                                    return;
                                }
                            }
                        }
                        return copyWithRenameImpl(obj, oldPath, newPath, 0);
                    };
                    var copyWithSetImpl = function(obj, path, index2, value) {
                        if (index2 >= path.length) {
                            return value;
                        }
                        var key = path[index2];
                        var updated = isArray(obj) ? obj.slice() : assign({}, obj);
                        updated[key] = copyWithSetImpl(obj[key], path, index2 + 1, value);
                        return updated;
                    };
                    var copyWithSet = function(obj, path, value) {
                        return copyWithSetImpl(obj, path, 0, value);
                    };
                    var findHook = function(fiber, id) {
                        var currentHook2 = fiber.memoizedState;
                        while(currentHook2 !== null && id > 0){
                            currentHook2 = currentHook2.next;
                            id--;
                        }
                        return currentHook2;
                    };
                    overrideHookState = function(fiber, id, path, value) {
                        var hook = findHook(fiber, id);
                        if (hook !== null) {
                            var newState = copyWithSet(hook.memoizedState, path, value);
                            hook.memoizedState = newState;
                            hook.baseState = newState;
                            fiber.memoizedProps = assign({}, fiber.memoizedProps);
                            scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
                        }
                    };
                    overrideHookStateDeletePath = function(fiber, id, path) {
                        var hook = findHook(fiber, id);
                        if (hook !== null) {
                            var newState = copyWithDelete(hook.memoizedState, path);
                            hook.memoizedState = newState;
                            hook.baseState = newState;
                            fiber.memoizedProps = assign({}, fiber.memoizedProps);
                            scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
                        }
                    };
                    overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
                        var hook = findHook(fiber, id);
                        if (hook !== null) {
                            var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
                            hook.memoizedState = newState;
                            hook.baseState = newState;
                            fiber.memoizedProps = assign({}, fiber.memoizedProps);
                            scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
                        }
                    };
                    overrideProps = function(fiber, path, value) {
                        fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
                        if (fiber.alternate) {
                            fiber.alternate.pendingProps = fiber.pendingProps;
                        }
                        scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
                    };
                    overridePropsDeletePath = function(fiber, path) {
                        fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
                        if (fiber.alternate) {
                            fiber.alternate.pendingProps = fiber.pendingProps;
                        }
                        scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
                    };
                    overridePropsRenamePath = function(fiber, oldPath, newPath) {
                        fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
                        if (fiber.alternate) {
                            fiber.alternate.pendingProps = fiber.pendingProps;
                        }
                        scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
                    };
                    scheduleUpdate = function(fiber) {
                        scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
                    };
                    setErrorHandler = function(newShouldErrorImpl) {
                        shouldErrorImpl = newShouldErrorImpl;
                    };
                    setSuspenseHandler = function(newShouldSuspendImpl) {
                        shouldSuspendImpl = newShouldSuspendImpl;
                    };
                }
                function findHostInstanceByFiber(fiber) {
                    var hostFiber = findCurrentHostFiber(fiber);
                    if (hostFiber === null) {
                        return null;
                    }
                    return hostFiber.stateNode;
                }
                function emptyFindFiberByHostInstance(instance) {
                    return null;
                }
                function getCurrentFiberForDevTools() {
                    return current;
                }
                function injectIntoDevTools(devToolsConfig) {
                    var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
                    var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
                    return injectInternals({
                        bundleType: devToolsConfig.bundleType,
                        version: devToolsConfig.version,
                        rendererPackageName: devToolsConfig.rendererPackageName,
                        rendererConfig: devToolsConfig.rendererConfig,
                        overrideHookState,
                        overrideHookStateDeletePath,
                        overrideHookStateRenamePath,
                        overrideProps,
                        overridePropsDeletePath,
                        overridePropsRenamePath,
                        setErrorHandler,
                        setSuspenseHandler,
                        scheduleUpdate,
                        currentDispatcherRef: ReactCurrentDispatcher2,
                        findHostInstanceByFiber,
                        findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
                        // React Refresh
                        findHostInstancesForRefresh,
                        scheduleRefresh,
                        scheduleRoot,
                        setRefreshHandler,
                        // Enables DevTools to append owner stacks to error messages in DEV mode.
                        getCurrentFiber: getCurrentFiberForDevTools,
                        // Enables DevTools to detect reconciler version rather than renderer version
                        // which may not match for third party renderers.
                        reconcilerVersion: ReactVersion
                    });
                }
                exports2.attemptContinuousHydration = attemptContinuousHydration;
                exports2.attemptHydrationAtCurrentPriority = attemptHydrationAtCurrentPriority;
                exports2.attemptSynchronousHydration = attemptSynchronousHydration;
                exports2.batchedUpdates = batchedUpdates;
                exports2.createComponentSelector = createComponentSelector;
                exports2.createContainer = createContainer;
                exports2.createHasPseudoClassSelector = createHasPseudoClassSelector;
                exports2.createHydrationContainer = createHydrationContainer;
                exports2.createPortal = createPortal;
                exports2.createRoleSelector = createRoleSelector;
                exports2.createTestNameSelector = createTestNameSelector;
                exports2.createTextSelector = createTextSelector;
                exports2.deferredUpdates = deferredUpdates;
                exports2.discreteUpdates = discreteUpdates;
                exports2.findAllNodes = findAllNodes;
                exports2.findBoundingRects = findBoundingRects;
                exports2.findHostInstance = findHostInstance;
                exports2.findHostInstanceWithNoPortals = findHostInstanceWithNoPortals;
                exports2.findHostInstanceWithWarning = findHostInstanceWithWarning;
                exports2.flushControlled = flushControlled;
                exports2.flushPassiveEffects = flushPassiveEffects;
                exports2.flushSync = flushSync;
                exports2.focusWithin = focusWithin;
                exports2.getCurrentUpdatePriority = getCurrentUpdatePriority;
                exports2.getFindAllNodesFailureDescription = getFindAllNodesFailureDescription;
                exports2.getPublicRootInstance = getPublicRootInstance;
                exports2.injectIntoDevTools = injectIntoDevTools;
                exports2.isAlreadyRendering = isAlreadyRendering;
                exports2.observeVisibleRects = observeVisibleRects;
                exports2.registerMutableSourceForHydration = registerMutableSourceForHydration;
                exports2.runWithPriority = runWithPriority;
                exports2.shouldError = shouldError;
                exports2.shouldSuspend = shouldSuspend;
                exports2.updateContainer = updateContainer;
                return exports2;
            };
        }
    }
});
// node_modules/react-reconciler/index.js
var require_react_reconciler = __commonJS({
    "node_modules/react-reconciler/index.js" (exports, module) {
        "use strict";
        if (false) {
            module.exports = null;
        } else {
            module.exports = require_react_reconciler_development();
        }
    }
});
// node_modules/react-reconciler/cjs/react-reconciler-constants.development.js
var require_react_reconciler_constants_development = __commonJS({
    "node_modules/react-reconciler/cjs/react-reconciler-constants.development.js" (exports) {
        "use strict";
        if (true) {
            (function() {
                "use strict";
                var SyncLane = /*                        */ 1;
                var InputContinuousLane = /*            */ 4;
                var DefaultLane = /*                    */ 16;
                var IdleLane = /*                       */ 536870912;
                var DiscreteEventPriority = SyncLane;
                var ContinuousEventPriority = InputContinuousLane;
                var DefaultEventPriority = DefaultLane;
                var IdleEventPriority = IdleLane;
                var LegacyRoot = 0;
                var ConcurrentRoot = 1;
                exports.ConcurrentRoot = ConcurrentRoot;
                exports.ContinuousEventPriority = ContinuousEventPriority;
                exports.DefaultEventPriority = DefaultEventPriority;
                exports.DiscreteEventPriority = DiscreteEventPriority;
                exports.IdleEventPriority = IdleEventPriority;
                exports.LegacyRoot = LegacyRoot;
            })();
        }
    }
});
// node_modules/react-reconciler/constants.js
var require_constants = __commonJS({
    "node_modules/react-reconciler/constants.js" (exports, module) {
        "use strict";
        if (false) {
            module.exports = null;
        } else {
            module.exports = require_react_reconciler_constants_development();
        }
    }
});
// node_modules/lodash/_baseFilter.js
var require_baseFilter = __commonJS({
    "node_modules/lodash/_baseFilter.js" (exports, module) {
        var baseEach = require_baseEach();
        function baseFilter(collection, predicate) {
            var result = [];
            baseEach(collection, function(value, index, collection2) {
                if (predicate(value, index, collection2)) {
                    result.push(value);
                }
            });
            return result;
        }
        module.exports = baseFilter;
    }
});
// node_modules/lodash/filter.js
var require_filter = __commonJS({
    "node_modules/lodash/filter.js" (exports, module) {
        var arrayFilter = require_arrayFilter();
        var baseFilter = require_baseFilter();
        var baseIteratee = require_baseIteratee();
        var isArray = require_isArray();
        function filter2(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, baseIteratee(predicate, 3));
        }
        module.exports = filter2;
    }
});
// node_modules/lodash/_baseSet.js
var require_baseSet = __commonJS({
    "node_modules/lodash/_baseSet.js" (exports, module) {
        var assignValue = require_assignValue();
        var castPath = require_castPath();
        var isIndex = require_isIndex();
        var isObject2 = require_isObject();
        var toKey = require_toKey();
        function baseSet(object, path, value, customizer) {
            if (!isObject2(object)) {
                return object;
            }
            path = castPath(path, object);
            var index = -1, length = path.length, lastIndex = length - 1, nested = object;
            while(nested != null && ++index < length){
                var key = toKey(path[index]), newValue = value;
                if (key === "__proto__" || key === "constructor" || key === "prototype") {
                    return object;
                }
                if (index != lastIndex) {
                    var objValue = nested[key];
                    newValue = customizer ? customizer(objValue, key, nested) : void 0;
                    if (newValue === void 0) {
                        newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                    }
                }
                assignValue(nested, key, newValue);
                nested = nested[key];
            }
            return object;
        }
        module.exports = baseSet;
    }
});
// node_modules/lodash/set.js
var require_set = __commonJS({
    "node_modules/lodash/set.js" (exports, module) {
        var baseSet = require_baseSet();
        function set(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
        }
        module.exports = set;
    }
});
// node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
    "node_modules/lodash/_baseAssign.js" (exports, module) {
        var copyObject = require_copyObject();
        var keys = require_keys();
        function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
        }
        module.exports = baseAssign;
    }
});
// node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
    "node_modules/lodash/_nativeKeysIn.js" (exports, module) {
        function nativeKeysIn(object) {
            var result = [];
            if (object != null) {
                for(var key in Object(object)){
                    result.push(key);
                }
            }
            return result;
        }
        module.exports = nativeKeysIn;
    }
});
// node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
    "node_modules/lodash/_baseKeysIn.js" (exports, module) {
        var isObject2 = require_isObject();
        var isPrototype = require_isPrototype();
        var nativeKeysIn = require_nativeKeysIn();
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        function baseKeysIn(object) {
            if (!isObject2(object)) {
                return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result = [];
            for(var key in object){
                if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                    result.push(key);
                }
            }
            return result;
        }
        module.exports = baseKeysIn;
    }
});
// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
    "node_modules/lodash/keysIn.js" (exports, module) {
        var arrayLikeKeys = require_arrayLikeKeys();
        var baseKeysIn = require_baseKeysIn();
        var isArrayLike = require_isArrayLike();
        function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        module.exports = keysIn;
    }
});
// node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
    "node_modules/lodash/_baseAssignIn.js" (exports, module) {
        var copyObject = require_copyObject();
        var keysIn = require_keysIn();
        function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
        }
        module.exports = baseAssignIn;
    }
});
// node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
    "node_modules/lodash/_cloneBuffer.js" (exports, module) {
        var root = require_root();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var Buffer = moduleExports ? root.Buffer : void 0;
        var allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
        function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
                return buffer.slice();
            }
            var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result);
            return result;
        }
        module.exports = cloneBuffer;
    }
});
// node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
    "node_modules/lodash/_copyArray.js" (exports, module) {
        function copyArray(source, array) {
            var index = -1, length = source.length;
            array || (array = Array(length));
            while(++index < length){
                array[index] = source[index];
            }
            return array;
        }
        module.exports = copyArray;
    }
});
// node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
    "node_modules/lodash/_copySymbols.js" (exports, module) {
        var copyObject = require_copyObject();
        var getSymbols = require_getSymbols();
        function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
        }
        module.exports = copySymbols;
    }
});
// node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
    "node_modules/lodash/_getSymbolsIn.js" (exports, module) {
        var arrayPush = require_arrayPush();
        var getPrototype = require_getPrototype();
        var getSymbols = require_getSymbols();
        var stubArray = require_stubArray();
        var nativeGetSymbols = Object.getOwnPropertySymbols;
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result = [];
            while(object){
                arrayPush(result, getSymbols(object));
                object = getPrototype(object);
            }
            return result;
        };
        module.exports = getSymbolsIn;
    }
});
// node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
    "node_modules/lodash/_copySymbolsIn.js" (exports, module) {
        var copyObject = require_copyObject();
        var getSymbolsIn = require_getSymbolsIn();
        function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
        }
        module.exports = copySymbolsIn;
    }
});
// node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
    "node_modules/lodash/_getAllKeysIn.js" (exports, module) {
        var baseGetAllKeys = require_baseGetAllKeys();
        var getSymbolsIn = require_getSymbolsIn();
        var keysIn = require_keysIn();
        function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        module.exports = getAllKeysIn;
    }
});
// node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
    "node_modules/lodash/_initCloneArray.js" (exports, module) {
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        function initCloneArray(array) {
            var length = array.length, result = new array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
                result.index = array.index;
                result.input = array.input;
            }
            return result;
        }
        module.exports = initCloneArray;
    }
});
// node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
    "node_modules/lodash/_cloneArrayBuffer.js" (exports, module) {
        var Uint8Array = require_Uint8Array();
        function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array(result).set(new Uint8Array(arrayBuffer));
            return result;
        }
        module.exports = cloneArrayBuffer;
    }
});
// node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
    "node_modules/lodash/_cloneDataView.js" (exports, module) {
        var cloneArrayBuffer = require_cloneArrayBuffer();
        function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        module.exports = cloneDataView;
    }
});
// node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
    "node_modules/lodash/_cloneRegExp.js" (exports, module) {
        var reFlags = /\w*$/;
        function cloneRegExp(regexp) {
            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result.lastIndex = regexp.lastIndex;
            return result;
        }
        module.exports = cloneRegExp;
    }
});
// node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
    "node_modules/lodash/_cloneSymbol.js" (exports, module) {
        var Symbol2 = require_Symbol();
        var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
        var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
        function cloneSymbol(symbol) {
            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
        }
        module.exports = cloneSymbol;
    }
});
// node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
    "node_modules/lodash/_cloneTypedArray.js" (exports, module) {
        var cloneArrayBuffer = require_cloneArrayBuffer();
        function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        module.exports = cloneTypedArray;
    }
});
// node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
    "node_modules/lodash/_initCloneByTag.js" (exports, module) {
        var cloneArrayBuffer = require_cloneArrayBuffer();
        var cloneDataView = require_cloneDataView();
        var cloneRegExp = require_cloneRegExp();
        var cloneSymbol = require_cloneSymbol();
        var cloneTypedArray = require_cloneTypedArray();
        var boolTag = "[object Boolean]";
        var dateTag = "[object Date]";
        var mapTag = "[object Map]";
        var numberTag = "[object Number]";
        var regexpTag = "[object RegExp]";
        var setTag = "[object Set]";
        var stringTag = "[object String]";
        var symbolTag = "[object Symbol]";
        var arrayBufferTag = "[object ArrayBuffer]";
        var dataViewTag = "[object DataView]";
        var float32Tag = "[object Float32Array]";
        var float64Tag = "[object Float64Array]";
        var int8Tag = "[object Int8Array]";
        var int16Tag = "[object Int16Array]";
        var int32Tag = "[object Int32Array]";
        var uint8Tag = "[object Uint8Array]";
        var uint8ClampedTag = "[object Uint8ClampedArray]";
        var uint16Tag = "[object Uint16Array]";
        var uint32Tag = "[object Uint32Array]";
        function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch(tag){
                case arrayBufferTag:
                    return cloneArrayBuffer(object);
                case boolTag:
                case dateTag:
                    return new Ctor(+object);
                case dataViewTag:
                    return cloneDataView(object, isDeep);
                case float32Tag:
                case float64Tag:
                case int8Tag:
                case int16Tag:
                case int32Tag:
                case uint8Tag:
                case uint8ClampedTag:
                case uint16Tag:
                case uint32Tag:
                    return cloneTypedArray(object, isDeep);
                case mapTag:
                    return new Ctor();
                case numberTag:
                case stringTag:
                    return new Ctor(object);
                case regexpTag:
                    return cloneRegExp(object);
                case setTag:
                    return new Ctor();
                case symbolTag:
                    return cloneSymbol(object);
            }
        }
        module.exports = initCloneByTag;
    }
});
// node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
    "node_modules/lodash/_baseCreate.js" (exports, module) {
        var isObject2 = require_isObject();
        var objectCreate = Object.create;
        var baseCreate = /* @__PURE__ */ function() {
            function object() {}
            return function(proto) {
                if (!isObject2(proto)) {
                    return {};
                }
                if (objectCreate) {
                    return objectCreate(proto);
                }
                object.prototype = proto;
                var result = new object();
                object.prototype = void 0;
                return result;
            };
        }();
        module.exports = baseCreate;
    }
});
// node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
    "node_modules/lodash/_initCloneObject.js" (exports, module) {
        var baseCreate = require_baseCreate();
        var getPrototype = require_getPrototype();
        var isPrototype = require_isPrototype();
        function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        module.exports = initCloneObject;
    }
});
// node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
    "node_modules/lodash/_baseIsMap.js" (exports, module) {
        var getTag = require_getTag();
        var isObjectLike = require_isObjectLike();
        var mapTag = "[object Map]";
        function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
        }
        module.exports = baseIsMap;
    }
});
// node_modules/lodash/isMap.js
var require_isMap = __commonJS({
    "node_modules/lodash/isMap.js" (exports, module) {
        var baseIsMap = require_baseIsMap();
        var baseUnary = require_baseUnary();
        var nodeUtil = require_nodeUtil();
        var nodeIsMap = nodeUtil && nodeUtil.isMap;
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        module.exports = isMap;
    }
});
// node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
    "node_modules/lodash/_baseIsSet.js" (exports, module) {
        var getTag = require_getTag();
        var isObjectLike = require_isObjectLike();
        var setTag = "[object Set]";
        function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
        }
        module.exports = baseIsSet;
    }
});
// node_modules/lodash/isSet.js
var require_isSet = __commonJS({
    "node_modules/lodash/isSet.js" (exports, module) {
        var baseIsSet = require_baseIsSet();
        var baseUnary = require_baseUnary();
        var nodeUtil = require_nodeUtil();
        var nodeIsSet = nodeUtil && nodeUtil.isSet;
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        module.exports = isSet;
    }
});
// node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
    "node_modules/lodash/_baseClone.js" (exports, module) {
        var Stack = require_Stack();
        var arrayEach = require_arrayEach();
        var assignValue = require_assignValue();
        var baseAssign = require_baseAssign();
        var baseAssignIn = require_baseAssignIn();
        var cloneBuffer = require_cloneBuffer();
        var copyArray = require_copyArray();
        var copySymbols = require_copySymbols();
        var copySymbolsIn = require_copySymbolsIn();
        var getAllKeys = require_getAllKeys();
        var getAllKeysIn = require_getAllKeysIn();
        var getTag = require_getTag();
        var initCloneArray = require_initCloneArray();
        var initCloneByTag = require_initCloneByTag();
        var initCloneObject = require_initCloneObject();
        var isArray = require_isArray();
        var isBuffer = require_isBuffer();
        var isMap = require_isMap();
        var isObject2 = require_isObject();
        var isSet = require_isSet();
        var keys = require_keys();
        var keysIn = require_keysIn();
        var CLONE_DEEP_FLAG = 1;
        var CLONE_FLAT_FLAG = 2;
        var CLONE_SYMBOLS_FLAG = 4;
        var argsTag = "[object Arguments]";
        var arrayTag = "[object Array]";
        var boolTag = "[object Boolean]";
        var dateTag = "[object Date]";
        var errorTag = "[object Error]";
        var funcTag = "[object Function]";
        var genTag = "[object GeneratorFunction]";
        var mapTag = "[object Map]";
        var numberTag = "[object Number]";
        var objectTag = "[object Object]";
        var regexpTag = "[object RegExp]";
        var setTag = "[object Set]";
        var stringTag = "[object String]";
        var symbolTag = "[object Symbol]";
        var weakMapTag = "[object WeakMap]";
        var arrayBufferTag = "[object ArrayBuffer]";
        var dataViewTag = "[object DataView]";
        var float32Tag = "[object Float32Array]";
        var float64Tag = "[object Float64Array]";
        var int8Tag = "[object Int8Array]";
        var int16Tag = "[object Int16Array]";
        var int32Tag = "[object Int32Array]";
        var uint8Tag = "[object Uint8Array]";
        var uint8ClampedTag = "[object Uint8ClampedArray]";
        var uint16Tag = "[object Uint16Array]";
        var uint32Tag = "[object Uint32Array]";
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        function baseClone(value, bitmask, customizer, key, object, stack) {
            var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
                result = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result !== void 0) {
                return result;
            }
            if (!isObject2(value)) {
                return value;
            }
            var isArr = isArray(value);
            if (isArr) {
                result = initCloneArray(value);
                if (!isDeep) {
                    return copyArray(value, result);
                }
            } else {
                var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                if (isBuffer(value)) {
                    return cloneBuffer(value, isDeep);
                }
                if (tag == objectTag || tag == argsTag || isFunc && !object) {
                    result = isFlat || isFunc ? {} : initCloneObject(value);
                    if (!isDeep) {
                        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
                    }
                } else {
                    if (!cloneableTags[tag]) {
                        return object ? value : {};
                    }
                    result = initCloneByTag(value, tag, isDeep);
                }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
                return stacked;
            }
            stack.set(value, result);
            if (isSet(value)) {
                value.forEach(function(subValue) {
                    result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
                });
            } else if (isMap(value)) {
                value.forEach(function(subValue, key2) {
                    result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
                });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? void 0 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
                if (props) {
                    key2 = subValue;
                    subValue = value[key2];
                }
                assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result;
        }
        module.exports = baseClone;
    }
});
// node_modules/lodash/last.js
var require_last = __commonJS({
    "node_modules/lodash/last.js" (exports, module) {
        function last(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : void 0;
        }
        module.exports = last;
    }
});
// node_modules/lodash/_parent.js
var require_parent = __commonJS({
    "node_modules/lodash/_parent.js" (exports, module) {
        var baseGet = require_baseGet();
        var baseSlice = require_baseSlice();
        function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        module.exports = parent;
    }
});
// node_modules/lodash/_baseUnset.js
var require_baseUnset = __commonJS({
    "node_modules/lodash/_baseUnset.js" (exports, module) {
        var castPath = require_castPath();
        var last = require_last();
        var parent = require_parent();
        var toKey = require_toKey();
        function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey(last(path))];
        }
        module.exports = baseUnset;
    }
});
// node_modules/lodash/_customOmitClone.js
var require_customOmitClone = __commonJS({
    "node_modules/lodash/_customOmitClone.js" (exports, module) {
        var isPlainObject = require_isPlainObject();
        function customOmitClone(value) {
            return isPlainObject(value) ? void 0 : value;
        }
        module.exports = customOmitClone;
    }
});
// node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
    "node_modules/lodash/_isFlattenable.js" (exports, module) {
        var Symbol2 = require_Symbol();
        var isArguments = require_isArguments();
        var isArray = require_isArray();
        var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
        function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        module.exports = isFlattenable;
    }
});
// node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
    "node_modules/lodash/_baseFlatten.js" (exports, module) {
        var arrayPush = require_arrayPush();
        var isFlattenable = require_isFlattenable();
        function baseFlatten(array, depth, predicate, isStrict, result) {
            var index = -1, length = array.length;
            predicate || (predicate = isFlattenable);
            result || (result = []);
            while(++index < length){
                var value = array[index];
                if (depth > 0 && predicate(value)) {
                    if (depth > 1) {
                        baseFlatten(value, depth - 1, predicate, isStrict, result);
                    } else {
                        arrayPush(result, value);
                    }
                } else if (!isStrict) {
                    result[result.length] = value;
                }
            }
            return result;
        }
        module.exports = baseFlatten;
    }
});
// node_modules/lodash/flatten.js
var require_flatten = __commonJS({
    "node_modules/lodash/flatten.js" (exports, module) {
        var baseFlatten = require_baseFlatten();
        function flatten(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
        }
        module.exports = flatten;
    }
});
// node_modules/lodash/_flatRest.js
var require_flatRest = __commonJS({
    "node_modules/lodash/_flatRest.js" (exports, module) {
        var flatten = require_flatten();
        var overRest = require_overRest();
        var setToString = require_setToString();
        function flatRest(func) {
            return setToString(overRest(func, void 0, flatten), func + "");
        }
        module.exports = flatRest;
    }
});
// node_modules/lodash/omit.js
var require_omit = __commonJS({
    "node_modules/lodash/omit.js" (exports, module) {
        var arrayMap = require_arrayMap();
        var baseClone = require_baseClone();
        var baseUnset = require_baseUnset();
        var castPath = require_castPath();
        var copyObject = require_copyObject();
        var customOmitClone = require_customOmitClone();
        var flatRest = require_flatRest();
        var getAllKeysIn = require_getAllKeysIn();
        var CLONE_DEEP_FLAG = 1;
        var CLONE_FLAT_FLAG = 2;
        var CLONE_SYMBOLS_FLAG = 4;
        var omit = flatRest(function(object, paths) {
            var result = {};
            if (object == null) {
                return result;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path) {
                path = castPath(path, object);
                isDeep || (isDeep = path.length > 1);
                return path;
            });
            copyObject(object, getAllKeysIn(object), result);
            if (isDeep) {
                result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length = paths.length;
            while(length--){
                baseUnset(result, paths[length]);
            }
            return result;
        });
        module.exports = omit;
    }
});
// node_modules/lodash/_createRelationalOperation.js
var require_createRelationalOperation = __commonJS({
    "node_modules/lodash/_createRelationalOperation.js" (exports, module) {
        var toNumber = require_toNumber();
        function createRelationalOperation(operator) {
            return function(value, other) {
                if (!(typeof value == "string" && typeof other == "string")) {
                    value = toNumber(value);
                    other = toNumber(other);
                }
                return operator(value, other);
            };
        }
        module.exports = createRelationalOperation;
    }
});
// node_modules/lodash/gte.js
var require_gte = __commonJS({
    "node_modules/lodash/gte.js" (exports, module) {
        var createRelationalOperation = require_createRelationalOperation();
        var gte = createRelationalOperation(function(value, other) {
            return value >= other;
        });
        module.exports = gte;
    }
});
// node_modules/lodash/slice.js
var require_slice = __commonJS({
    "node_modules/lodash/slice.js" (exports, module) {
        var baseSlice = require_baseSlice();
        var isIterateeCall = require_isIterateeCall();
        var toInteger = require_toInteger();
        function slice(array, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
                return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
                start = 0;
                end = length;
            } else {
                start = start == null ? 0 : toInteger(start);
                end = end === void 0 ? length : toInteger(end);
            }
            return baseSlice(array, start, end);
        }
        module.exports = slice;
    }
});
// node_modules/performance-now/lib/performance-now.js
var require_performance_now = __commonJS({
    "node_modules/performance-now/lib/performance-now.js" (exports, module) {
        (function() {
            var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
            if (typeof performance !== "undefined" && performance !== null && performance.now) {
                module.exports = function() {
                    return performance.now();
                };
            } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
                module.exports = function() {
                    return (getNanoSeconds() - nodeLoadTime) / 1e6;
                };
                hrtime = process.hrtime;
                getNanoSeconds = function() {
                    var hr;
                    hr = hrtime();
                    return hr[0] * 1e9 + hr[1];
                };
                moduleLoadTime = getNanoSeconds();
                upTime = process.uptime() * 1e9;
                nodeLoadTime = moduleLoadTime - upTime;
            } else if (Date.now) {
                module.exports = function() {
                    return Date.now() - loadTime;
                };
                loadTime = Date.now();
            } else {
                module.exports = function() {
                    return /* @__PURE__ */ new Date().getTime() - loadTime;
                };
                loadTime = /* @__PURE__ */ new Date().getTime();
            }
        }).call(exports);
    }
});
// node_modules/raf/index.js
var require_raf = __commonJS({
    "node_modules/raf/index.js" (exports, module) {
        var now = require_performance_now();
        var root = typeof window === "undefined" ? global : window;
        var vendors = [
            "moz",
            "webkit"
        ];
        var suffix = "AnimationFrame";
        var raf2 = root["request" + suffix];
        var caf = root["cancel" + suffix] || root["cancelRequest" + suffix];
        for(i = 0; !raf2 && i < vendors.length; i++){
            raf2 = root[vendors[i] + "Request" + suffix];
            caf = root[vendors[i] + "Cancel" + suffix] || root[vendors[i] + "CancelRequest" + suffix];
        }
        var i;
        if (!raf2 || !caf) {
            last = 0, id = 0, queue = [], frameDuration = 1e3 / 60;
            raf2 = function(callback) {
                if (queue.length === 0) {
                    var _now = now(), next = Math.max(0, frameDuration - (_now - last));
                    last = next + _now;
                    setTimeout(function() {
                        var cp = queue.slice(0);
                        queue.length = 0;
                        for(var i2 = 0; i2 < cp.length; i2++){
                            if (!cp[i2].cancelled) {
                                try {
                                    cp[i2].callback(last);
                                } catch (e) {
                                    setTimeout(function() {
                                        throw e;
                                    }, 0);
                                }
                            }
                        }
                    }, Math.round(next));
                }
                queue.push({
                    handle: ++id,
                    callback,
                    cancelled: false
                });
                return id;
            };
            caf = function(handle) {
                for(var i2 = 0; i2 < queue.length; i2++){
                    if (queue[i2].handle === handle) {
                        queue[i2].cancelled = true;
                    }
                }
            };
        }
        var last;
        var id;
        var queue;
        var frameDuration;
        module.exports = function(fn) {
            return raf2.call(root, fn);
        };
        module.exports.cancel = function() {
            caf.apply(root, arguments);
        };
        module.exports.polyfill = function(object) {
            if (!object) {
                object = root;
            }
            object.requestAnimationFrame = raf2;
            object.cancelAnimationFrame = caf;
        };
    }
});
// node_modules/lodash/_baseGt.js
var require_baseGt = __commonJS({
    "node_modules/lodash/_baseGt.js" (exports, module) {
        function baseGt(value, other) {
            return value > other;
        }
        module.exports = baseGt;
    }
});
// node_modules/lodash/gt.js
var require_gt = __commonJS({
    "node_modules/lodash/gt.js" (exports, module) {
        var baseGt = require_baseGt();
        var createRelationalOperation = require_createRelationalOperation();
        var gt = createRelationalOperation(baseGt);
        module.exports = gt;
    }
});
// node_modules/lodash/_baseIsDate.js
var require_baseIsDate = __commonJS({
    "node_modules/lodash/_baseIsDate.js" (exports, module) {
        var baseGetTag = require_baseGetTag();
        var isObjectLike = require_isObjectLike();
        var dateTag = "[object Date]";
        function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        module.exports = baseIsDate;
    }
});
// node_modules/lodash/isDate.js
var require_isDate = __commonJS({
    "node_modules/lodash/isDate.js" (exports, module) {
        var baseIsDate = require_baseIsDate();
        var baseUnary = require_baseUnary();
        var nodeUtil = require_nodeUtil();
        var nodeIsDate = nodeUtil && nodeUtil.isDate;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        module.exports = isDate;
    }
});
// node_modules/lodash/concat.js
var require_concat = __commonJS({
    "node_modules/lodash/concat.js" (exports, module) {
        var arrayPush = require_arrayPush();
        var baseFlatten = require_baseFlatten();
        var copyArray = require_copyArray();
        var isArray = require_isArray();
        function concat() {
            var length = arguments.length;
            if (!length) {
                return [];
            }
            var args = Array(length - 1), array = arguments[0], index = length;
            while(index--){
                args[index - 1] = arguments[index];
            }
            return arrayPush(isArray(array) ? copyArray(array) : [
                array
            ], baseFlatten(args, 1));
        }
        module.exports = concat;
    }
});
// node_modules/lodash/_baseSome.js
var require_baseSome = __commonJS({
    "node_modules/lodash/_baseSome.js" (exports, module) {
        var baseEach = require_baseEach();
        function baseSome(collection, predicate) {
            var result;
            baseEach(collection, function(value, index, collection2) {
                result = predicate(value, index, collection2);
                return !result;
            });
            return !!result;
        }
        module.exports = baseSome;
    }
});
// node_modules/lodash/some.js
var require_some = __commonJS({
    "node_modules/lodash/some.js" (exports, module) {
        var arraySome = require_arraySome();
        var baseIteratee = require_baseIteratee();
        var baseSome = require_baseSome();
        var isArray = require_isArray();
        var isIterateeCall = require_isIterateeCall();
        function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
                predicate = void 0;
            }
            return func(collection, baseIteratee(predicate, 3));
        }
        module.exports = some;
    }
});
// node_modules/lodash/_iteratorToArray.js
var require_iteratorToArray = __commonJS({
    "node_modules/lodash/_iteratorToArray.js" (exports, module) {
        function iteratorToArray(iterator) {
            var data, result = [];
            while(!(data = iterator.next()).done){
                result.push(data.value);
            }
            return result;
        }
        module.exports = iteratorToArray;
    }
});
// node_modules/lodash/_baseValues.js
var require_baseValues = __commonJS({
    "node_modules/lodash/_baseValues.js" (exports, module) {
        var arrayMap = require_arrayMap();
        function baseValues(object, props) {
            return arrayMap(props, function(key) {
                return object[key];
            });
        }
        module.exports = baseValues;
    }
});
// node_modules/lodash/values.js
var require_values = __commonJS({
    "node_modules/lodash/values.js" (exports, module) {
        var baseValues = require_baseValues();
        var keys = require_keys();
        function values2(object) {
            return object == null ? [] : baseValues(object, keys(object));
        }
        module.exports = values2;
    }
});
// node_modules/lodash/toArray.js
var require_toArray = __commonJS({
    "node_modules/lodash/toArray.js" (exports, module) {
        var Symbol2 = require_Symbol();
        var copyArray = require_copyArray();
        var getTag = require_getTag();
        var isArrayLike = require_isArrayLike();
        var isString2 = require_isString();
        var iteratorToArray = require_iteratorToArray();
        var mapToArray = require_mapToArray();
        var setToArray = require_setToArray();
        var stringToArray = require_stringToArray();
        var values2 = require_values();
        var mapTag = "[object Map]";
        var setTag = "[object Set]";
        var symIterator = Symbol2 ? Symbol2.iterator : void 0;
        function toArray(value) {
            if (!value) {
                return [];
            }
            if (isArrayLike(value)) {
                return isString2(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
                return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values2;
            return func(value);
        }
        module.exports = toArray;
    }
});
// node_modules/lodash/times.js
var require_times = __commonJS({
    "node_modules/lodash/times.js" (exports, module) {
        var baseTimes = require_baseTimes();
        var castFunction = require_castFunction();
        var toInteger = require_toInteger();
        var MAX_SAFE_INTEGER = 9007199254740991;
        var MAX_ARRAY_LENGTH = 4294967295;
        var nativeMin = Math.min;
        function times(n, iteratee) {
            n = toInteger(n);
            if (n < 1 || n > MAX_SAFE_INTEGER) {
                return [];
            }
            var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee = castFunction(iteratee);
            n -= MAX_ARRAY_LENGTH;
            var result = baseTimes(length, iteratee);
            while(++index < n){
                iteratee(index);
            }
            return result;
        }
        module.exports = times;
    }
});
// node_modules/lodash/padStart.js
var require_padStart = __commonJS({
    "node_modules/lodash/padStart.js" (exports, module) {
        var createPadding = require_createPadding();
        var stringSize = require_stringSize();
        var toInteger = require_toInteger();
        var toString2 = require_toString();
        function padStart(string, length, chars) {
            string = toString2(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        module.exports = padStart;
    }
});
// node_modules/lodash/_baseReduce.js
var require_baseReduce = __commonJS({
    "node_modules/lodash/_baseReduce.js" (exports, module) {
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
            eachFunc(collection, function(value, index, collection2) {
                accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
            });
            return accumulator;
        }
        module.exports = baseReduce;
    }
});
// node_modules/lodash/reduce.js
var require_reduce = __commonJS({
    "node_modules/lodash/reduce.js" (exports, module) {
        var arrayReduce = require_arrayReduce();
        var baseEach = require_baseEach();
        var baseIteratee = require_baseIteratee();
        var baseReduce = require_baseReduce();
        var isArray = require_isArray();
        function reduce(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
        }
        module.exports = reduce;
    }
});
// node_modules/lodash/cloneDeep.js
var require_cloneDeep = __commonJS({
    "node_modules/lodash/cloneDeep.js" (exports, module) {
        var baseClone = require_baseClone();
        var CLONE_DEEP_FLAG = 1;
        var CLONE_SYMBOLS_FLAG = 4;
        function cloneDeep2(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        module.exports = cloneDeep2;
    }
});
// node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
    "node_modules/lodash/_baseIsNaN.js" (exports, module) {
        function baseIsNaN(value) {
            return value !== value;
        }
        module.exports = baseIsNaN;
    }
});
// node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
    "node_modules/lodash/_strictIndexOf.js" (exports, module) {
        function strictIndexOf(array, value, fromIndex) {
            var index = fromIndex - 1, length = array.length;
            while(++index < length){
                if (array[index] === value) {
                    return index;
                }
            }
            return -1;
        }
        module.exports = strictIndexOf;
    }
});
// node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
    "node_modules/lodash/_baseIndexOf.js" (exports, module) {
        var baseFindIndex = require_baseFindIndex();
        var baseIsNaN = require_baseIsNaN();
        var strictIndexOf = require_strictIndexOf();
        function baseIndexOf(array, value, fromIndex) {
            return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        module.exports = baseIndexOf;
    }
});
// node_modules/lodash/includes.js
var require_includes = __commonJS({
    "node_modules/lodash/includes.js" (exports, module) {
        var baseIndexOf = require_baseIndexOf();
        var isArrayLike = require_isArrayLike();
        var isString2 = require_isString();
        var toInteger = require_toInteger();
        var values2 = require_values();
        var nativeMax = Math.max;
        function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values2(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
                fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        module.exports = includes;
    }
});
// node_modules/lodash/flatMap.js
var require_flatMap = __commonJS({
    "node_modules/lodash/flatMap.js" (exports, module) {
        var baseFlatten = require_baseFlatten();
        var map2 = require_map();
        function flatMap(collection, iteratee) {
            return baseFlatten(map2(collection, iteratee), 1);
        }
        module.exports = flatMap;
    }
});
// node_modules/lodash/isError.js
var require_isError = __commonJS({
    "node_modules/lodash/isError.js" (exports, module) {
        var baseGetTag = require_baseGetTag();
        var isObjectLike = require_isObjectLike();
        var isPlainObject = require_isPlainObject();
        var domExcTag = "[object DOMException]";
        var errorTag = "[object Error]";
        function isError(value) {
            if (!isObjectLike(value)) {
                return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        module.exports = isError;
    }
});
// node_modules/lodash/now.js
var require_now = __commonJS({
    "node_modules/lodash/now.js" (exports, module) {
        var root = require_root();
        var now = function() {
            return root.Date.now();
        };
        module.exports = now;
    }
});
// node_modules/lodash/debounce.js
var require_debounce = __commonJS({
    "node_modules/lodash/debounce.js" (exports, module) {
        var isObject2 = require_isObject();
        var now = require_now();
        var toNumber = require_toNumber();
        var FUNC_ERROR_TEXT = "Expected a function";
        var nativeMax = Math.max;
        var nativeMin = Math.min;
        function debounce2(func, wait, options) {
            var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject2(options)) {
                leading = !!options.leading;
                maxing = "maxWait" in options;
                maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
                var args = lastArgs, thisArg = lastThis;
                lastArgs = lastThis = void 0;
                lastInvokeTime = time;
                result = func.apply(thisArg, args);
                return result;
            }
            function leadingEdge(time) {
                lastInvokeTime = time;
                timerId = setTimeout(timerExpired, wait);
                return leading ? invokeFunc(time) : result;
            }
            function remainingWait(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
                return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
                var time = now();
                if (shouldInvoke(time)) {
                    return trailingEdge(time);
                }
                timerId = setTimeout(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
                timerId = void 0;
                if (trailing && lastArgs) {
                    return invokeFunc(time);
                }
                lastArgs = lastThis = void 0;
                return result;
            }
            function cancel2() {
                if (timerId !== void 0) {
                    clearTimeout(timerId);
                }
                lastInvokeTime = 0;
                lastArgs = lastCallTime = lastThis = timerId = void 0;
            }
            function flush() {
                return timerId === void 0 ? result : trailingEdge(now());
            }
            function debounced() {
                var time = now(), isInvoking = shouldInvoke(time);
                lastArgs = arguments;
                lastThis = this;
                lastCallTime = time;
                if (isInvoking) {
                    if (timerId === void 0) {
                        return leadingEdge(lastCallTime);
                    }
                    if (maxing) {
                        clearTimeout(timerId);
                        timerId = setTimeout(timerExpired, wait);
                        return invokeFunc(lastCallTime);
                    }
                }
                if (timerId === void 0) {
                    timerId = setTimeout(timerExpired, wait);
                }
                return result;
            }
            debounced.cancel = cancel2;
            debounced.flush = flush;
            return debounced;
        }
        module.exports = debounce2;
    }
});
// node_modules/lodash/throttle.js
var require_throttle = __commonJS({
    "node_modules/lodash/throttle.js" (exports, module) {
        var debounce2 = require_debounce();
        var isObject2 = require_isObject();
        var FUNC_ERROR_TEXT = "Expected a function";
        function throttle2(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            if (isObject2(options)) {
                leading = "leading" in options ? !!options.leading : leading;
                trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce2(func, wait, {
                "leading": leading,
                "maxWait": wait,
                "trailing": trailing
            });
        }
        module.exports = throttle2;
    }
});
// node_modules/lodash/isNaN.js
var require_isNaN = __commonJS({
    "node_modules/lodash/isNaN.js" (exports, module) {
        var isNumber2 = require_isNumber();
        function isNaN(value) {
            return isNumber2(value) && value != +value;
        }
        module.exports = isNaN;
    }
});
// node_modules/lodash/replace.js
var require_replace = __commonJS({
    "node_modules/lodash/replace.js" (exports, module) {
        var toString2 = require_toString();
        function replace() {
            var args = arguments, string = toString2(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        module.exports = replace;
    }
});
// node_modules/@taroify/core/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development2 = __commonJS({
    "node_modules/@taroify/core/node_modules/react-is/cjs/react-is.development.js" (exports) {
        "use strict";
        if (true) {
            (function() {
                "use strict";
                var REACT_ELEMENT_TYPE = Symbol.for("react.element");
                var REACT_PORTAL_TYPE = Symbol.for("react.portal");
                var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
                var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
                var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
                var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
                var REACT_CONTEXT_TYPE = Symbol.for("react.context");
                var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
                var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
                var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
                var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
                var REACT_MEMO_TYPE = Symbol.for("react.memo");
                var REACT_LAZY_TYPE = Symbol.for("react.lazy");
                var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
                var enableScopeAPI = false;
                var enableCacheElement = false;
                var enableTransitionTracing = false;
                var enableLegacyHidden = false;
                var enableDebugTracing = false;
                var REACT_MODULE_REFERENCE;
                {
                    REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
                }
                function isValidElementType(type) {
                    if (typeof type === "string" || typeof type === "function") {
                        return true;
                    }
                    if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
                        return true;
                    }
                    if (typeof type === "object" && type !== null) {
                        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
                        // types supported by any Flight configuration anywhere since
                        // we don't know which Flight build this will end up being used
                        // with.
                        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
                            return true;
                        }
                    }
                    return false;
                }
                function typeOf(object) {
                    if (typeof object === "object" && object !== null) {
                        var $$typeof = object.$$typeof;
                        switch($$typeof){
                            case REACT_ELEMENT_TYPE:
                                var type = object.type;
                                switch(type){
                                    case REACT_FRAGMENT_TYPE:
                                    case REACT_PROFILER_TYPE:
                                    case REACT_STRICT_MODE_TYPE:
                                    case REACT_SUSPENSE_TYPE:
                                    case REACT_SUSPENSE_LIST_TYPE:
                                        return type;
                                    default:
                                        var $$typeofType = type && type.$$typeof;
                                        switch($$typeofType){
                                            case REACT_SERVER_CONTEXT_TYPE:
                                            case REACT_CONTEXT_TYPE:
                                            case REACT_FORWARD_REF_TYPE:
                                            case REACT_LAZY_TYPE:
                                            case REACT_MEMO_TYPE:
                                            case REACT_PROVIDER_TYPE:
                                                return $$typeofType;
                                            default:
                                                return $$typeof;
                                        }
                                }
                            case REACT_PORTAL_TYPE:
                                return $$typeof;
                        }
                    }
                    return void 0;
                }
                var ContextConsumer = REACT_CONTEXT_TYPE;
                var ContextProvider = REACT_PROVIDER_TYPE;
                var Element2 = REACT_ELEMENT_TYPE;
                var ForwardRef = REACT_FORWARD_REF_TYPE;
                var Fragment20 = REACT_FRAGMENT_TYPE;
                var Lazy = REACT_LAZY_TYPE;
                var Memo = REACT_MEMO_TYPE;
                var Portal = REACT_PORTAL_TYPE;
                var Profiler = REACT_PROFILER_TYPE;
                var StrictMode = REACT_STRICT_MODE_TYPE;
                var Suspense = REACT_SUSPENSE_TYPE;
                var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
                var hasWarnedAboutDeprecatedIsAsyncMode = false;
                var hasWarnedAboutDeprecatedIsConcurrentMode = false;
                function isAsyncMode(object) {
                    {
                        if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                            hasWarnedAboutDeprecatedIsAsyncMode = true;
                            console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
                        }
                    }
                    return false;
                }
                function isConcurrentMode(object) {
                    {
                        if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
                            hasWarnedAboutDeprecatedIsConcurrentMode = true;
                            console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
                        }
                    }
                    return false;
                }
                function isContextConsumer(object) {
                    return typeOf(object) === REACT_CONTEXT_TYPE;
                }
                function isContextProvider(object) {
                    return typeOf(object) === REACT_PROVIDER_TYPE;
                }
                function isElement(object) {
                    return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
                }
                function isForwardRef(object) {
                    return typeOf(object) === REACT_FORWARD_REF_TYPE;
                }
                function isFragment2(object) {
                    return typeOf(object) === REACT_FRAGMENT_TYPE;
                }
                function isLazy(object) {
                    return typeOf(object) === REACT_LAZY_TYPE;
                }
                function isMemo(object) {
                    return typeOf(object) === REACT_MEMO_TYPE;
                }
                function isPortal(object) {
                    return typeOf(object) === REACT_PORTAL_TYPE;
                }
                function isProfiler(object) {
                    return typeOf(object) === REACT_PROFILER_TYPE;
                }
                function isStrictMode(object) {
                    return typeOf(object) === REACT_STRICT_MODE_TYPE;
                }
                function isSuspense(object) {
                    return typeOf(object) === REACT_SUSPENSE_TYPE;
                }
                function isSuspenseList(object) {
                    return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
                }
                exports.ContextConsumer = ContextConsumer;
                exports.ContextProvider = ContextProvider;
                exports.Element = Element2;
                exports.ForwardRef = ForwardRef;
                exports.Fragment = Fragment20;
                exports.Lazy = Lazy;
                exports.Memo = Memo;
                exports.Portal = Portal;
                exports.Profiler = Profiler;
                exports.StrictMode = StrictMode;
                exports.Suspense = Suspense;
                exports.SuspenseList = SuspenseList;
                exports.isAsyncMode = isAsyncMode;
                exports.isConcurrentMode = isConcurrentMode;
                exports.isContextConsumer = isContextConsumer;
                exports.isContextProvider = isContextProvider;
                exports.isElement = isElement;
                exports.isForwardRef = isForwardRef;
                exports.isFragment = isFragment2;
                exports.isLazy = isLazy;
                exports.isMemo = isMemo;
                exports.isPortal = isPortal;
                exports.isProfiler = isProfiler;
                exports.isStrictMode = isStrictMode;
                exports.isSuspense = isSuspense;
                exports.isSuspenseList = isSuspenseList;
                exports.isValidElementType = isValidElementType;
                exports.typeOf = typeOf;
            })();
        }
    }
});
// node_modules/@taroify/core/node_modules/react-is/index.js
var require_react_is2 = __commonJS({
    "node_modules/@taroify/core/node_modules/react-is/index.js" (exports, module) {
        "use strict";
        if (false) {
            module.exports = null;
        } else {
            module.exports = require_react_is_development2();
        }
    }
});
// node_modules/@taroify/icons/utils/index.js
var import_classnames = __toESM(require_classnames());
var import_hasIn = __toESM(require_hasIn());
var import_react = __toESM(require_react());
// node_modules/@taroify/icons/shared.js
var ICON_TYPE = Symbol("__iconType__");
var ICON_PRESET_SIZES = [
    "inherit",
    "mini",
    "small",
    "medium",
    "large"
];
var ICON_PRESET_COLORS = [
    "inherit",
    "default",
    "primary",
    "info",
    "success",
    "warning",
    "danger"
];
// node_modules/@taroify/icons/utils/index.js
function isIconElement(node) {
    if (!(0, import_react.isValidElement)(node)) {
        return false;
    }
    const element = node;
    return (0, import_hasIn.default)(element.type, ICON_TYPE);
}
function cloneIconElement(node, props) {
    if (!isIconElement(node)) {
        return (0, import_react.isValidElement)(node) ? (0, import_react.cloneElement)(node, props) : node;
    }
    const { className } = props, restProps = _object_without_properties(props, [
        "className"
    ]);
    const element = node;
    const { props: oldProps } = element;
    const newProps = _object_spread(_object_spread_props(_object_spread({}, oldProps), {
        className: (0, import_classnames.default)(oldProps.className, className)
    }), restProps);
    return (0, import_react.cloneElement)(element, newProps);
}
// node_modules/@taroify/core/button/button.js
var import_classnames5 = __toESM(require_classnames());
var import_isBoolean = __toESM(require_isBoolean());
var import_size = __toESM(require_size());
var import_map2 = __toESM(require_map());
var import_isPlainObject = __toESM(require_isPlainObject());
var React4 = __toESM(require_react());
var import_react7 = __toESM(require_react());
// node_modules/@taroify/core/button-base/button-base.js
var import_classnames2 = __toESM(require_classnames());
var React = __toESM(require_react());
// node_modules/@taroify/core/styles/prefix.js
var COMPONENT_PREFIX = "taroify-";
function prefixClassname(component) {
    return `${COMPONENT_PREFIX}${component}`;
}
// node_modules/@taroify/core/button-base/button-base.js
function ButtonBase(props) {
    const { className } = props, restProps = _object_without_properties(props, [
        "className"
    ]);
    return React.createElement(Button, _object_spread({
        className: (0, import_classnames2.default)(prefixClassname("button-base"), className)
    }, restProps));
}
var button_base_default = ButtonBase;
// node_modules/@taroify/core/loading/loading.js
var import_classnames3 = __toESM(require_classnames());
var import_range = __toESM(require_range());
var React2 = __toESM(require_react());
var import_react2 = __toESM(require_react());
// node_modules/@taroify/core/utils/format/unit.js
var import_isNumber = __toESM(require_isNumber());
var import_isString = __toESM(require_isString());
function addUnitPx(value) {
    return value === void 0 ? "" : `${unitToPx(value)}px`;
}
function getSizeStyle(originSize) {
    if ((0, import_isNumber.default)(originSize) || (0, import_isString.default)(originSize)) {
        const size = addUnitPx(originSize);
        return {
            width: size,
            height: size
        };
    }
    return {};
}
var rootFontSize;
function getRootFontSize() {
    if (!rootFontSize) {
        const doc = document.documentElement;
        const fontSize = doc.style.fontSize || window.getComputedStyle(doc).fontSize;
        rootFontSize = Number.parseFloat(fontSize);
    }
    return rootFontSize;
}
function convertRpx(value) {
    let valueCache = value;
    valueCache = valueCache.replace(/rpx/g, "");
    const { windowWidth } = getWindowInfo();
    const pixelRatio = 750 / windowWidth;
    return +valueCache / pixelRatio;
}
function convertPx(value) {
    let valueCache = value;
    valueCache = valueCache.replace(/px/g, "");
    return +valueCache;
}
function convertRem(value) {
    let valueCache = value;
    valueCache = valueCache.replace(/rem/g, "");
    return +valueCache * getRootFontSize();
}
function convertVw(value) {
    let valueCache = value;
    valueCache = valueCache.replace(/vw/g, "");
    return +valueCache * window.innerWidth / 100;
}
function convertVh(value) {
    let valueCache = value;
    valueCache = valueCache.replace(/vh/g, "");
    return +valueCache * window.innerHeight / 100;
}
function unitToPx(value) {
    if (typeof value === "number") {
        return value;
    }
    if (value.includes("rpx")) {
        return convertRpx(value);
    }
    if (value.includes("px")) {
        return convertPx(value);
    }
    if (value.includes("rem")) {
        return convertRem(value);
    }
    if (value.includes("vw")) {
        return convertVw(value);
    }
    if (value.includes("vh")) {
        return convertVh(value);
    }
    return Number.parseFloat(value);
}
// node_modules/@taroify/core/loading/loading.js
var SpinIcon = (0, import_range.default)(0, 12).map((key)=>React2.createElement(View, {
        key,
        className: prefixClassname("loading__spinner__item")
    }));
function LoadingSpinner(props) {
    const { size } = props;
    const rootStyle = (0, import_react2.useMemo)(()=>({
            width: addUnitPx(size) || "",
            height: addUnitPx(size) || ""
        }), [
        size
    ]);
    return React2.createElement(View, {
        className: prefixClassname("loading__spinner"),
        style: rootStyle
    }, SpinIcon);
}
function LoadingCircular(props) {
    const { size } = props;
    const rootStyle = (0, import_react2.useMemo)(()=>({
            width: addUnitPx(size) || "",
            height: addUnitPx(size) || ""
        }), [
        size
    ]);
    return React2.createElement(View, {
        className: prefixClassname("loading__circular"),
        style: rootStyle
    });
}
function Loading(props) {
    const { className, size, type = "circular", direction = "horizontal", children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "size",
        "type",
        "direction",
        "children"
    ]);
    return React2.createElement(View, _object_spread({
        className: (0, import_classnames3.default)(prefixClassname("loading"), prefixClassname(`loading--${direction}`), prefixClassname(`loading--${type}`), className)
    }, restProps), type === "spinner" && React2.createElement(LoadingSpinner, {
        size
    }), type === "circular" && React2.createElement(LoadingCircular, {
        size
    }), children2 && React2.createElement(View, {
        className: prefixClassname("loading__text"),
        children: children2
    }));
}
// node_modules/@taroify/core/utils/children.js
var import_isArray2 = __toESM(require_isArray());
var import_first = __toESM(require_first());
var import_forEach = __toESM(require_forEach());
var import_map = __toESM(require_map());
var import_react4 = __toESM(require_react());
// node_modules/@taroify/core/utils/validate/index.js
var import_isUndefined = __toESM(require_isUndefined());
var import_isNull = __toESM(require_isNull());
var import_isNumber2 = __toESM(require_isNumber());
var import_isString2 = __toESM(require_isString());
var import_isObject = __toESM(require_isObject());
var import_isArray = __toESM(require_isArray());
var import_get = __toESM(require_get());
var import_isFunction = __toESM(require_isFunction());
var import_isEmpty = __toESM(require_isEmpty());
var import_endsWith = __toESM(require_endsWith());
var import_react3 = __toESM(require_react());
function isTextElement(node) {
    return (0, import_isNumber2.default)(node) || (0, import_isString2.default)(node);
}
function isObjectElement(node) {
    return !(0, import_react3.isValidElement)(node) && (0, import_isObject.default)(node) && !(0, import_isArray.default)(node);
}
function isElementOf(node, type) {
    if ((0, import_react3.isValidElement)(node)) {
        const element = node;
        if (element.type === type) {
            return true;
        }
        const displayName = (0, import_get.default)(element.type, "displayName");
        if ((0, import_isFunction.default)(element.type) && !(0, import_isEmpty.default)(displayName) && (0, import_endsWith.default)(displayName, (0, import_get.default)(type, "displayName"))) {
            return true;
        }
    }
    return false;
}
// node_modules/@taroify/core/utils/children.js
function isObjectChildren(children2) {
    if (!(0, import_isArray2.default)(children2)) {
        return false;
    }
    const node = (0, import_first.default)(children2);
    return isObjectElement(node);
}
function forEachChildren(children2, fn) {
    const objectified = isObjectChildren(children2);
    const forEach = objectified ? import_forEach.default : import_react4.Children.forEach;
    return forEach(children2, fn);
}
function mapChildren(children2, fn) {
    const objectified = isObjectChildren(children2);
    const map2 = objectified ? import_map.default : import_react4.Children.map;
    return map2(children2, fn);
}
var Children = {
    toArray: import_react4.Children.toArray,
    forEach: forEachChildren,
    map: mapChildren
};
var children_default = Children;
// node_modules/@taroify/core/button/button-content.js
var import_classnames4 = __toESM(require_classnames());
var React3 = __toESM(require_react());
function ButtonContent(props) {
    const { className } = props, restProps = _object_without_properties(props, [
        "className"
    ]);
    return React3.createElement(View, _object_spread({
        className: (0, import_classnames4.default)(prefixClassname("button__content"), className)
    }, restProps));
}
var button_content_default = ButtonContent;
// node_modules/@taroify/core/button/button-group.context.js
var import_react5 = __toESM(require_react());
var ButtonGroupContext = (0, import_react5.createContext)({});
var button_group_context_default = ButtonGroupContext;
// node_modules/@taroify/core/button/button.context.js
var import_react6 = __toESM(require_react());
var ButtonContext = (0, import_react6.createContext)({});
var button_context_default = ButtonContext;
// node_modules/@taroify/core/button/button.js
function useButtonLoading(loading) {
    return (0, import_react7.useMemo)(()=>{
        if ((0, import_isBoolean.default)(loading) && loading) {
            return React4.createElement(Loading, {
                className: (0, import_classnames5.default)(prefixClassname("button__loading"), prefixClassname("button__loading--right"))
            });
        }
        if (isObjectElement(loading)) {
            const { className } = loading, restProps = _object_without_properties(loading, [
                "className"
            ]);
            return React4.createElement(Loading, _object_spread({
                className: (0, import_classnames5.default)(prefixClassname("button__loading"), prefixClassname("button__loading--right"), className)
            }, restProps));
        }
        if (isElementOf(loading, Loading)) {
            return (0, import_react7.cloneElement)(loading, {
                className: (0, import_classnames5.default)(prefixClassname("button__loading"), prefixClassname("button__loading--right"))
            });
        }
        return loading;
    }, [
        loading
    ]);
}
function appendButtonIconClassname(icon, className) {
    return isIconElement(icon) ? cloneIconElement(icon, {
        className
    }) : icon;
}
function useButtonChildren(options) {
    const { loading, icon: iconProp, children: children2, iconPosition } = options;
    if (isElementOf(children2, button_content_default)) {
        return children2;
    }
    const childrenArray = children_default.toArray(children2);
    const lastIndex = (0, import_size.default)(childrenArray) - 1;
    const icon = appendButtonIconClassname(iconProp, prefixClassname(iconPosition === "left" ? "button__icon--right" : "button__icon--left"));
    return React4.createElement(button_content_default, null, loading, iconPosition === "left" && icon, (0, import_map2.default)(childrenArray, (child, index)=>{
        if (isIconElement(child) && index === 0) {
            return appendButtonIconClassname(child, prefixClassname("button__icon--right"));
        }
        if (isIconElement(child) && index === lastIndex) {
            return appendButtonIconClassname(child, prefixClassname("button__icon--left"));
        }
        return React4.createElement(View, {
            key: index,
            className: prefixClassname("button__text")
        }, child);
    }), iconPosition === "right" && icon);
}
function useButtonPropertyValue(value1, value2, defaultValue) {
    return (0, import_react7.useMemo)(()=>{
        if (value1) {
            return value1;
        }
        if (value2) {
            return value2;
        }
        return defaultValue;
    }, [
        defaultValue,
        value1,
        value2
    ]);
}
function Button2(props) {
    const { className, style, variant: variantProp, shape: shapeProp, size: sizeProp, color: colorProp, formType = "button", block, hairline: hairlineProp, disabled: disabledProp, loading: loadingProp, icon, iconPosition = "left", children: childrenProp, onClick } = props, restProps = _object_without_properties(props, [
        "className",
        "style",
        "variant",
        "shape",
        "size",
        "color",
        "formType",
        "block",
        "hairline",
        "disabled",
        "loading",
        "icon",
        "iconPosition",
        "children",
        "onClick"
    ]);
    const { variant: variantCtx, shape: shapeCtx, size: sizeCtx, color: colorCtx, hairline: hairlineCtx, disabled: disabledCtx } = (0, import_react7.useContext)(button_group_context_default);
    const { onClick: onCtxClick } = (0, import_react7.useContext)(button_context_default);
    const variant = useButtonPropertyValue(variantProp, variantCtx, "contained");
    const shape = useButtonPropertyValue(shapeProp, shapeCtx);
    const size = useButtonPropertyValue(sizeProp, sizeCtx, "medium");
    const color = useButtonPropertyValue(colorProp, colorCtx, "default");
    const hairline = useButtonPropertyValue(hairlineProp, hairlineCtx);
    const disabled = useButtonPropertyValue(disabledProp, disabledCtx);
    const loading = useButtonLoading(loadingProp);
    const children2 = useButtonChildren({
        children: childrenProp,
        loading,
        icon,
        iconPosition
    });
    return React4.createElement(View, {
        className: (0, import_classnames5.default)(prefixClassname("button"), {
            [prefixClassname("button--text")]: variant === "text",
            [prefixClassname("button--contained")]: variant === "contained",
            [prefixClassname("button--outlined")]: variant === "outlined",
            [prefixClassname(`button--${color}`)]: color,
            [prefixClassname("button--round")]: shape === "round",
            [prefixClassname("button--square")]: shape === "square",
            [prefixClassname("button--mini")]: size === "mini",
            [prefixClassname("button--small")]: size === "small",
            [prefixClassname("button--medium")]: size === "medium",
            [prefixClassname("button--large")]: size === "large",
            [prefixClassname("button--hairline")]: hairline,
            [prefixClassname("hairline--surround")]: hairline,
            [prefixClassname("button--disabled")]: disabled,
            [prefixClassname("button--loading")]: loading,
            [prefixClassname("button--block")]: block
        }, className),
        style,
        onClick: (e)=>{
            if (!disabled && !loading) {
                onClick === null || onClick === void 0 ? void 0 : onClick(e);
                onCtxClick === null || onCtxClick === void 0 ? void 0 : onCtxClick(e, props);
            }
        }
    }, children2, React4.createElement(button_base_default, _object_spread({
        className: prefixClassname("button__button"),
        formType: formType === "submit" ? "submit" : formType === "reset" ? "reset" : void 0,
        disabled: disabled || !!loading,
        loading: false
    }, restProps)));
}
function createButton(children2, props) {
    if ((0, import_isPlainObject.default)(children2)) {
        return React4.createElement(Button2, _object_spread({}, children2, props));
    }
    return React4.createElement(Button2, _object_spread({
        children: children2
    }, props));
}
// node_modules/@taroify/core/button/button-group.js
var import_classnames6 = __toESM(require_classnames());
var React5 = __toESM(require_react());
function ButtonGroup(props) {
    const { className, variant, shape, size, color, block, hairline, disabled } = props, restProps = _object_without_properties(props, [
        "className",
        "variant",
        "shape",
        "size",
        "color",
        "block",
        "hairline",
        "disabled"
    ]);
    return React5.createElement(button_group_context_default.Provider, {
        value: {
            variant,
            size,
            color,
            shape,
            hairline,
            disabled
        }
    }, React5.createElement(View, _object_spread({
        className: (0, import_classnames6.default)(prefixClassname("button-group"), {
            [prefixClassname("button-group--contained")]: variant === "contained",
            [prefixClassname("button-group--text")]: variant === "text",
            [prefixClassname("button-group--outlined")]: variant === "outlined",
            [prefixClassname("button-group--round")]: shape === "round",
            [prefixClassname("button-group--block")]: block
        }, className)
    }, restProps)));
}
var button_group_default = ButtonGroup;
// node_modules/@taroify/core/button/index.js
var Button3 = Button2;
Button3.Content = button_content_default;
Button3.Group = button_group_default;
var button_default = Button3;
// node_modules/@taroify/core/cell/cell.js
var React11 = __toESM(require_react());
// node_modules/@taroify/core/cell/cell-base.js
var import_classnames8 = __toESM(require_classnames());
var React7 = __toESM(require_react());
var import_react9 = __toESM(require_react());
// node_modules/@taroify/icons/van/VanIcon.js
var import_classnames7 = __toESM(require_classnames());
var React6 = __toESM(require_react());
// node_modules/@taroify/icons/utils/unit.js
function addUnitPx2(value) {
    return value === void 0 ? "" : `${unitToPx2(value)}px`;
}
var rootFontSize2;
function getRootFontSize2() {
    if (!rootFontSize2) {
        const doc = document.documentElement;
        const fontSize = doc.style.fontSize || window.getComputedStyle(doc).fontSize;
        rootFontSize2 = Number.parseFloat(fontSize);
    }
    return rootFontSize2;
}
function convertPx2(value) {
    const valueCache = value.replace(/px/g, "");
    return +valueCache;
}
function convertRem2(value) {
    const valueCache = value.replace(/rem/g, "");
    return +valueCache * getRootFontSize2();
}
function convertVw2(value) {
    const valueCache = value.replace(/vw/g, "");
    return +valueCache * window.innerWidth / 100;
}
function convertVh2(value) {
    const valueCache = value.replace(/vh/g, "");
    return +valueCache * window.innerHeight / 100;
}
function unitToPx2(value) {
    if (typeof value === "number") {
        return value;
    }
    if (value.includes("px")) {
        return convertPx2(value);
    }
    if (value.includes("rem")) {
        return convertRem2(value);
    }
    if (value.includes("vw")) {
        return convertVw2(value);
    }
    if (value.includes("vh")) {
        return convertVh2(value);
    }
    return Number.parseFloat(value);
}
// node_modules/@taroify/icons/van/VanIcon.js
function VanIcon(_param) {
    var { className, style, name, size = "inherit", classPrefix = "van-icon", color = "inherit" } = _param, restProps = _object_without_properties(_param, [
        "className",
        "style",
        "name",
        "size",
        "classPrefix",
        "color"
    ]);
    const presetColor = ICON_PRESET_COLORS.includes(color);
    const presetSize = ICON_PRESET_SIZES.includes(size);
    return React6.createElement(View, _object_spread({
        className: (0, import_classnames7.default)(classPrefix, `${classPrefix}-${name}`, "taroify-icon", {
            [`taroify-icon--${color}`]: presetColor,
            [`taroify-icon--${size}`]: presetSize
        }, className),
        style: _object_spread({
            color: presetColor ? "" : color,
            fontSize: presetSize ? "" : addUnitPx2(size)
        }, style)
    }, restProps));
}
function createVanIconComponent(name) {
    function VanIconWrapper(props) {
        return React6.createElement(VanIcon, _object_spread({
            name
        }, props));
    }
    VanIconWrapper[ICON_TYPE] = ICON_TYPE;
    return VanIconWrapper;
}
// node_modules/@taroify/icons/Arrow.js
var Arrow = createVanIconComponent("arrow");
// node_modules/@taroify/icons/ArrowRight.js
var ArrowRight = createVanIconComponent("arrow");
var ArrowRight_default = ArrowRight;
// node_modules/@taroify/icons/ArrowLeft.js
var ArrowLeft = createVanIconComponent("arrow-left");
var ArrowLeft_default = ArrowLeft;
// node_modules/@taroify/icons/ArrowUp.js
var ArrowUp = createVanIconComponent("arrow-up");
var ArrowUp_default = ArrowUp;
// node_modules/@taroify/icons/ArrowDown.js
var ArrowDown = createVanIconComponent("arrow-down");
var ArrowDown_default = ArrowDown;
// node_modules/@taroify/icons/Success.js
var Success = createVanIconComponent("success");
var Success_default = Success;
// node_modules/@taroify/icons/Cross.js
var Cross = createVanIconComponent("cross");
var Cross_default = Cross;
// node_modules/@taroify/icons/Plus.js
var Plus = createVanIconComponent("plus");
// node_modules/@taroify/icons/Minus.js
var Minus = createVanIconComponent("minus");
// node_modules/@taroify/icons/Fail.js
var Fail = createVanIconComponent("fail");
var Fail_default = Fail;
// node_modules/@taroify/icons/Circle.js
var Circle = createVanIconComponent("circle");
// node_modules/@taroify/icons/LocationOutlined.js
var LocationOutlined = createVanIconComponent("location-o");
// node_modules/@taroify/icons/LikeOutlined.js
var LikeOutlined = createVanIconComponent("like-o");
// node_modules/@taroify/icons/StarOutlined.js
var StarOutlined = createVanIconComponent("star-o");
var StarOutlined_default = StarOutlined;
// node_modules/@taroify/icons/PhoneOutlined.js
var PhoneOutlined = createVanIconComponent("phone-o");
// node_modules/@taroify/icons/SettingOutlined.js
var SettingOutlined = createVanIconComponent("setting-o");
// node_modules/@taroify/icons/FireOutlined.js
var FireOutlined = createVanIconComponent("fire-o");
// node_modules/@taroify/icons/CouponOutlined.js
var CouponOutlined = createVanIconComponent("coupon-o");
// node_modules/@taroify/icons/CartOutlined.js
var CartOutlined = createVanIconComponent("cart-o");
// node_modules/@taroify/icons/ShoppingCartOutlined.js
var ShoppingCartOutlined = createVanIconComponent("shopping-cart-o");
// node_modules/@taroify/icons/CartCircleOutlined.js
var CartCircleOutlined = createVanIconComponent("cart-circle-o");
// node_modules/@taroify/icons/FriendsOutlined.js
var FriendsOutlined = createVanIconComponent("friends-o");
// node_modules/@taroify/icons/CommentOutlined.js
var CommentOutlined = createVanIconComponent("comment-o");
// node_modules/@taroify/icons/GemOutlined.js
var GemOutlined = createVanIconComponent("gem-o");
// node_modules/@taroify/icons/GiftOutlined.js
var GiftOutlined = createVanIconComponent("gift-o");
// node_modules/@taroify/icons/PointGiftOutlined.js
var PointGiftOutlined = createVanIconComponent("point-gift-o");
// node_modules/@taroify/icons/SendGiftOutlined.js
var SendGiftOutlined = createVanIconComponent("send-gift-o");
// node_modules/@taroify/icons/ServiceOutlined.js
var ServiceOutlined = createVanIconComponent("service-o");
// node_modules/@taroify/icons/BagOutlined.js
var BagOutlined = createVanIconComponent("bag-o");
// node_modules/@taroify/icons/TodoListOutlined.js
var TodoListOutlined = createVanIconComponent("todo-list-o");
// node_modules/@taroify/icons/BalanceListOutlined.js
var BalanceListOutlined = createVanIconComponent("balance-list-o");
// node_modules/@taroify/icons/Close.js
var Close = createVanIconComponent("close");
var Close_default = Close;
// node_modules/@taroify/icons/ClockOutlined.js
var ClockOutlined = createVanIconComponent("clock-o");
// node_modules/@taroify/icons/QuestionOutlined.js
var QuestionOutlined = createVanIconComponent("question-o");
// node_modules/@taroify/icons/Passed.js
var Passed = createVanIconComponent("passed");
// node_modules/@taroify/icons/AddOutlined.js
var AddOutlined = createVanIconComponent("add-o");
// node_modules/@taroify/icons/GoldCoinOutlined.js
var GoldCoinOutlined = createVanIconComponent("gold-coin-o");
// node_modules/@taroify/icons/InfoOutlined.js
var InfoOutlined = createVanIconComponent("info-o");
// node_modules/@taroify/icons/PlayCircleOutlined.js
var PlayCircleOutlined = createVanIconComponent("play-circle-o");
// node_modules/@taroify/icons/PauseCircleOutlined.js
var PauseCircleOutlined = createVanIconComponent("pause-circle-o");
// node_modules/@taroify/icons/StopCircleOutlined.js
var StopCircleOutlined = createVanIconComponent("stop-circle-o");
// node_modules/@taroify/icons/WarningOutlined.js
var WarningOutlined = createVanIconComponent("warning-o");
// node_modules/@taroify/icons/PhoneCircleOutlined.js
var PhoneCircleOutlined = createVanIconComponent("phone-circle-o");
// node_modules/@taroify/icons/MusicOutlined.js
var MusicOutlined = createVanIconComponent("music-o");
// node_modules/@taroify/icons/SmileOutlined.js
var SmileOutlined = createVanIconComponent("smile-o");
// node_modules/@taroify/icons/ThumbCircleOutlined.js
var ThumbCircleOutlined = createVanIconComponent("thumb-circle-o");
// node_modules/@taroify/icons/CommentCircleOutlined.js
var CommentCircleOutlined = createVanIconComponent("comment-circle-o");
// node_modules/@taroify/icons/BrowsingHistoryOutlined.js
var BrowsingHistoryOutlined = createVanIconComponent("browsing-history-o");
// node_modules/@taroify/icons/UnderwayOutlined.js
var UnderwayOutlined = createVanIconComponent("underway-o");
// node_modules/@taroify/icons/MoreOutlined.js
var MoreOutlined = createVanIconComponent("more-o");
// node_modules/@taroify/icons/VideoOutlined.js
var VideoOutlined = createVanIconComponent("video-o");
// node_modules/@taroify/icons/ShopOutlined.js
var ShopOutlined = createVanIconComponent("shop-o");
// node_modules/@taroify/icons/ShopCollectOutlined.js
var ShopCollectOutlined = createVanIconComponent("shop-collect-o");
// node_modules/@taroify/icons/ShareOutlined.js
var ShareOutlined = createVanIconComponent("share-o");
// node_modules/@taroify/icons/ChatOutlined.js
var ChatOutlined = createVanIconComponent("chat-o");
// node_modules/@taroify/icons/SmileCommentOutlined.js
var SmileCommentOutlined = createVanIconComponent("smile-comment-o");
// node_modules/@taroify/icons/VipCardOutlined.js
var VipCardOutlined = createVanIconComponent("vip-card-o");
// node_modules/@taroify/icons/AwardOutlined.js
var AwardOutlined = createVanIconComponent("award-o");
// node_modules/@taroify/icons/DiamondOutlined.js
var DiamondOutlined = createVanIconComponent("diamond-o");
// node_modules/@taroify/icons/VolumeOutlined.js
var VolumeOutlined = createVanIconComponent("volume-o");
// node_modules/@taroify/icons/ClusterOutlined.js
var ClusterOutlined = createVanIconComponent("cluster-o");
// node_modules/@taroify/icons/WapHomeOutlined.js
var WapHomeOutlined = createVanIconComponent("wap-home-o");
// node_modules/@taroify/icons/PhotoOutlined.js
var PhotoOutlined = createVanIconComponent("photo-o");
// node_modules/@taroify/icons/GiftCardOutlined.js
var GiftCardOutlined = createVanIconComponent("gift-card-o");
// node_modules/@taroify/icons/ExpandOutlined.js
var ExpandOutlined = createVanIconComponent("expand-o");
// node_modules/@taroify/icons/MedalOutlined.js
var MedalOutlined = createVanIconComponent("medal-o");
// node_modules/@taroify/icons/GoodJobOutlined.js
var GoodJobOutlined = createVanIconComponent("good-job-o");
// node_modules/@taroify/icons/ManagerOutlined.js
var ManagerOutlined = createVanIconComponent("manager-o");
// node_modules/@taroify/icons/LabelOutlined.js
var LabelOutlined = createVanIconComponent("label-o");
// node_modules/@taroify/icons/BookmarkOutlined.js
var BookmarkOutlined = createVanIconComponent("bookmark-o");
// node_modules/@taroify/icons/BillOutlined.js
var BillOutlined = createVanIconComponent("bill-o");
// node_modules/@taroify/icons/HotOutlined.js
var HotOutlined = createVanIconComponent("hot-o");
// node_modules/@taroify/icons/HotSaleOutlined.js
var HotSaleOutlined = createVanIconComponent("hot-sale-o");
// node_modules/@taroify/icons/NewOutlined.js
var NewOutlined = createVanIconComponent("new-o");
// node_modules/@taroify/icons/NewArrivalOutlined.js
var NewArrivalOutlined = createVanIconComponent("new-arrival-o");
// node_modules/@taroify/icons/GoodsCollectOutlined.js
var GoodsCollectOutlined = createVanIconComponent("goods-collect-o");
// node_modules/@taroify/icons/EyeOutlined.js
var EyeOutlined = createVanIconComponent("eye-o");
// node_modules/@taroify/icons/DeleteOutlined.js
var DeleteOutlined = createVanIconComponent("delete-o");
// node_modules/@taroify/icons/FontOutlined.js
var FontOutlined = createVanIconComponent("font-o");
// node_modules/@taroify/icons/BalanceOutlined.js
var BalanceOutlined = createVanIconComponent("balance-o");
// node_modules/@taroify/icons/RefundOutlined.js
var RefundOutlined = createVanIconComponent("refund-o");
// node_modules/@taroify/icons/BirthdayCakeOutlined.js
var BirthdayCakeOutlined = createVanIconComponent("birthday-cake-o");
// node_modules/@taroify/icons/UserOutlined.js
var UserOutlined = createVanIconComponent("user-o");
// node_modules/@taroify/icons/OrdersOutlined.js
var OrdersOutlined = createVanIconComponent("orders-o");
// node_modules/@taroify/icons/TvOutlined.js
var TvOutlined = createVanIconComponent("tv-o");
// node_modules/@taroify/icons/EnvelopOutlined.js
var EnvelopOutlined = createVanIconComponent("envelop-o");
// node_modules/@taroify/icons/FlagOutlined.js
var FlagOutlined = createVanIconComponent("flag-o");
// node_modules/@taroify/icons/FlowerOutlined.js
var FlowerOutlined = createVanIconComponent("flower-o");
// node_modules/@taroify/icons/FilterOutlined.js
var FilterOutlined = createVanIconComponent("filter-o");
// node_modules/@taroify/icons/BarChartOutlined.js
var BarChartOutlined = createVanIconComponent("bar-chart-o");
// node_modules/@taroify/icons/ChartTrendingOutlined.js
var ChartTrendingOutlined = createVanIconComponent("chart-trending-o");
// node_modules/@taroify/icons/BrushOutlined.js
var BrushOutlined = createVanIconComponent("brush-o");
// node_modules/@taroify/icons/BullhornOutlined.js
var BullhornOutlined = createVanIconComponent("bullhorn-o");
// node_modules/@taroify/icons/HotelOutlined.js
var HotelOutlined = createVanIconComponent("hotel-o");
// node_modules/@taroify/icons/CashierOutlined.js
var CashierOutlined = createVanIconComponent("cashier-o");
// node_modules/@taroify/icons/NewspaperOutlined.js
var NewspaperOutlined = createVanIconComponent("newspaper-o");
// node_modules/@taroify/icons/WarnOutlined.js
var WarnOutlined = createVanIconComponent("warn-o");
// node_modules/@taroify/icons/NotesOutlined.js
var NotesOutlined = createVanIconComponent("notes-o");
// node_modules/@taroify/icons/CalendarOutlined.js
var CalendarOutlined = createVanIconComponent("calendar-o");
// node_modules/@taroify/icons/BulbOutlined.js
var BulbOutlined = createVanIconComponent("bulb-o");
// node_modules/@taroify/icons/UserCircleOutlined.js
var UserCircleOutlined = createVanIconComponent("user-circle-o");
// node_modules/@taroify/icons/DesktopOutlined.js
var DesktopOutlined = createVanIconComponent("desktop-o");
// node_modules/@taroify/icons/AppsOutlined.js
var AppsOutlined = createVanIconComponent("apps-o");
// node_modules/@taroify/icons/HomeOutlined.js
var HomeOutlined = createVanIconComponent("home-o");
// node_modules/@taroify/icons/RecordsOutlined.js
var Records = createVanIconComponent("records-o");
// node_modules/@taroify/icons/ContactOutlined.js
var Contact = createVanIconComponent("contact-o");
// node_modules/@taroify/icons/DiscountOutlined.js
var Discount = createVanIconComponent("discount-o");
// node_modules/@taroify/icons/CompletedOutlined.js
var Completed = createVanIconComponent("completed-o");
// node_modules/@taroify/icons/DescriptionOutlined.js
var Description = createVanIconComponent("description-o");
// node_modules/@taroify/icons/CashBackRecordOutlined.js
var CashBackRecord = createVanIconComponent("cash-back-record-o");
// node_modules/@taroify/icons/BackTop.js
var BackTop = createVanIconComponent("back-top");
var BackTop_default = BackTop;
// node_modules/@taroify/icons/Search.js
var Search = createVanIconComponent("search");
var Search_default = Search;
// node_modules/@taroify/icons/Points.js
var Points = createVanIconComponent("points");
// node_modules/@taroify/icons/Edit.js
var Edit = createVanIconComponent("edit");
// node_modules/@taroify/icons/Qr.js
var Qr = createVanIconComponent("qr");
// node_modules/@taroify/icons/QrInvalid.js
var QrInvalid = createVanIconComponent("qr-invalid");
// node_modules/@taroify/icons/ClosedEye.js
var ClosedEye = createVanIconComponent("closed-eye");
// node_modules/@taroify/icons/Down.js
var Down = createVanIconComponent("down");
// node_modules/@taroify/icons/Scan.js
var Scan = createVanIconComponent("scan");
// node_modules/@taroify/icons/Revoke.js
var Revoke = createVanIconComponent("revoke");
// node_modules/@taroify/icons/FreePostage.js
var FreePostage = createVanIconComponent("free-postage");
// node_modules/@taroify/icons/Certificate.js
var Certificate = createVanIconComponent("certificate");
// node_modules/@taroify/icons/Logistics.js
var Logistics = createVanIconComponent("logistics");
// node_modules/@taroify/icons/Contact.js
var Contact2 = createVanIconComponent("contact");
// node_modules/@taroify/icons/CashBackRecord.js
var CashBackRecord2 = createVanIconComponent("cash-back-record");
// node_modules/@taroify/icons/AfterSale.js
var AfterSale = createVanIconComponent("after-sale");
// node_modules/@taroify/icons/Exchange.js
var Exchange = createVanIconComponent("exchange");
// node_modules/@taroify/icons/Upgrade.js
var Upgrade = createVanIconComponent("upgrade");
// node_modules/@taroify/icons/Ellipsis.js
var Ellipsis = createVanIconComponent("ellipsis");
// node_modules/@taroify/icons/Description.js
var Description2 = createVanIconComponent("description");
var Description_default = Description2;
// node_modules/@taroify/icons/Records.js
var Records2 = createVanIconComponent("records");
// node_modules/@taroify/icons/Sign.js
var Sign = createVanIconComponent("sign");
// node_modules/@taroify/icons/Completed.js
var Completed2 = createVanIconComponent("completed");
// node_modules/@taroify/icons/Failure.js
var Failure = createVanIconComponent("failure");
// node_modules/@taroify/icons/EcardPay.js
var EcardPay = createVanIconComponent("ecard-pay");
// node_modules/@taroify/icons/PeerPay.js
var PeerPay = createVanIconComponent("peer-pay");
// node_modules/@taroify/icons/BalancePay.js
var BalancePay = createVanIconComponent("balance-pay");
// node_modules/@taroify/icons/CreditPay.js
var CreditPay = createVanIconComponent("credit-pay");
// node_modules/@taroify/icons/DebitPay.js
var DebitPay = createVanIconComponent("debit-pay");
// node_modules/@taroify/icons/CashOnDeliver.js
var CashOnDeliver = createVanIconComponent("cash-on-deliver");
// node_modules/@taroify/icons/OtherPay.js
var OtherPay = createVanIconComponent("other-pay");
// node_modules/@taroify/icons/Tosend.js
var Tosend = createVanIconComponent("tosend");
// node_modules/@taroify/icons/PendingPayment.js
var PendingPayment = createVanIconComponent("pending-payment");
// node_modules/@taroify/icons/Paid.js
var Paid = createVanIconComponent("paid");
// node_modules/@taroify/icons/Aim.js
var Aim = createVanIconComponent("aim");
// node_modules/@taroify/icons/Discount.js
var Discount2 = createVanIconComponent("discount");
// node_modules/@taroify/icons/Idcard.js
var Idcard = createVanIconComponent("idcard");
// node_modules/@taroify/icons/Replay.js
var Replay = createVanIconComponent("replay");
// node_modules/@taroify/icons/Shrink.js
var Shrink = createVanIconComponent("shrink");
// node_modules/@taroify/icons/ShieldOutlined.js
var ShieldOutlined = createVanIconComponent("shield-o");
// node_modules/@taroify/icons/GuideOutlined.js
var GuideOutlined = createVanIconComponent("guide-o");
// node_modules/@taroify/icons/Location.js
var Location = createVanIconComponent("location");
// node_modules/@taroify/icons/Like.js
var Like = createVanIconComponent("like");
// node_modules/@taroify/icons/Star.js
var Star = createVanIconComponent("star");
var Star_default = Star;
// node_modules/@taroify/icons/Phone.js
var Phone = createVanIconComponent("phone");
// node_modules/@taroify/icons/Setting.js
var Setting = createVanIconComponent("setting");
// node_modules/@taroify/icons/Fire.js
var Fire = createVanIconComponent("fire");
// node_modules/@taroify/icons/Coupon.js
var Coupon = createVanIconComponent("coupon");
// node_modules/@taroify/icons/Cart.js
var Cart = createVanIconComponent("cart");
// node_modules/@taroify/icons/ShoppingCart.js
var ShoppingCart = createVanIconComponent("shopping-cart");
// node_modules/@taroify/icons/CartCircle.js
var CartCircle = createVanIconComponent("cart-circle");
// node_modules/@taroify/icons/Friends.js
var Friends = createVanIconComponent("friends");
// node_modules/@taroify/icons/Comment.js
var Comment = createVanIconComponent("comment");
// node_modules/@taroify/icons/Gem.js
var Gem = createVanIconComponent("gem");
// node_modules/@taroify/icons/Gift.js
var Gift = createVanIconComponent("gift");
// node_modules/@taroify/icons/PointGift.js
var PointGift = createVanIconComponent("point-gift");
// node_modules/@taroify/icons/SendGift.js
var SendGift = createVanIconComponent("send-gift");
// node_modules/@taroify/icons/Service.js
var Service = createVanIconComponent("service");
// node_modules/@taroify/icons/Bag.js
var Bag = createVanIconComponent("bag");
// node_modules/@taroify/icons/TodoList.js
var TodoList = createVanIconComponent("todo-list");
// node_modules/@taroify/icons/BalanceList.js
var BalanceList = createVanIconComponent("balance-list");
// node_modules/@taroify/icons/Clear.js
var Clear = createVanIconComponent("clear");
var Clear_default = Clear;
// node_modules/@taroify/icons/Clock.js
var Clock = createVanIconComponent("clock");
// node_modules/@taroify/icons/Question.js
var Question = createVanIconComponent("question");
// node_modules/@taroify/icons/Checked.js
var Checked = createVanIconComponent("checked");
// node_modules/@taroify/icons/Add.js
var Add = createVanIconComponent("add");
// node_modules/@taroify/icons/GoldCoin.js
var GoldCoin = createVanIconComponent("gold-coin");
// node_modules/@taroify/icons/Info.js
var Info = createVanIconComponent("info");
// node_modules/@taroify/icons/PlayCircle.js
var PlayCircle = createVanIconComponent("play-circle");
// node_modules/@taroify/icons/PauseCircle.js
var PauseCircle = createVanIconComponent("pause-circle");
// node_modules/@taroify/icons/StopCircle.js
var StopCircle = createVanIconComponent("stop-circle");
// node_modules/@taroify/icons/Warning.js
var Warning = createVanIconComponent("warning");
// node_modules/@taroify/icons/PhoneCircle.js
var PhoneCircle = createVanIconComponent("phone-circle");
// node_modules/@taroify/icons/Music.js
var Music = createVanIconComponent("music");
// node_modules/@taroify/icons/Smile.js
var Smile = createVanIconComponent("smile");
// node_modules/@taroify/icons/ThumbCircle.js
var ThumbCircle = createVanIconComponent("thumb-circle");
// node_modules/@taroify/icons/CommentCircle.js
var CommentCircle = createVanIconComponent("comment-circle");
// node_modules/@taroify/icons/BrowsingHistory.js
var BrowsingHistory = createVanIconComponent("browsing-history");
// node_modules/@taroify/icons/Underway.js
var Underway = createVanIconComponent("underway");
// node_modules/@taroify/icons/More.js
var More = createVanIconComponent("more");
// node_modules/@taroify/icons/Video.js
var Video = createVanIconComponent("video");
// node_modules/@taroify/icons/Shop.js
var Shop = createVanIconComponent("shop");
// node_modules/@taroify/icons/ShopCollect.js
var ShopCollect = createVanIconComponent("shop-collect");
// node_modules/@taroify/icons/Share.js
var Share = createVanIconComponent("share");
// node_modules/@taroify/icons/Chat.js
var Chat = createVanIconComponent("chat");
// node_modules/@taroify/icons/SmileComment.js
var SmileComment = createVanIconComponent("smile-comment");
// node_modules/@taroify/icons/VipCard.js
var VipCard = createVanIconComponent("vip-card");
// node_modules/@taroify/icons/Award.js
var Award = createVanIconComponent("award");
// node_modules/@taroify/icons/Diamond.js
var Diamond = createVanIconComponent("diamond");
// node_modules/@taroify/icons/Volume.js
var Volume = createVanIconComponent("volume");
// node_modules/@taroify/icons/Cluster.js
var Cluster = createVanIconComponent("cluster");
// node_modules/@taroify/icons/WapHome.js
var WapHome = createVanIconComponent("wap-home");
// node_modules/@taroify/icons/Photo.js
var Photo = createVanIconComponent("photo");
// node_modules/@taroify/icons/GiftCard.js
var GiftCard = createVanIconComponent("gift-card");
// node_modules/@taroify/icons/Expand.js
var Expand = createVanIconComponent("expand");
// node_modules/@taroify/icons/Medal.js
var Medal = createVanIconComponent("medal");
// node_modules/@taroify/icons/GoodJob.js
var GoodJob = createVanIconComponent("good-job");
// node_modules/@taroify/icons/Manager.js
var Manager = createVanIconComponent("manager");
// node_modules/@taroify/icons/Label.js
var Label = createVanIconComponent("label");
// node_modules/@taroify/icons/Bookmark.js
var Bookmark = createVanIconComponent("bookmark");
// node_modules/@taroify/icons/Bill.js
var Bill = createVanIconComponent("bill");
// node_modules/@taroify/icons/Hot.js
var Hot = createVanIconComponent("hot");
// node_modules/@taroify/icons/HotSale.js
var HotSale = createVanIconComponent("hot-sale");
// node_modules/@taroify/icons/New.js
var New = createVanIconComponent("new");
// node_modules/@taroify/icons/NewArrival.js
var NewArrival = createVanIconComponent("new-arrival");
// node_modules/@taroify/icons/GoodsCollect.js
var GoodsCollect = createVanIconComponent("goods-collect");
// node_modules/@taroify/icons/Eye.js
var Eye = createVanIconComponent("eye");
// node_modules/@taroify/icons/Delete.js
var Delete = createVanIconComponent("delete");
// node_modules/@taroify/icons/Font.js
var Font = createVanIconComponent("font");
// node_modules/@taroify/icons/Wechat.js
var Wechat = createVanIconComponent("wechat");
// node_modules/@taroify/icons/WechatPay.js
var WechatPay = createVanIconComponent("wechat-pay");
// node_modules/@taroify/icons/Alipay.js
var Alipay = createVanIconComponent("alipay");
// node_modules/@taroify/icons/Photograph.js
var Photograph = createVanIconComponent("photograph");
var Photograph_default = Photograph;
// node_modules/@taroify/icons/YouzanShield.js
var YouzanShield = createVanIconComponent("youzan-shield");
// node_modules/@taroify/icons/UmbrellaCircle.js
var UmbrellaCircle = createVanIconComponent("umbrella-circle");
// node_modules/@taroify/icons/Bell.js
var Bell = createVanIconComponent("bell");
// node_modules/@taroify/icons/Printer.js
var Printer = createVanIconComponent("printer");
// node_modules/@taroify/icons/MapMarked.js
var MapMarked = createVanIconComponent("map-marked");
// node_modules/@taroify/icons/Card.js
var Card = createVanIconComponent("card");
// node_modules/@taroify/icons/AddSquare.js
var AddSquare = createVanIconComponent("add-square");
// node_modules/@taroify/icons/Live.js
var Live = createVanIconComponent("live");
// node_modules/@taroify/icons/Lock.js
var Lock = createVanIconComponent("lock");
// node_modules/@taroify/icons/Audio.js
var Audio = createVanIconComponent("audio");
// node_modules/@taroify/icons/Graphic.js
var Graphic = createVanIconComponent("graphic");
// node_modules/@taroify/icons/Column.js
var Column = createVanIconComponent("column");
// node_modules/@taroify/icons/Invitation.js
var Invitation = createVanIconComponent("invitation");
// node_modules/@taroify/icons/Play.js
var Play = createVanIconComponent("play");
// node_modules/@taroify/icons/Pause.js
var Pause = createVanIconComponent("pause");
// node_modules/@taroify/icons/Stop.js
var Stop = createVanIconComponent("stop");
// node_modules/@taroify/icons/WeappNav.js
var WeappNav = createVanIconComponent("weapp-nav");
// node_modules/@taroify/icons/Ascending.js
var Ascending = createVanIconComponent("ascending");
// node_modules/@taroify/icons/Descending.js
var Descending = createVanIconComponent("descending");
// node_modules/@taroify/icons/Bars.js
var Bars = createVanIconComponent("bars");
// node_modules/@taroify/icons/WapNav.js
var WapNav = createVanIconComponent("wap-nav");
// node_modules/@taroify/icons/Enlarge.js
var Enlarge = createVanIconComponent("enlarge");
// node_modules/@taroify/icons/PhotoFail.js
var PhotoFail = createVanIconComponent("photo-fail");
// node_modules/@taroify/icons/Sort.js
var Sort = createVanIconComponent("sort");
// node_modules/@taroify/icons/User.js
var UserOutlined2 = createVanIconComponent("user");
// node_modules/@taroify/icons/Notes.js
var NotesOutlined2 = createVanIconComponent("notes");
// node_modules/@taroify/icons/Newspaper.js
var NewspaperOutlined2 = createVanIconComponent("newspaper");
// node_modules/@taroify/icons/ListSwitch.js
var Add2 = createVanIconComponent("list-switch");
// node_modules/@taroify/icons/ListSwitching.js
var Add3 = createVanIconComponent("list-switching");
// node_modules/@taroify/core/cell/cell-group.context.js
var import_react8 = __toESM(require_react());
var CellGroupContext = (0, import_react8.createContext)({});
var cell_group_context_default = CellGroupContext;
// node_modules/@taroify/core/cell/cell-base.js
var iconMap = {
    right: ArrowRight_default,
    left: ArrowLeft_default,
    up: ArrowUp_default,
    down: ArrowDown_default
};
function CellBase(props) {
    const { className, size = "medium", align, clickable: clickableProp = false, required = false, bordered = true, isLink = false, icon, arrowDirection = "right", rightIcon: rightIconProps, children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "size",
        "align",
        "clickable",
        "required",
        "bordered",
        "isLink",
        "icon",
        "arrowDirection",
        "rightIcon",
        "children"
    ]);
    const { clickable } = (0, import_react9.useContext)(cell_group_context_default);
    const cellClickable = isLink || clickable || clickableProp;
    const leftIcon = (0, import_react9.useMemo)(()=>{
        if (icon) {
            return isIconElement(icon) ? cloneIconElement(icon, {
                className: prefixClassname("cell__icon")
            }) : icon;
        }
        return null;
    }, [
        icon
    ]);
    const rightIcon = (0, import_react9.useMemo)(()=>{
        if (rightIconProps) {
            return isIconElement(rightIconProps) ? cloneIconElement(rightIconProps, {
                className: prefixClassname("cell__right-icon")
            }) : rightIconProps;
        } else if (isLink && iconMap[arrowDirection]) {
            const Icon = iconMap[arrowDirection];
            return React7.createElement(Icon, {
                className: prefixClassname("cell__right-icon")
            });
        }
        return null;
    }, [
        rightIconProps,
        isLink,
        arrowDirection
    ]);
    return React7.createElement(View, _object_spread({
        className: (0, import_classnames8.default)(prefixClassname("cell"), {
            [prefixClassname("cell--start")]: align === "start",
            [prefixClassname("cell--center")]: align === "center",
            [prefixClassname("cell--end")]: align === "end",
            [prefixClassname("cell--large")]: size === "large",
            [prefixClassname("cell--clickable")]: cellClickable,
            [prefixClassname("cell--required")]: required,
            [prefixClassname("cell--borderless")]: !bordered
        }, className)
    }, restProps), leftIcon, children2, rightIcon);
}
var cell_base_default = CellBase;
// node_modules/@taroify/core/cell/cell-brief.js
var import_classnames9 = __toESM(require_classnames());
var React8 = __toESM(require_react());
function CellBrief(props) {
    const { className, briefClass } = props, restProps = _object_without_properties(props, [
        "className",
        "briefClass"
    ]);
    return React8.createElement(View, _object_spread({
        className: (0, import_classnames9.default)(prefixClassname("cell__brief"), className, briefClass)
    }, restProps));
}
var cell_brief_default = CellBrief;
// node_modules/@taroify/core/cell/cell-title.js
var import_classnames10 = __toESM(require_classnames());
var React9 = __toESM(require_react());
function CellTitle(props) {
    const { className, titleStyle, titleClass } = props, restProps = _object_without_properties(props, [
        "className",
        "titleStyle",
        "titleClass"
    ]);
    return React9.createElement(View, _object_spread({
        className: (0, import_classnames10.default)(prefixClassname("cell__title"), className, titleClass),
        style: titleStyle
    }, restProps));
}
var cell_title_default = CellTitle;
// node_modules/@taroify/core/cell/cell-value.js
var import_classnames11 = __toESM(require_classnames());
var React10 = __toESM(require_react());
function CellValue(props) {
    const { className, alone, valueClass } = props, restProps = _object_without_properties(props, [
        "className",
        "alone",
        "valueClass"
    ]);
    return React10.createElement(View, _object_spread({
        className: (0, import_classnames11.default)(prefixClassname("cell__value"), {
            [prefixClassname("cell__value--alone")]: alone
        }, className, valueClass)
    }, restProps));
}
var cell_value_default = CellValue;
// node_modules/@taroify/core/cell/cell.js
function Cell(props) {
    const { title, brief, children: children2, titleStyle, titleClass, valueClass, briefClass } = props, restProps = _object_without_properties(props, [
        "title",
        "brief",
        "children",
        "titleStyle",
        "titleClass",
        "valueClass",
        "briefClass"
    ]);
    return React11.createElement(cell_base_default, _object_spread({}, restProps), title && React11.createElement(cell_title_default, {
        titleStyle,
        titleClass
    }, title, brief && React11.createElement(cell_brief_default, {
        children: brief,
        briefClass
    })), React11.createElement(cell_value_default, {
        alone: !title,
        children: children2
    }));
}
var cell_default = Cell;
// node_modules/@taroify/core/cell/cell-group.js
var import_classnames12 = __toESM(require_classnames());
var React12 = __toESM(require_react());
function CellGroup(props) {
    const { title, clickable = false, inset = false, bordered = true, children: children2, className } = props, restProps = _object_without_properties(props, [
        "title",
        "clickable",
        "inset",
        "bordered",
        "children",
        "className"
    ]);
    return React12.createElement(cell_group_context_default.Provider, {
        value: {
            clickable
        }
    }, React12.createElement(View, _object_spread({
        className: (0, import_classnames12.default)(prefixClassname("cell-group"), {
            [prefixClassname("cell-group--inset")]: inset
        }, className)
    }, restProps), title && React12.createElement(View, {
        className: (0, import_classnames12.default)(prefixClassname("cell-group__title"), {
            [prefixClassname("cell-group__title--inset")]: inset
        }),
        children: title
    }), React12.createElement(View, {
        className: (0, import_classnames12.default)(prefixClassname("cell-group"), {
            [prefixClassname("hairline--top-bottom")]: bordered
        }),
        children: children2
    })));
}
var cell_group_default = CellGroup;
// node_modules/@taroify/core/cell/index.js
var Cell2 = cell_default;
Cell2.Group = cell_group_default;
var cell_default2 = Cell2;
// node_modules/@taroify/core/config-provider/config-provider.js
var import_kebabCase = __toESM(require_kebabCase());
var React13 = __toESM(require_react());
var import_react10 = __toESM(require_react());
function convertThemeVarsToCSSVars(themeVars) {
    const cssVars = {};
    Object.keys(themeVars).forEach((key)=>{
        cssVars[`--${(0, import_kebabCase.default)(key)}`] = themeVars[key];
    });
    return cssVars;
}
function ConfigProvider(props) {
    const { theme = {}, children: children2 } = props;
    const style = (0, import_react10.useMemo)(()=>convertThemeVarsToCSSVars(theme), [
        theme
    ]);
    return React13.createElement(View, {
        style,
        children: children2
    });
}
var config_provider_default = ConfigProvider;
// node_modules/@taroify/core/col/col.js
var React16 = __toESM(require_react());
// node_modules/@taroify/core/flex/flex.js
var import_classnames13 = __toESM(require_classnames());
var import_isNumber3 = __toESM(require_isNumber());
var import_isString3 = __toESM(require_isString());
var import_toNumber = __toESM(require_toNumber());
var import_isArray3 = __toESM(require_isArray());
var React14 = __toESM(require_react());
var import_react12 = __toESM(require_react());
// node_modules/@taroify/core/flex/flex.context.js
var import_react11 = __toESM(require_react());
var FlexContext = (0, import_react11.createContext)({
    gutter: [
        void 0,
        void 0
    ]
});
var flex_context_default = FlexContext;
// node_modules/@taroify/core/flex/flex.js
function useFlexGutter(gutter) {
    return (0, import_react12.useMemo)(()=>{
        if (gutter === void 0) {
            return [
                void 0,
                void 0
            ];
        }
        if ((0, import_isNumber3.default)(gutter)) {
            return [
                gutter,
                gutter
            ];
        }
        if ((0, import_isString3.default)(gutter)) {
            const gutterNumber = (0, import_toNumber.default)(gutter);
            return [
                gutterNumber,
                gutterNumber
            ];
        }
        if ((0, import_isArray3.default)(gutter)) {
            const [horizontalGutter, verticalGutter] = gutter;
            return [
                (0, import_toNumber.default)(horizontalGutter),
                (0, import_toNumber.default)(verticalGutter)
            ];
        }
        return [
            0,
            0
        ];
    }, [
        gutter
    ]);
}
var Flex = (0, import_react12.forwardRef)((props, ref)=>{
    const { className, style, gutter: gutterProp, direction = "row", wrap = "nowrap", justify = "start", align = "start", children: childrenProp } = props, restProps = _object_without_properties(props, [
        "className",
        "style",
        "gutter",
        "direction",
        "wrap",
        "justify",
        "align",
        "children"
    ]);
    const gutter = useFlexGutter(gutterProp);
    const [horizontalGutter] = gutter;
    const gutterStyle = (0, import_react12.useMemo)(()=>{
        const gutterStyle2 = {};
        if (horizontalGutter) {
            const averagePadding = (0, import_toNumber.default)(horizontalGutter) / 2;
            gutterStyle2.marginLeft = addUnitPx(-averagePadding);
            gutterStyle2.marginRight = addUnitPx(-averagePadding);
        }
        return {};
    }, [
        horizontalGutter
    ]);
    const rowStyle = (0, import_react12.useMemo)(()=>{
        const rowStyle2 = {};
        if (horizontalGutter) {
            const averageMargin = (0, import_toNumber.default)(horizontalGutter) / 2;
            rowStyle2.marginLeft = addUnitPx(-averageMargin);
            rowStyle2.marginRight = addUnitPx(-averageMargin);
        }
        return rowStyle2;
    }, [
        horizontalGutter
    ]);
    const children2 = (0, import_react12.useMemo)(()=>import_react12.Children.map(childrenProp, (item, index)=>{
            return (0, import_react12.isValidElement)(item) ? (0, import_react12.cloneElement)(item, {
                __dataIndex__: index
            }) : item;
        }), [
        childrenProp
    ]);
    return React14.createElement(View, _object_spread({
        ref,
        className: (0, import_classnames13.default)(prefixClassname("flex"), {
            [prefixClassname("flex--row")]: direction === "row",
            [prefixClassname("flex--row-reverse")]: direction === "row-reverse",
            [prefixClassname("flex--column")]: direction === "column",
            [prefixClassname("flex--column-reverse")]: direction === "column-reverse",
            [prefixClassname("flex--nowrap")]: wrap === "nowrap",
            [prefixClassname("flex--wrap")]: wrap === "wrap",
            [prefixClassname("flex--wrap-reverse")]: wrap === "wrap-reverse",
            [prefixClassname("flex--justify-start")]: justify === "start",
            [prefixClassname("flex--justify-center")]: justify === "center",
            [prefixClassname("flex--justify-end")]: justify === "end",
            [prefixClassname("flex--justify-space-around")]: justify === "space-around",
            [prefixClassname("flex--justify-space-between")]: justify === "space-between",
            [prefixClassname("flex--align-start")]: align === "start",
            [prefixClassname("flex--align-center")]: align === "center",
            [prefixClassname("flex--align-end")]: align === "end",
            [prefixClassname("flex--align-baseline")]: align === "baseline",
            [prefixClassname("flex--align-stretch")]: align === "stretch"
        }, className),
        style: _object_spread({}, style, gutterStyle, rowStyle)
    }, restProps), React14.createElement(flex_context_default.Provider, {
        value: {
            gutter
        },
        children: children2
    }));
});
var flex_default = Flex;
// node_modules/@taroify/core/flex/flex-item.js
var import_classnames14 = __toESM(require_classnames());
var React15 = __toESM(require_react());
var import_react13 = __toESM(require_react());
function FlexItem(props) {
    const { __dataIndex__ = 0, className, style, span, offset } = props, restProps = _object_without_properties(props, [
        "__dataIndex__",
        "className",
        "style",
        "span",
        "offset"
    ]);
    const { gutter: gutters } = (0, import_react13.useContext)(flex_context_default);
    const [horizontalGutter] = gutters;
    const gutterStyle = {};
    if (horizontalGutter) {
        const averagePadding = horizontalGutter / 2;
        gutterStyle.paddingLeft = addUnitPx(averagePadding);
        gutterStyle.paddingRight = addUnitPx(averagePadding);
    }
    return React15.createElement(View, _object_spread({
        className: (0, import_classnames14.default)(prefixClassname("flex-item"), {
            [prefixClassname(`flex-item-${span}`)]: span !== void 0,
            [prefixClassname(`flex-item-offset-${offset}`)]: offset !== void 0
        }, className),
        style: _object_spread({}, style, gutterStyle)
    }, restProps));
}
// node_modules/@taroify/core/flex/index.js
var Flex2 = flex_default;
Flex2.Item = FlexItem;
var flex_default2 = Flex2;
// node_modules/@taroify/core/col/col.js
function Col(props) {
    console.warn("[Deprecated] The Col component is deprecated. Please use the Flex.Item component.");
    return React16.createElement(flex_default2.Item, _object_spread({}, props));
}
var col_default = Col;
// node_modules/@taroify/core/row/row.js
var React17 = __toESM(require_react());
function Row(props) {
    console.warn("[Deprecated] The Row component is deprecated. Please use the Flex component.");
    return React17.createElement(flex_default2, _object_spread({}, props));
}
var row_default = Row;
// node_modules/@taroify/core/image/image.js
var import_classnames16 = __toESM(require_classnames());
var import_isBoolean2 = __toESM(require_isBoolean());
var React19 = __toESM(require_react());
var import_react25 = __toESM(require_react());
// node_modules/@taroify/core/utils/logger.js
var debugLevel = 1;
var infoLevel = debugLevel << 2;
var warnLevel = infoLevel << 2;
var logConfig = {
    level: debugLevel
};
function getLogger(name) {
    return {
        warn (message, ...optionalParams) {
            if (logConfig.level <= warnLevel) {
                console.warn(`Taroify - ${name} : ${message}`, ...optionalParams);
            }
        },
        deprecated (message, ...optionalParams) {
            if (logConfig.level <= warnLevel) {
                console.warn(`[Deprecated] Taroify - ${name} : ${message}`, ...optionalParams);
            }
        }
    };
}
// node_modules/@taroify/core/hooks/use-did-effect.js
var import_react14 = __toESM(require_react());
function useDidEffect(effect, deps) {
    const mounted = (0, import_react14.useRef)(false);
    (0, import_react14.useEffect)(()=>{
        if (mounted.current) {
            effect === null || effect === void 0 ? void 0 : effect();
        } else {
            mounted.current = true;
        }
    }, deps);
}
var use_did_effect_default = useDidEffect;
// node_modules/@taroify/core/hooks/use-function-interceptor.js
var import_promise = __toESM(require_promise());
// node_modules/@taroify/core/utils/promisify.js
var import_isObjectLike = __toESM(require_isObjectLike());
var import_isFunction2 = __toESM(require_isFunction());
function isPromise(val) {
    return (0, import_isObjectLike.default)(val) && (0, import_isFunction2.default)(val.then) && (0, import_isFunction2.default)(val.catch);
}
function fulfillPromise(promise) {
    if (isPromise(promise)) {
        promise === null || promise === void 0 ? void 0 : promise.then(()=>{}, ()=>{});
    }
}
// node_modules/@taroify/core/hooks/use-function-interceptor.js
function useFunctionInterceptor(interceptor) {
    return (...args)=>new import_promise.default((resolve, reject)=>{
            if (interceptor) {
                const result = interceptor.apply(null, args);
                if (isPromise(result)) {
                    result.then((value)=>{
                        if (value) {
                            resolve();
                        } else {
                            reject();
                        }
                    }).catch(reject);
                } else if (result) {
                    resolve();
                } else {
                    reject();
                }
            } else {
                resolve();
            }
        });
}
// node_modules/@taroify/core/hooks/use-height.js
var import_react15 = __toESM(require_react());
// node_modules/@taroify/core/utils/base.js
var inBrowser = typeof document !== "undefined" && !!document.scripts;
var inWechat = false;
// node_modules/@taroify/core/utils/dom/element.js
var import_isEmpty2 = __toESM(require_isEmpty());
var import_split = __toESM(require_split());
var ELEMENT_NODE_TYPE = 1;
function isWindow(val) {
    return val === window;
}
function isRootElement(node) {
    return (node === null || node === void 0 ? void 0 : node.nodeType) === ELEMENT_NODE_TYPE && (node === null || node === void 0 ? void 0 : node.tagName) === "ROOT";
}
function isBlockElement(node) {
    return (node === null || node === void 0 ? void 0 : node.nodeType) === ELEMENT_NODE_TYPE && (node === null || node === void 0 ? void 0 : node.tagName) === "BLOCK";
}
function elementUnref(elementOrRef) {
    if (elementOrRef === void 0 || elementOrRef === null) {
        return elementOrRef;
    }
    if ("current" in elementOrRef) {
        return elementOrRef.current;
    }
    return elementOrRef;
}
function matchSelector(aSelector, bSelector) {
    return aSelector === bSelector;
}
function getElementSelector(id, className) {
    const selectors = [];
    if (!(0, import_isEmpty2.default)(id)) {
        selectors.push(`#${id}`);
    }
    if (!(0, import_isEmpty2.default)(className)) {
        selectors.push((0, import_split.default)(className, " ").join("."));
    }
    return selectors.join(".");
}
function prependPageSelector(selector) {
    var _getCurrentInstance_router;
    const path = (_getCurrentInstance_router = getCurrentInstance().router) === null || _getCurrentInstance_router === void 0 ? void 0 : _getCurrentInstance_router.path;
    return path ? `${path}__${selector}` : selector;
}
function usePrependPageSelector(selector) {
    const { path } = getCurrentInstance().router || {};
    return path ? `${path}__${selector}` : selector;
}
function getAncestorWrapper(element) {
    if (inWechat) {
        let ancestor = element;
        for(let cursor = element; !(0, import_isEmpty2.default)(cursor.parentNode);){
            if (isRootElement(cursor.parentNode)) {
                break;
            }
            if (!isBlockElement(cursor.parentNode)) {
                ancestor = cursor.parentNode;
            }
            cursor = cursor.parentNode;
        }
        if (ancestor && ancestor !== element) {
            return ancestor;
        }
    }
}
function queryNodesRef(element) {
    if (isRootElement(element)) {
        return createSelectorQuery().selectViewport();
    }
    const ancestor = getAncestorWrapper(element);
    if (ancestor) {
        return createSelectorQuery().select(`#${ancestor.uid}>>>#${element.uid}`);
    }
    return createSelectorQuery().select(`#${element.uid}`);
}
function queryAllNodesRef(element, selector) {
    if (isRootElement(element)) {
        return createSelectorQuery().selectViewport();
    }
    const ancestor = getAncestorWrapper(element);
    if (ancestor) {
        return createSelectorQuery().selectAll(`#${ancestor.uid}>>>#${element.uid} ${selector}`);
    }
    return createSelectorQuery().selectAll(`#${element.uid}${selector}`);
}
// node_modules/@taroify/core/utils/dom/rect.js
function makeRect(width, height) {
    return {
        top: 0,
        left: 0,
        right: width,
        bottom: height,
        width,
        height
    };
}
function getRect(elementOrRef) {
    const element = elementUnref(elementOrRef);
    if (element) {
        if (inBrowser) {
            if (isWindow(element)) {
                const width = element.innerWidth;
                const height = element.innerHeight;
                return Promise.resolve(makeRect(width, height));
            }
            return Promise.resolve(element.getBoundingClientRect());
        }
        return new Promise((resolve)=>{
            queryNodesRef(element).boundingClientRect().exec(([rect])=>{
                if (isRootElement(element)) {
                    const { width, height } = rect;
                    resolve(makeRect(width, height));
                } else {
                    resolve(rect);
                }
            });
        });
    }
    return Promise.resolve(makeRect(0, 0));
}
function getRects(elementOrRef, selector) {
    const element = elementUnref(elementOrRef);
    if (element) {
        if (inBrowser) {
            const rects = [];
            element.querySelectorAll(selector).forEach((oneElement)=>rects.push(oneElement.getBoundingClientRect()));
            return Promise.resolve(rects);
        }
        return new Promise((resolve)=>{
            queryAllNodesRef(element, selector).boundingClientRect().exec(([rects])=>resolve(rects));
        });
    }
    return Promise.resolve([]);
}
// node_modules/@taroify/core/hooks/use-height.js
function useHeight(elementOrRef, deps) {
    const [height, _setHeight] = (0, import_react15.useState)(0);
    const heightRef = (0, import_react15.useRef)(0);
    const setHeight = (0, import_react15.useCallback)(()=>{
        getRect(elementOrRef).then((rect)=>rect === null || rect === void 0 ? void 0 : rect.height).then((val)=>{
            if (val !== heightRef.current) {
                heightRef.current = val;
                _setHeight(val);
            }
        });
    }, []);
    use_rendered_effect_default(()=>{
        setHeight();
    }, deps);
    useMounted(()=>{
        nextTick(setHeight);
    });
    use_window_resize_default(setHeight);
    return height;
}
// node_modules/@taroify/core/hooks/use-rendered-effect.js
var import_isFunction3 = __toESM(require_isFunction());
var import_react16 = __toESM(require_react());
function useRenderedEffect(effect, deps) {
    const destructorRef = (0, import_react16.useRef)();
    (0, import_react16.useEffect)(()=>{
        nextTick(()=>{
            const destructor = effect === null || effect === void 0 ? void 0 : effect();
            if ((0, import_isFunction3.default)(destructor)) {
                destructorRef.current = destructor;
            }
        });
        return destructorRef.current;
    }, deps);
}
var use_rendered_effect_default = useRenderedEffect;
// node_modules/@taroify/core/hooks/use-mounted.js
function useMounted(cb) {
    use_rendered_effect_default(cb, []);
}
// node_modules/@taroify/core/hooks/use-timeout.js
var import_react17 = __toESM(require_react());
function useTimeout() {
    const timerRef = (0, import_react17.useRef)();
    const cbRef = (0, import_react17.useRef)();
    const msRef = (0, import_react17.useRef)();
    const argsRef = (0, import_react17.useRef)();
    const stop = (0, import_react17.useCallback)(()=>{
        if (timerRef.current) {
            clearTimeout(timerRef.current);
            timerRef.current = void 0;
        }
    }, []);
    const start = (0, import_react17.useCallback)((callback, ms, ...args)=>{
        if (timerRef.current) {
            return;
        }
        cbRef.current = callback;
        msRef.current = ms;
        argsRef.current = args;
        timerRef.current = setTimeout(callback, ms, args);
    }, []);
    const restart = (0, import_react17.useCallback)((callback, ms, ...args)=>{
        stop();
        if (callback) {
            start(callback, ms, args);
        } else if (cbRef.current) {
            start(cbRef.current, msRef.current, argsRef.current);
        }
    }, []);
    return (0, import_react17.useMemo)(()=>({
            restart,
            start,
            stop
        }), [
        restart,
        start,
        stop
    ]);
}
var use_timeout_default = useTimeout;
// node_modules/@taroify/core/hooks/use-unique-id.js
var import_uniqueId = __toESM(require_uniqueId());
var import_react18 = __toESM(require_react());
function useUniqueId(prefix = "t_") {
    const uniqueIdRef = (0, import_react18.useRef)((0, import_uniqueId.default)(prefix));
    return uniqueIdRef.current;
}
var use_unique_id_default = useUniqueId;
// node_modules/@taroify/hooks/use-force-update/use-force-update.js
var import_react19 = __toESM(require_react());
var updateReducer = (num)=>(num + 1) % 1e6;
function useForceUpdate() {
    const [, update] = (0, import_react19.useReducer)(updateReducer, 0);
    return update;
}
var use_force_update_default = useForceUpdate;
// node_modules/@taroify/core/hooks/use-update.js
var use_update_default = use_force_update_default;
// node_modules/@taroify/core/hooks/use-window-resize.js
var import_react20 = __toESM(require_react());
function useWindowResize(callback) {
    (0, import_react20.useEffect)(()=>{
        onWindowResize === null || onWindowResize === void 0 ? void 0 : onWindowResize(callback);
        return ()=>offWindowResize === null || offWindowResize === void 0 ? void 0 : offWindowResize(callback);
    }, [
        callback
    ]);
}
var use_window_resize_default = useWindowResize;
// node_modules/@taroify/core/hooks/use-memoized-fn.js
var import_react21 = __toESM(require_react());
function useMemoizedFn(fn) {
    const fnRef = (0, import_react21.useRef)(fn);
    fnRef.current = (0, import_react21.useMemo)(()=>fn, [
        fn
    ]);
    const memoizedFn = (0, import_react21.useRef)();
    if (!memoizedFn.current) {
        memoizedFn.current = function(...args) {
            return fnRef.current.apply(this, args);
        };
    }
    return memoizedFn.current;
}
// node_modules/@taroify/core/hooks/use-canvas.js
var import_react22 = __toESM(require_react());
function useCanvas(canvasId, canvasRef, options = {}) {
    const [loaded, setLoaded] = (0, import_react22.useState)(false);
    const [canvas, setCanvas] = (0, import_react22.useState)(null);
    const [ctx, setCtx] = (0, import_react22.useState)(null);
    const ratio = (0, import_react22.useMemo)(()=>getWindowInfo().pixelRatio || 1, []);
    const { onLoaded: onLoadedProp } = options;
    const onLoaded = useMemoizedFn((a, b)=>onLoadedProp === null || onLoadedProp === void 0 ? void 0 : onLoadedProp(a, b));
    (0, import_react22.useEffect)(()=>{
        const env = getEnv();
        let retry = 0;
        const setData = function() {
            var _ref = _async_to_generator(function*(_canvas) {
                if (_canvas) {
                    const canvasRectRef = yield getRect(canvasRef);
                    _canvas.width = Math.floor((canvasRectRef.width || _canvas.width) * ratio);
                    _canvas.height = Math.floor((canvasRectRef.height || _canvas.height) * ratio);
                }
                const _ctx = _canvas === null || _canvas === void 0 ? void 0 : _canvas.getContext("2d");
                if (_ctx) {
                    _ctx.scale(ratio, ratio);
                    setCanvas(_canvas);
                    setCtx(_ctx);
                    setLoaded(true);
                    onLoaded(_canvas, _ctx);
                } else {
                    setTimeout(()=>{
                        if (retry++ < 5) {
                            init();
                            console.log("[Taroify] canvas: init again");
                        } else {
                            console.error("[Taroify] canvas: init fail");
                        }
                    }, 100 * Math.pow(2, retry));
                }
            });
            return function setData(_canvas) {
                return _ref.apply(this, arguments);
            };
        }();
        const init = ()=>{
            if (env === "WEB") {
                var _canvasRef_current;
                setData((((_canvasRef_current = canvasRef.current) === null || _canvasRef_current === void 0 ? void 0 : _canvasRef_current.children) || [])[0]);
            } else {
                nextTick(()=>{
                    createSelectorQuery().select(`#${canvasId}`).fields({
                        node: true
                    }).exec((res)=>{
                        var _res_;
                        setData((_res_ = res[0]) === null || _res_ === void 0 ? void 0 : _res_.node);
                    });
                });
            }
        };
        init();
    }, [
        canvasId,
        canvasRef
    ]);
    return [
        canvas,
        ctx,
        loaded
    ];
}
var use_canvas_default = useCanvas;
// node_modules/@taroify/core/hooks/use-deep-compare.js
var import_react23 = __toESM(require_react());
var import_isEqual = __toESM(require_isEqual());
function createDeepCompare(deps) {
    const ref = (0, import_react23.useRef)();
    const signalRef = (0, import_react23.useRef)(0);
    if (deps === void 0 || !(0, import_isEqual.default)(deps, ref.current)) {
        ref.current = deps;
        signalRef.current += 1;
    }
    return [
        signalRef.current
    ];
}
function useDeepCompareEffect(effect, deps) {
    return (0, import_react23.useEffect)(effect, createDeepCompare(deps));
}
function useDeepCompareMemo(factory, deps) {
    return (0, import_react23.useMemo)(factory, createDeepCompare(deps));
}
// node_modules/@taroify/core/utils/merge-style.js
function mergeStyle(style, objectStyle) {
    let styleObject;
    if (typeof style === "string") {
        styleObject = {};
        style.split(";").forEach((item)=>{
            const [key, value] = item.split(":");
            if (key && value) {
                styleObject[key.trim()] = value.trim();
            }
        });
    } else if (typeof style === "object" && style) {
        styleObject = style;
    } else {
        styleObject = {};
    }
    return _object_spread({}, styleObject, objectStyle);
}
// node_modules/@taroify/core/image/image-placeholder.js
var import_classnames15 = __toESM(require_classnames());
var import_isString4 = __toESM(require_isString());
var import_isNumber4 = __toESM(require_isNumber());
var React18 = __toESM(require_react());
var import_react24 = __toESM(require_react());
function ImagePlaceholder(props) {
    const { prefix = "placeholder", children: children2 } = props;
    if ((0, import_react24.isValidElement)(children2)) {
        return (0, import_react24.cloneElement)(children2, {
            className: (0, import_classnames15.default)(prefixClassname(`image__${prefix}`), prefixClassname(`image__${prefix}-icon`))
        });
    }
    if ((0, import_isString4.default)(children2) || (0, import_isNumber4.default)(children2)) {
        return React18.createElement(View, {
            className: prefixClassname(`image__${prefix}`),
            children: children2
        });
    }
    return React18.createElement(React18.Fragment, null);
}
// node_modules/@taroify/core/image/image.js
var { warn } = getLogger("Image");
function useImageMode(mode) {
    return (0, import_react25.useMemo)(()=>{
        if (mode === "topLeft") {
            return "top left";
        }
        if (mode === "topRight") {
            return "top right";
        }
        if (mode === "bottomLeft") {
            return "bottom left";
        }
        if (mode === "bottomRight") {
            return "bottom right";
        }
        return mode;
    }, [
        mode
    ]);
}
function useImageShape(shape, round) {
    let shapeResult = shape;
    if ((0, import_isBoolean2.default)(round) && round) {
        shapeResult = "circle";
        warn(`Use the shape="${shapeResult}" prop instead of the round prop`);
        if (round) {
            return shapeResult;
        }
    }
    return shapeResult;
}
function Image3(props) {
    const { className, wrapperClassName, src, alt, width: widthProp, height: heightProp, mode = "scaleToFill", round, shape: shapeProp, lazyLoad = false, placeholder = false, fallback = false, onLoad, onError, style: styleProp } = props, restProps = _object_without_properties(props, [
        "className",
        "wrapperClassName",
        "src",
        "alt",
        "width",
        "height",
        "mode",
        "round",
        "shape",
        "lazyLoad",
        "placeholder",
        "fallback",
        "onLoad",
        "onError",
        "style"
    ]);
    const taroImageRef = (0, import_react25.useRef)();
    const taroMode = useImageMode(mode);
    const shape = useImageShape(shapeProp, round);
    const [loading, setLoading] = (0, import_react25.useState)(false);
    const [failed, setFailed] = (0, import_react25.useState)(false);
    const isLoadedRef = (0, import_react25.useRef)(false);
    const [viewStyle, imgStyle] = (0, import_react25.useMemo)(()=>{
        const width = widthProp ? typeof widthProp === "number" ? pxTransform(widthProp) : widthProp : void 0;
        const height = heightProp ? typeof heightProp === "number" ? pxTransform(heightProp) : heightProp : void 0;
        const imgStyle2 = mergeStyle(styleProp, {});
        imgStyle2.width = width || imgStyle2.width;
        imgStyle2.height = height || imgStyle2.height;
        return [
            {
                width: imgStyle2.width || "100%",
                height: imgStyle2.height || "100%",
                position: "relative"
            },
            imgStyle2
        ];
    }, [
        styleProp,
        widthProp,
        heightProp
    ]);
    const handleLoad = useMemoizedFn(()=>{
        if (!isLoadedRef.current) {
            isLoadedRef.current = true;
            onLoad === null || onLoad === void 0 ? void 0 : onLoad();
            setLoading(false);
        }
    });
    const handleError = useMemoizedFn(()=>{
        onError === null || onError === void 0 ? void 0 : onError();
        setLoading(false);
        setFailed(true);
    });
    (0, import_react25.useEffect)(()=>{
        var _taroImageRef_current_children, _taroImageRef_current;
        isLoadedRef.current = false;
        const nativeImg = (_taroImageRef_current = taroImageRef.current) === null || _taroImageRef_current === void 0 ? void 0 : (_taroImageRef_current_children = _taroImageRef_current.children) === null || _taroImageRef_current_children === void 0 ? void 0 : _taroImageRef_current_children[0];
        if (nativeImg === null || nativeImg === void 0 ? void 0 : nativeImg.complete) {
            handleLoad();
        } else {
            setLoading(true);
        }
    }, [
        src
    ]);
    return React19.createElement(View, {
        style: viewStyle,
        className: wrapperClassName
    }, !failed && src && React19.createElement(Image2, _object_spread({
        ref: taroImageRef,
        src,
        mode: taroMode,
        lazyLoad,
        className: (0, import_classnames16.default)(prefixClassname("image"), {
            [prefixClassname("image--square")]: shape === "square",
            [prefixClassname("image--rounded")]: shape === "rounded",
            [prefixClassname("image--circle")]: shape === "circle",
            [prefixClassname("image--loading")]: loading
        }, className),
        style: imgStyle,
        imgProps: {
            alt
        },
        onLoad: handleLoad,
        onError: handleError
    }, restProps)), loading && placeholder && React19.createElement(ImagePlaceholder, {
        prefix: "placeholder",
        children: placeholder
    }), failed && fallback && React19.createElement(ImagePlaceholder, {
        prefix: "fallback",
        children: fallback
    }));
}
// node_modules/@taroify/hooks/use-area/use-area.js
var import_map3 = __toESM(require_map());
var import_padEnd = __toESM(require_padEnd());
var import_forEach2 = __toESM(require_forEach());
var import_startsWith = __toESM(require_startsWith());
var import_first2 = __toESM(require_first());
var import_get2 = __toESM(require_get());
var import_find = __toESM(require_find());
var import_isArray4 = __toESM(require_isArray());
var import_isEqual2 = __toESM(require_isEqual());
var import_react27 = __toESM(require_react());
// node_modules/@taroify/hooks/use-to-ref/use-to-ref.js
var import_react26 = __toESM(require_react());
function useToRef(value) {
    const stateRef = (0, import_react26.useRef)();
    stateRef.current = value;
    return stateRef;
}
// node_modules/@taroify/hooks/use-area/area.shared.js
var import_isEmpty3 = __toESM(require_isEmpty());
// node_modules/@taroify/hooks/use-cascader/use-cascader.new.js
var import_get3 = __toESM(require_get());
var import_isUndefined3 = __toESM(require_isUndefined());
var import_isEmpty4 = __toESM(require_isEmpty());
var import_clamp = __toESM(require_clamp());
var import_size2 = __toESM(require_size());
var import_range2 = __toESM(require_range());
var import_isEqual3 = __toESM(require_isEqual());
var import_react28 = __toESM(require_react());
// node_modules/@taroify/hooks/use-cascader/use-cascader.shared.js
var import_find2 = __toESM(require_find());
var import_isUndefined2 = __toESM(require_isUndefined());
var import_first3 = __toESM(require_first());
function findCascadeOption(options, value, defaultFirst = false) {
    const option = (0, import_find2.default)(options, (option2)=>option2.value === value);
    return (0, import_isUndefined2.default)(option) && defaultFirst ? (0, import_first3.default)(options) : option;
}
// node_modules/@taroify/hooks/use-cascader/use-cascader.new.js
function doCascadeSelect({ value: values2, data: options }) {
    const newValues = [];
    const newColumns = [];
    newColumns.push({
        children: options
    });
    let cursorOptions = options;
    let depth = 0;
    for(;;){
        const value = (0, import_get3.default)(values2, depth);
        const nextOption = findCascadeOption(cursorOptions, value, true);
        if ((0, import_isUndefined3.default)(nextOption)) {
            break;
        }
        const { value: newValue, children: nextOptions } = nextOption;
        newValues.push(newValue);
        if (!nextOptions || (0, import_isEmpty4.default)(nextOptions)) {
            break;
        }
        newColumns.push(nextOption);
        cursorOptions = nextOptions;
        depth++;
    }
    return [
        newColumns,
        newValues
    ];
}
function useCascadeSelect(options) {
    const { value, data, depth } = options;
    return (0, import_react28.useMemo)(()=>doCascadeSelect({
            value,
            data,
            depth
        }), [
        data,
        depth,
        value
    ]);
}
function useCascaderNew({ value: values2 = [], depth: maxDepth = 0, data = [], onChange }) {
    maxDepth = (0, import_clamp.default)(maxDepth, 0, maxDepth);
    const onChangeRef = useToRef(onChange);
    const [columns, newValues] = useCascadeSelect({
        value: values2,
        depth: maxDepth,
        data
    });
    (0, import_react28.useEffect)(()=>{
        if (maxDepth !== 0 && maxDepth > (0, import_size2.default)(columns)) {
            (0, import_range2.default)(maxDepth - (0, import_size2.default)(columns)).map(()=>[]).forEach((e)=>columns.push(e));
        }
        if (!(0, import_isEqual3.default)(values2, newValues)) {
            var _onChangeRef_current;
            (_onChangeRef_current = onChangeRef.current) === null || _onChangeRef_current === void 0 ? void 0 : _onChangeRef_current.call(onChangeRef, newValues);
        }
    }, [
        columns,
        maxDepth,
        newValues,
        onChangeRef,
        values2
    ]);
    return {
        columns
    };
}
// node_modules/@taroify/hooks/use-cascader/use-cascader.old.js
var import_clamp2 = __toESM(require_clamp());
var import_isEmpty5 = __toESM(require_isEmpty());
var import_isUndefined4 = __toESM(require_isUndefined());
var import_size3 = __toESM(require_size());
var import_range3 = __toESM(require_range());
var import_react29 = __toESM(require_react());
var emptyArr = [];
var defaultFieldNames = {
    label: "label",
    value: "value",
    children: "children"
};
function useCascaderOld({ value: values2 = emptyArr, depth = 0, options, fieldNames = defaultFieldNames, refreshKey = 0 }) {
    depth = (0, import_clamp2.default)(depth, 0, depth);
    const cacheMapRef = (0, import_react29.useRef)(/* @__PURE__ */ new Map());
    const [columns, setColumns] = (0, import_react29.useState)([]);
    (0, import_react29.useEffect)(()=>{
        return ()=>{
            cacheMapRef.current.clear();
        };
    }, [
        options
    ]);
    (0, import_react29.useEffect)(()=>{
        if (options === void 0) {
            return;
        }
        const newColumns = [];
        newColumns.push(options);
        if (!(0, import_isEmpty5.default)(values2)) {
            let cursorOptions = options;
            for (const value of values2){
                if (!cacheMapRef.current.has(value)) {
                    cursorOptions.forEach((item)=>{
                        cacheMapRef.current.set(item[fieldNames.value], item);
                    });
                }
                const nextOption = cacheMapRef.current.get(value);
                if ((0, import_isUndefined4.default)(nextOption)) {
                    break;
                }
                const nextOptions = nextOption[fieldNames.children];
                if (!nextOptions || (0, import_isEmpty5.default)(nextOptions)) {
                    break;
                }
                cursorOptions = nextOptions;
                newColumns.push(nextOptions);
            }
        }
        if (depth !== 0 && depth > (0, import_size3.default)(newColumns)) {
            (0, import_range3.default)(depth - (0, import_size3.default)(newColumns)).forEach(()=>newColumns.push([]));
        }
        setColumns(newColumns);
    }, [
        depth,
        options,
        values2,
        fieldNames,
        refreshKey
    ]);
    return {
        columns
    };
}
// node_modules/@taroify/hooks/use-cascader/use-cascader.js
function useCascader(_param) {
    var { data } = _param, restOptions = _object_without_properties(_param, [
        "data"
    ]);
    const useCompatibleCascader = data ? useCascaderNew : useCascaderOld;
    return useCompatibleCascader(_object_spread({
        data
    }, restOptions));
}
var use_cascader_default = useCascader;
// node_modules/@taroify/hooks/use-getter/use-getter.js
var import_isFunction4 = __toESM(require_isFunction());
var import_react30 = __toESM(require_react());
function useGetter(state) {
    return (0, import_react30.useMemo)(()=>{
        if ((0, import_isFunction4.default)(state)) {
            return state;
        }
        return ()=>state;
    }, [
        state
    ]);
}
// node_modules/@taroify/hooks/use-uncontrolled/use-uncontrolled.js
var import_isUndefined5 = __toESM(require_isUndefined());
var import_react31 = __toESM(require_react());
function useUncontrolled(options = {}) {
    const { defaultValue, value: valueProp, onChange } = options;
    const forceUpdate = use_force_update_default();
    const valueRef = useToRef(valueProp);
    const stateRef = (0, import_react31.useRef)(defaultValue !== null && defaultValue !== void 0 ? defaultValue : valueRef.current);
    if (valueRef.current !== void 0) {
        stateRef.current = valueRef.current;
    }
    const setValue = (0, import_react31.useCallback)((newValue, emitChange)=>{
        const changed = stateRef.current !== newValue;
        if (changed) {
            var _this;
            if ((0, import_isUndefined5.default)(valueRef.current)) {
                stateRef.current = newValue;
                forceUpdate();
            }
            ;
            (_this = emitChange !== null && emitChange !== void 0 ? emitChange : onChange) === null || _this === void 0 ? void 0 : _this(newValue);
        }
    }, [
        onChange
    ]);
    const getValue = (0, import_react31.useCallback)(()=>stateRef.current, []);
    return (0, import_react31.useMemo)(()=>({
            value: stateRef.current,
            getValue,
            setValue
        }), [
        stateRef.current,
        getValue,
        setValue
    ]);
}
// node_modules/@taroify/core/popup/popup.js
var import_classnames19 = __toESM(require_classnames());
var import_isNumber6 = __toESM(require_isNumber());
var import_isUndefined7 = __toESM(require_isUndefined());
var React30 = __toESM(require_react());
var import_react45 = __toESM(require_react());
// node_modules/@taroify/core/backdrop/backdrop.js
var import_classnames17 = __toESM(require_classnames());
var import_isNumber5 = __toESM(require_isNumber());
var React27 = __toESM(require_react());
var import_react41 = __toESM(require_react());
// node_modules/@taroify/core/transition/transition.js
var React26 = __toESM(require_react());
var import_react39 = __toESM(require_react());
// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t[n] = r[n];
    }
    return t;
}
// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
    }, _setPrototypeOf(t, e);
}
// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(t, o) {
    t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
}
// node_modules/react-transition-group/esm/CSSTransition.js
var import_prop_types3 = __toESM(require_prop_types());
// node_modules/dom-helpers/esm/hasClass.js
function hasClass(element, className) {
    if (element.classList) return !!className && element.classList.contains(className);
    return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}
// node_modules/dom-helpers/esm/addClass.js
function addClass(element, className) {
    if (element.classList) element.classList.add(className);
    else if (!hasClass(element, className)) if (typeof element.className === "string") element.className = element.className + " " + className;
    else element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
}
// node_modules/dom-helpers/esm/removeClass.js
function replaceClassName(origClass, classToRemove) {
    return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass(element, className) {
    if (element.classList) {
        element.classList.remove(className);
    } else if (typeof element.className === "string") {
        element.className = replaceClassName(element.className, className);
    } else {
        element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
    }
}
// node_modules/react-transition-group/esm/CSSTransition.js
var import_react34 = __toESM(require_react());
// node_modules/react-transition-group/esm/Transition.js
var import_prop_types2 = __toESM(require_prop_types());
var import_react33 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
// node_modules/react-transition-group/esm/config.js
var config_default = {
    disabled: false
};
// node_modules/react-transition-group/esm/utils/PropTypes.js
var import_prop_types = __toESM(require_prop_types());
var timeoutsShape = true ? import_prop_types.default.oneOfType([
    import_prop_types.default.number,
    import_prop_types.default.shape({
        enter: import_prop_types.default.number,
        exit: import_prop_types.default.number,
        appear: import_prop_types.default.number
    }).isRequired
]) : null;
var classNamesShape = true ? import_prop_types.default.oneOfType([
    import_prop_types.default.string,
    import_prop_types.default.shape({
        enter: import_prop_types.default.string,
        exit: import_prop_types.default.string,
        active: import_prop_types.default.string
    }),
    import_prop_types.default.shape({
        enter: import_prop_types.default.string,
        enterDone: import_prop_types.default.string,
        enterActive: import_prop_types.default.string,
        exit: import_prop_types.default.string,
        exitDone: import_prop_types.default.string,
        exitActive: import_prop_types.default.string
    })
]) : null;
// node_modules/react-transition-group/esm/TransitionGroupContext.js
var import_react32 = __toESM(require_react());
var TransitionGroupContext_default = import_react32.default.createContext(null);
// node_modules/react-transition-group/esm/utils/reflow.js
var forceReflow = function forceReflow2(node) {
    return node.scrollTop;
};
// node_modules/react-transition-group/esm/Transition.js
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = function(_React$Component) {
    _inheritsLoose(Transition3, _React$Component);
    function Transition3(props, context) {
        var _this;
        _this = _React$Component.call(this, props, context) || this;
        var parentGroup = context;
        var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
        var initialStatus;
        _this.appearStatus = null;
        if (props.in) {
            if (appear) {
                initialStatus = EXITED;
                _this.appearStatus = ENTERING;
            } else {
                initialStatus = ENTERED;
            }
        } else {
            if (props.unmountOnExit || props.mountOnEnter) {
                initialStatus = UNMOUNTED;
            } else {
                initialStatus = EXITED;
            }
        }
        _this.state = {
            status: initialStatus
        };
        _this.nextCallback = null;
        return _this;
    }
    Transition3.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
        var nextIn = _ref.in;
        if (nextIn && prevState.status === UNMOUNTED) {
            return {
                status: EXITED
            };
        }
        return null;
    };
    var _proto = Transition3.prototype;
    _proto.componentDidMount = function componentDidMount() {
        this.updateStatus(true, this.appearStatus);
    };
    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
        var nextStatus = null;
        if (prevProps !== this.props) {
            var status = this.state.status;
            if (this.props.in) {
                if (status !== ENTERING && status !== ENTERED) {
                    nextStatus = ENTERING;
                }
            } else {
                if (status === ENTERING || status === ENTERED) {
                    nextStatus = EXITING;
                }
            }
        }
        this.updateStatus(false, nextStatus);
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
        this.cancelNextCallback();
    };
    _proto.getTimeouts = function getTimeouts() {
        var timeout2 = this.props.timeout;
        var exit, enter, appear;
        exit = enter = appear = timeout2;
        if (timeout2 != null && typeof timeout2 !== "number") {
            exit = timeout2.exit;
            enter = timeout2.enter;
            appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
        }
        return {
            exit,
            enter,
            appear
        };
    };
    _proto.updateStatus = function updateStatus(mounting, nextStatus) {
        if (mounting === void 0) {
            mounting = false;
        }
        if (nextStatus !== null) {
            this.cancelNextCallback();
            if (nextStatus === ENTERING) {
                if (this.props.unmountOnExit || this.props.mountOnEnter) {
                    var node = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom.default.findDOMNode(this);
                    if (node) forceReflow(node);
                }
                this.performEnter(mounting);
            } else {
                this.performExit();
            }
        } else if (this.props.unmountOnExit && this.state.status === EXITED) {
            this.setState({
                status: UNMOUNTED
            });
        }
    };
    _proto.performEnter = function performEnter(mounting) {
        var _this2 = this;
        var enter = this.props.enter;
        var appearing = this.context ? this.context.isMounting : mounting;
        var _ref2 = this.props.nodeRef ? [
            appearing
        ] : [
            import_react_dom.default.findDOMNode(this),
            appearing
        ], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
        var timeouts = this.getTimeouts();
        var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
        if (!mounting && !enter || config_default.disabled) {
            this.safeSetState({
                status: ENTERED
            }, function() {
                _this2.props.onEntered(maybeNode);
            });
            return;
        }
        this.props.onEnter(maybeNode, maybeAppearing);
        this.safeSetState({
            status: ENTERING
        }, function() {
            _this2.props.onEntering(maybeNode, maybeAppearing);
            _this2.onTransitionEnd(enterTimeout, function() {
                _this2.safeSetState({
                    status: ENTERED
                }, function() {
                    _this2.props.onEntered(maybeNode, maybeAppearing);
                });
            });
        });
    };
    _proto.performExit = function performExit() {
        var _this3 = this;
        var exit = this.props.exit;
        var timeouts = this.getTimeouts();
        var maybeNode = this.props.nodeRef ? void 0 : import_react_dom.default.findDOMNode(this);
        if (!exit || config_default.disabled) {
            this.safeSetState({
                status: EXITED
            }, function() {
                _this3.props.onExited(maybeNode);
            });
            return;
        }
        this.props.onExit(maybeNode);
        this.safeSetState({
            status: EXITING
        }, function() {
            _this3.props.onExiting(maybeNode);
            _this3.onTransitionEnd(timeouts.exit, function() {
                _this3.safeSetState({
                    status: EXITED
                }, function() {
                    _this3.props.onExited(maybeNode);
                });
            });
        });
    };
    _proto.cancelNextCallback = function cancelNextCallback() {
        if (this.nextCallback !== null) {
            this.nextCallback.cancel();
            this.nextCallback = null;
        }
    };
    _proto.safeSetState = function safeSetState(nextState, callback) {
        callback = this.setNextCallback(callback);
        this.setState(nextState, callback);
    };
    _proto.setNextCallback = function setNextCallback(callback) {
        var _this4 = this;
        var active = true;
        this.nextCallback = function(event) {
            if (active) {
                active = false;
                _this4.nextCallback = null;
                callback(event);
            }
        };
        this.nextCallback.cancel = function() {
            active = false;
        };
        return this.nextCallback;
    };
    _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
        this.setNextCallback(handler);
        var node = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom.default.findDOMNode(this);
        var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
        if (!node || doesNotHaveTimeoutOrListener) {
            setTimeout(this.nextCallback, 0);
            return;
        }
        if (this.props.addEndListener) {
            var _ref3 = this.props.nodeRef ? [
                this.nextCallback
            ] : [
                node,
                this.nextCallback
            ], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
            this.props.addEndListener(maybeNode, maybeNextCallback);
        }
        if (timeout2 != null) {
            setTimeout(this.nextCallback, timeout2);
        }
    };
    _proto.render = function render2() {
        var status = this.state.status;
        if (status === UNMOUNTED) {
            return null;
        }
        var _this$props = this.props, children2 = _this$props.children, _in = _this$props.in, _mountOnEnter = _this$props.mountOnEnter, _unmountOnExit = _this$props.unmountOnExit, _appear = _this$props.appear, _enter = _this$props.enter, _exit = _this$props.exit, _timeout = _this$props.timeout, _addEndListener = _this$props.addEndListener, _onEnter = _this$props.onEnter, _onEntering = _this$props.onEntering, _onEntered = _this$props.onEntered, _onExit = _this$props.onExit, _onExiting = _this$props.onExiting, _onExited = _this$props.onExited, _nodeRef = _this$props.nodeRef, childProps = _objectWithoutPropertiesLoose(_this$props, [
            "children",
            "in",
            "mountOnEnter",
            "unmountOnExit",
            "appear",
            "enter",
            "exit",
            "timeout",
            "addEndListener",
            "onEnter",
            "onEntering",
            "onEntered",
            "onExit",
            "onExiting",
            "onExited",
            "nodeRef"
        ]);
        return(// allows for nested Transitions
        import_react33.default.createElement(TransitionGroupContext_default.Provider, {
            value: null
        }, typeof children2 === "function" ? children2(status, childProps) : import_react33.default.cloneElement(import_react33.default.Children.only(children2), childProps)));
    };
    return Transition3;
}(import_react33.default.Component);
Transition.contextType = TransitionGroupContext_default;
Transition.propTypes = true ? {
    /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */ nodeRef: import_prop_types2.default.shape({
        current: typeof Element === "undefined" ? import_prop_types2.default.any : function(propValue, key, componentName, location, propFullName, secret) {
            var value = propValue[key];
            return import_prop_types2.default.instanceOf(value && "ownerDocument" in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
        }
    }),
    /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */ children: import_prop_types2.default.oneOfType([
        import_prop_types2.default.func.isRequired,
        import_prop_types2.default.element.isRequired
    ]).isRequired,
    /**
   * Show the component; triggers the enter or exit states
   */ in: import_prop_types2.default.bool,
    /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */ mountOnEnter: import_prop_types2.default.bool,
    /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */ unmountOnExit: import_prop_types2.default.bool,
    /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */ appear: import_prop_types2.default.bool,
    /**
   * Enable or disable enter transitions.
   */ enter: import_prop_types2.default.bool,
    /**
   * Enable or disable exit transitions.
   */ exit: import_prop_types2.default.bool,
    /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */ timeout: function timeout(props) {
        var pt = timeoutsShape;
        if (!props.addEndListener) pt = pt.isRequired;
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            args[_key - 1] = arguments[_key];
        }
        return pt.apply(void 0, [
            props
        ].concat(args));
    },
    /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */ addEndListener: import_prop_types2.default.func,
    /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */ onEnter: import_prop_types2.default.func,
    /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */ onEntering: import_prop_types2.default.func,
    /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */ onEntered: import_prop_types2.default.func,
    /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */ onExit: import_prop_types2.default.func,
    /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */ onExiting: import_prop_types2.default.func,
    /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */ onExited: import_prop_types2.default.func
} : {};
function noop2() {}
Transition.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: noop2,
    onEntering: noop2,
    onEntered: noop2,
    onExit: noop2,
    onExiting: noop2,
    onExited: noop2
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var Transition_default = Transition;
// node_modules/react-transition-group/esm/CSSTransition.js
var _addClass = function addClass2(node, classes) {
    return node && classes && classes.split(" ").forEach(function(c) {
        return addClass(node, c);
    });
};
var removeClass2 = function removeClass3(node, classes) {
    return node && classes && classes.split(" ").forEach(function(c) {
        return removeClass(node, c);
    });
};
var CSSTransition = function(_React$Component) {
    _inheritsLoose(CSSTransition2, _React$Component);
    function CSSTransition2() {
        var _this;
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _React$Component.call.apply(_React$Component, [
            this
        ].concat(args)) || this;
        _this.appliedClasses = {
            appear: {},
            enter: {},
            exit: {}
        };
        _this.onEnter = function(maybeNode, maybeAppearing) {
            var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
            _this.removeClasses(node, "exit");
            _this.addClass(node, appearing ? "appear" : "enter", "base");
            if (_this.props.onEnter) {
                _this.props.onEnter(maybeNode, maybeAppearing);
            }
        };
        _this.onEntering = function(maybeNode, maybeAppearing) {
            var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
            var type = appearing ? "appear" : "enter";
            _this.addClass(node, type, "active");
            if (_this.props.onEntering) {
                _this.props.onEntering(maybeNode, maybeAppearing);
            }
        };
        _this.onEntered = function(maybeNode, maybeAppearing) {
            var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
            var type = appearing ? "appear" : "enter";
            _this.removeClasses(node, type);
            _this.addClass(node, type, "done");
            if (_this.props.onEntered) {
                _this.props.onEntered(maybeNode, maybeAppearing);
            }
        };
        _this.onExit = function(maybeNode) {
            var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
            _this.removeClasses(node, "appear");
            _this.removeClasses(node, "enter");
            _this.addClass(node, "exit", "base");
            if (_this.props.onExit) {
                _this.props.onExit(maybeNode);
            }
        };
        _this.onExiting = function(maybeNode) {
            var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
            _this.addClass(node, "exit", "active");
            if (_this.props.onExiting) {
                _this.props.onExiting(maybeNode);
            }
        };
        _this.onExited = function(maybeNode) {
            var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
            _this.removeClasses(node, "exit");
            _this.addClass(node, "exit", "done");
            if (_this.props.onExited) {
                _this.props.onExited(maybeNode);
            }
        };
        _this.resolveArguments = function(maybeNode, maybeAppearing) {
            return _this.props.nodeRef ? [
                _this.props.nodeRef.current,
                maybeNode
            ] : [
                maybeNode,
                maybeAppearing
            ];
        };
        _this.getClassNames = function(type) {
            var classNames153 = _this.props.classNames;
            var isStringClassNames = typeof classNames153 === "string";
            var prefix = isStringClassNames && classNames153 ? classNames153 + "-" : "";
            var baseClassName = isStringClassNames ? "" + prefix + type : classNames153[type];
            var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames153[type + "Active"];
            var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames153[type + "Done"];
            return {
                baseClassName,
                activeClassName,
                doneClassName
            };
        };
        return _this;
    }
    var _proto = CSSTransition2.prototype;
    _proto.addClass = function addClass3(node, type, phase) {
        var className = this.getClassNames(type)[phase + "ClassName"];
        var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
        if (type === "appear" && phase === "done" && doneClassName) {
            className += " " + doneClassName;
        }
        if (phase === "active") {
            if (node) forceReflow(node);
        }
        if (className) {
            this.appliedClasses[type][phase] = className;
            _addClass(node, className);
        }
    };
    _proto.removeClasses = function removeClasses(node, type) {
        var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
        this.appliedClasses[type] = {};
        if (baseClassName) {
            removeClass2(node, baseClassName);
        }
        if (activeClassName) {
            removeClass2(node, activeClassName);
        }
        if (doneClassName) {
            removeClass2(node, doneClassName);
        }
    };
    _proto.render = function render2() {
        var _this$props = this.props, _ = _this$props.classNames, props = _objectWithoutPropertiesLoose(_this$props, [
            "classNames"
        ]);
        return import_react34.default.createElement(Transition_default, _extends({}, props, {
            onEnter: this.onEnter,
            onEntered: this.onEntered,
            onEntering: this.onEntering,
            onExit: this.onExit,
            onExiting: this.onExiting,
            onExited: this.onExited
        }));
    };
    return CSSTransition2;
}(import_react34.default.Component);
CSSTransition.defaultProps = {
    classNames: ""
};
CSSTransition.propTypes = true ? _extends({}, Transition_default.propTypes, {
    /**
   * The animation classNames applied to the component as it appears, enters,
   * exits or has finished the transition. A single name can be provided, which
   * will be suffixed for each stage, e.g. `classNames="fade"` applies:
   *
   * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
   * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
   * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
   *
   * A few details to note about how these classes are applied:
   *
   * 1. They are _joined_ with the ones that are already defined on the child
   *    component, so if you want to add some base styles, you can use
   *    `className` without worrying that it will be overridden.
   *
   * 2. If the transition component mounts with `in={false}`, no classes are
   *    applied yet. You might be expecting `*-exit-done`, but if you think
   *    about it, a component cannot finish exiting if it hasn't entered yet.
   *
   * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
   *    allows you to define different behavior for when appearing is done and
   *    when regular entering is done, using selectors like
   *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
   *    an epic entrance animation when element first appears in the DOM using
   *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
   *    simply use `fade-enter-done` for defining both cases.
   *
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  appearDone: 'my-done-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply
   * spread them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  appearDone?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */ classNames: classNamesShape,
    /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */ onEnter: import_prop_types3.default.func,
    /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */ onEntering: import_prop_types3.default.func,
    /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */ onEntered: import_prop_types3.default.func,
    /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */ onExit: import_prop_types3.default.func,
    /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */ onExiting: import_prop_types3.default.func,
    /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */ onExited: import_prop_types3.default.func
}) : {};
var CSSTransition_default = CSSTransition;
// node_modules/react-transition-group/esm/ReplaceTransition.js
var import_prop_types5 = __toESM(require_prop_types());
var import_react37 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());
// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
}
// node_modules/react-transition-group/esm/TransitionGroup.js
var import_prop_types4 = __toESM(require_prop_types());
var import_react36 = __toESM(require_react());
// node_modules/react-transition-group/esm/utils/ChildMapping.js
var import_react35 = __toESM(require_react());
function getChildMapping(children2, mapFn) {
    var mapper = function mapper2(child) {
        return mapFn && (0, import_react35.isValidElement)(child) ? mapFn(child) : child;
    };
    var result = /* @__PURE__ */ Object.create(null);
    if (children2) import_react35.Children.map(children2, function(c) {
        return c;
    }).forEach(function(child) {
        result[child.key] = mapper(child);
    });
    return result;
}
function mergeChildMappings(prev, next) {
    prev = prev || {};
    next = next || {};
    function getValueForKey(key) {
        return key in next ? next[key] : prev[key];
    }
    var nextKeysPending = /* @__PURE__ */ Object.create(null);
    var pendingKeys = [];
    for(var prevKey in prev){
        if (prevKey in next) {
            if (pendingKeys.length) {
                nextKeysPending[prevKey] = pendingKeys;
                pendingKeys = [];
            }
        } else {
            pendingKeys.push(prevKey);
        }
    }
    var i;
    var childMapping = {};
    for(var nextKey in next){
        if (nextKeysPending[nextKey]) {
            for(i = 0; i < nextKeysPending[nextKey].length; i++){
                var pendingNextKey = nextKeysPending[nextKey][i];
                childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
            }
        }
        childMapping[nextKey] = getValueForKey(nextKey);
    }
    for(i = 0; i < pendingKeys.length; i++){
        childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    }
    return childMapping;
}
function getProp(child, prop, props) {
    return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
    return getChildMapping(props.children, function(child) {
        return (0, import_react35.cloneElement)(child, {
            onExited: onExited.bind(null, child),
            in: true,
            appear: getProp(child, "appear", props),
            enter: getProp(child, "enter", props),
            exit: getProp(child, "exit", props)
        });
    });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
    var nextChildMapping = getChildMapping(nextProps.children);
    var children2 = mergeChildMappings(prevChildMapping, nextChildMapping);
    Object.keys(children2).forEach(function(key) {
        var child = children2[key];
        if (!(0, import_react35.isValidElement)(child)) return;
        var hasPrev = key in prevChildMapping;
        var hasNext = key in nextChildMapping;
        var prevChild = prevChildMapping[key];
        var isLeaving = (0, import_react35.isValidElement)(prevChild) && !prevChild.props.in;
        if (hasNext && (!hasPrev || isLeaving)) {
            children2[key] = (0, import_react35.cloneElement)(child, {
                onExited: onExited.bind(null, child),
                in: true,
                exit: getProp(child, "exit", nextProps),
                enter: getProp(child, "enter", nextProps)
            });
        } else if (!hasNext && hasPrev && !isLeaving) {
            children2[key] = (0, import_react35.cloneElement)(child, {
                in: false
            });
        } else if (hasNext && hasPrev && (0, import_react35.isValidElement)(prevChild)) {
            children2[key] = (0, import_react35.cloneElement)(child, {
                onExited: onExited.bind(null, child),
                in: prevChild.props.in,
                exit: getProp(child, "exit", nextProps),
                enter: getProp(child, "enter", nextProps)
            });
        }
    });
    return children2;
}
// node_modules/react-transition-group/esm/TransitionGroup.js
var values = Object.values || function(obj) {
    return Object.keys(obj).map(function(k) {
        return obj[k];
    });
};
var defaultProps = {
    component: "div",
    childFactory: function childFactory(child) {
        return child;
    }
};
var TransitionGroup = function(_React$Component) {
    _inheritsLoose(TransitionGroup2, _React$Component);
    function TransitionGroup2(props, context) {
        var _this;
        _this = _React$Component.call(this, props, context) || this;
        var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
        _this.state = {
            contextValue: {
                isMounting: true
            },
            handleExited,
            firstRender: true
        };
        return _this;
    }
    var _proto = TransitionGroup2.prototype;
    _proto.componentDidMount = function componentDidMount() {
        this.mounted = true;
        this.setState({
            contextValue: {
                isMounting: false
            }
        });
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
        this.mounted = false;
    };
    TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
        var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
        return {
            children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
            firstRender: false
        };
    };
    _proto.handleExited = function handleExited(child, node) {
        var currentChildMapping = getChildMapping(this.props.children);
        if (child.key in currentChildMapping) return;
        if (child.props.onExited) {
            child.props.onExited(node);
        }
        if (this.mounted) {
            this.setState(function(state) {
                var children2 = _extends({}, state.children);
                delete children2[child.key];
                return {
                    children: children2
                };
            });
        }
    };
    _proto.render = function render2() {
        var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, [
            "component",
            "childFactory"
        ]);
        var contextValue = this.state.contextValue;
        var children2 = values(this.state.children).map(childFactory2);
        delete props.appear;
        delete props.enter;
        delete props.exit;
        if (Component === null) {
            return import_react36.default.createElement(TransitionGroupContext_default.Provider, {
                value: contextValue
            }, children2);
        }
        return import_react36.default.createElement(TransitionGroupContext_default.Provider, {
            value: contextValue
        }, import_react36.default.createElement(Component, props, children2));
    };
    return TransitionGroup2;
}(import_react36.default.Component);
TransitionGroup.propTypes = true ? {
    /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */ component: import_prop_types4.default.any,
    /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   *
   * While this component is meant for multiple `Transition` or `CSSTransition`
   * children, sometimes you may want to have a single transition child with
   * content that you want to be transitioned out and in when you change it
   * (e.g. routes, images etc.) In that case you can change the `key` prop of
   * the transition child as you change its content, this will cause
   * `TransitionGroup` to transition the child out and back in.
   */ children: import_prop_types4.default.node,
    /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */ appear: import_prop_types4.default.bool,
    /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */ enter: import_prop_types4.default.bool,
    /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */ exit: import_prop_types4.default.bool,
    /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */ childFactory: import_prop_types4.default.func
} : {};
TransitionGroup.defaultProps = defaultProps;
var TransitionGroup_default = TransitionGroup;
// node_modules/react-transition-group/esm/ReplaceTransition.js
var ReplaceTransition = function(_React$Component) {
    _inheritsLoose(ReplaceTransition2, _React$Component);
    function ReplaceTransition2() {
        var _this;
        for(var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++){
            _args[_key] = arguments[_key];
        }
        _this = _React$Component.call.apply(_React$Component, [
            this
        ].concat(_args)) || this;
        _this.handleEnter = function() {
            for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){
                args[_key2] = arguments[_key2];
            }
            return _this.handleLifecycle("onEnter", 0, args);
        };
        _this.handleEntering = function() {
            for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){
                args[_key3] = arguments[_key3];
            }
            return _this.handleLifecycle("onEntering", 0, args);
        };
        _this.handleEntered = function() {
            for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){
                args[_key4] = arguments[_key4];
            }
            return _this.handleLifecycle("onEntered", 0, args);
        };
        _this.handleExit = function() {
            for(var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++){
                args[_key5] = arguments[_key5];
            }
            return _this.handleLifecycle("onExit", 1, args);
        };
        _this.handleExiting = function() {
            for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++){
                args[_key6] = arguments[_key6];
            }
            return _this.handleLifecycle("onExiting", 1, args);
        };
        _this.handleExited = function() {
            for(var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++){
                args[_key7] = arguments[_key7];
            }
            return _this.handleLifecycle("onExited", 1, args);
        };
        return _this;
    }
    var _proto = ReplaceTransition2.prototype;
    _proto.handleLifecycle = function handleLifecycle(handler, idx, originalArgs) {
        var _child$props;
        var children2 = this.props.children;
        var child = import_react37.default.Children.toArray(children2)[idx];
        if (child.props[handler]) (_child$props = child.props)[handler].apply(_child$props, originalArgs);
        if (this.props[handler]) {
            var maybeNode = child.props.nodeRef ? void 0 : import_react_dom2.default.findDOMNode(this);
            this.props[handler](maybeNode);
        }
    };
    _proto.render = function render2() {
        var _this$props = this.props, children2 = _this$props.children, inProp = _this$props.in, props = _objectWithoutPropertiesLoose(_this$props, [
            "children",
            "in"
        ]);
        var _React$Children$toArr = import_react37.default.Children.toArray(children2), first = _React$Children$toArr[0], second = _React$Children$toArr[1];
        delete props.onEnter;
        delete props.onEntering;
        delete props.onEntered;
        delete props.onExit;
        delete props.onExiting;
        delete props.onExited;
        return import_react37.default.createElement(TransitionGroup_default, props, inProp ? import_react37.default.cloneElement(first, {
            key: "first",
            onEnter: this.handleEnter,
            onEntering: this.handleEntering,
            onEntered: this.handleEntered
        }) : import_react37.default.cloneElement(second, {
            key: "second",
            onEnter: this.handleExit,
            onEntering: this.handleExiting,
            onEntered: this.handleExited
        }));
    };
    return ReplaceTransition2;
}(import_react37.default.Component);
ReplaceTransition.propTypes = true ? {
    in: import_prop_types5.default.bool.isRequired,
    children: function children(props, propName) {
        if (import_react37.default.Children.count(props[propName]) !== 2) return new Error('"' + propName + '" must be exactly two transition components.');
        return null;
    }
} : {};
// node_modules/react-transition-group/esm/SwitchTransition.js
var import_react38 = __toESM(require_react());
var import_prop_types6 = __toESM(require_prop_types());
var _leaveRenders;
var _enterRenders;
function areChildrenDifferent(oldChildren, newChildren) {
    if (oldChildren === newChildren) return false;
    if (import_react38.default.isValidElement(oldChildren) && import_react38.default.isValidElement(newChildren) && oldChildren.key != null && oldChildren.key === newChildren.key) {
        return false;
    }
    return true;
}
var modes = {
    out: "out-in",
    in: "in-out"
};
var callHook = function callHook2(element, name, cb) {
    return function() {
        var _element$props;
        element.props[name] && (_element$props = element.props)[name].apply(_element$props, arguments);
        cb();
    };
};
var leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function(_ref) {
    var current = _ref.current, changeState = _ref.changeState;
    return import_react38.default.cloneElement(current, {
        in: false,
        onExited: callHook(current, "onExited", function() {
            changeState(ENTERING, null);
        })
    });
}, _leaveRenders[modes.in] = function(_ref2) {
    var current = _ref2.current, changeState = _ref2.changeState, children2 = _ref2.children;
    return [
        current,
        import_react38.default.cloneElement(children2, {
            in: true,
            onEntered: callHook(children2, "onEntered", function() {
                changeState(ENTERING);
            })
        })
    ];
}, _leaveRenders);
var enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function(_ref3) {
    var children2 = _ref3.children, changeState = _ref3.changeState;
    return import_react38.default.cloneElement(children2, {
        in: true,
        onEntered: callHook(children2, "onEntered", function() {
            changeState(ENTERED, import_react38.default.cloneElement(children2, {
                in: true
            }));
        })
    });
}, _enterRenders[modes.in] = function(_ref4) {
    var current = _ref4.current, children2 = _ref4.children, changeState = _ref4.changeState;
    return [
        import_react38.default.cloneElement(current, {
            in: false,
            onExited: callHook(current, "onExited", function() {
                changeState(ENTERED, import_react38.default.cloneElement(children2, {
                    in: true
                }));
            })
        }),
        import_react38.default.cloneElement(children2, {
            in: true
        })
    ];
}, _enterRenders);
var SwitchTransition = function(_React$Component) {
    _inheritsLoose(SwitchTransition2, _React$Component);
    function SwitchTransition2() {
        var _this;
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _React$Component.call.apply(_React$Component, [
            this
        ].concat(args)) || this;
        _this.state = {
            status: ENTERED,
            current: null
        };
        _this.appeared = false;
        _this.changeState = function(status, current) {
            if (current === void 0) {
                current = _this.state.current;
            }
            _this.setState({
                status,
                current
            });
        };
        return _this;
    }
    var _proto = SwitchTransition2.prototype;
    _proto.componentDidMount = function componentDidMount() {
        this.appeared = true;
    };
    SwitchTransition2.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
        if (props.children == null) {
            return {
                current: null
            };
        }
        if (state.status === ENTERING && props.mode === modes.in) {
            return {
                status: ENTERING
            };
        }
        if (state.current && areChildrenDifferent(state.current, props.children)) {
            return {
                status: EXITING
            };
        }
        return {
            current: import_react38.default.cloneElement(props.children, {
                in: true
            })
        };
    };
    _proto.render = function render2() {
        var _this$props = this.props, children2 = _this$props.children, mode = _this$props.mode, _this$state = this.state, status = _this$state.status, current = _this$state.current;
        var data = {
            children: children2,
            current,
            changeState: this.changeState,
            status
        };
        var component;
        switch(status){
            case ENTERING:
                component = enterRenders[mode](data);
                break;
            case EXITING:
                component = leaveRenders[mode](data);
                break;
            case ENTERED:
                component = current;
        }
        return import_react38.default.createElement(TransitionGroupContext_default.Provider, {
            value: {
                isMounting: !this.appeared
            }
        }, component);
    };
    return SwitchTransition2;
}(import_react38.default.Component);
SwitchTransition.propTypes = true ? {
    /**
   * Transition modes.
   * `out-in`: Current element transitions out first, then when complete, the new element transitions in.
   * `in-out`: New element transitions in first, then when complete, the current element transitions out.
   *
   * @type {'out-in'|'in-out'}
   */ mode: import_prop_types6.default.oneOf([
        modes.in,
        modes.out
    ]),
    /**
   * Any `Transition` or `CSSTransition` component.
   */ children: import_prop_types6.default.oneOfType([
        import_prop_types6.default.element.isRequired
    ])
} : {};
SwitchTransition.defaultProps = {
    mode: modes.out
};
// node_modules/@taroify/core/transition/transition.js
var TransitionName;
(function(TransitionName2) {
    TransitionName2["Fade"] = "fade";
    TransitionName2["SlideUp"] = "slide-up";
    TransitionName2["SlideDown"] = "slide-down";
    TransitionName2["SlideLeft"] = "slide-left";
    TransitionName2["SlideRight"] = "slide-right";
})(TransitionName || (TransitionName = {}));
var TRANSITION_PRESETS = [
    TransitionName.Fade,
    TransitionName.SlideUp,
    TransitionName.SlideDown,
    TransitionName.SlideLeft,
    TransitionName.SlideRight
];
function isTransitionPreset(name) {
    return name && TRANSITION_PRESETS.includes(name);
}
function useElementStyle(children2) {
    return (0, import_react39.useMemo)(()=>{
        if (!(0, import_react39.isValidElement)(children2)) {
            return {};
        }
        const element = children2;
        const { style } = element.props;
        return style !== null && style !== void 0 ? style : {};
    }, [
        children2
    ]);
}
function Transition2(props) {
    const { name, in: inProp = false, appear = false, mountOnEnter = false, unmountOnExit, timeout: timeout2 = 300, children: childrenProp, onEnter, onEntering, onEntered, onExit, onExiting, onExited } = props;
    const children2 = (0, import_react39.useMemo)(()=>childrenProp, [
        childrenProp
    ]);
    const childrenStyle = useElementStyle(children2);
    const transactionName = isTransitionPreset(name) ? prefixClassname(`transition-${name}`) : name;
    const [enter, setEnter] = (0, import_react39.useState)(false);
    const [exited, setExited] = (0, import_react39.useState)(false);
    const ref = (0, import_react39.useRef)(null);
    const setRef = (value)=>{
        ref.current = value;
    };
    return React26.createElement(CSSTransition_default, {
        in: inProp,
        nodeRef: ref,
        mountOnEnter,
        unmountOnExit,
        timeout: timeout2,
        appear,
        classNames: transactionName,
        style: _object_spread_props(_object_spread({}, childrenStyle), {
            display: enter && !exited ? "" : "none"
        }),
        onEnter: (node, isAppearing)=>{
            setEnter(true);
            setExited(false);
            onEnter === null || onEnter === void 0 ? void 0 : onEnter(node, isAppearing);
        },
        onEntering,
        onEntered,
        onExit,
        onExiting,
        onExited: (node)=>{
            setEnter(false);
            setExited(true);
            onExited === null || onExited === void 0 ? void 0 : onExited(node);
        }
    }, (0, import_react39.cloneElement)(children2, {
        ref: setRef
    }));
}
// node_modules/@taroify/core/utils/dom/event.js
function stopPropagation(event) {
    event.stopPropagation();
}
function preventDefault(event, isStopPropagation) {
    if (inBrowser) {
        if (typeof event.cancelable !== "boolean" || event.cancelable) {
            event.preventDefault();
        }
    } else {
        event.preventDefault();
    }
    if (isStopPropagation) {
        stopPropagation(event);
    }
}
function getClientCoordinates(event) {
    const { clientX, clientY, detail = {}, touches = [] } = event;
    if (clientX && clientY) {
        return {
            clientX,
            clientY
        };
    }
    return touches[0] || {
        clientX: detail.x || detail.clientX,
        clientY: detail.y || detail.clientY
    };
}
// node_modules/@taroify/core/utils/dom/use-lock-scroll-taro.js
var import_react40 = __toESM(require_react());
// node_modules/@taroify/core/utils/dom/can-use-dom.js
var canUseDom = !!(typeof window !== "undefined" && typeof document !== "undefined" && window.document && window.document.createElement);
// node_modules/@taroify/core/utils/dom/supports-passive.js
var supportsPassive = false;
if (canUseDom) {
    try {
        const opts = Object.defineProperty({}, "passive", {
            get: ()=>{
                supportsPassive = true;
            }
        });
        window.addEventListener("testPassive", null, opts);
    } catch (e) {}
}
// node_modules/@taroify/core/utils/dom/use-lock-scroll-taro.js
var totalLockCount = 0;
var BODY_LOCK_CLASS = "taroify-popup-overflow-hidden";
var useLockScrollTaro = (shouldLock)=>{
    (0, import_react40.useEffect)(()=>{
        if (getEnv() === "WEB" && shouldLock) {
            const touchmoveHandler = (e)=>{
                preventDefault(e, true);
            };
            const lock = ()=>{
                document.addEventListener("touchmove", touchmoveHandler, supportsPassive ? {
                    passive: false
                } : false);
                if (!totalLockCount) {
                    document.body.classList.add(BODY_LOCK_CLASS);
                }
                totalLockCount++;
            };
            const unlock = ()=>{
                if (totalLockCount) {
                    document.removeEventListener("touchmove", touchmoveHandler);
                    totalLockCount--;
                    if (!totalLockCount) {
                        document.body.classList.remove(BODY_LOCK_CLASS);
                    }
                }
            };
            lock();
            return ()=>unlock();
        }
    }, [
        shouldLock
    ]);
};
// node_modules/@taroify/core/backdrop/backdrop.js
function Backdrop(props) {
    const { className, style: styleProp, defaultOpen, open: openProp, closeable = false, lock = true, duration, children: children2, onClick, onClose } = props, restProps = _object_without_properties(props, [
        "className",
        "style",
        "defaultOpen",
        "open",
        "closeable",
        "lock",
        "duration",
        "children",
        "onClick",
        "onClose"
    ]);
    const { value: open = false, setValue } = useUncontrolled({
        defaultValue: defaultOpen,
        value: openProp
    });
    useLockScrollTaro(!!open && lock);
    const durationStyle = (0, import_react41.useMemo)(()=>(0, import_isNumber5.default)(duration) ? {
            "--animation-duration-base": `${duration}ms`
        } : {}, [
        duration
    ]);
    function handleClick(event) {
        onClick === null || onClick === void 0 ? void 0 : onClick(event);
        if (closeable) {
            setValue(false);
            onClose === null || onClose === void 0 ? void 0 : onClose(false);
        }
    }
    return React27.createElement(Transition2, {
        in: open,
        appear: true,
        mountOnEnter: true,
        timeout: duration,
        name: "fade"
    }, React27.createElement(View, _object_spread({
        className: (0, import_classnames17.default)(prefixClassname("backdrop"), {
            [prefixClassname("backdrop--open")]: open
        }, className),
        style: _object_spread({}, durationStyle, styleProp),
        catchMove: lock,
        children: children2,
        onClick: handleClick,
        onTouchMove: preventDefault
    }, restProps)));
}
Backdrop.displayName = "Backdrop";
// node_modules/@taroify/core/popup/popup-backdrop.js
var import_isUndefined6 = __toESM(require_isUndefined());
var import_isNull2 = __toESM(require_isNull());
var import_isBoolean3 = __toESM(require_isBoolean());
var React28 = __toESM(require_react());
var import_react43 = __toESM(require_react());
// node_modules/@taroify/core/popup/popup.context.js
var import_react42 = __toESM(require_react());
var PopupContext = (0, import_react42.createContext)({});
var popup_context_default = PopupContext;
// node_modules/@taroify/core/popup/popup-backdrop.js
function PopupBackdrop(props) {
    const { open: openProp = true, duration, closeable = true, lock } = props, restProps = _object_without_properties(props, [
        "open",
        "duration",
        "closeable",
        "lock"
    ]);
    const { open, duration: ctxDuration, onClose } = (0, import_react43.useContext)(popup_context_default);
    return React28.createElement(Backdrop, _object_spread({
        open: openProp && open,
        lock,
        duration: duration !== null && duration !== void 0 ? duration : ctxDuration,
        closeable,
        onClose
    }, restProps));
}
PopupBackdrop.displayName = "PopupBackdrop";
function usePopupBackdrop(backdrop = React28.createElement(PopupBackdrop, null), options) {
    return (0, import_react43.useMemo)(()=>{
        if ((0, import_isUndefined6.default)(options) || (0, import_isNull2.default)(options)) {
            return backdrop;
        }
        if ((0, import_isBoolean3.default)(options) && options) {
            return (0, import_react43.cloneElement)(backdrop, {
                open: true
            });
        }
        if ((0, import_isBoolean3.default)(options) && !options) {
            return (0, import_react43.cloneElement)(backdrop, {
                open: false
            });
        }
        return (0, import_react43.cloneElement)(backdrop, _object_spread_props(_object_spread({}, options), {
            open: true
        }));
    }, [
        backdrop,
        options
    ]);
}
// node_modules/@taroify/core/popup/popup-close.js
var import_classnames18 = __toESM(require_classnames());
var React29 = __toESM(require_react());
var import_react44 = __toESM(require_react());
function usePopupClosePlacement(placement) {
    const { placement: ctxPlacement } = (0, import_react44.useContext)(popup_context_default);
    if (placement) {
        return placement;
    }
    if (ctxPlacement === "right") {
        return "top-left";
    }
    return "top-right";
}
function PopupClose(props) {
    const { children: children2 = React29.createElement(Cross_default, null) } = props;
    const { onClose } = (0, import_react44.useContext)(popup_context_default);
    const placement = usePopupClosePlacement(props.placement);
    if (React29.isValidElement(children2)) {
        const iconElement = children2;
        return React29.cloneElement(iconElement, {
            className: (0, import_classnames18.default)(iconElement.props.classNames, prefixClassname("popup__close-icon"), {
                [prefixClassname("popup__close-icon--top-left")]: placement === "top-left",
                [prefixClassname("popup__close-icon--top-right")]: placement === "top-right",
                [prefixClassname("popup__close-icon--bottom-left")]: placement === "bottom-left" || placement === "bottom-right"
            }),
            onClick: ()=>onClose === null || onClose === void 0 ? void 0 : onClose(false)
        });
    }
    return React29.createElement(React29.Fragment, null, children2);
}
// node_modules/@taroify/core/popup/popup.js
function toTransactionName(placement) {
    if (placement === "top") {
        return TransitionName.SlideDown;
    }
    if (placement === "bottom") {
        return TransitionName.SlideUp;
    }
    if (placement === "right") {
        return TransitionName.SlideRight;
    }
    if (placement === "left") {
        return TransitionName.SlideLeft;
    }
    return TransitionName.Fade;
}
function usePopupChildren(children2) {
    return (0, import_react45.useMemo)(()=>{
        const __children__ = {
            backdrop: void 0,
            close: void 0,
            content: []
        };
        import_react45.Children.forEach(children2, (child)=>{
            if ((0, import_react45.isValidElement)(child)) {
                const element = child;
                if (isElementOf(element, Backdrop)) {
                    __children__.backdrop = element;
                } else if (element.type === PopupClose) {
                    __children__.close = element;
                } else {
                    __children__.content.push(child);
                }
            } else {
                __children__.content.push(child);
            }
        });
        return __children__;
    }, [
        children2
    ]);
}
var Popup = (0, import_react45.forwardRef)((props, ref)=>{
    const { className, style: styleProp, defaultOpen, open: openProp, placement, rounded = false, lock = true, children: children2, duration, transaction, transactionTimeout: transactionTimeout2, transitionAppear = true, mountOnEnter = true, onClose, onTransitionEnter, onTransitionEntered, onTransitionExit, onTransitionExited } = props, restProps = _object_without_properties(props, [
        "className",
        "style",
        "defaultOpen",
        "open",
        "placement",
        "rounded",
        "lock",
        "children",
        "duration",
        "transaction",
        "transactionTimeout",
        "transitionAppear",
        "mountOnEnter",
        "onClose",
        "onTransitionEnter",
        "onTransitionEntered",
        "onTransitionExit",
        "onTransitionExited"
    ]);
    const { value: open } = useUncontrolled({
        defaultValue: defaultOpen,
        value: openProp
    });
    const onClosePropRef = useToRef(onClose);
    const initializedRef = useToRef(open);
    useLockScrollTaro(!!open && lock);
    (0, import_react45.useEffect)(()=>{
        if (initializedRef.current) {
            var _onClosePropRef_current;
            if (open === false) (_onClosePropRef_current = onClosePropRef.current) === null || _onClosePropRef_current === void 0 ? void 0 : _onClosePropRef_current.call(onClosePropRef, false);
        } else {
            initializedRef.current = true;
        }
    }, [
        open
    ]);
    const transactionName = transaction !== null && transaction !== void 0 ? transaction : toTransactionName(placement);
    const { backdrop = React30.createElement(PopupBackdrop, {
        lock
    }), close, content } = usePopupChildren(children2);
    const durationStyle = (0, import_react45.useMemo)(()=>(0, import_isNumber6.default)(duration) ? {
            "--animation-duration-base": `${duration}ms`
        } : {}, [
        duration
    ]);
    return React30.createElement(popup_context_default.Provider, {
        value: {
            open,
            duration,
            placement,
            onClose
        }
    }, React30.createElement(Transition2, {
        in: open,
        name: transactionName,
        appear: transitionAppear,
        timeout: transactionTimeout2 || duration,
        mountOnEnter,
        onEnter: onTransitionEnter,
        onEntered: onTransitionEntered,
        onExit: onTransitionExit,
        onExited: onTransitionExited
    }, React30.createElement(View, _object_spread({
        className: (0, import_classnames19.default)(prefixClassname("popup"), {
            [prefixClassname("popup--rounded")]: rounded,
            [prefixClassname("popup--center")]: placement === "center" || (0, import_isUndefined7.default)(placement),
            [prefixClassname("popup--top")]: placement === "top",
            [prefixClassname("popup--right")]: placement === "right",
            [prefixClassname("popup--bottom")]: placement === "bottom",
            [prefixClassname("popup--left")]: placement === "left"
        }, className),
        style: _object_spread({}, durationStyle, styleProp),
        catchMove: lock
    }, restProps), close, content)), backdrop);
});
var popup_default = Popup;
// node_modules/@taroify/core/popup/index.js
var Popup2 = popup_default;
Popup2.Backdrop = PopupBackdrop;
Popup2.Close = PopupClose;
var popup_default2 = Popup2;
// node_modules/@taroify/core/space/space.js
var import_classnames20 = __toESM(require_classnames());
var import_react46 = __toESM(require_react());
var React31 = __toESM(require_react());
var import_react47 = __toESM(require_react());
function normalizeSize(size) {
    if (Array.isArray(size)) {
        return [
            "",
            pxTransform(size[0]),
            pxTransform(size[1])
        ];
    } else if (typeof size === "number") {
        return [
            "",
            pxTransform(size),
            pxTransform(size)
        ];
    } else if ([
        "mini",
        "small",
        "medium",
        "large"
    ].includes(size)) {
        return [
            size
        ];
    } else {
        return [
            "small"
        ];
    }
}
function Space(props) {
    const { className, size: _size17 = "small", justify, align, direction = "horizontal", wrap = "wrap", fill, children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "size",
        "justify",
        "align",
        "direction",
        "wrap",
        "fill",
        "children"
    ]);
    const [size, gapX, gapY] = (0, import_react46.useMemo)(()=>normalizeSize(_size17), [
        _size17
    ]);
    return React31.createElement(flex_default2, _object_spread({
        className: (0, import_classnames20.default)(prefixClassname("space"), {
            [prefixClassname("space--horizontal")]: direction === "horizontal",
            [prefixClassname("space--vertical")]: direction === "vertical",
            [prefixClassname("space--mini")]: size === "mini",
            [prefixClassname("space--small")]: size === "small",
            [prefixClassname("space--medium")]: size === "medium",
            [prefixClassname("space--large")]: size === "large"
        }, className),
        direction: direction === "horizontal" ? "row" : direction === "vertical" ? "column" : void 0,
        justify,
        align,
        wrap
    }, restProps), import_react47.Children.map(children2, (item, index)=>React31.createElement(flex_default2.Item, {
            key: index,
            style: {
                marginRight: gapX,
                marginBottom: gapY
            },
            className: (0, import_classnames20.default)(prefixClassname("space__item"), {
                [prefixClassname("space__item--mini")]: size === "mini",
                [prefixClassname("space__item--small")]: size === "small",
                [prefixClassname("space__item--medium")]: size === "medium",
                [prefixClassname("space__item--large")]: size === "large",
                [prefixClassname("space__item--fill")]: fill
            }),
            children: item
        })));
}
// node_modules/@taroify/core/space/index.js
var space_default = Space;
// node_modules/@taroify/core/toast/toast.js
var import_classnames21 = __toESM(require_classnames());
var React32 = __toESM(require_react());
var import_react49 = __toESM(require_react());
// node_modules/@taroify/core/utils/state.js
var import_isEqual4 = __toESM(require_isEqual());
var import_react48 = __toESM(require_react());
function usePreviousRef(value) {
    const previousRef = (0, import_react48.useRef)(value);
    (0, import_react48.useEffect)(()=>{
        previousRef.current = value;
    });
    return previousRef;
}
function useRendered(cb) {
    return cb === null || cb === void 0 ? void 0 : cb();
}
function useRenderedRef(cb) {
    const stateRef = (0, import_react48.useRef)();
    if (cb) {
        stateRef.current = cb();
    }
    return stateRef;
}
function useRefs() {
    const refs = (0, import_react48.useRef)([]);
    const setRefs = (0, import_react48.useCallback)((index)=>(el)=>{
            if (!refs.current[index]) {
                refs.current[index] = (0, import_react48.createRef)();
            }
            refs.current[index].current = el;
        }, []);
    const getRef = (0, import_react48.useCallback)((index)=>refs.current[index], []);
    const getRefs = (0, import_react48.useCallback)(()=>refs.current, []);
    const clearRefs = (0, import_react48.useCallback)(()=>refs.current = [], []);
    return (0, import_react48.useMemo)(()=>({
            refs,
            getRef,
            getRefs,
            setRefs,
            clearRefs
        }), [
        clearRefs,
        getRef,
        getRefs,
        setRefs
    ]);
}
function useObject(state) {
    const forceUpdate = use_force_update_default();
    const stateRef = (0, import_react48.useRef)(state);
    const currentRef = (0, import_react48.useRef)();
    const previousRef = (0, import_react48.useRef)();
    if (!(0, import_isEqual4.default)(currentRef.current, state)) {
        previousRef.current = currentRef.current;
        currentRef.current = state;
        stateRef.current = state;
    }
    const setObject = (0, import_react48.useCallback)((newState)=>{
        stateRef.current = _object_spread({}, stateRef.current, newState);
        forceUpdate();
    }, []);
    const getObject = (0, import_react48.useCallback)(()=>stateRef.current, []);
    return (0, import_react48.useMemo)(()=>({
            object: stateRef.current,
            getObject,
            setObject
        }), [
        stateRef.current,
        getObject,
        setObject
    ]);
}
// node_modules/@taroify/core/toast/toast.shared.js
var toastEvents = new Events();
var toastSelectorSet = /* @__PURE__ */ new Set();
// node_modules/@taroify/core/toast/toast.js
var TOAST_PRESET_TYPES = [
    "text",
    "loading",
    "success",
    "fail",
    "html"
];
var TOAST_PRESET_POSITIONS = [
    "top",
    "middle",
    "bottom"
];
function useToastOpen(cb) {
    (0, import_react49.useEffect)(()=>{
        toastEvents.on("open", cb);
        return ()=>{
            toastEvents.off("open", cb);
        };
    }, []);
}
function useToastClose(cb) {
    (0, import_react49.useEffect)(()=>{
        toastEvents.on("close", cb);
        return ()=>{
            toastEvents.off("close", cb);
        };
    }, []);
}
function defaultToastIcon(icon, type) {
    if (icon) {
        return icon;
    }
    if (type === "success") {
        return React32.createElement(Success_default, null);
    }
    if (type === "loading") {
        return React32.createElement(Loading, {
            className: prefixClassname("toast__loading")
        });
    }
    if (type === "fail") {
        return React32.createElement(Fail_default, null);
    }
    return void 0;
}
function useToastIcon(node, type) {
    return (0, import_react49.useMemo)(()=>{
        const icon = defaultToastIcon(node, type);
        if (!(0, import_react49.isValidElement)(icon)) {
            return icon;
        }
        const element = icon;
        return (0, import_react49.cloneElement)(icon, {
            className: (0, import_classnames21.default)(prefixClassname("toast__icon"), element.props.className)
        });
    }, [
        node,
        type
    ]);
}
function useToastChildren(children2) {
    return (0, import_react49.useMemo)(()=>{
        const __children__ = {
            content: []
        };
        import_react49.Children.forEach(children2, (child)=>{
            if ((0, import_react49.isValidElement)(child)) {
                const element = child;
                if (isElementOf(element, Backdrop)) {
                    __children__.backdrop = element;
                } else {
                    var __children___content;
                    (__children___content = __children__.content) === null || __children___content === void 0 ? void 0 : __children___content.push(child);
                }
            } else {
                var __children___content1;
                (__children___content1 = __children__.content) === null || __children___content1 === void 0 ? void 0 : __children___content1.push(child);
            }
        });
        if (!__children__.backdrop) {
            __children__.backdrop = React32.createElement(popup_default2.Backdrop, {
                open: false
            });
        }
        return __children__;
    }, [
        children2
    ]);
}
function Toast(props) {
    const _useObject = useObject(props), { object: { id, className, defaultOpen, open: openProp, icon: iconProp, type = "text", position = "middle", duration = 3e3, children: childrenProp, backdrop: backdropOptions, onClose }, setObject } = _useObject, restProps = _object_without_properties(_useObject.object, [
        "id",
        "className",
        "defaultOpen",
        "open",
        "icon",
        "type",
        "position",
        "duration",
        "children",
        "backdrop",
        "onClose"
    ]);
    const rootSelectorRef = useToRef(usePrependPageSelector(getElementSelector(id)));
    const { value: open = false, setValue: setOpen } = useUncontrolled({
        defaultValue: defaultOpen,
        value: openProp,
        onChange: (aOpened)=>!aOpened && (onClose === null || onClose === void 0 ? void 0 : onClose(aOpened))
    });
    const { backdrop: backdropElement, content } = useToastChildren(childrenProp);
    const backdrop = usePopupBackdrop(backdropElement, backdropOptions);
    const icon = useToastIcon(iconProp, type);
    const { stop: stopAutoClose, restart: restartAutoClose } = use_timeout_default();
    (0, import_react49.useEffect)(()=>{
        rootSelectorRef.current && toastSelectorSet.add(rootSelectorRef.current);
        return ()=>{
            rootSelectorRef.current && toastSelectorSet.delete(rootSelectorRef.current);
        };
    }, []);
    (0, import_react49.useEffect)(()=>{
        if (open) {
            if (duration) {
                restartAutoClose(()=>{
                    setOpen(false);
                    stopAutoClose();
                }, duration);
            }
        } else {
            stopAutoClose();
        }
        return ()=>stopAutoClose();
    }, [
        duration,
        open,
        restartAutoClose,
        setObject,
        setOpen,
        stopAutoClose
    ]);
    useToastOpen((_param)=>{
        var { selector, message } = _param, restOptions = _object_without_properties(_param, [
            "selector",
            "message"
        ]);
        if (matchSelector(prependPageSelector(selector), rootSelectorRef.current)) {
            restartAutoClose();
            setObject(_object_spread({
                children: message
            }, restOptions));
            setOpen(true);
        }
    });
    useToastClose((selector)=>{
        if (matchSelector(prependPageSelector(selector), rootSelectorRef.current)) {
            setOpen(false);
        }
    });
    return React32.createElement(popup_default2, _object_spread({
        open,
        id,
        className: (0, import_classnames21.default)(prefixClassname("toast"), {
            [prefixClassname(`toast--${position}`)]: TOAST_PRESET_POSITIONS.includes(position),
            [prefixClassname(`toast--${type}`)]: !icon && TOAST_PRESET_TYPES.includes(type)
        }, className)
    }, restProps), backdrop, icon, icon ? React32.createElement(View, {
        className: prefixClassname("toast__message"),
        children: content
    }) : content);
}
// node_modules/@taroify/core/toast/toast.imperative.js
var import_assign = __toESM(require_assign());
var import_isPlainObject2 = __toESM(require_isPlainObject());
var import_react51 = __toESM(require_react());
// node_modules/@tarojs/react/dist/react.esm.js
var import_react_reconciler = __toESM(require_react_reconciler());
var import_constants = __toESM(require_constants());
var randomKey = Math.random().toString(36).slice(2);
var internalPropsKey = "__reactProps$" + randomKey;
var internalInstanceKey = "__reactFiber$" + randomKey;
var internalContainerInstanceKey = "__reactContainer$" + randomKey;
var HostRoot = 3;
var HostComponent = 5;
var HostText = 6;
var SuspenseComponent = 13;
function precacheFiberNode(hostInst, node) {
    node[internalInstanceKey] = hostInst;
}
function getInstanceFromNode(node) {
    const inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
    if (inst) {
        if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
            return inst;
        } else {
            return null;
        }
    }
    return null;
}
function getFiberCurrentPropsFromNode(node) {
    return node[internalPropsKey] || null;
}
function updateFiberProps(node, props) {
    node[internalPropsKey] = props;
}
function updateInputWrapper(element, oldValue, props) {
    const node = element;
    const checked = props.checked;
    if (checked != null) {
        console.warn("updateCheck \u672A\u5B9E\u73B0", node);
        return;
    }
    updateWrapper(element, oldValue, props);
    updateNamedCousins(element, props);
}
function updateNamedCousins(rootNode, props) {
    const name = props.name;
    if (props.type === "radio" && name != null) {
        console.warn("radio updateNamedCousins \u672A\u5B9E\u73B0", rootNode, props);
    }
}
function getToStringValue(value) {
    const isEmptyType = typeof value === "function" || typeof value === "symbol";
    return isEmptyType ? "" : value;
}
function toString(value) {
    return "" + value;
}
function updateWrapper(element, oldValue, props) {
    const node = element;
    const value = getToStringValue(props.value);
    const type = props.type;
    setNodeValue(node, oldValue, value, type);
}
function setNodeValue(node, oldValue, value, type = "string") {
    if (value != null) {
        if (type === "number") {
            if (value === 0 && node.value === "" || // We explicitly want to coerce to number here if possible.
            // eslint-disable-next-line
            oldValue != value) {
                node.value = toString(value);
            }
        } else if (oldValue !== toString(value)) {
            node.value = toString(value);
        }
    } else if (type === "submit" || type === "reset") {
        node.removeAttribute("value");
    }
}
var ReactDOMTextareaRestoreControlledState = updateWrapper;
var ReactDOMInputRestoreControlledState = updateInputWrapper;
function isCheckable(elem) {
    const type = elem.type;
    const nodeName = elem.nodeName;
    return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
}
function getTracker(node) {
    return node._valueTracker;
}
function detachTracker(node) {
    node._valueTracker = null;
}
function trackValueOnNode(node) {
    const valueField = isCheckable(node) ? "checked" : "value";
    const descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
    let currentValue = "" + node[valueField];
    if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
        return;
    }
    const { get, set } = descriptor;
    Object.defineProperty(node, valueField, {
        configurable: true,
        enumerable: descriptor.enumerable,
        get: function() {
            return get.call(this);
        },
        set: function(value) {
            currentValue = "" + value;
            set.call(this, value);
        }
    });
    const tracker = {
        getValue () {
            return currentValue;
        },
        setValue (value) {
            currentValue = "" + value;
        },
        stopTracking () {
            detachTracker(node);
            delete node[valueField];
        }
    };
    return tracker;
}
function track(node) {
    if (getTracker(node)) {
        return;
    }
    node._valueTracker = trackValueOnNode(node);
}
function isEventName(s) {
    return s[0] === "o" && s[1] === "n";
}
var IS_NON_DIMENSIONAL = /aspect|acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function updateProps(dom, oldProps, newProps) {
    const updatePayload = getUpdatePayload(dom, oldProps, newProps);
    if (updatePayload) {
        updatePropsByPayload(dom, oldProps, updatePayload);
    }
}
function updatePropsByPayload(dom, oldProps, updatePayload) {
    for(let i = 0; i < updatePayload.length; i += 2){
        const key = updatePayload[i];
        const newProp = updatePayload[i + 1];
        const oldProp = oldProps[key];
        setProperty(dom, key, newProp, oldProp);
    }
}
function getUpdatePayload(dom, oldProps, newProps) {
    let i;
    let updatePayload = null;
    for(i in oldProps){
        if (!(i in newProps)) {
            (updatePayload = updatePayload || []).push(i, null);
        }
    }
    const isFormElement = dom instanceof FormElement;
    for(i in newProps){
        if (oldProps[i] !== newProps[i] || isFormElement && i === "value") {
            (updatePayload = updatePayload || []).push(i, newProps[i]);
        }
    }
    return updatePayload;
}
function setEvent(dom, name, value, oldValue) {
    const isCapture = name.endsWith("Capture");
    let eventName = name.toLowerCase().slice(2);
    if (isCapture) {
        eventName = eventName.slice(0, -7);
    }
    const compName = capitalize(toCamelCase(dom.tagName.toLowerCase()));
    if (eventName === "click" && compName in internalComponents) {
        eventName = "tap";
    }
    if (isFunction(value)) {
        if (oldValue) {
            dom.removeEventListener(eventName, oldValue, false);
            dom.addEventListener(eventName, value, {
                isCapture,
                sideEffect: false
            });
        } else {
            dom.addEventListener(eventName, value, isCapture);
        }
    } else {
        dom.removeEventListener(eventName, oldValue);
    }
}
function setStyle(style, key, value) {
    if (key[0] === "-") {
        style.setProperty(key, value.toString());
        return;
    }
    style[key] = isNumber(value) && IS_NON_DIMENSIONAL.test(key) === false ? value + "px" : value == null ? "" : value;
}
function setProperty(dom, name, value, oldValue) {
    var _a, _b;
    name = name === "className" ? "class" : name;
    if (name === "key" || name === "children" || name === "ref") ;
    else if (name === "style") {
        const style = dom.style;
        if (isString(value)) {
            style.cssText = value;
        } else {
            if (isString(oldValue)) {
                style.cssText = "";
                oldValue = null;
            }
            if (isObject(oldValue)) {
                for(const i in oldValue){
                    if (!(value && i in value)) {
                        setStyle(style, i, "");
                    }
                }
            }
            if (isObject(value)) {
                for(const i in value){
                    if (!oldValue || value[i] !== oldValue[i]) {
                        setStyle(style, i, value[i]);
                    }
                }
            }
        }
    } else if (isEventName(name)) {
        setEvent(dom, name, value, oldValue);
    } else if (name === "dangerouslySetInnerHTML") {
        const newHtml = (_a = value === null || value === void 0 ? void 0 : value.__html) !== null && _a !== void 0 ? _a : "";
        const oldHtml = (_b = oldValue === null || oldValue === void 0 ? void 0 : oldValue.__html) !== null && _b !== void 0 ? _b : "";
        if (newHtml || oldHtml) {
            if (oldHtml !== newHtml) {
                dom.innerHTML = newHtml;
            }
        }
    } else if (!isFunction(value)) {
        if (value == null) {
            dom.removeAttribute(name);
        } else {
            dom.setAttribute(name, value);
        }
    }
}
var hostConfig = {
    // below keys order by {React ReactFiberHostConfig.custom.js}, convenient for comparing each other.
    // -------------------
    // required by @types/react-reconciler
    // -------------------
    getPublicInstance (inst) {
        return inst;
    },
    getRootHostContext () {
        return {};
    },
    getChildHostContext (parentHostContext) {
        return parentHostContext;
    },
    prepareForCommit (..._) {
        return null;
    },
    resetAfterCommit: noop,
    createInstance (type, props, _rootContainerInstance, _hostContext, internalInstanceHandle) {
        const element = document$1.createElement(type);
        precacheFiberNode(internalInstanceHandle, element);
        updateFiberProps(element, props);
        return element;
    },
    appendInitialChild (parent, child) {
        parent.appendChild(child);
    },
    finalizeInitialChildren (dom, type, props) {
        let newProps = props;
        if (dom instanceof FormElement) {
            const [defaultName, defaultKey] = [
                "switch",
                "checkbox",
                "radio"
            ].includes(type) ? [
                "checked",
                "defaultChecked"
            ] : [
                "value",
                "defaultValue"
            ];
            if (props.hasOwnProperty(defaultKey)) {
                newProps = Object.assign(Object.assign({}, newProps), {
                    [defaultName]: props[defaultKey]
                });
                delete newProps[defaultKey];
            }
        }
        updateProps(dom, {}, newProps);
        if (type === "input" || type === "textarea") {
            track(dom);
        }
        return false;
    },
    prepareUpdate (instance, _, oldProps, newProps) {
        return getUpdatePayload(instance, oldProps, newProps);
    },
    shouldSetTextContent () {
        return false;
    },
    createTextInstance (text, _rootContainerInstance, _hostContext, internalInstanceHandle) {
        const textNode = document$1.createTextNode(text);
        precacheFiberNode(internalInstanceHandle, textNode);
        return textNode;
    },
    scheduleTimeout: setTimeout,
    cancelTimeout: clearTimeout,
    noTimeout: -1,
    isPrimaryRenderer: true,
    warnsIfNotActing: true,
    supportsMutation: true,
    supportsPersistence: false,
    supportsHydration: false,
    getInstanceFromNode: ()=>null,
    beforeActiveInstanceBlur: noop,
    afterActiveInstanceBlur: noop,
    preparePortalMount: noop,
    prepareScopeUpdate: noop,
    getInstanceFromScope: ()=>null,
    getCurrentEventPriority () {
        return import_constants.DefaultEventPriority;
    },
    detachDeletedInstance: noop,
    // -------------------
    //      Microtasks
    //     (optional)
    // -------------------
    supportsMicrotasks: true,
    scheduleMicrotask: isUndefined(Promise) ? setTimeout : (callback)=>Promise.resolve(null).then(callback).catch(function(error) {
            setTimeout(()=>{
                throw error;
            });
        }),
    // -------------------
    //      Mutation
    //     (required if supportsMutation is true)
    // -------------------
    appendChild (parent, child) {
        parent.appendChild(child);
    },
    appendChildToContainer (parent, child) {
        parent.appendChild(child);
    },
    commitTextUpdate (textInst, _, newText) {
        textInst.nodeValue = newText;
    },
    commitMount: noop,
    commitUpdate (dom, updatePayload, _, oldProps, newProps) {
        updatePropsByPayload(dom, oldProps, updatePayload);
        updateFiberProps(dom, newProps);
    },
    insertBefore (parent, child, refChild) {
        parent.insertBefore(child, refChild);
    },
    insertInContainerBefore (parent, child, refChild) {
        parent.insertBefore(child, refChild);
    },
    removeChild (parent, child) {
        parent.removeChild(child);
    },
    removeChildFromContainer (parent, child) {
        parent.removeChild(child);
    },
    resetTextContent: noop,
    hideInstance (instance) {
        const style = instance.style;
        style.setProperty("display", "none");
    },
    hideTextInstance (textInstance) {
        textInstance.nodeValue = "";
    },
    unhideInstance (instance, props) {
        const styleProp = props.style;
        let display = (styleProp === null || styleProp === void 0 ? void 0 : styleProp.hasOwnProperty("display")) ? styleProp.display : null;
        display = display == null || isBoolean(display) || display === "" ? "" : ("" + display).trim();
        instance.style["display"] = display;
    },
    unhideTextInstance (textInstance, text) {
        textInstance.nodeValue = text;
    },
    clearContainer (element) {
        if (element.childNodes.length > 0) {
            element.textContent = "";
        }
    }
};
var TaroReconciler = (0, import_react_reconciler.default)(hostConfig);
if (true) {
    const foundDevTools = TaroReconciler.injectIntoDevTools({
        bundleType: 1,
        version: "18.0.0",
        rendererPackageName: "taro-react"
    });
    if (!foundDevTools) {
        console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools", "font-weight:bold");
    }
}
var restoreQueue = null;
function needsStateRestore() {
    return restoreQueue !== null;
}
function finishEventHandler() {
    const controlledComponentsHavePendingUpdates = needsStateRestore();
    if (controlledComponentsHavePendingUpdates) {
        TaroReconciler.flushSync();
        restoreStateIfNeeded();
    }
}
function restoreStateIfNeeded() {
    if (!restoreQueue) {
        return;
    }
    const queuedTargets = restoreQueue;
    restoreQueue = null;
    for(let i = 0; i < queuedTargets.length; i++){
        restoreStateOfTarget(queuedTargets[i]);
    }
}
function restoreImpl(domElement, tag, oldValue, props) {
    switch(tag){
        case "input":
            ReactDOMInputRestoreControlledState(domElement, oldValue, props);
            break;
        case "textarea":
            ReactDOMTextareaRestoreControlledState(domElement, oldValue, props);
            break;
    }
}
function restoreStateOfTarget(item) {
    const internalInstance = getInstanceFromNode(item.target);
    if (!internalInstance) return;
    const { stateNode, type } = internalInstance;
    if (stateNode) {
        const props = getFiberCurrentPropsFromNode(stateNode);
        restoreImpl(stateNode, type, item.value, props);
    }
}
var ContainerMap = /* @__PURE__ */ new WeakMap();
var Root = class {
    initInternalRoot(renderer, domContainer, options) {
        const containerInfo = domContainer;
        if (options) {
            const tag = 1;
            const concurrentUpdatesByDefaultOverride = false;
            let isStrictMode = false;
            let identifierPrefix = "";
            let onRecoverableError = (error)=>console.error(error);
            let transitionCallbacks = null;
            if (options.unstable_strictMode === true) {
                isStrictMode = true;
            }
            if (options.identifierPrefix !== void 0) {
                identifierPrefix = options.identifierPrefix;
            }
            if (options.onRecoverableError !== void 0) {
                onRecoverableError = options.onRecoverableError;
            }
            if (options.unstable_transitionCallbacks !== void 0) {
                transitionCallbacks = options.unstable_transitionCallbacks;
            }
            this.internalRoot = renderer.createContainer(containerInfo, tag, null, // hydrationCallbacks
            isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks);
        } else {
            const tag = 0;
            this.internalRoot = renderer.createContainer(containerInfo, tag, null, // hydrationCallbacks
            false, // isStrictMode
            false, // concurrentUpdatesByDefaultOverride,
            "", // identifierPrefix
            ()=>{}, // onRecoverableError, this isn't reachable because onRecoverableError isn't called in the legacy API.
            null);
        }
    }
    render(children2, cb) {
        const { renderer, internalRoot } = this;
        renderer.updateContainer(children2, internalRoot, null, cb);
        return renderer.getPublicRootInstance(internalRoot);
    }
    unmount(cb) {
        this.renderer.updateContainer(null, this.internalRoot, null, cb);
    }
    constructor(renderer, domContainer, options){
        this.renderer = renderer;
        this.initInternalRoot(renderer, domContainer, options);
    }
};
function render(element, domContainer, cb) {
    const oldRoot = ContainerMap.get(domContainer);
    if (oldRoot != null) {
        return oldRoot.render(element, cb);
    }
    const root = new Root(TaroReconciler, domContainer);
    ContainerMap.set(domContainer, root);
    return root.render(element, cb);
}
var isInsideEventHandler = false;
var unstable_batchedUpdates = (fn, a)=>{
    if (isInsideEventHandler) {
        return fn(a);
    }
    isInsideEventHandler = true;
    try {
        return TaroReconciler.batchedUpdates(fn, a);
    } finally{
        isInsideEventHandler = false;
        finishEventHandler();
    }
};
function unmountComponentAtNode(dom) {
    ensure(dom && [
        1,
        8,
        9,
        11
    ].includes(dom.nodeType), "unmountComponentAtNode(...): Target container is not a DOM element.");
    const root = ContainerMap.get(dom);
    if (!root) return false;
    unstable_batchedUpdates(()=>{
        root.unmount(()=>{
            ContainerMap.delete(dom);
        });
    }, null);
    return true;
}
var portalType = isFunction(Symbol) && Symbol.for ? Symbol.for("react.portal") : 60106;
// node_modules/@taroify/core/utils/dom/portal.js
function getPagePath() {
    const currentPages = getCurrentPages();
    const currentPage = currentPages[currentPages.length - 1];
    const path = currentPage.$taroPath;
    return path;
}
var portalViewMap = /* @__PURE__ */ new Map();
function mountPortal(children2, dom) {
    const view = dom || document$1.createElement("view");
    const path = getPagePath();
    const pageElement = document$1.getElementById(path);
    if (pageElement) {
        var _portalViewMap_get;
        if (!portalViewMap.has(path)) {
            const portalView = document$1.createElement("view");
            pageElement.appendChild(portalView);
            portalViewMap.set(path, portalView);
        }
        render(children2, view);
        (_portalViewMap_get = portalViewMap.get(path)) === null || _portalViewMap_get === void 0 ? void 0 : _portalViewMap_get.appendChild(view);
    } else {
        console.error("[Taroify] cannot find page element");
    }
    return view;
}
function unmountPortal(dom) {
    const path = getPagePath();
    const pageElement = document$1.getElementById(path);
    unmountComponentAtNode(dom);
    if (pageElement) {
        var _dom_parentElement;
        (_dom_parentElement = dom.parentElement) === null || _dom_parentElement === void 0 ? void 0 : _dom_parentElement.removeChild(dom);
    } else {
        console.error("[Taroify] cannot find page element");
    }
}
// node_modules/@taroify/core/toast/toast.imperative.js
var _isMultipleAllowed = false;
var initialToastOptions = {
    className: void 0,
    style: void 0,
    backdrop: void 0,
    type: void 0,
    position: void 0,
    icon: void 0,
    duration: void 0,
    message: void 0
};
var DEFAULT_TOAST_SELECTOR = "#toast";
var DEFAULT_TOAST_SELECTOR_CREATE = "toast";
var defaultToastOptions = {};
resetDefaultToastOptions();
function setDefaultToastOptions(options) {
    (0, import_assign.default)(defaultToastOptions, options);
}
function resetDefaultToastOptions() {
    (0, import_assign.default)(defaultToastOptions, {
        selector: DEFAULT_TOAST_SELECTOR
    });
}
function parseToastOptions(message) {
    const options = !(0, import_react51.isValidElement)(message) && (0, import_isPlainObject2.default)(message) ? message : {
        message
    };
    return (0, import_assign.default)({}, initialToastOptions, defaultToastOptions, options);
}
function allowMultiple(allow) {
    _isMultipleAllowed = allow;
}
function openToast(args) {
    const _parseToastOptions = parseToastOptions(args), { selector } = _parseToastOptions, restOptions = _object_without_properties(_parseToastOptions, [
        "selector"
    ]);
    const hasExistingToast = selector && toastSelectorSet.has(`${getPagePath()}__${selector}`);
    if (_isMultipleAllowed && !hasExistingToast || !_isMultipleAllowed && !hasExistingToast) {
        const toastView = document$1.createElement("view");
        const onTransitionExited = restOptions.onTransitionExited;
        restOptions.onTransitionExited = ()=>{
            onTransitionExited === null || onTransitionExited === void 0 ? void 0 : onTransitionExited();
            unmountPortal(toastView);
        };
        const selectorId = selector === DEFAULT_TOAST_SELECTOR ? DEFAULT_TOAST_SELECTOR_CREATE : selector;
        const uniqueId = _isMultipleAllowed ? `${selectorId}-${Date.now()}` : selectorId;
        mountPortal((0, import_react51.createElement)(Toast, _object_spread_props(_object_spread({}, restOptions), {
            children: restOptions.message,
            defaultOpen: true,
            id: uniqueId
        })), toastView);
        return uniqueId;
    }
    toastEvents.trigger("open", _object_spread({
        selector
    }, restOptions));
    return selector;
}
function createToast(type) {
    return (args)=>{
        const options = parseToastOptions(args);
        options.type = type;
        return openToast(options);
    };
}
function closeToast(selector) {
    if (selector) {
        const selectorWithPrefix = selector.startsWith("#") ? selector : `#${selector}`;
        toastEvents.trigger("close", selectorWithPrefix);
    } else {
        toastEvents.trigger("close", defaultToastOptions.selector);
    }
}
// node_modules/@taroify/core/toast/index.js
var Toast2 = Toast;
Toast2.Backdrop = popup_default2.Backdrop;
Toast2.open = openToast;
Toast2.loading = createToast("loading");
Toast2.success = createToast("success");
Toast2.fail = createToast("fail");
Toast2.close = closeToast;
Toast2.setDefaultOptions = setDefaultToastOptions;
Toast2.resetDefaultOptions = resetDefaultToastOptions;
Toast2.allowMultiple = allowMultiple;
var toast_default = Toast2;
// node_modules/@taroify/core/white-space/white-space.js
var import_classnames22 = __toESM(require_classnames());
var React33 = __toESM(require_react());
var import_react52 = __toESM(require_react());
var WhiteSpaceSize;
(function(WhiteSpaceSize2) {
    WhiteSpaceSize2["Mini"] = "mini";
    WhiteSpaceSize2["Small"] = "small";
    WhiteSpaceSize2["Medium"] = "medium";
    WhiteSpaceSize2["Large"] = "large";
})(WhiteSpaceSize || (WhiteSpaceSize = {}));
var SIZE_PRESETS = [
    WhiteSpaceSize.Mini,
    WhiteSpaceSize.Small,
    WhiteSpaceSize.Medium,
    WhiteSpaceSize.Large
];
function isPresetSize(size) {
    return SIZE_PRESETS.includes(size);
}
function WhiteSpace(props) {
    const { size = WhiteSpaceSize.Medium } = props;
    const rootStyle = (0, import_react52.useMemo)(()=>({
            height: isPresetSize(size) ? "" : size
        }), [
        size
    ]);
    return React33.createElement(View, {
        className: (0, import_classnames22.default)(prefixClassname("white-space"), {
            [prefixClassname(`white-space-size-${size}`)]: isPresetSize(size)
        }),
        style: rootStyle
    });
}
// node_modules/@taroify/core/white-space/index.js
var white_space_default = WhiteSpace;
// node_modules/@taroify/core/safe-area/safe-area.js
var import_classnames23 = __toESM(require_classnames());
var React34 = __toESM(require_react());
var import_react53 = __toESM(require_react());
function SafeArea(props) {
    const { className, position, nativeSafeTop, style } = props, restProps = _object_without_properties(props, [
        "className",
        "position",
        "nativeSafeTop",
        "style"
    ]);
    const { statusBarHeight } = getWindowInfo();
    const customStyle = (0, import_react53.useMemo)(()=>{
        if (position === "top" && nativeSafeTop) {
            return {
                paddingTop: `${statusBarHeight || 0}px`
            };
        }
        return {};
    }, [
        position,
        nativeSafeTop,
        statusBarHeight
    ]);
    return React34.createElement(View, _object_spread({
        className: (0, import_classnames23.default)(prefixClassname("safe-area"), {
            [prefixClassname("safe-area--top")]: position === "top",
            [prefixClassname("safe-area--bottom")]: position === "bottom"
        }, className),
        style: _object_spread({}, customStyle, style)
    }, restProps));
}
var safe_area_default = SafeArea;
// node_modules/@taroify/core/fixed-view/fixed-view.js
var import_classnames24 = __toESM(require_classnames());
var import_isString5 = __toESM(require_isString());
var import_isObject2 = __toESM(require_isObject());
var React35 = __toESM(require_react());
var import_react54 = __toESM(require_react());
function useFixedViewPlaceholder(placeholder) {
    if (placeholder === true) {
        return {
            className: prefixClassname("fixed-view__placeholder")
        };
    }
    if ((0, import_isString5.default)(placeholder)) {
        return {
            className: placeholder
        };
    }
    if ((0, import_isObject2.default)(placeholder)) {
        return placeholder;
    }
}
function FixedView(props) {
    const { className, position, safeArea, nativeSafeTop, placeholder: placeholderProp, children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "position",
        "safeArea",
        "nativeSafeTop",
        "placeholder",
        "children"
    ]);
    const rootRef = (0, import_react54.useRef)();
    const placeholder = useFixedViewPlaceholder(placeholderProp);
    const height = useHeight(rootRef);
    if (position !== "top" && position !== "bottom" && position !== true) {
        return children2;
    }
    const content = React35.createElement(View, _object_spread({
        ref: rootRef,
        className: (0, import_classnames24.default)(prefixClassname("fixed-view"), {
            [prefixClassname("fixed-view--top")]: position === "top",
            [prefixClassname("fixed-view--bottom")]: position === "bottom" || position === true
        }, className)
    }, restProps), safeArea === "top" && React35.createElement(safe_area_default, {
        position: "top",
        nativeSafeTop
    }), children2, safeArea === "bottom" && React35.createElement(safe_area_default, {
        position: "bottom"
    }));
    if (placeholder) {
        const { className: placeholderClassName, style: styleProp } = placeholder, restPlaceholder = _object_without_properties(placeholder, [
            "className",
            "style"
        ]);
        const style = mergeStyle(styleProp, height ? {
            height: addUnitPx(height)
        } : {});
        return React35.createElement(View, _object_spread({
            className: (0, import_classnames24.default)(prefixClassname("fixed-view__placeholder"), placeholderClassName),
            style,
            children: content
        }, restPlaceholder));
    }
    return content;
}
var fixed_view_default = FixedView;
// node_modules/@taroify/core/picker/picker.js
var import_classnames30 = __toESM(require_classnames());
var import_isArray5 = __toESM(require_isArray());
var import_isEmpty7 = __toESM(require_isEmpty());
var import_isObject3 = __toESM(require_isObject());
var import_map7 = __toESM(require_map());
var React44 = __toESM(require_react());
var import_react64 = __toESM(require_react());
// node_modules/@taroify/core/picker/picker-columns.js
var import_map6 = __toESM(require_map());
var import_filter = __toESM(require_filter());
var import_isUndefined9 = __toESM(require_isUndefined());
var import_set = __toESM(require_set());
var import_size5 = __toESM(require_size());
var React39 = __toESM(require_react());
var import_react61 = __toESM(require_react());
// node_modules/@taroify/core/picker/picker-columns-render.js
var import_classnames27 = __toESM(require_classnames());
var import_map5 = __toESM(require_map());
var import_get4 = __toESM(require_get());
var React38 = __toESM(require_react());
var import_react60 = __toESM(require_react());
// node_modules/@taroify/core/styles/hairline.js
var HAIRLINE_BORDER = prefixClassname("hairline");
var HAIRLINE_BORDER_TOP = `${HAIRLINE_BORDER}--top`;
var HAIRLINE_BORDER_LEFT = `${HAIRLINE_BORDER}--left`;
var HAIRLINE_BORDER_BOTTOM = `${HAIRLINE_BORDER}--bottom`;
var HAIRLINE_BORDER_SURROUND = `${HAIRLINE_BORDER}--surround`;
var HAIRLINE_BORDER_TOP_BOTTOM = `${HAIRLINE_BORDER}--top-bottom`;
var HAIRLINE_BORDER_UNSET_TOP_BOTTOM = `${HAIRLINE_BORDER}-unset--top-bottom`;
// node_modules/@taroify/core/picker/picker-column.js
var import_classnames26 = __toESM(require_classnames());
var import_size4 = __toESM(require_size());
var import_clamp3 = __toESM(require_clamp());
var import_findIndex = __toESM(require_findIndex());
var import_map4 = __toESM(require_map());
var import_omit = __toESM(require_omit());
var React37 = __toESM(require_react());
var import_react58 = __toESM(require_react());
// node_modules/@taroify/core/utils/touch.js
var import_react55 = __toESM(require_react());
var MIN_DISTANCE = 10;
var TouchDirection;
(function(TouchDirection2) {
    TouchDirection2["Horizontal"] = "horizontal";
    TouchDirection2["Vertical"] = "vertical";
})(TouchDirection || (TouchDirection = {}));
function getDirection(x, y) {
    if (x > y && x > MIN_DISTANCE) {
        return TouchDirection.Horizontal;
    }
    if (y > x && y > MIN_DISTANCE) {
        return TouchDirection.Vertical;
    }
}
function emptyFunction() {}
var TAP_OFFSET = 5;
function useTouch() {
    const touchRef = (0, import_react55.useRef)({
        startX: 0,
        startY: 0,
        deltaX: 0,
        deltaY: 0,
        offsetX: 0,
        offsetY: 0,
        isTap: true,
        isVertical: ()=>false,
        isHorizontal: ()=>false,
        start: emptyFunction,
        move: emptyFunction,
        reset: emptyFunction
    });
    const isVertical = (0, import_react55.useCallback)(()=>touchRef.current.direction === TouchDirection.Vertical, []);
    const isHorizontal = (0, import_react55.useCallback)(()=>touchRef.current.direction === TouchDirection.Horizontal, []);
    const reset = (0, import_react55.useCallback)(()=>{
        touchRef.current.deltaX = 0;
        touchRef.current.deltaY = 0;
        touchRef.current.offsetX = 0;
        touchRef.current.offsetY = 0;
        touchRef.current.direction = void 0;
        touchRef.current.isTap = true;
    }, []);
    const start = (0, import_react55.useCallback)((event)=>{
        reset();
        touchRef.current.startX = event.touches[0].clientX;
        touchRef.current.startY = event.touches[0].clientY;
    }, [
        reset
    ]);
    const move = (0, import_react55.useCallback)((event)=>{
        const touch = event.touches[0];
        touchRef.current.deltaX = touch.clientX < 0 ? 0 : touch.clientX - touchRef.current.startX;
        touchRef.current.deltaY = touch.clientY - touchRef.current.startY;
        touchRef.current.offsetX = Math.abs(touchRef.current.deltaX);
        touchRef.current.offsetY = Math.abs(touchRef.current.deltaY);
        if (!touchRef.current.direction) {
            touchRef.current.direction = getDirection(touchRef.current.offsetX, touchRef.current.offsetY);
        }
        if (touchRef.current.isTap && (touchRef.current.offsetX > TAP_OFFSET || touchRef.current.offsetY > TAP_OFFSET)) {
            touchRef.current.isTap = false;
        }
    }, []);
    (0, import_react55.useEffect)(()=>{
        if (touchRef.current.isHorizontal !== isHorizontal) {
            touchRef.current.isHorizontal = isHorizontal;
        }
    }, [
        touchRef,
        isHorizontal
    ]);
    (0, import_react55.useEffect)(()=>{
        if (touchRef.current.isVertical !== isVertical) {
            touchRef.current.isVertical = isVertical;
        }
    }, [
        touchRef,
        isVertical
    ]);
    (0, import_react55.useEffect)(()=>{
        if (touchRef.current.reset !== reset) {
            touchRef.current.reset = reset;
        }
    }, [
        touchRef,
        reset
    ]);
    (0, import_react55.useEffect)(()=>{
        if (touchRef.current.start !== start) {
            touchRef.current.start = start;
        }
    }, [
        touchRef,
        start
    ]);
    (0, import_react55.useEffect)(()=>{
        if (touchRef.current.move !== move) {
            touchRef.current.move = move;
        }
    }, [
        touchRef,
        move
    ]);
    return touchRef.current;
}
// node_modules/@taroify/core/picker/picker-option.js
var import_classnames25 = __toESM(require_classnames());
var React36 = __toESM(require_react());
var import_react57 = __toESM(require_react());
// node_modules/@taroify/core/picker/picker.context.js
var import_react56 = __toESM(require_react());
// node_modules/@taroify/core/picker/picker.shared.js
var import_isNumber7 = __toESM(require_isNumber());
var import_gte = __toESM(require_gte());
var import_isUndefined8 = __toESM(require_isUndefined());
var import_first4 = __toESM(require_first());
var DEFAULT_SIBLING_COUNT = 3;
var DEFAULT_OPTION_HEIGHT = 44;
var DEFAULT_COLUMN_INDEX = 0;
function validPickerColumn(column) {
    const { index } = column;
    return (0, import_isNumber7.default)(index) && (0, import_gte.default)(index, DEFAULT_COLUMN_INDEX) ? column : void 0;
}
function getPickerOptionKey(option) {
    const { key, value, label, children: children2 } = option;
    var _ref;
    const newKey = (_ref = key !== null && key !== void 0 ? key : value) !== null && _ref !== void 0 ? _ref : label;
    if ((0, import_isUndefined8.default)(newKey) && isTextElement(children2)) {
        return children2;
    }
    return newKey;
}
function getPickerValue(values2, multiColumns) {
    return multiColumns ? values2 : (0, import_first4.default)(values2);
}
// node_modules/@taroify/core/picker/picker.context.js
var PickerContext = (0, import_react56.createContext)({
    siblingCount: DEFAULT_SIBLING_COUNT,
    optionHeight: DEFAULT_OPTION_HEIGHT
});
var picker_context_default = PickerContext;
// node_modules/@taroify/core/picker/picker-option.js
function PickerOption(props) {
    const { className, disabled, index, value, label, children: childrenProp } = props, restProps = _object_without_properties(props, [
        "className",
        "disabled",
        "index",
        "value",
        "label",
        "children"
    ]);
    const { optionHeight } = (0, import_react57.useContext)(picker_context_default);
    const children2 = (0, import_react57.useMemo)(()=>{
        if ((0, import_react57.isValidElement)(childrenProp)) {
            return childrenProp;
        }
        if (isTextElement(childrenProp)) {
            return React36.createElement(View, {
                className: prefixClassname("ellipsis")
            }, childrenProp);
        }
        if ((0, import_react57.isValidElement)(label)) {
            return label;
        }
        if (isTextElement(label)) {
            return React36.createElement(View, {
                className: prefixClassname("ellipsis")
            }, label);
        }
    }, [
        childrenProp,
        label
    ]);
    return React36.createElement(View, _object_spread({
        className: (0, import_classnames25.default)(prefixClassname("picker-option"), {
            [prefixClassname("picker-option--disabled")]: disabled
        }, className),
        style: {
            height: `${optionHeight}px`
        },
        children: children2
    }, restProps));
}
// node_modules/@taroify/core/picker/picker-column.js
var MOMENTUM_LIMIT_TIME = 300;
var MOMENTUM_LIMIT_DISTANCE = 15;
var DEFAULT_DURATION = 200;
var PickerColumn = (0, import_react58.forwardRef)((props, ref)=>{
    const { value, className, readonly, visibleCount = DEFAULT_SIBLING_COUNT * 2, optionHeight = DEFAULT_OPTION_HEIGHT, children: childrenProp = [], onChange, onTouchStart, onTouchMove, onTouchEnd, onTouchCancel } = props, restProps = _object_without_properties(props, [
        "value",
        "className",
        "readonly",
        "visibleCount",
        "optionHeight",
        "children",
        "onChange",
        "onTouchStart",
        "onTouchMove",
        "onTouchEnd",
        "onTouchCancel"
    ]);
    const childrenRef = useToRef(childrenProp);
    const wrapperRef = (0, import_react58.useRef)();
    const movingRef = (0, import_react58.useRef)();
    const startOffsetRef = (0, import_react58.useRef)(0);
    const moveOffsetRef = (0, import_react58.useRef)(0);
    const momentumOffsetRef = (0, import_react58.useRef)(0);
    const touchStartTimeRef = (0, import_react58.useRef)(0);
    const currentDurationRef = (0, import_react58.useRef)(0);
    const transitionEndTriggerRef = (0, import_react58.useRef)();
    const touch = useTouch();
    const activeIndexRef = (0, import_react58.useRef)(-1);
    const [activeOffset, setActiveOffset] = (0, import_react58.useState)(0);
    const activeOffsetRef = useToRef(activeOffset);
    const baseOffset = (0, import_react58.useMemo)(()=>optionHeight * (+visibleCount - 1) / 2, [
        visibleCount,
        optionHeight
    ]);
    const countRef = useRenderedRef(()=>(0, import_size4.default)(childrenProp));
    const adjustIndex = (0, import_react58.useCallback)((index)=>{
        const indexCache = (0, import_clamp3.default)(index, 0, countRef.current);
        for(let i = indexCache; i < countRef.current; i++){
            if (!childrenRef.current[i].disabled) return i;
        }
        for(let i = indexCache - 1; i >= 0; i--){
            if (!childrenRef.current[i].disabled) return i;
        }
        return indexCache;
    }, [
        countRef,
        childrenRef
    ]);
    const setIndex = (0, import_react58.useCallback)((index, emitChange)=>{
        const indexCache = adjustIndex(index) || 0;
        const offset = -indexCache * optionHeight;
        const trigger = ()=>{
            if (indexCache !== activeIndexRef.current) {
                activeIndexRef.current = indexCache;
                const option = childrenRef.current[indexCache];
                onChange === null || onChange === void 0 ? void 0 : onChange(option, emitChange);
            }
        };
        if (movingRef.current && offset !== activeOffsetRef.current) {
            transitionEndTriggerRef.current = trigger;
        } else {
            trigger();
        }
        setActiveOffset(offset);
        if (movingRef.current) {
            moveOffsetRef.current = offset;
        }
    }, [
        adjustIndex,
        activeOffsetRef,
        childrenRef,
        onChange,
        optionHeight
    ]);
    const getIndexByValue = (0, import_react58.useCallback)((aValue)=>{
        const index = (0, import_findIndex.default)(childrenRef.current, ({ value: iValue })=>iValue === aValue);
        return index === -1 ? 0 : index;
    }, [
        childrenRef
    ]);
    const childrenChanged = useRendered(()=>JSON.stringify((0, import_map4.default)(childrenProp, ({ value: value2, label })=>({
                value: value2,
                label
            }))));
    (0, import_react58.useEffect)(()=>{
        const valueIndex = getIndexByValue(value);
        if (childrenChanged) {
            activeIndexRef.current = -1;
        }
        if (childrenProp.length !== 0 && childrenProp[valueIndex].value !== value) {
            activeIndexRef.current = -1;
        }
        if (valueIndex !== activeIndexRef.current) {
            setIndex(valueIndex);
        }
    }, [
        value,
        childrenChanged
    ]);
    const getIndexByOffset = (0, import_react58.useCallback)((offset)=>(0, import_clamp3.default)(Math.round(-offset / optionHeight), 0, countRef.current - 1), [
        countRef,
        optionHeight
    ]);
    const momentum = (0, import_react58.useCallback)((distance, duration)=>{
        const speed = Math.abs(distance / duration);
        const distanceCache = activeOffset + speed / 3e-3 * (distance < 0 ? -1 : 1);
        const index = getIndexByOffset(distanceCache);
        currentDurationRef.current = 1e3;
        setIndex(index, true);
    }, [
        activeOffset,
        getIndexByOffset,
        setIndex
    ]);
    const stopMomentum = (0, import_react58.useCallback)(()=>{
        movingRef.current = false;
        currentDurationRef.current = 0;
        if (transitionEndTriggerRef.current) {
            var _transitionEndTriggerRef_current;
            (_transitionEndTriggerRef_current = transitionEndTriggerRef.current) === null || _transitionEndTriggerRef_current === void 0 ? void 0 : _transitionEndTriggerRef_current.call(transitionEndTriggerRef);
            transitionEndTriggerRef.current = void 0;
        }
    }, []);
    const onItemClick = (0, import_react58.useCallback)((index)=>{
        if (movingRef.current || readonly) {
            return;
        }
        transitionEndTriggerRef.current = void 0;
        currentDurationRef.current = DEFAULT_DURATION;
        setIndex(index, true);
    }, [
        readonly,
        setIndex
    ]);
    const handleTouchStart = function() {
        var _ref = _async_to_generator(function*(event) {
            if (readonly) {
                return;
            }
            touch.start(event);
            if (movingRef.current) {
                const translateY = moveOffsetRef.current;
                const offset = Math.min(0, translateY);
                if (movingRef.current) {
                    setActiveOffset(offset);
                }
                startOffsetRef.current = offset;
            } else {
                startOffsetRef.current = activeOffset;
            }
            currentDurationRef.current = 0;
            touchStartTimeRef.current = Date.now();
            momentumOffsetRef.current = startOffsetRef.current;
        });
        return function handleTouchStart(event) {
            return _ref.apply(this, arguments);
        };
    }();
    const handleTouchMove = (event)=>{
        if (readonly) {
            return;
        }
        touch.move(event);
        if (touch.isVertical()) {
            movingRef.current = true;
            preventDefault(event, true);
        }
        const now = Date.now();
        if (now - touchStartTimeRef.current > MOMENTUM_LIMIT_TIME) {
            touchStartTimeRef.current = now;
            momentumOffsetRef.current = activeOffset;
        }
        const newOffset = (0, import_clamp3.default)(startOffsetRef.current + touch.deltaY, -(countRef.current * optionHeight), optionHeight);
        moveOffsetRef.current = newOffset;
        setActiveOffset(newOffset);
    };
    const handleTouchEnd = ()=>{
        if (readonly) {
            return;
        }
        const distance = activeOffset - momentumOffsetRef.current;
        const duration = Date.now() - touchStartTimeRef.current;
        const allowMomentum = duration < MOMENTUM_LIMIT_TIME && Math.abs(distance) > MOMENTUM_LIMIT_DISTANCE;
        if (allowMomentum) {
            momentum(distance, duration);
            return;
        }
        const index = getIndexByOffset(activeOffset);
        currentDurationRef.current = DEFAULT_DURATION;
        setIndex(index, true);
        setTimeout(()=>{
            movingRef.current = false;
        }, 0);
    };
    const wrapperStyle = (0, import_react58.useMemo)(()=>({
            transform: `translate3d(0, ${addUnitPx(activeOffset + baseOffset)}, 0)`,
            transitionDuration: `${currentDurationRef.current}ms`,
            transitionProperty: currentDurationRef.current ? "all" : "none"
        }), [
        activeOffset,
        baseOffset
    ]);
    (0, import_react58.useImperativeHandle)(ref, ()=>({
            stopMomentum
        }), [
        stopMomentum
    ]);
    return React37.createElement(View, _object_spread({
        className: (0, import_classnames26.default)(prefixClassname("picker-column"), className),
        catchMove: true,
        onTouchStart: (event)=>{
            fulfillPromise(handleTouchStart(event));
            onTouchStart === null || onTouchStart === void 0 ? void 0 : onTouchStart(event);
        },
        onTouchMove: (event)=>{
            handleTouchMove(event);
            onTouchMove === null || onTouchMove === void 0 ? void 0 : onTouchMove(event);
        },
        onTouchEnd: (event)=>{
            handleTouchEnd();
            onTouchEnd === null || onTouchEnd === void 0 ? void 0 : onTouchEnd(event);
        },
        onTouchCancel: (event)=>{
            handleTouchEnd();
            onTouchCancel === null || onTouchCancel === void 0 ? void 0 : onTouchCancel(event);
        }
    }, (0, import_omit.default)(restProps, "label")), React37.createElement(View, {
        ref: wrapperRef,
        style: wrapperStyle,
        className: (0, import_classnames26.default)(prefixClassname("picker-column__wrapper")),
        onTransitionEnd: stopMomentum
    }, (0, import_map4.default)(childrenProp, (option, index)=>{
        var _getPickerOptionKey;
        return React37.createElement(PickerOption, _object_spread_props(_object_spread({
            key: (_getPickerOptionKey = getPickerOptionKey(option)) !== null && _getPickerOptionKey !== void 0 ? _getPickerOptionKey : index
        }, option), {
            onClick: ()=>onItemClick(index)
        }));
    })));
});
var picker_column_default = PickerColumn;
// node_modules/@taroify/core/picker/use-picker-options.js
var import_isPlainObject3 = __toESM(require_isPlainObject());
var import_react59 = __toESM(require_react());
function elementToObject(element, index, depth, maxDepth) {
    if ((0, import_react59.isValidElement)(element)) {
        const { props } = element;
        const { value, label, children: children2 } = props, restProps = _object_without_properties(props, [
            "value",
            "label",
            "children"
        ]);
        const textChildren = isTextElement(children2) ? children2 : void 0;
        var _ref;
        return _object_spread({
            index,
            value: (_ref = value !== null && value !== void 0 ? value : label) !== null && _ref !== void 0 ? _ref : textChildren,
            label: label !== null && label !== void 0 ? label : textChildren,
            children: isTextElement(children2) || depth === maxDepth ? children2 : mapToChildrenOptions(children2, depth + 1, maxDepth)
        }, restProps);
    }
    if ((0, import_isPlainObject3.default)(element)) {
        return element;
    }
}
function mapToOption(nodeOrObject, index, depth, maxDepth) {
    return elementToObject(nodeOrObject, index, depth, maxDepth);
}
function mapToChildrenOptions(children2, depth, maxDepth) {
    return children_default.map(children2, (child, index)=>{
        return mapToOption(child, index, depth, maxDepth);
    });
}
function usePickerOptions(children2 = void 0, options = {}) {
    const { depth = 1 } = options;
    return (0, import_react59.useMemo)(()=>mapToChildrenOptions(children2, 0, depth), [
        depth,
        children2
    ]);
}
var use_picker_options_default = usePickerOptions;
// node_modules/@taroify/core/picker/picker-columns-render.js
function PickerColumnsRender(props) {
    const { className, style, children: children2, readonly, values: values2, siblingCount, onChange } = props, restProps = _object_without_properties(props, [
        "className",
        "style",
        "children",
        "readonly",
        "values",
        "siblingCount",
        "onChange"
    ]);
    const { setColumnRefs, clearColumnRefs, optionHeight } = (0, import_react60.useContext)(picker_context_default);
    const columns = use_picker_options_default(children2);
    const visibleCount = siblingCount * 2;
    const wrapHeight = (0, import_react60.useMemo)(()=>optionHeight * visibleCount, [
        visibleCount,
        optionHeight
    ]);
    const rootStyle = (0, import_react60.useMemo)(()=>_object_spread_props(_object_spread({}, style), {
            height: addUnitPx(wrapHeight)
        }), [
        style,
        wrapHeight
    ]);
    const maskStyle = (0, import_react60.useMemo)(()=>({
            backgroundSize: `100% ${addUnitPx((wrapHeight - optionHeight) / 2)}`
        }), [
        wrapHeight,
        optionHeight
    ]);
    const frameStyle = (0, import_react60.useMemo)(()=>({
            height: addUnitPx(optionHeight)
        }), [
        optionHeight
    ]);
    const columnsRender = useRendered(()=>(0, import_map5.default)(columns, (column, columnIndex)=>{
            const { children: options } = column, restColumnProps = _object_without_properties(column, [
                "children"
            ]);
            clearColumnRefs === null || clearColumnRefs === void 0 ? void 0 : clearColumnRefs();
            var _getPickerOptionKey;
            return React38.createElement(picker_column_default, _object_spread_props(_object_spread({
                ref: setColumnRefs === null || setColumnRefs === void 0 ? void 0 : setColumnRefs(columnIndex),
                key: (_getPickerOptionKey = getPickerOptionKey(column)) !== null && _getPickerOptionKey !== void 0 ? _getPickerOptionKey : columnIndex,
                children: options,
                readonly
            }, restColumnProps), {
                visibleCount,
                optionHeight,
                value: (0, import_get4.default)(values2, columnIndex),
                onChange: (option, emitChange)=>onChange === null || onChange === void 0 ? void 0 : onChange(option, _object_spread_props(_object_spread({}, column), {
                        index: columnIndex
                    }), emitChange)
            }));
        }));
    return React38.createElement(View, _object_spread({
        className: (0, import_classnames27.default)(prefixClassname("picker__columns"), className),
        style: rootStyle,
        catchMove: true,
        onTouchMove: preventDefault
    }, restProps), columnsRender, React38.createElement(View, {
        className: prefixClassname("picker__mask"),
        style: maskStyle
    }), React38.createElement(View, {
        className: (0, import_classnames27.default)([
            HAIRLINE_BORDER_UNSET_TOP_BOTTOM,
            prefixClassname("picker__frame")
        ]),
        style: frameStyle
    }));
}
var picker_columns_render_default = PickerColumnsRender;
// node_modules/@taroify/core/picker/picker-columns.js
function PickerColumns(props) {
    const { readonly, values: values2, siblingCount, getValueOptions, isMultiValue, setValueOptions, onChange } = (0, import_react61.useContext)(picker_context_default);
    const onColumnChange = (0, import_react61.useCallback)((option, unverifiedColumn, emitChange)=>{
        setValueOptions === null || setValueOptions === void 0 ? void 0 : setValueOptions(option, unverifiedColumn);
        const column = validPickerColumn(unverifiedColumn);
        if (column && emitChange) {
            const { index: columnIndex } = column;
            const newValues = (0, import_map6.default)((0, import_filter.default)(getValueOptions === null || getValueOptions === void 0 ? void 0 : getValueOptions(), (newOption)=>!(0, import_isUndefined9.default)(newOption)), ({ value })=>value);
            (0, import_set.default)(newValues, columnIndex, option === null || option === void 0 ? void 0 : option.value);
            const aValues = getPickerValue(newValues, (isMultiValue === null || isMultiValue === void 0 ? void 0 : isMultiValue()) || (0, import_size5.default)(newValues) > 1);
            onChange === null || onChange === void 0 ? void 0 : onChange(aValues, _object_spread({}, option), _object_spread({}, column));
        }
    }, [
        getValueOptions,
        isMultiValue,
        onChange,
        setValueOptions
    ]);
    return React39.createElement(picker_columns_render_default, _object_spread_props(_object_spread({}, props), {
        readonly,
        values: values2,
        siblingCount,
        onChange: onColumnChange
    }));
}
var picker_columns_default = PickerColumns;
// node_modules/@taroify/core/picker/picker-toolbar.js
var import_classnames29 = __toESM(require_classnames());
var import_isEmpty6 = __toESM(require_isEmpty());
var React42 = __toESM(require_react());
var import_react63 = __toESM(require_react());
// node_modules/@taroify/core/picker/picker-button.js
var import_classnames28 = __toESM(require_classnames());
var React40 = __toESM(require_react());
var import_react62 = __toESM(require_react());
var PickerButtonType;
(function(PickerButtonType2) {
    PickerButtonType2["Cancel"] = "cancel";
    PickerButtonType2["Confirm"] = "confirm";
})(PickerButtonType || (PickerButtonType = {}));
function PickerButton(props) {
    const { type = PickerButtonType.Cancel, children: children2, onClick } = props;
    const { onCancel, onConfirm } = (0, import_react62.useContext)(picker_context_default);
    return React40.createElement(View, {
        className: (0, import_classnames28.default)({
            [prefixClassname("picker__cancel")]: type === PickerButtonType.Cancel,
            [prefixClassname("picker__confirm")]: type === PickerButtonType.Confirm
        }),
        children: children2,
        onClick: (e)=>{
            onClick === null || onClick === void 0 ? void 0 : onClick(e);
            if (type === PickerButtonType.Cancel) {
                onCancel === null || onCancel === void 0 ? void 0 : onCancel();
            } else if (type === PickerButtonType.Confirm) {
                onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm();
            }
        }
    });
}
// node_modules/@taroify/core/picker/picker-title.js
var React41 = __toESM(require_react());
function PickerTitle(props) {
    const { children: children2 } = props;
    return React41.createElement(View, {
        className: prefixClassname("picker__title"),
        children: children2
    });
}
// node_modules/@taroify/core/picker/picker-toolbar.js
function usePickerToolbarChildren(children2) {
    return (0, import_react63.useMemo)(()=>{
        const __children__ = {
            title: void 0,
            cancel: void 0,
            confirm: void 0
        };
        import_react63.Children.forEach(children2, (child, index)=>{
            if ((0, import_react63.isValidElement)(child)) {
                const element = child;
                const { type: elementType } = element;
                if (elementType === PickerTitle) {
                    __children__.title = element;
                } else if (elementType === PickerButton) {
                    const { props } = element;
                    const { type } = props;
                    if (type === PickerButtonType.Cancel) {
                        __children__.cancel = element;
                    } else if (type === PickerButtonType.Confirm) {
                        __children__.confirm = element;
                    } else if ((0, import_isEmpty6.default)(type) && (0, import_isEmpty6.default)(__children__.cancel)) {
                        __children__.cancel = (0, import_react63.cloneElement)(element, {
                            type: PickerButtonType.Cancel
                        });
                    } else if ((0, import_isEmpty6.default)(type) && (0, import_isEmpty6.default)(__children__.confirm)) {
                        __children__.confirm = (0, import_react63.cloneElement)(element, {
                            type: PickerButtonType.Confirm
                        });
                    }
                }
            }
        });
        return __children__;
    }, [
        children2
    ]);
}
function PickerToolbar(props) {
    const { className, children: childrenProp } = props, restProps = _object_without_properties(props, [
        "className",
        "children"
    ]);
    const { title, cancel: cancel2, confirm } = usePickerToolbarChildren(childrenProp);
    return React42.createElement(View, _object_spread({
        className: (0, import_classnames29.default)(prefixClassname("picker__toolbar"), className)
    }, restProps), cancel2, title, confirm);
}
// node_modules/@taroify/core/picker/picker.composition.js
var React43 = __toESM(require_react());
function PickerColumn2(props) {
    return React43.createElement(React43.Fragment, null);
}
// node_modules/@taroify/core/picker/picker.js
function usePickerValues(value) {
    return (0, import_isArray5.default)(value) ? value : [
        value
    ];
}
var defaultFieldNames2 = {
    label: "label",
    value: "value"
};
function Picker(props) {
    const { defaultValue, value: valueProp, className, loading, readonly, title, confirmText = "\u786E\u8BA4", cancelText = "\u53D6\u6D88", columns: columnsProp, columnsFieldNames: columnsFieldNamesProp, siblingCount = DEFAULT_SIBLING_COUNT, optionHeight: optionHeightProp, children: childrenProp, onChange, onCancel, onConfirm } = props, restProps = _object_without_properties(props, [
        "defaultValue",
        "value",
        "className",
        "loading",
        "readonly",
        "title",
        "confirmText",
        "cancelText",
        "columns",
        "columnsFieldNames",
        "siblingCount",
        "optionHeight",
        "children",
        "onChange",
        "onCancel",
        "onConfirm"
    ]);
    const { getRefs: getColumnRefs, setRefs: setColumnRefs, clearRefs: clearColumnRefs } = useRefs();
    const { value, setValue } = useUncontrolled({
        value: valueProp,
        defaultValue
    });
    const multiValueRef = useToRef((0, import_isArray5.default)(value));
    const values2 = usePickerValues(value);
    const fieldNames = (0, import_react64.useMemo)(()=>{
        if (!(0, import_isEmpty7.default)(columnsFieldNamesProp) && (0, import_isObject3.default)(columnsFieldNamesProp)) {
            return Object.assign(_object_spread({}, defaultFieldNames2), columnsFieldNamesProp);
        }
        return defaultFieldNames2;
    }, [
        columnsFieldNamesProp
    ]);
    const children2 = (0, import_react64.useMemo)(()=>{
        let toolbar = null;
        const __children__ = [];
        const columns = [];
        import_react64.Children.toArray(childrenProp).forEach((child)=>{
            if (isElementOf(child, PickerColumn2)) {
                const element = child;
                columns.push(element);
            } else if (isElementOf(child, picker_columns_default)) {
                const element = child;
                columns.push(...element.props.children);
            } else if (isElementOf(child, PickerToolbar)) {
                toolbar = child;
            } else {
                __children__.push(child);
            }
        });
        if (!toolbar && (title || confirmText || cancelText)) {
            toolbar = React44.createElement(PickerToolbar, {
                key: "-2"
            }, React44.createElement(PickerButton, {
                type: "cancel"
            }, cancelText), React44.createElement(PickerTitle, null, title), React44.createElement(PickerButton, {
                type: "confirm"
            }, confirmText));
        }
        if ((0, import_isEmpty7.default)(columns) && columnsProp && columnsProp.length > 0) {
            ;
            (Array.isArray(columnsProp[0]) ? columnsProp : [
                columnsProp
            ]).forEach((col, i)=>{
                columns.push(React44.createElement(PickerColumn2, {
                    key: i
                }, col.map((data, ii)=>React44.createElement(PickerOption, {
                        key: ii,
                        label: data[fieldNames.label],
                        value: data[fieldNames.value],
                        disabled: data.disabled
                    }))));
            });
        }
        __children__.unshift(React44.createElement(picker_columns_default, {
            key: "-1",
            children: columns
        }));
        __children__.unshift(toolbar);
        return __children__;
    }, [
        childrenProp,
        title,
        confirmText,
        cancelText,
        columnsProp,
        fieldNames
    ]);
    const valueOptionsRef = (0, import_react64.useRef)([]);
    const optionHeight = (0, import_react64.useMemo)(()=>optionHeightProp ? unitToPx(optionHeightProp) : DEFAULT_OPTION_HEIGHT, [
        optionHeightProp
    ]);
    const setValueOptions = (0, import_react64.useCallback)((option, unverifiedColumn)=>{
        const column = validPickerColumn(unverifiedColumn);
        if (option && column) {
            const { index: columnIndex } = column;
            valueOptionsRef.current[columnIndex] = option;
        }
    }, []);
    const handleChange = (0, import_react64.useCallback)((values3, option, column)=>{
        setValue(values3);
        onChange === null || onChange === void 0 ? void 0 : onChange(values3, option, column);
    }, [
        onChange,
        setValue
    ]);
    const stopMomentum = (0, import_react64.useCallback)(()=>getColumnRefs().filter((columnRef)=>columnRef.current).forEach((columnRef)=>columnRef.current.stopMomentum()), [
        getColumnRefs
    ]);
    const handleAction = (action)=>()=>{
            stopMomentum();
            action === null || action === void 0 ? void 0 : action((0, import_map7.default)(valueOptionsRef.current, ({ value: value2 })=>value2), (0, import_map7.default)(valueOptionsRef.current, (valueOption)=>_object_spread({}, valueOption)));
        };
    const getValueOptions = (0, import_react64.useCallback)(()=>valueOptionsRef.current, []);
    const isMultiValue = (0, import_react64.useCallback)(()=>multiValueRef.current, [
        multiValueRef
    ]);
    return React44.createElement(picker_context_default.Provider, {
        value: {
            readonly,
            siblingCount,
            optionHeight,
            values: values2,
            getValueOptions,
            isMultiValue,
            setValueOptions,
            clearColumnRefs,
            setColumnRefs,
            onChange: handleChange,
            onConfirm: handleAction(onConfirm),
            onCancel: handleAction(onCancel)
        }
    }, React44.createElement(View, _object_spread({
        className: (0, import_classnames30.default)(prefixClassname("picker"), className)
    }, restProps), loading && React44.createElement(Loading, {
        className: prefixClassname("picker__loading")
    }), children2));
}
var picker_default = Picker;
// node_modules/@taroify/core/picker/index.js
var Picker2 = picker_default;
Picker2.Toolbar = PickerToolbar;
Picker2.Title = PickerTitle;
Picker2.Button = PickerButton;
Picker2.Columns = picker_columns_default;
Picker2.Column = PickerColumn2;
Picker2.Option = PickerOption;
var picker_default2 = Picker2;
// node_modules/@taroify/core/area-picker/area-picker.js
var React45 = __toESM(require_react());
var import_react65 = __toESM(require_react());
// node_modules/@taroify/core/area-picker/area-picker.shared.js
var AREA_EMPTY_CODE = "000000";
var makeOption = (text = "", value = AREA_EMPTY_CODE, children2 = void 0)=>({
        label: text,
        value,
        children: children2
    });
function formatDataForCascade({ areaList, columnsNum, columnsPlaceholder: placeholder = [] }) {
    const { city_list: city = {}, county_list: county = {}, province_list: province = {} } = areaList;
    const showCity = +columnsNum > 1;
    const showCounty = +columnsNum > 2;
    const getProvinceChildren = ()=>{
        if (showCity) {
            return placeholder.length ? [
                makeOption(placeholder[0], AREA_EMPTY_CODE, showCounty ? [] : void 0)
            ] : [];
        }
    };
    const provinceMap = /* @__PURE__ */ new Map();
    for (const code of Object.keys(province)){
        provinceMap.set(code.slice(0, 2), makeOption(province[code], code, getProvinceChildren()));
    }
    const cityMap = /* @__PURE__ */ new Map();
    if (showCity) {
        const getCityChildren = ()=>{
            if (showCounty) {
                return placeholder.length ? [
                    makeOption(placeholder[1])
                ] : [];
            }
        };
        for (const code of Object.keys(city)){
            const option = makeOption(city[code], code, getCityChildren());
            cityMap.set(code.slice(0, 4), option);
            const province2 = provinceMap.get(code.slice(0, 2));
            if (province2) {
                province2.children.push(option);
            }
        }
    }
    if (showCounty) {
        for (const code of Object.keys(county)){
            const city2 = cityMap.get(code.slice(0, 4));
            if (city2) {
                city2.children.push(makeOption(county[code], code));
            }
        }
    }
    const options = Array.from(provinceMap.values());
    if (placeholder.length) {
        const county2 = showCounty ? [
            makeOption(placeholder[2])
        ] : void 0;
        const city2 = showCity ? [
            makeOption(placeholder[1], AREA_EMPTY_CODE, county2)
        ] : void 0;
        options.unshift(makeOption(placeholder[0], AREA_EMPTY_CODE, city2));
    }
    return [
        options,
        provinceMap,
        cityMap
    ];
}
// node_modules/@taroify/core/area-picker/area-picker-columns.js
function AreaPickerColumns(props) {
    return null;
}
var area_picker_columns_default = AreaPickerColumns;
// node_modules/@taroify/core/area-picker/area-picker.js
var defaultAreaList = {};
function AreaPicker(_param) {
    var { areaList: areaListProp, depth: depthProp, children: childrenProps, value: valueProp, defaultValue, onChange: onChangeProp, onConfirm: onConfirmProp, onCancel: onCancelProp } = _param, restProps = _object_without_properties(_param, [
        "areaList",
        "depth",
        "children",
        "value",
        "defaultValue",
        "onChange",
        "onConfirm",
        "onCancel"
    ]);
    const hasChange = (0, import_react65.useRef)(false);
    const { value, setValue } = useUncontrolled({
        value: valueProp,
        defaultValue
    });
    const [areaList, columnsNum] = (0, import_react65.useMemo)(()=>{
        let __areaList__ = areaListProp || defaultAreaList;
        import_react65.Children.forEach(childrenProps, (child)=>{
            if (isElementOf(child, area_picker_columns_default)) {
                __areaList__ = child.props.children;
            }
        });
        return [
            __areaList__,
            depthProp || 3
        ];
    }, [
        childrenProps,
        areaListProp,
        depthProp
    ]);
    const [origin, provinceMap, cityMap] = (0, import_react65.useMemo)(()=>formatDataForCascade({
            areaList,
            columnsNum
        }), [
        areaList,
        columnsNum
    ]);
    const columns = (0, import_react65.useMemo)(()=>{
        const ret = [
            origin
        ];
        let parent = origin;
        for(let i = 0; i < columnsNum - 1; i++){
            let selected;
            if (value === null || value === void 0 ? void 0 : value[i]) {
                selected = parent.find((item)=>item.value === (value === null || value === void 0 ? void 0 : value[i]));
            } else {
                selected = parent[0];
            }
            parent = (selected === null || selected === void 0 ? void 0 : selected.children) || [];
            ret.push(parent);
        }
        return ret;
    }, [
        origin,
        value
    ]);
    const handleChange = useMemoizedFn((val, option, column)=>{
        const valCache = Array.isArray(val) && val.length ? val : [
            val
        ];
        const idx = valCache.findIndex((item)=>item === option.value);
        let newVal = [];
        if (idx === 0) {
            newVal = [
                valCache[0]
            ];
            if (columnsNum > 1) {
                var _province_children;
                const province = provinceMap.get(option.value.slice(0, 2));
                const city = province === null || province === void 0 ? void 0 : (_province_children = province.children) === null || _province_children === void 0 ? void 0 : _province_children[0];
                newVal.push(city === null || city === void 0 ? void 0 : city.value);
                if (columnsNum > 2) {
                    var _city_children_, _city_children;
                    newVal.push(city === null || city === void 0 ? void 0 : (_city_children = city.children) === null || _city_children === void 0 ? void 0 : (_city_children_ = _city_children[0]) === null || _city_children_ === void 0 ? void 0 : _city_children_.value);
                }
            }
        } else if (idx === 1) {
            const city = cityMap.get(option.value.slice(0, 4));
            newVal = [
                valCache[0],
                city === null || city === void 0 ? void 0 : city.value
            ];
            if (columnsNum > 2) {
                var _city_children_1, _city_children1;
                newVal.push(city === null || city === void 0 ? void 0 : (_city_children1 = city.children) === null || _city_children1 === void 0 ? void 0 : (_city_children_1 = _city_children1[0]) === null || _city_children_1 === void 0 ? void 0 : _city_children_1.value);
            }
        } else if (idx === 2) {
            newVal = [
                value === null || value === void 0 ? void 0 : value[0],
                value === null || value === void 0 ? void 0 : value[1],
                option.value
            ];
        }
        hasChange.current = true;
        setValue(newVal);
        onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(newVal, option, column);
    });
    const genValOption = (valueParam)=>{
        var _val_;
        const val = (hasChange.current ? value : valueParam) || [];
        const province = provinceMap.get((_val_ = val[0]) === null || _val_ === void 0 ? void 0 : _val_.slice(0, 2)) || {};
        const option = [
            province
        ];
        if (columnsNum > 1) {
            var _val_1;
            const _ref = cityMap.get((_val_1 = val[1]) === null || _val_1 === void 0 ? void 0 : _val_1.slice(0, 4)) || {}, { children: children2 } = _ref, city = _object_without_properties(_ref, [
                "children"
            ]);
            option.push(city);
            if (columnsNum > 2) {
                const country = children2 === null || children2 === void 0 ? void 0 : children2.find((item)=>item.value === val[2]);
                option.push(country || {});
            }
        }
        return [
            val,
            option
        ];
    };
    const handleConfirm = useMemoizedFn((valueParam)=>{
        if (onConfirmProp) {
            const [val, option] = genValOption(valueParam);
            onConfirmProp(val, option);
        }
    });
    const handleCancel = useMemoizedFn((valueParam)=>{
        if (onCancelProp) {
            const [val, option] = genValOption(valueParam);
            onCancelProp(val, option);
        }
    });
    return React45.createElement(picker_default2, _object_spread_props(_object_spread({}, restProps), {
        children: childrenProps,
        columns,
        value,
        defaultValue,
        onChange: handleChange,
        onConfirm: handleConfirm,
        onCancel: handleCancel
    }));
}
var area_picker_default = AreaPicker;
// node_modules/@taroify/core/area-picker/index.js
var AreaPicker2 = area_picker_default;
AreaPicker2.Toolbar = picker_default2.Toolbar;
AreaPicker2.Title = picker_default2.Title;
AreaPicker2.Button = picker_default2.Button;
AreaPicker2.Columns = area_picker_columns_default;
var area_picker_default2 = AreaPicker2;
// node_modules/@taroify/core/cascader/cascader.js
var import_classnames44 = __toESM(require_classnames());
var import_size8 = __toESM(require_size());
var import_isEmpty9 = __toESM(require_isEmpty());
var import_isObject4 = __toESM(require_isObject());
var import_slice = __toESM(require_slice());
var import_isEqual5 = __toESM(require_isEqual());
var import_map10 = __toESM(require_map());
var import_get7 = __toESM(require_get());
var React62 = __toESM(require_react());
var import_react79 = __toESM(require_react());
// node_modules/@taroify/core/tabs/tab-pane.js
var React46 = __toESM(require_react());
function TabPane(props) {
    return React46.createElement(React46.Fragment, null);
}
// node_modules/@taroify/core/tabs/tabs.js
var import_classnames41 = __toESM(require_classnames());
var import_size7 = __toESM(require_size());
var import_isBoolean4 = __toESM(require_isBoolean());
var React57 = __toESM(require_react());
var import_react78 = __toESM(require_react());
// node_modules/@taroify/core/sticky/sticky.js
var import_classnames31 = __toESM(require_classnames());
var React47 = __toESM(require_react());
var import_react67 = __toESM(require_react());
// node_modules/@taroify/core/utils/system.js
var import_react66 = __toESM(require_react());
function getSystemRect() {
    return getSystemInfo().then(({ screenHeight, screenWidth, windowHeight, windowWidth })=>({
            screenHeight,
            screenWidth,
            windowHeight,
            windowWidth
        }));
}
// node_modules/@taroify/core/sticky/sticky.js
function Sticky(props) {
    const { className, style: styleProp, position = "top", offsetTop: offsetTopProp, offsetBottom: offsetBottomProp, offset: offsetProp, container: containerRef, children: children2, onChange, onScroll } = props, restProps = _object_without_properties(props, [
        "className",
        "style",
        "position",
        "offsetTop",
        "offsetBottom",
        "offset",
        "container",
        "children",
        "onChange",
        "onScroll"
    ]);
    if (offsetProp) {
        const { top, bottom } = offsetProp;
        if (top) {
            console.warn("[Deprecated] Use the 'offsetTop' prop instead of the 'offset.top' prop.");
        }
        if (bottom) {
            console.warn("[Deprecated] Use the 'offsetBottom' prop instead of the 'offset.bottom' prop.");
        }
    }
    const offsetTop = offsetTopProp !== null && offsetTopProp !== void 0 ? offsetTopProp : offsetProp === null || offsetProp === void 0 ? void 0 : offsetProp.top;
    const offsetBottom = offsetBottomProp !== null && offsetBottomProp !== void 0 ? offsetBottomProp : offsetProp === null || offsetProp === void 0 ? void 0 : offsetProp.bottom;
    const rootRef = (0, import_react67.useRef)();
    const counterRef = (0, import_react67.useRef)(0);
    const [rootRect, setRootRect] = (0, import_react67.useState)({});
    const [fixed, setFixed] = (0, import_react67.useState)(false);
    const [transform, setTransform] = (0, import_react67.useState)(0);
    const offsetValue = (0, import_react67.useMemo)(()=>{
        var _ref;
        return unitToPx((_ref = position === "top" ? offsetTop : offsetBottom) !== null && _ref !== void 0 ? _ref : 0);
    }, [
        offsetBottom,
        offsetTop,
        position
    ]);
    const rootStyle = (0, import_react67.useMemo)(()=>{
        if (!fixed) {
            return {
                height: "",
                width: ""
            };
        }
        const style = {};
        if (rootRect.height) {
            style.height = addUnitPx(rootRect.height);
        }
        if (rootRect.width) {
            style.width = addUnitPx(rootRect.width);
        }
        return style;
    }, [
        fixed,
        rootRect.height,
        rootRect.width
    ]);
    const stickyStyle = (0, import_react67.useMemo)(()=>{
        if (!fixed) {
            return {
                height: "",
                width: "",
                [position]: ""
            };
        }
        const style = {};
        if (rootRect.height) {
            style.height = addUnitPx(rootRect.height);
        }
        if (rootRect.width) {
            style.width = addUnitPx(rootRect.width);
        }
        style.transform = transform ? `translate3d(0, ${addUnitPx(transform)}, 0)` : "";
        style[position] = addUnitPx(offsetValue);
        return style;
    }, [
        fixed,
        rootRect.height,
        rootRect.width,
        transform,
        position,
        offsetValue
    ]);
    function invokeScroll(_) {
        return _invokeScroll.apply(this, arguments);
    }
    function _invokeScroll() {
        _invokeScroll = _async_to_generator(function*({ scrollTop }) {
            const __rootRect__ = yield getRect(rootRef);
            if (__rootRect__) {
                setRootRect(__rootRect__);
                if (position === "top") {
                    if (containerRef) {
                        const containerRect = yield getRect(containerRef);
                        const difference = containerRect.bottom - offsetValue - __rootRect__.height;
                        setTransform(difference < 0 ? difference : 0);
                        setFixed(offsetValue > __rootRect__.top && containerRect.bottom > 0);
                    } else {
                        setFixed(offsetValue > __rootRect__.top);
                    }
                } else {
                    const { windowHeight } = yield getSystemRect();
                    if (containerRef) {
                        const containerRect = yield getRect(containerRef);
                        const difference = windowHeight - containerRect.top - offsetValue - __rootRect__.height;
                        setTransform(difference < 0 ? difference : 0);
                        setFixed(windowHeight - offsetValue < __rootRect__.bottom && windowHeight > containerRect.top);
                    } else {
                        setFixed(windowHeight - offsetValue < __rootRect__.bottom);
                    }
                }
            }
            onScroll === null || onScroll === void 0 ? void 0 : onScroll({
                scrollTop
            });
        });
        return _invokeScroll.apply(this, arguments);
    }
    (0, import_react67.useEffect)(()=>{
        if (counterRef.current > 0) {
            onChange === null || onChange === void 0 ? void 0 : onChange(fixed);
        }
        counterRef.current++;
    }, [
        fixed,
        onChange
    ]);
    useMounted(()=>invokeScroll({
            scrollTop: 0
        }));
    usePageScroll(({ scrollTop })=>invokeScroll({
            scrollTop
        }));
    return React47.createElement(View, _object_spread({
        ref: rootRef,
        style: _object_spread({}, styleProp, rootStyle)
    }, restProps), React47.createElement(View, {
        style: stickyStyle,
        className: (0, import_classnames31.default)(prefixClassname("sticky"), {
            [prefixClassname("sticky--fixed")]: fixed
        }, className),
        children: children2
    }));
}
// node_modules/@taroify/core/sticky/index.js
var sticky_default = Sticky;
// node_modules/@taroify/core/tabs/tabs-content.js
var import_classnames36 = __toESM(require_classnames());
var import_map8 = __toESM(require_map());
var import_find3 = __toESM(require_find());
var import_get5 = __toESM(require_get());
var React52 = __toESM(require_react());
var import_react74 = __toESM(require_react());
// node_modules/@taroify/core/swiper/swiper.js
var import_classnames34 = __toESM(require_classnames());
var import_clamp4 = __toESM(require_clamp());
var React50 = __toESM(require_react());
var import_react71 = __toESM(require_react());
// node_modules/@taroify/core/utils/dom/computed-style.js
function getComputedStyle(elementOrRef, computedStyle) {
    const element = elementUnref(elementOrRef);
    if (element) {
        if (inBrowser) {
            return Promise.resolve(window.getComputedStyle(element));
        }
        return new Promise((resolve)=>{
            queryNodesRef(element).fields({
                computedStyle
            }, (result)=>resolve(result)).exec();
        });
    }
    return Promise.resolve({});
}
// node_modules/@taroify/core/utils/raf.js
var import_isNumber8 = __toESM(require_isNumber());
var import_isArray6 = __toESM(require_isArray());
var import_forEach3 = __toESM(require_forEach());
var requestAnimationFrame = __toESM(require_raf());
function cancelRaf(rafId) {
    if ((0, import_isNumber8.default)(rafId)) {
        requestAnimationFrame.cancel(rafId);
    } else if ((0, import_isArray6.default)(rafId)) {
        (0, import_forEach3.default)(rafId, cancelRaf);
    }
}
function raf(cb) {
    return requestAnimationFrame.default(cb);
}
var raf_default = raf;
function doubleRaf(cb) {
    const rafIds = [
        0,
        0
    ];
    rafIds[1] = raf(()=>{
        rafIds[0] = raf(cb);
    });
    return rafIds;
}
// node_modules/@taroify/core/swiper/swiper-indicator.js
var import_classnames32 = __toESM(require_classnames());
var import_range4 = __toESM(require_range());
var React48 = __toESM(require_react());
var import_react69 = __toESM(require_react());
// node_modules/@taroify/core/swiper/swiper.context.js
var import_react68 = __toESM(require_react());
var SwiperContext = (0, import_react68.createContext)({
    itemInstances: []
});
var swiper_context_default = SwiperContext;
// node_modules/@taroify/core/swiper/swiper-indicator.js
function SwiperIndicator(props) {
    const { className, children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "children"
    ]);
    const { indicator = 0, direction, count } = (0, import_react69.useContext)(swiper_context_default);
    const renderIndicator = (0, import_react69.useCallback)((index)=>React48.createElement(View, {
            key: index,
            className: (0, import_classnames32.default)(prefixClassname("swiper__indicator"), {
                [prefixClassname("swiper__indicator--active")]: index === indicator
            })
        }), [
        indicator
    ]);
    const indicators = (0, import_react69.useMemo)(()=>!children2 && (0, import_range4.default)(0, count).map(renderIndicator), [
        children2,
        count,
        renderIndicator
    ]);
    return React48.createElement(View, _object_spread({
        className: (0, import_classnames32.default)({
            [prefixClassname("swiper__indicators")]: !children2,
            [prefixClassname("swiper__indicators--vertical")]: !children2 && direction === "vertical"
        }, className),
        children: children2 !== null && children2 !== void 0 ? children2 : indicators
    }, restProps));
}
// node_modules/@taroify/core/swiper/swiper-item.js
var import_classnames33 = __toESM(require_classnames());
var React49 = __toESM(require_react());
var import_react70 = __toESM(require_react());
function SwiperItem(props) {
    const { __dataIndex__ = 0, className, style: styleProp, children: childrenProp } = props, restProps = _object_without_properties(props, [
        "__dataIndex__",
        "className",
        "style",
        "children"
    ]);
    const { lazyRender, getSize, direction, loop, indicator = 0, count = 0, itemInstances } = (0, import_react70.useContext)(swiper_context_default);
    const vertical = direction === "vertical";
    const initializedRef = (0, import_react70.useRef)(false);
    const mountedRef = (0, import_react70.useRef)(false);
    const [offset, setOffset] = (0, import_react70.useState)(0);
    const shouldRender = (0, import_react70.useMemo)(()=>{
        if (!lazyRender || initializedRef.current) {
            return true;
        }
        if (!mountedRef.current && indicator !== 0) {
            return false;
        }
        const active = indicator;
        const maxActive = count - 1;
        const prevActive = active === 0 && loop ? maxActive : active - 1;
        const nextActive = active === maxActive && loop ? 0 : active + 1;
        initializedRef.current = __dataIndex__ === active || __dataIndex__ === prevActive || __dataIndex__ === nextActive;
        return initializedRef.current;
    }, [
        __dataIndex__,
        count,
        indicator,
        lazyRender,
        loop
    ]);
    useMounted(()=>{
        mountedRef.current = true;
    });
    (0, import_react70.useEffect)(()=>{
        if (!itemInstances[__dataIndex__]) {
            itemInstances[__dataIndex__] = {
                setOffset
            };
        }
    }, [
        itemInstances,
        __dataIndex__
    ]);
    const rootStyle = useRendered(()=>{
        const style = {};
        const size = getSize === null || getSize === void 0 ? void 0 : getSize();
        if (size) {
            const mainAxis = vertical ? "height" : "width";
            style[mainAxis] = addUnitPx(size);
        }
        style.transform = offset ? `translate${vertical ? "Y" : "X"}(${addUnitPx(offset)})` : "";
        return style;
    });
    return React49.createElement(View, _object_spread({
        className: (0, import_classnames33.default)(prefixClassname("swiper-item"), className),
        style: _object_spread({}, styleProp, rootStyle),
        children: shouldRender ? childrenProp : void 0
    }, restProps));
}
// node_modules/@taroify/core/swiper/swiper.js
function useSwiperChildren(children2) {
    const __children__ = {
        items: [],
        indicator: void 0,
        count: 0
    };
    let index = 0;
    import_react71.Children.forEach(children2, (child, i)=>{
        if (!(0, import_react71.isValidElement)(child)) {
            return;
        }
        const element = child;
        const elementType = element.type;
        if (elementType === SwiperIndicator) {
            __children__.indicator = element;
        } else if (elementType === SwiperItem) {
            const { key } = element;
            __children__.items.push((0, import_react71.cloneElement)(element, _object_spread_props(_object_spread({}, element.props), {
                key: key !== null && key !== void 0 ? key : i,
                __dataIndex__: index++
            })));
        } else {
            __children__.items.push(element);
        }
    });
    __children__.count = __children__.items.length;
    return __children__;
}
function getIndicatorValue(value, count) {
    return (value + count) % count;
}
function Swiper(props) {
    const { className, defaultValue, value: valueProp, lazyRender, loop = true, touchable = true, autoplay = 0, duration = 500, width, height, direction = "horizontal", stopPropagation: stopPropagation2 = true, children: childrenProp, onChange: onChangeProp } = props, restProps = _object_without_properties(props, [
        "className",
        "defaultValue",
        "value",
        "lazyRender",
        "loop",
        "touchable",
        "autoplay",
        "duration",
        "width",
        "height",
        "direction",
        "stopPropagation",
        "children",
        "onChange"
    ]);
    const { value = 0, setValue } = useUncontrolled({
        value: valueProp,
        defaultValue,
        onChange: onChangeProp
    });
    const valueRef = useToRef(value);
    const { count, indicator, items } = useSwiperChildren(childrenProp);
    const itemInstances = (0, import_react71.useMemo)(()=>[], []);
    const [isInit, setIsInit] = (0, import_react71.useState)(false);
    const touch = useTouch();
    const forceUpdate = use_force_update_default();
    const vertical = direction === "vertical";
    const rootRef = (0, import_react71.useRef)();
    const rectRef = (0, import_react71.useRef)();
    const [offset, setOffset] = (0, import_react71.useState)(0);
    const swipingRef = (0, import_react71.useRef)(false);
    const activeIndexRef = (0, import_react71.useRef)(0);
    const touchStartTimeRef = (0, import_react71.useRef)(0);
    const autoplayTimerRef = (0, import_react71.useRef)();
    const valueIndicatorRef = useRenderedRef(()=>getIndicatorValue(value, count));
    const activeIndicatorRef = useRenderedRef(()=>getIndicatorValue(activeIndexRef.current, count));
    const getDelta = (0, import_react71.useCallback)(()=>vertical ? touch.deltaY : touch.deltaX, []);
    const getCorrectDirection = (0, import_react71.useCallback)(()=>touch.direction === direction, []);
    const getCustomRect = (0, import_react71.useCallback)(()=>{
        var _rectRef_current, _rectRef_current1;
        return {
            width: width !== null && width !== void 0 ? width : (_rectRef_current = rectRef.current) === null || _rectRef_current === void 0 ? void 0 : _rectRef_current.width,
            height: height !== null && height !== void 0 ? height : (_rectRef_current1 = rectRef.current) === null || _rectRef_current1 === void 0 ? void 0 : _rectRef_current1.height
        };
    }, [
        height,
        width
    ]);
    const propRectRef = useRenderedRef(()=>({
            width,
            height
        }));
    const getSize = (0, import_react71.useCallback)(()=>{
        const { height: height2, width: width2 } = getCustomRect();
        var _ref;
        return (_ref = vertical ? height2 : width2) !== null && _ref !== void 0 ? _ref : 0;
    }, [
        getCustomRect,
        vertical
    ]);
    const getTrackSize = (0, import_react71.useCallback)(()=>count * getSize(), [
        count,
        getSize
    ]);
    const getMinOffset = (0, import_react71.useCallback)(()=>{
        if (rectRef.current) {
            var _rectRef_current, _rectRef_current1;
            var _ref;
            const base = (_ref = vertical ? (_rectRef_current = rectRef.current) === null || _rectRef_current === void 0 ? void 0 : _rectRef_current.height : (_rectRef_current1 = rectRef.current) === null || _rectRef_current1 === void 0 ? void 0 : _rectRef_current1.width) !== null && _ref !== void 0 ? _ref : 0;
            return base - getSize() * count;
        }
        return 0;
    }, [
        count,
        getSize,
        vertical
    ]);
    const getMaxCount = (0, import_react71.useCallback)(()=>Math.ceil(Math.abs(getMinOffset()) / getSize()), [
        getMinOffset,
        getSize
    ]);
    const getTargetActive = (0, import_react71.useCallback)((pace)=>{
        if (pace) {
            if (loop) {
                return (0, import_clamp4.default)(activeIndexRef.current + pace, -1, count);
            }
            return (0, import_clamp4.default)(activeIndexRef.current + pace, 0, getMaxCount());
        }
        return activeIndexRef.current;
    }, [
        loop,
        getMaxCount,
        count
    ]);
    const getTargetOffset = (0, import_react71.useCallback)((targetActive, offset2 = 0)=>{
        const size = getSize();
        const minOffset = getMinOffset();
        let currentPosition = targetActive * size;
        if (!loop) {
            currentPosition = Math.min(currentPosition, -minOffset);
        }
        let targetOffset = offset2 - currentPosition;
        if (!loop) {
            targetOffset = (0, import_clamp4.default)(targetOffset, getMinOffset(), 0);
        }
        return targetOffset;
    }, [
        getMinOffset,
        getSize,
        loop
    ]);
    const moveTo = (0, import_react71.useCallback)(({ pace = 0, offset: offset2 = 0, emitChange = false })=>{
        if (count <= 1) {
            return;
        }
        const minOffset = getMinOffset();
        const targetActive = getTargetActive(pace);
        const targetOffset = getTargetOffset(targetActive, offset2);
        if (loop) {
            if (itemInstances[0] && targetOffset !== minOffset) {
                const outRightBound = targetOffset < minOffset;
                itemInstances[0].setOffset(outRightBound ? getTrackSize() : 0);
            }
            if (itemInstances[count - 1] && targetOffset !== 0) {
                const outLeftBound = targetOffset > 0;
                itemInstances[count - 1].setOffset(outLeftBound ? -getTrackSize() : 0);
            }
        }
        const previousActiveIndex = activeIndexRef.current;
        activeIndexRef.current = targetActive;
        setOffset(targetOffset);
        if (emitChange && previousActiveIndex !== targetActive) {
            setValue(getIndicatorValue(targetActive, count));
        }
    }, [
        count,
        getMinOffset,
        getTargetActive,
        getTargetOffset,
        loop,
        itemInstances,
        getSize,
        getTrackSize,
        setValue
    ]);
    const correctPosition = (0, import_react71.useCallback)(()=>{
        swipingRef.current = true;
        if (activeIndexRef.current <= -1) {
            moveTo({
                pace: count
            });
        } else if (activeIndexRef.current >= count) {
            moveTo({
                pace: -count
            });
        }
    }, [
        count,
        moveTo
    ]);
    const swipeTo = (0, import_react71.useCallback)((index)=>{
        correctPosition();
        touch.reset();
        doubleRaf(()=>{
            let targetIndex;
            if (loop && index === count) {
                targetIndex = activeIndexRef.current === 0 ? 0 : index;
            } else {
                targetIndex = index % count;
            }
            swipingRef.current = false;
            moveTo({
                pace: targetIndex - activeIndexRef.current,
                emitChange: true
            });
        });
    }, [
        correctPosition,
        count,
        loop,
        moveTo,
        touch
    ]);
    const next = (0, import_react71.useCallback)(()=>{
        correctPosition();
        doubleRaf(()=>{
            swipingRef.current = false;
            moveTo({
                pace: 1,
                emitChange: true
            });
        });
    }, [
        correctPosition,
        moveTo
    ]);
    const stopAutoplay = (0, import_react71.useCallback)(()=>{
        if (autoplayTimerRef.current) {
            clearTimeout(autoplayTimerRef.current);
        }
    }, []);
    const startAutoplay = (0, import_react71.useCallback)(()=>{
        stopAutoplay();
        if (autoplay > 0 && count > 1) {
            autoplayTimerRef.current = setTimeout(()=>{
                next();
                startAutoplay();
            }, +autoplay);
        } else {
            swipingRef.current = false;
        }
    }, [
        autoplay,
        count,
        next,
        stopAutoplay
    ]);
    const onTouchStart = (0, import_react71.useCallback)((event)=>{
        if (!touchable) {
            return;
        }
        touch.start(event);
        touchStartTimeRef.current = Date.now();
        stopAutoplay();
        correctPosition();
    }, [
        correctPosition,
        stopAutoplay,
        touch,
        touchable
    ]);
    const onTouchMove = (0, import_react71.useCallback)((event)=>{
        if (!touchable || !swipingRef.current) {
            return;
        }
        touch.move(event);
        const correctDirection = getCorrectDirection();
        const shouldPrevent = correctDirection || touch.offsetY > touch.offsetX === vertical;
        if (shouldPrevent) {
            preventDefault(event, stopPropagation2);
        }
        if (correctDirection) {
            moveTo({
                offset: getDelta()
            });
        }
    }, [
        getCorrectDirection,
        getDelta,
        moveTo,
        stopPropagation2,
        touch,
        touchable,
        vertical
    ]);
    const onTouchEnd = (0, import_react71.useCallback)(()=>{
        if (!touchable || !swipingRef.current) {
            return;
        }
        const duration2 = Date.now() - touchStartTimeRef.current;
        const delta = getDelta();
        const speed = delta / duration2;
        const size = getSize();
        const shouldSwipe = Math.abs(speed) > 0.25 || Math.abs(delta) > size / 2;
        swipingRef.current = false;
        const correctDirection = getCorrectDirection();
        if (shouldSwipe && correctDirection) {
            const offset2 = vertical ? touch.offsetY : touch.offsetX;
            let pace;
            if (loop) {
                pace = offset2 > 0 ? delta > 0 ? -1 : 1 : 0;
            } else {
                pace = -Math[delta > 0 ? "ceil" : "floor"](delta / size);
            }
            moveTo({
                pace,
                emitChange: true
            });
        } else if (delta) {
            moveTo({
                pace: 0
            });
        }
        startAutoplay();
    }, [
        touchable,
        getDelta,
        getSize,
        getCorrectDirection,
        startAutoplay,
        vertical,
        touch.offsetY,
        touch.offsetX,
        loop,
        moveTo
    ]);
    const getTrackRect = (0, import_react71.useCallback)(()=>new Promise((resolve)=>{
            nextTick(()=>resolve(Promise.all([
                    getRect(rootRef),
                    getComputedStyle(rootRef, [
                        "width",
                        "height"
                    ])
                ]).then(([rect, style])=>makeRect(style.width === "auto" ? rect.width : unitToPx(style.width), style.height === "auto" ? rect.height : unitToPx(style.height)))));
        }), []);
    const initialize = useMemoizedFn(/*#__PURE__*/ _async_to_generator(function*(activeIndex = valueRef.current) {
        if (!rootRef.current) {
            return;
        }
        let activeIndexCache = activeIndex;
        if (count) {
            activeIndexCache = Math.min(count - 1, activeIndexCache);
        }
        activeIndexRef.current = activeIndexCache;
        swipingRef.current = true;
        const targetOffset = getTargetOffset(activeIndexCache);
        setOffset(targetOffset);
        if (targetOffset === offset) {
            forceUpdate();
        }
        itemInstances.forEach((item)=>item.setOffset(0));
        startAutoplay();
    }));
    const resize = (0, import_react71.useCallback)(()=>nextTick(()=>initialize(activeIndexRef.current)), [
        initialize
    ]);
    use_window_resize_default(/*#__PURE__*/ _async_to_generator(function*() {
        rectRef.current = yield getTrackRect();
        resize();
    }));
    (0, import_react71.useEffect)(()=>{
        if (!isInit) {
            return;
        }
        if (count !== 0) {
            nextTick(initialize);
        }
    }, [
        count,
        initialize,
        isInit
    ]);
    (0, import_react71.useEffect)(()=>{
        if (!isInit) {
            return;
        }
        if (valueProp !== activeIndexRef.current) {
            nextTick(initialize);
        }
    }, [
        valueProp,
        initialize,
        isInit
    ]);
    useMounted(()=>{
        const fn = function() {
            var _ref = _async_to_generator(function*() {
                rectRef.current = yield getTrackRect();
                setIsInit(true);
            });
            return function fn() {
                return _ref.apply(this, arguments);
            };
        }();
        fn();
        return stopAutoplay;
    });
    (0, import_react71.useEffect)(()=>{
        const valueIndicator = valueIndicatorRef.current;
        const activeIndicator = activeIndicatorRef.current;
        if (valueIndicator !== activeIndicator) {
            try {
                stopAutoplay();
                swipeTo(valueIndicator);
            } finally{
                startAutoplay();
            }
        }
    }, [
        valueIndicatorRef.current
    ]);
    const trackStyle = useRendered(()=>{
        const style = {
            transitionDuration: `${swipingRef.current ? 0 : duration}ms`,
            transform: `translate${vertical ? "Y" : "X"}(${addUnitPx(offset)})`
        };
        const size = getTrackSize === null || getTrackSize === void 0 ? void 0 : getTrackSize();
        if (size) {
            const mainAxis = vertical ? "height" : "width";
            style[mainAxis] = `${addUnitPx(size)}`;
            const crossAxis = vertical ? "width" : "height";
            const crossAxisValue = propRectRef.current[crossAxis];
            style[crossAxis] = crossAxisValue ? addUnitPx(crossAxisValue) : "";
        }
        return style;
    });
    return React50.createElement(View, _object_spread({
        ref: rootRef,
        className: (0, import_classnames34.default)(prefixClassname("swiper"), className)
    }, restProps), React50.createElement(swiper_context_default.Provider, {
        value: {
            lazyRender,
            loop,
            direction,
            indicator: activeIndicatorRef.current,
            getSize,
            count,
            itemInstances
        }
    }, isInit && React50.createElement(React50.Fragment, null, React50.createElement(View, {
        className: (0, import_classnames34.default)(prefixClassname("swiper__track"), {
            [prefixClassname("swiper__track--vertical")]: vertical
        }),
        catchMove: stopPropagation2,
        onTouchStart,
        onTouchMove,
        onTouchEnd,
        onTouchCancel: onTouchEnd,
        style: trackStyle,
        children: items
    }), indicator)));
}
var swiper_default = Swiper;
// node_modules/@taroify/core/swiper/index.js
var Swiper2 = swiper_default;
Swiper2.Item = SwiperItem;
Swiper2.Indicator = SwiperIndicator;
var swiper_default2 = Swiper2;
// node_modules/@taroify/core/tabs/tab-pane-base.js
var import_classnames35 = __toESM(require_classnames());
var React51 = __toESM(require_react());
var import_react73 = __toESM(require_react());
// node_modules/@taroify/core/tabs/tabs.context.js
var import_react72 = __toESM(require_react());
var TabsContext = (0, import_react72.createContext)({
    value: void 0,
    lazyRender: true,
    animated: false,
    swipeable: false,
    swipeThreshold: 5,
    tabObjects: []
});
var tabs_context_default = TabsContext;
// node_modules/@taroify/core/tabs/tab-pane-base.js
function TabPaneBase(props) {
    const { className, style, index, value, children: children2, title } = props, restProps = _object_without_properties(props, [
        "className",
        "style",
        "index",
        "value",
        "children",
        "title"
    ]);
    const { value: activeValue, lazyRender, animated, swipeable } = (0, import_react73.useContext)(tabs_context_default);
    const active = activeValue === value;
    const initializedRef = (0, import_react73.useRef)(false);
    const shouldRender = (0, import_react73.useMemo)(()=>{
        if (!lazyRender) {
            return true;
        }
        if (initializedRef.current) {
            return true;
        }
        if (active && !initializedRef.current) {
            initializedRef.current = true;
        }
        return active;
    }, [
        active,
        lazyRender
    ]);
    const tabPane = React51.createElement(View, _object_spread({
        style: _object_spread_props(_object_spread({}, style), {
            display: !(animated || swipeable) && !active ? "none" : ""
        }),
        className: (0, import_classnames35.default)(prefixClassname("tabs__tab-pane"), className),
        children: shouldRender ? children2 : void 0
    }, restProps));
    if (animated || swipeable) {
        return React51.createElement(swiper_default2.Item, {
            className: (0, import_classnames35.default)(prefixClassname("tabs__tab-pane-wrapper"), {
                [prefixClassname("tabs__tab-pane-wrapper--inactive")]: !active
            }),
            children: tabPane
        });
    }
    return tabPane;
}
// node_modules/@taroify/core/tabs/tabs-content.js
function useTabPanes(tabObjects) {
    return (0, import_react74.useMemo)(()=>(0, import_map8.default)(tabObjects, (props)=>React52.createElement(TabPaneBase, _object_spread({}, props))), [
        tabObjects
    ]);
}
function TabsContent(props) {
    const { value: activeValue, duration, animated, swipeable, tabObjects, onTabChange } = props;
    const activeIndex = (0, import_react74.useMemo)(()=>{
        var _this;
        return (_this = (0, import_find3.default)(tabObjects, (tab)=>tab.value === activeValue)) === null || _this === void 0 ? void 0 : _this.index;
    }, [
        activeValue,
        tabObjects
    ]);
    const panes = useTabPanes(tabObjects);
    function onSwiperChange(index) {
        const tabObject = (0, import_get5.default)(tabObjects, index);
        if (tabObject) {
            const { value, title, disabled } = tabObject;
            if (!disabled) {
                onTabChange === null || onTabChange === void 0 ? void 0 : onTabChange({
                    value,
                    title,
                    disabled
                });
            }
        }
    }
    const childrenRender = useRendered(()=>{
        if (animated || swipeable) {
            return React52.createElement(swiper_default2, {
                value: activeIndex,
                loop: false,
                className: prefixClassname("tabs__track"),
                duration,
                touchable: swipeable,
                children: panes,
                stopPropagation: false,
                onChange: onSwiperChange
            });
        }
        return panes;
    });
    return React52.createElement(View, {
        className: (0, import_classnames36.default)(prefixClassname("tabs__content"), {
            [prefixClassname("tabs__content--animated")]: animated
        }),
        children: childrenRender
    });
}
// node_modules/@taroify/core/tabs/tabs-header.js
var import_classnames40 = __toESM(require_classnames());
var import_findIndex2 = __toESM(require_findIndex());
var import_isEmpty8 = __toESM(require_isEmpty());
var import_size6 = __toESM(require_size());
var import_map9 = __toESM(require_map());
var React56 = __toESM(require_react());
var import_react77 = __toESM(require_react());
// node_modules/@taroify/core/tabs/tab.js
var import_classnames39 = __toESM(require_classnames());
var React55 = __toESM(require_react());
// node_modules/@taroify/core/badge/badge.js
var import_classnames37 = __toESM(require_classnames());
var import_isNumber9 = __toESM(require_isNumber());
var import_toString = __toESM(require_toString());
var import_gt = __toESM(require_gt());
var React53 = __toESM(require_react());
var import_react75 = __toESM(require_react());
function Badge(props) {
    const { className, content: contentProp, max, dot: dotProp, position = "top-right", children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "content",
        "max",
        "dot",
        "position",
        "children"
    ]);
    const hasChildren = children2 !== void 0;
    const dot = contentProp === true || dotProp;
    const content = (0, import_react75.useMemo)(()=>(0, import_isNumber9.default)(contentProp) ? (0, import_toString.default)((0, import_gt.default)(contentProp, max) ? `${max}+` : contentProp) : contentProp, [
        contentProp,
        max
    ]);
    const badge = React53.createElement(View, _object_spread({
        className: (0, import_classnames37.default)(prefixClassname("badge__badge"), {
            [prefixClassname("badge--dot")]: dot,
            [prefixClassname("badge--content")]: content,
            [prefixClassname("badge--fixed")]: hasChildren,
            [prefixClassname("badge--top-left")]: position === "top-left",
            [prefixClassname("badge--top-right")]: position === "top-right",
            [prefixClassname("badge--bottom-left")]: position === "bottom-left",
            [prefixClassname("badge--bottom-right")]: position === "bottom-right"
        }, !hasChildren && className),
        children: !dot && content
    }, restProps));
    if (isElementOf(contentProp, Badge)) {
        return (0, import_react75.cloneElement)(contentProp, {
            className,
            children: children2
        });
    }
    if (hasChildren) {
        return React53.createElement(View, {
            className: (0, import_classnames37.default)(prefixClassname("badge-wrapper"), className)
        }, children2, (dot || content) && badge);
    }
    return badge;
}
var badge_default = Badge;
// node_modules/@taroify/core/badge/index.js
var badge_default2 = badge_default;
// node_modules/@taroify/core/tabs/tabs-line.js
var import_classnames38 = __toESM(require_classnames());
var React54 = __toESM(require_react());
var import_react76 = __toESM(require_react());
function TabsLine(props) {
    const { active } = props;
    const { duration } = (0, import_react76.useContext)(tabs_context_default);
    return React54.createElement(View, {
        className: (0, import_classnames38.default)(prefixClassname("tabs__line"), {
            [prefixClassname("tabs__line--active")]: active
        }),
        style: {
            transitionDuration: `${duration}ms`
        }
    });
}
// node_modules/@taroify/core/tabs/tab.js
function Tab(props) {
    const { className, active, disabled = false, underline, ellipsis, flexBasis, dot, badge, children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "active",
        "disabled",
        "underline",
        "ellipsis",
        "flexBasis",
        "dot",
        "badge",
        "children"
    ]);
    return React55.createElement(View, _object_spread({
        style: {
            flexBasis
        },
        className: (0, import_classnames39.default)(prefixClassname("tabs__tab"), {
            [prefixClassname("tabs__tab--active")]: active,
            [prefixClassname("tabs__tab--disabled")]: disabled
        }, className)
    }, restProps), React55.createElement(badge_default2, {
        dot,
        content: badge
    }, React55.createElement(View, {
        className: (0, import_classnames39.default)(prefixClassname("tabs__tab__content"))
    }, React55.createElement(View, {
        className: (0, import_classnames39.default)({
            [prefixClassname("tabs__tab__content-ellipsis")]: ellipsis
        })
    }, children2))), underline && React55.createElement(TabsLine, {
        active
    }));
}
// node_modules/@taroify/core/tabs/tabs-header.js
function TabsHeader(props) {
    const { value: activeValue, theme, ellipsis, bordered, shrink, tabObjects, swipeThreshold, onTabClick } = props;
    const themeLine = theme === "line";
    const themeCard = theme === "card";
    const navRef = (0, import_react77.useRef)();
    const [navOffset, setNavOffset] = (0, import_react77.useState)({});
    const [tabOffsets, setTabOffsets] = (0, import_react77.useState)([]);
    const activeIndex = (0, import_react77.useMemo)(()=>(0, import_findIndex2.default)(tabObjects, (tab)=>tab.value === activeValue), [
        tabObjects,
        activeValue
    ]);
    const activeOffset = (0, import_react77.useMemo)(()=>{
        if ((0, import_isEmpty8.default)(tabOffsets) || activeIndex === -1 || activeIndex >= (0, import_size6.default)(tabOffsets)) {
            return {};
        }
        const { width } = tabOffsets[activeIndex];
        const left = tabOffsets.slice(0, activeIndex).reduce((prev, curr)=>{
            var _curr_width;
            return prev + ((_curr_width = curr.width) !== null && _curr_width !== void 0 ? _curr_width : 0);
        }, 0);
        return {
            left,
            width
        };
    }, [
        tabOffsets,
        activeIndex
    ]);
    const scrollLeft = (0, import_react77.useMemo)(()=>{
        if (navOffset) {
            const { width: navOffsetWidth = 0 } = navOffset;
            const { left: offsetLeft = 0, width: offsetWidth = 0 } = activeOffset;
            return offsetLeft - (navOffsetWidth - offsetWidth) / 2;
        }
        return 0;
    }, [
        navOffset,
        activeOffset
    ]);
    const resize = (0, import_react77.useCallback)(()=>{
        Promise.all([
            getRect(navRef),
            getRects(navRef, ` .${prefixClassname("tabs__tab")}`)
        ]).then(([navRect, tabRects])=>{
            setNavOffset(navRect);
            setTabOffsets(tabRects);
        });
    }, []);
    const flexBasis = (0, import_react77.useMemo)(()=>{
        if (shrink) return "";
        return ellipsis && themeLine ? `${88 / swipeThreshold}%` : "";
    }, [
        ellipsis,
        themeLine,
        swipeThreshold,
        shrink
    ]);
    (0, import_react77.useEffect)(()=>nextTick(resize), [
        resize,
        tabObjects
    ]);
    (0, import_react77.useEffect)(()=>{
        onWindowResize === null || onWindowResize === void 0 ? void 0 : onWindowResize(resize);
        return ()=>offWindowResize === null || offWindowResize === void 0 ? void 0 : offWindowResize(resize);
    }, [
        resize
    ]);
    return React56.createElement(View, {
        className: (0, import_classnames40.default)(prefixClassname("tabs__wrap"), prefixClassname("tabs__wrap--scrollable"), {
            [HAIRLINE_BORDER_TOP_BOTTOM]: bordered && themeLine
        })
    }, React56.createElement(ScrollView, {
        enhanced: true,
        showScrollbar: false,
        scrollX: tabObjects.length > swipeThreshold || !ellipsis,
        scrollWithAnimation: true,
        scrollLeft,
        className: (0, import_classnames40.default)(prefixClassname("tabs__wrap__scroll"), {
            [prefixClassname("tabs__wrap__scroll--line")]: themeLine,
            [prefixClassname("tabs__wrap__scroll--card")]: themeCard,
            [prefixClassname("tabs__wrap__scroll--shrink")]: shrink && themeCard
        })
    }, React56.createElement(View, {
        ref: navRef,
        className: (0, import_classnames40.default)(prefixClassname("tabs__nav"), {
            [prefixClassname("tabs__nav--line")]: themeLine,
            [prefixClassname("tabs__nav--card")]: themeCard
        })
    }, (0, import_map9.default)(tabObjects, (tabObject)=>{
        var _tabObject_classNames;
        return React56.createElement(Tab, {
            key: tabObject.key,
            flexBasis,
            className: (0, import_classnames40.default)(tabObject === null || tabObject === void 0 ? void 0 : (_tabObject_classNames = tabObject.classNames) === null || _tabObject_classNames === void 0 ? void 0 : _tabObject_classNames.title, {
                [prefixClassname("tabs__tab--shrink")]: shrink
            }),
            dot: tabObject.dot,
            badge: tabObject.badge,
            active: activeValue === tabObject.value,
            disabled: tabObject.disabled,
            underline: themeLine,
            ellipsis: themeLine && ellipsis,
            children: tabObject.title,
            onClick: ()=>onTabClick === null || onTabClick === void 0 ? void 0 : onTabClick({
                    value: tabObject.value,
                    title: tabObject.title,
                    disabled: tabObject.disabled
                })
        });
    }))));
}
// node_modules/@taroify/core/tabs/tabs.js
function useTabObjects(children2) {
    return (0, import_react78.useMemo)(()=>{
        const tabObjects = [];
        import_react78.Children.forEach(children2, (node)=>{
            if (!(0, import_react78.isValidElement)(node)) {
                return node;
            }
            const element = node;
            if (element.type !== TabPane) {
                return element;
            }
            const { key, props } = element;
            const index = (0, import_size7.default)(tabObjects);
            const { value } = props, restProps = _object_without_properties(props, [
                "value"
            ]);
            tabObjects.push(_object_spread({
                key: key !== null && key !== void 0 ? key : index,
                index,
                value: value !== null && value !== void 0 ? value : index
            }, restProps));
        });
        return tabObjects;
    }, [
        children2
    ]);
}
function useTabsSticky(sticky) {
    if (sticky === false) {
        return void 0;
    }
    if ((0, import_isBoolean4.default)(sticky) && sticky) {
        return {
            offsetTop: 0
        };
    }
    return sticky;
}
function Tabs(props) {
    const { className, defaultValue, value: valueProp, duration = 300, lazyRender = true, animated = false, swipeable = false, sticky = false, theme = "line", ellipsis = true, bordered, swipeThreshold = 5, children: childrenProp, shrink, onTabClick, onChange, onScroll } = props, restProps = _object_without_properties(props, [
        "className",
        "defaultValue",
        "value",
        "duration",
        "lazyRender",
        "animated",
        "swipeable",
        "sticky",
        "theme",
        "ellipsis",
        "bordered",
        "swipeThreshold",
        "children",
        "shrink",
        "onTabClick",
        "onChange",
        "onScroll"
    ]);
    const { value = 0, getValue, setValue } = useUncontrolled({
        defaultValue,
        value: valueProp
    });
    const rootRef = (0, import_react78.useRef)();
    const stickyProps = useTabsSticky(sticky);
    const tabObjects = useTabObjects(childrenProp);
    const index = (0, import_react78.useMemo)(()=>{
        for (const tab of tabObjects){
            if (tab.value === value) {
                return tab.index;
            }
        }
    }, [
        tabObjects,
        value
    ]);
    const onTabChange = (0, import_react78.useCallback)((event)=>{
        if (!event.disabled) {
            if (getValue() !== event.value) {
                onChange === null || onChange === void 0 ? void 0 : onChange(event.value, event);
                setValue(event.value);
            }
        }
    }, [
        getValue,
        onChange,
        setValue
    ]);
    const handleTabClick = (0, import_react78.useCallback)((event)=>{
        onTabClick === null || onTabClick === void 0 ? void 0 : onTabClick(event);
        onTabChange(event);
    }, [
        onTabChange,
        onTabClick
    ]);
    const headerRender = (0, import_react78.useMemo)(()=>React57.createElement(TabsHeader, {
            value,
            theme,
            bordered,
            ellipsis,
            shrink,
            tabObjects,
            swipeThreshold,
            onTabClick: handleTabClick
        }), [
        bordered,
        ellipsis,
        handleTabClick,
        tabObjects,
        theme,
        value,
        swipeThreshold
    ]);
    return React57.createElement(tabs_context_default.Provider, {
        value: {
            index,
            value,
            duration,
            lazyRender,
            animated,
            swipeable,
            theme,
            ellipsis,
            bordered,
            tabObjects,
            swipeThreshold
        }
    }, React57.createElement(View, _object_spread({
        ref: rootRef,
        className: (0, import_classnames41.default)(prefixClassname("tabs"), {
            [prefixClassname("tabs--line")]: theme === "line",
            [prefixClassname("tabs--card")]: theme === "card"
        }, className)
    }, restProps), stickyProps ? React57.createElement(sticky_default, {
        container: rootRef,
        offsetTop: stickyProps.offsetTop,
        children: headerRender,
        onScroll
    }) : headerRender, React57.createElement(TabsContent, {
        value,
        lazyRender,
        duration,
        animated,
        swipeable,
        tabObjects,
        onTabChange
    })));
}
var tabs_default = Tabs;
// node_modules/@taroify/core/tabs/index.js
var Tabs2 = tabs_default;
Tabs2.TabPane = TabPane;
var tabs_default2 = Tabs2;
// node_modules/@taroify/core/cascader/cascader-header.js
var import_classnames42 = __toESM(require_classnames());
var React58 = __toESM(require_react());
function CascaderHeader(props) {
    const { className } = props, restProps = _object_without_properties(props, [
        "className"
    ]);
    return React58.createElement(View, _object_spread({
        className: (0, import_classnames42.default)(prefixClassname("cascader__header"), className)
    }, restProps));
}
var cascader_header_default = CascaderHeader;
// node_modules/@taroify/core/cascader/cascader-option.js
var React59 = __toESM(require_react());
function CascaderOption() {
    return React59.createElement(React59.Fragment, null);
}
var cascader_option_default = CascaderOption;
// node_modules/@taroify/core/cascader/cascader-option-base.js
var import_classnames43 = __toESM(require_classnames());
var React60 = __toESM(require_react());
function CascaderOptionBase(props) {
    const { className, active, disabled, children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "active",
        "disabled",
        "children"
    ]);
    return React60.createElement(View, _object_spread({
        className: (0, import_classnames43.default)(prefixClassname("cascader__option"), {
            [prefixClassname("cascader__option--active")]: active,
            [prefixClassname("cascader__option--disabled")]: disabled
        }, className),
        hoverClass: prefixClassname("cascader__option--hover")
    }, restProps), React60.createElement(View, null, children2), active && React60.createElement(Success_default, {
        className: prefixClassname("cascader__active-icon")
    }));
}
var cascader_option_base_default = CascaderOptionBase;
// node_modules/@taroify/core/cascader/cascader-tab.js
var React61 = __toESM(require_react());
function CascaderTab(props) {
    return React61.createElement(React61.Fragment, null);
}
var cascader_tab_default = CascaderTab;
// node_modules/@taroify/core/cascader/cascader.shared.js
var import_get6 = __toESM(require_get());
function isActiveOption(option, values2) {
    return (0, import_get6.default)(values2, option.tabIndex) === option.value;
}
// node_modules/@taroify/core/cascader/cascader.js
function getCascaderOptions(children2, tabIndex) {
    const options = [];
    import_react79.Children.forEach(children2, (child)=>{
        if ((0, import_react79.isValidElement)(child)) {
            const element = child;
            const { key, props, type } = element;
            const { value } = props, restProps = _object_without_properties(props, [
                "value"
            ]);
            if (type === cascader_option_default) {
                const index = (0, import_size8.default)(options);
                options.push(_object_spread({
                    key: key !== null && key !== void 0 ? key : index,
                    tabIndex,
                    value: value !== null && value !== void 0 ? value : index
                }, restProps));
            }
        }
    });
    return options;
}
function useCascaderChildren(children2) {
    return (0, import_react79.useMemo)(()=>{
        const __children__ = {
            header: void 0,
            tabs: []
        };
        import_react79.Children.forEach(children2, (child)=>{
            if ((0, import_react79.isValidElement)(child)) {
                const element = child;
                const { props, type } = element;
                if (type === cascader_header_default) {
                    __children__.header = element;
                } else if (type === cascader_tab_default) {
                    const { children: children3 } = props;
                    __children__.tabs.push({
                        options: getCascaderOptions(children3, (0, import_size8.default)(__children__.tabs))
                    });
                }
            }
        });
        return __children__;
    }, [
        children2
    ]);
}
var defaultFieldNames3 = {
    label: "label",
    value: "value",
    children: "children"
};
function Cascader(props) {
    const { className, defaultValue, value: valueProp, placeholder = "\u8BF7\u9009\u62E9", title, loadData, fieldNames: _fieldNames, animated = true, swipeable = false, ellipsis = true, children: childrenProp, options, onChange, onSelect, onTabClick } = props;
    const [colRefreshKey, refreshKey] = (0, import_react79.useReducer)((state)=>state + 1, 0);
    const { value: values2 = [], setValue: setValues } = useUncontrolled({
        defaultValue,
        value: valueProp
    });
    const fieldNames = (0, import_react79.useMemo)(()=>{
        if (!(0, import_isEmpty9.default)(_fieldNames) && (0, import_isObject4.default)(_fieldNames)) {
            return Object.assign(_object_spread({}, defaultFieldNames3), _fieldNames);
        }
        return defaultFieldNames3;
    }, [
        _fieldNames
    ]);
    const { columns } = use_cascader_default({
        options,
        value: values2,
        fieldNames,
        refreshKey: colRefreshKey
    });
    const { header: _header, tabs: _tab } = useCascaderChildren(childrenProp);
    const header = (0, import_react79.useMemo)(()=>title ? React62.createElement(cascader_header_default, null, title) : _header, [
        title,
        _header
    ]);
    const [tabs, tabsMap] = (0, import_react79.useMemo)(()=>{
        let ret;
        const cache = /* @__PURE__ */ new Map();
        if (columns.length > 0) {
            ret = columns.map((column, idx)=>({
                    options: column.map((item)=>({
                            children: item[fieldNames.label],
                            key: item[fieldNames.value],
                            value: item[fieldNames.value],
                            disabled: item.disabled,
                            tabIndex: idx
                        }))
                }));
        } else {
            ret = _tab;
        }
        ret.forEach((r)=>{
            var _r_options;
            return (_r_options = r.options) === null || _r_options === void 0 ? void 0 : _r_options.forEach((rr)=>cache.set(rr.value, rr));
        });
        return [
            ret,
            cache
        ];
    }, [
        columns,
        _tab,
        fieldNames
    ]);
    const [activeTab, setActiveTab] = (0, import_react79.useState)(0);
    const renderedTabs = (0, import_react79.useMemo)(()=>(0, import_slice.default)(tabs, 0, (0, import_size8.default)(values2) + 1), [
        tabs,
        values2
    ]);
    const renderedOptions = (0, import_react79.useMemo)(()=>values2.map((item)=>tabsMap.get(item)), [
        tabsMap,
        values2
    ]);
    const emitChange = useMemoizedFn(function() {
        var _ref = _async_to_generator(function*(newValues) {
            const newActiveOptions = newValues.map((item)=>tabsMap.get(item));
            onSelect === null || onSelect === void 0 ? void 0 : onSelect(newValues, newActiveOptions);
            if (!(0, import_isEqual5.default)(newValues, valueProp)) {
                if (columns.length > 0) {
                    let children2;
                    if (loadData) {
                        children2 = yield loadData(newValues.slice(), newActiveOptions.slice());
                        const level = newValues.length - 1;
                        const selected = columns[level].find((item)=>item[fieldNames.value] === newValues[level]);
                        if (selected) {
                            selected[fieldNames.children] = children2;
                        }
                    } else {
                        const last = columns[newValues.length - 1].find((item)=>item[fieldNames.value] === newValues[newValues.length - 1]);
                        children2 = last === null || last === void 0 ? void 0 : last[fieldNames.children];
                    }
                    if (!children2 || children2.length === 0) {
                        onChange === null || onChange === void 0 ? void 0 : onChange(newValues, newActiveOptions);
                    } else {
                        nextTick(()=>{
                            refreshKey();
                            setActiveTab((prev)=>prev + 1);
                        });
                    }
                } else {
                    if ((0, import_size8.default)(tabs) === (0, import_size8.default)(newValues)) {
                        onChange === null || onChange === void 0 ? void 0 : onChange(newValues, newActiveOptions);
                    } else {
                        nextTick(()=>{
                            setActiveTab((prev)=>prev + 1);
                        });
                    }
                }
            }
        });
        return function(newValues) {
            return _ref.apply(this, arguments);
        };
    }());
    const handleSelect = useMemoizedFn((option)=>{
        const { disabled, tabIndex, value } = option;
        if (disabled) {
            return;
        }
        const newValues = (0, import_slice.default)(values2, 0, tabIndex + 1);
        newValues[tabIndex] = value;
        setValues(newValues);
        emitChange(newValues.slice());
    });
    const panes = (0, import_react79.useMemo)(()=>(0, import_map10.default)(renderedTabs, (tab, index)=>{
            var _this, _this1;
            var _children;
            return React62.createElement(tabs_default2.TabPane, {
                key: index,
                value: index,
                title: (_children = (_this = (0, import_get7.default)(renderedOptions, index)) === null || _this === void 0 ? void 0 : _this.children) !== null && _children !== void 0 ? _children : placeholder,
                classNames: {
                    title: (0, import_classnames44.default)(prefixClassname("cascader__tab"), {
                        [prefixClassname("cascader__tab--inactive")]: (0, import_isEmpty9.default)((_this1 = (0, import_get7.default)(renderedOptions, index)) === null || _this1 === void 0 ? void 0 : _this1.children)
                    })
                }
            }, React62.createElement(ScrollView, {
                scrollY: true,
                className: prefixClassname("cascader__options")
            }, (0, import_map10.default)(tab.options, (option)=>{
                const { onClick, value, children: children2 } = option, restProps = _object_without_properties(option, [
                    "onClick",
                    "value",
                    "children"
                ]);
                return React62.createElement(cascader_option_base_default, _object_spread_props(_object_spread({}, restProps), {
                    children: children2 !== null && children2 !== void 0 ? children2 : value,
                    onClick: (event)=>{
                        onClick === null || onClick === void 0 ? void 0 : onClick(event);
                        handleSelect(option);
                    },
                    active: isActiveOption(option, values2)
                }));
            })));
        }), [
        renderedOptions,
        renderedTabs,
        handleSelect,
        placeholder,
        values2
    ]);
    return React62.createElement(View, {
        className: (0, import_classnames44.default)(prefixClassname("cascader"), className)
    }, header, React62.createElement(tabs_default2, {
        className: prefixClassname("cascader__tabs"),
        value: activeTab,
        animated,
        swipeable,
        onChange: (value)=>setActiveTab(value),
        onTabClick,
        children: panes,
        ellipsis
    }));
}
var cascader_default = Cascader;
// node_modules/@taroify/core/cascader/index.js
var Cascader2 = cascader_default;
Cascader2.Header = cascader_header_default;
Cascader2.Tab = cascader_tab_default;
Cascader2.Option = cascader_option_default;
var cascader_default2 = Cascader2;
// node_modules/@taroify/core/calendar/calendar.js
var import_classnames48 = __toESM(require_classnames());
var import_filter2 = __toESM(require_filter());
var import_size9 = __toESM(require_size());
var import_isDate = __toESM(require_isDate());
var import_map14 = __toESM(require_map());
var React69 = __toESM(require_react());
var import_react87 = __toESM(require_react());
// node_modules/@taroify/core/utils/dom/scroll.js
var defaultRoot = inBrowser ? window : void 0;
var ELEMENT_NODE_TYPE2 = 1;
var overflowScrollReg = /scroll|auto/i;
function isElementNode(node) {
    return node.tagName !== "HTML" && node.tagName !== "BODY" && node.nodeType === ELEMENT_NODE_TYPE2;
}
function getScrollParent(elementOrRef) {
    return _getScrollParent.apply(this, arguments);
}
function _getScrollParent() {
    _getScrollParent = _async_to_generator(function*(elementOrRef, root = defaultRoot) {
        let node = elementUnref(elementOrRef);
        while(node && node !== root && isElementNode(node)){
            const { overflowY } = yield getComputedStyle(node, [
                "overflowY"
            ]);
            if (overflowScrollReg.test(overflowY)) {
                return node;
            }
            if (isRootElement(node)) {
                return node;
            }
            node = node.parentNode;
        }
        return root;
    });
    return _getScrollParent.apply(this, arguments);
}
function makeScrollOffset() {
    return {
        scrollTop: 0,
        scrollLeft: 0
    };
}
function getScrollOffset(elementOrRef) {
    const element = elementUnref(elementOrRef);
    if (element) {
        if (inBrowser) {
            const $element = element;
            const top = "scrollTop" in element ? $element.scrollTop : $element["pageYOffset"];
            const left = "scrollLeft" in element ? $element.scrollLeft : $element["pageXOffset"];
            return Promise.resolve({
                scrollTop: Math.max(top, 0),
                scrollLeft: Math.max(left, 0)
            });
        }
        return new Promise((resolve)=>{
            queryNodesRef(element).scrollOffset(resolve).exec();
        });
    }
    return Promise.resolve(makeScrollOffset());
}
function getScrollTop(elementOrRef) {
    return getScrollOffset(elementOrRef).then(({ scrollTop })=>scrollTop);
}
// node_modules/@taroify/core/calendar/calendar-footer.js
var import_classnames46 = __toESM(require_classnames());
var React64 = __toESM(require_react());
var import_react83 = __toESM(require_react());
// node_modules/@taroify/core/calendar/calendar-button.js
var import_classnames45 = __toESM(require_classnames());
var React63 = __toESM(require_react());
var import_react82 = __toESM(require_react());
// node_modules/@taroify/core/calendar/calendar.context.js
var import_react81 = __toESM(require_react());
// node_modules/@taroify/core/datetime-picker/datetime-picker.shared.js
var import_isUndefined10 = __toESM(require_isUndefined());
var import_clamp5 = __toESM(require_clamp());
var import_slice2 = __toESM(require_slice());
var import_isEmpty10 = __toESM(require_isEmpty());
var import_concat = __toESM(require_concat());
var import_map11 = __toESM(require_map());
var import_react80 = __toESM(require_react());
var CURRENT_YEAR = /* @__PURE__ */ new Date().getFullYear();
var MIN_DATE = new Date(CURRENT_YEAR - 10, 0, 1, 0, 0, 0);
var MAX_DATE = new Date(CURRENT_YEAR + 10, 11, 31, 59, 59, 59);
function getEndDayOfMonth(year, month) {
    return 32 - new Date(year, month - 1, 32).getDate();
}
function clampDate(value, minDate, maxDate) {
    if ((0, import_isUndefined10.default)(value)) {
        return minDate !== null && minDate !== void 0 ? minDate : maxDate;
    }
    const timestamp = (0, import_clamp5.default)(value.getTime(), minDate.getTime(), maxDate.getTime());
    return new Date(timestamp);
}
function getDatetime(date) {
    return [
        date.getFullYear(),
        date.getMonth() + 1,
        date.getDate(),
        date.getHours(),
        date.getMinutes(),
        date.getSeconds()
    ];
}
function getBoundaryDatetime(type, boundary, current) {
    const year = boundary.getFullYear();
    let month = 1;
    let day = 1;
    let hour = 0;
    let minute = 0;
    let second = 0;
    if (type === "max") {
        month = 12;
        day = getEndDayOfMonth(current.getFullYear(), current.getMonth() + 1);
        hour = 23;
        minute = 59;
        second = 59;
    }
    if (current.getFullYear() === year) {
        month = boundary.getMonth() + 1;
        if (current.getMonth() + 1 === month) {
            day = boundary.getDate();
            if (current.getDate() === day) {
                hour = boundary.getHours();
                if (current.getHours() === hour) {
                    minute = boundary.getMinutes();
                    if (current.getMinutes() === minute) {
                        second = boundary.getSeconds();
                    }
                }
            }
        }
    }
    return [
        year,
        month,
        day,
        hour,
        minute,
        second
    ];
}
function getMinDatetime(boundary, current) {
    return getBoundaryDatetime("min", boundary, current);
}
function getMaxDatetime(boundary, current) {
    return getBoundaryDatetime("max", boundary, current);
}
function useAllDatetimeRanges(date, minDate, maxDate) {
    const [minYear, minMonth, minDay, minHour, minMinute, minSecond] = getMinDatetime(minDate, date !== null && date !== void 0 ? date : minDate);
    const [maxYear, maxMonth, maxDay, maxHour, maxMinute, maxSecond] = getMaxDatetime(maxDate, date !== null && date !== void 0 ? date : minDate);
    return (0, import_react80.useMemo)(()=>[
            {
                type: "year",
                range: [
                    minYear,
                    maxYear
                ]
            },
            {
                type: "month",
                range: [
                    minMonth,
                    maxMonth
                ]
            },
            {
                type: "day",
                range: [
                    minDay,
                    maxDay
                ]
            },
            {
                type: "hour",
                range: [
                    minHour,
                    maxHour
                ]
            },
            {
                type: "minute",
                range: [
                    minMinute,
                    maxMinute
                ]
            },
            {
                type: "second",
                range: [
                    minSecond,
                    maxSecond
                ]
            }
        ], [
        maxDay,
        maxHour,
        maxMinute,
        maxMonth,
        maxSecond,
        maxYear,
        minDay,
        minHour,
        minMinute,
        minMonth,
        minSecond,
        minYear
    ]);
}
function useSpecifiedDatetimeRanges(ranges, type) {
    return (0, import_react80.useMemo)(()=>{
        switch(type){
            case "date":
                return (0, import_slice2.default)(ranges, 0, 3);
            case "time":
                return (0, import_slice2.default)(ranges, 3, 6);
            case "year-month":
                return (0, import_slice2.default)(ranges, 0, 2);
            case "month-day":
                return (0, import_slice2.default)(ranges, 1, 3);
            case "date-hour":
                return (0, import_slice2.default)(ranges, 0, 4);
            case "date-minute":
                return (0, import_slice2.default)(ranges, 0, 5);
            case "hour-minute":
                return (0, import_slice2.default)(ranges, 3, 5);
        }
        return ranges;
    }, [
        ranges,
        type
    ]);
}
function useOrderedDatetimeRanges(ranges, fields) {
    return (0, import_react80.useMemo)(()=>{
        if ((0, import_isEmpty10.default)(fields)) {
            return ranges;
        }
        const fieldsOrder = (0, import_concat.default)(fields, (0, import_map11.default)(ranges, ({ type })=>type));
        return ranges.sort((a, b)=>fieldsOrder.indexOf(a.type) - fieldsOrder.indexOf(b.type));
    }, [
        fields,
        ranges
    ]);
}
function useDatetimeRanges(date, minDate, maxDate, type, fields) {
    const allRanges = useAllDatetimeRanges(date, minDate, maxDate);
    const specifiedRanges = useSpecifiedDatetimeRanges(allRanges, type);
    return useOrderedDatetimeRanges(specifiedRanges, fields);
}
// node_modules/@taroify/core/calendar/calendar.shared.js
function compareYearMonth(date1, date2) {
    const year1 = date1 === null || date1 === void 0 ? void 0 : date1.getFullYear();
    const year2 = date2 === null || date2 === void 0 ? void 0 : date2.getFullYear();
    if (year1 === year2) {
        const month1 = date1 === null || date1 === void 0 ? void 0 : date1.getMonth();
        const month2 = date2 === null || date2 === void 0 ? void 0 : date2.getMonth();
        return month1 === month2 ? 0 : month1 > month2 ? 1 : -1;
    }
    return year1 > year2 ? 1 : -1;
}
function compareDate(day1, day2) {
    const compareMonthResult = compareYearMonth(day1, day2);
    if (compareMonthResult === 0) {
        const date1 = day1 === null || day1 === void 0 ? void 0 : day1.getDate();
        const date2 = day2 === null || day2 === void 0 ? void 0 : day2.getDate();
        return date1 === date2 ? 0 : date1 > date2 ? 1 : -1;
    }
    return compareMonthResult;
}
var cloneDate = (date)=>new Date(date);
function createDayByOffset(date, offset) {
    const cloned = cloneDate(date);
    cloned.setDate(cloned.getDate() + offset);
    return cloned;
}
var createPreviousDay = (date)=>createDayByOffset(date, -1);
var createNextDay = (date)=>createDayByOffset(date, 1);
function createToday() {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    return today;
}
var MIN_DATE2 = createToday();
var MAX_DATE2 = new Date(MIN_DATE2.getFullYear(), MIN_DATE2.getMonth() + 6, 14);
var genMonthId = (date)=>`taroify-calendar-${date.getFullYear()}-${date.getMonth()}`;
// node_modules/@taroify/core/calendar/calendar.context.js
var CalendarContext = (0, import_react81.createContext)({
    type: "single",
    firstDayOfWeek: 0,
    min: MIN_DATE2,
    max: MAX_DATE2
});
var calendar_context_default = CalendarContext;
// node_modules/@taroify/core/calendar/calendar-button.js
function CalendarButton(props) {
    const { className, confirmText, confirmDisabledText, type = "confirm", children: children2 = "\u786E\u5B9A", onClick } = props, restProps = _object_without_properties(props, [
        "className",
        "confirmText",
        "confirmDisabledText",
        "type",
        "children",
        "onClick"
    ]);
    const confirm = type === "confirm";
    const { value: currentValue, type: ctxType, onConfirm } = (0, import_react82.useContext)(calendar_context_default);
    const disabled = (0, import_react82.useMemo)(()=>{
        if (currentValue) {
            if (ctxType === "range") {
                return !currentValue[0] || !currentValue[1];
            }
            if (ctxType === "multiple") {
                return !currentValue.length;
            }
        }
        return Array.isArray(currentValue) ? currentValue.length === 0 : !currentValue;
    }, [
        ctxType,
        currentValue
    ]);
    return React63.createElement(button_default, _object_spread({
        className: (0, import_classnames45.default)({
            [prefixClassname("calendar__confirm")]: confirm
        }, className),
        shape: "round",
        block: true,
        disabled: confirm && disabled,
        color: "primary",
        onClick: (event)=>{
            onClick === null || onClick === void 0 ? void 0 : onClick(event);
            if (confirm && !disabled) {
                onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm();
            }
        }
    }, restProps), props.children ? children2 : disabled ? confirmDisabledText : confirmText);
}
CalendarButton.defaultProps = {
    type: "confirm"
};
var calendar_button_default = CalendarButton;
// node_modules/@taroify/core/calendar/calendar-footer.js
function CalendarFooter(props) {
    const { className, children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "children"
    ]);
    const { notifyConfirm } = (0, import_react83.useContext)(calendar_context_default);
    (0, import_react83.useEffect)(()=>{
        let hasConfirm = false;
        import_react83.Children.forEach(children2, (child)=>{
            if (hasConfirm) {
                return;
            }
            if ((0, import_react83.isValidElement)(child)) {
                const element = child;
                const { type: elementType, props: props2 } = element;
                if (elementType === calendar_button_default) {
                    const button = props2;
                    if (button.type === "confirm") {
                        hasConfirm = true;
                    }
                }
            }
        });
        notifyConfirm === null || notifyConfirm === void 0 ? void 0 : notifyConfirm(hasConfirm);
    }, [
        children2,
        notifyConfirm
    ]);
    return React64.createElement(View, _object_spread({
        className: (0, import_classnames46.default)(prefixClassname("calendar__footer"), className),
        children: children2
    }, restProps));
}
var calendar_footer_default = CalendarFooter;
// node_modules/@taroify/core/calendar/calendar-header.js
var React66 = __toESM(require_react());
var import_isFunction5 = __toESM(require_isFunction());
// node_modules/@taroify/core/calendar/calendar-weekdays.js
var import_map12 = __toESM(require_map());
var React65 = __toESM(require_react());
var import_react84 = __toESM(require_react());
function CalendarWeekdays() {
    const { firstDayOfWeek } = (0, import_react84.useContext)(calendar_context_default);
    const weekdays = [
        "\u65E5",
        "\u4E00",
        "\u4E8C",
        "\u4E09",
        "\u56DB",
        "\u4E94",
        "\u516D"
    ];
    const renderWeekdays = [
        ...weekdays.slice(firstDayOfWeek, 7),
        ...weekdays.slice(0, firstDayOfWeek)
    ];
    return React65.createElement(View, {
        className: prefixClassname("calendar__weekdays")
    }, (0, import_map12.default)(renderWeekdays, (day)=>React65.createElement(View, {
            className: prefixClassname("calendar__weekday"),
            key: day,
            children: day
        })));
}
var calendar_weekdays_default = CalendarWeekdays;
// node_modules/@taroify/core/calendar/calendar-header.js
function CalendarHeader(props) {
    const { title, subtitle, showSubtitle, date } = props;
    return React66.createElement(View, {
        className: prefixClassname("calendar__header")
    }, React66.createElement(View, {
        className: prefixClassname("calendar__header-title")
    }, title), showSubtitle && React66.createElement(View, {
        className: prefixClassname("calendar__header-subtitle")
    }, (0, import_isFunction5.default)(subtitle) ? date ? subtitle(date) : "" : subtitle), React66.createElement(calendar_weekdays_default, null));
}
var calendar_header_default = CalendarHeader;
// node_modules/@taroify/core/calendar/calendar-month.js
var import_some = __toESM(require_some());
var import_map13 = __toESM(require_map());
var React68 = __toESM(require_react());
var import_react86 = __toESM(require_react());
// node_modules/@taroify/core/calendar/calendar-day.js
var import_classnames47 = __toESM(require_classnames());
var React67 = __toESM(require_react());
var import_react85 = __toESM(require_react());
function CalendarDay(props) {
    const { className, style, type, value, top, bottom, children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "style",
        "type",
        "value",
        "top",
        "bottom",
        "children"
    ]);
    const { type: ctxType, onDayClick } = (0, import_react85.useContext)(calendar_context_default);
    const single = ctxType === "single";
    const disabled = type === "disabled";
    const onClick = (0, import_react85.useCallback)(()=>{
        if (!disabled) {
            onDayClick === null || onDayClick === void 0 ? void 0 : onDayClick({
                type,
                value,
                children: children2
            });
        }
    }, [
        children2,
        disabled,
        onDayClick,
        type,
        value
    ]);
    const renderContent2 = ()=>{
        if (single && type === "active") {
            return React67.createElement(React67.Fragment, null, top && React67.createElement(View, {
                className: prefixClassname("calendar__day__top"),
                children: top
            }), React67.createElement(View, {
                className: prefixClassname("calendar__active-day"),
                children: children2
            }), bottom && React67.createElement(View, {
                className: prefixClassname("calendar__day__bottom"),
                children: bottom
            }));
        }
        return React67.createElement(React67.Fragment, null, top && React67.createElement(View, {
            className: prefixClassname("calendar__day__top"),
            children: top
        }), children2, bottom && React67.createElement(View, {
            className: prefixClassname("calendar__day__bottom"),
            children: bottom
        }));
    };
    return React67.createElement(View, _object_spread({
        className: (0, import_classnames47.default)(prefixClassname("calendar__day"), {
            [prefixClassname(`calendar__day--${type}`)]: type
        }, className),
        style,
        onClick
    }, restProps), renderContent2());
}
var calendar_day_default = CalendarDay;
// node_modules/@taroify/core/calendar/calendar-month.js
function CalendarMonthWatermark(props) {
    const { children: children2 } = props;
    return React68.createElement(View, {
        className: prefixClassname("calendar__month-watermark"),
        children: children2
    });
}
function getBottom(type, dayType) {
    if (type === "range") {
        if (dayType === "start") {
            return "\u5F00\u59CB";
        }
        if (dayType === "end") {
            return "\u7ED3\u675F";
        }
        if (dayType === "active") {
            return "\u5F00\u59CB/\u7ED3\u675F";
        }
    }
}
var CalendarMonth = (0, import_react86.forwardRef)((props, ref)=>{
    const { value: monthValue = /* @__PURE__ */ new Date(), watermark, showMonthTitle } = props;
    const { type, firstDayOfWeek, min, max, value: currentValue, formatter } = (0, import_react86.useContext)(calendar_context_default);
    const monthRef = (0, import_react86.useRef)();
    const height = useHeight(monthRef);
    const month = (0, import_react86.useMemo)(()=>monthValue.getMonth() + 1, [
        monthValue
    ]);
    const id = (0, import_react86.useMemo)(()=>genMonthId(monthValue), [
        monthValue
    ]);
    const title = (0, import_react86.useMemo)(()=>`${monthValue.getFullYear()}\u5E74${monthValue.getMonth() + 1}\u6708`, [
        monthValue
    ]);
    const offset = (0, import_react86.useMemo)(()=>{
        const realDay = monthValue.getDay();
        if (firstDayOfWeek) {
            return (realDay + 7 - firstDayOfWeek) % 7;
        }
        return realDay;
    }, [
        firstDayOfWeek,
        monthValue
    ]);
    const totalDay = (0, import_react86.useMemo)(()=>getEndDayOfMonth(monthValue.getFullYear(), monthValue.getMonth() + 1), [
        monthValue
    ]);
    const getMultipleDayType = (0, import_react86.useCallback)((day)=>{
        const isActive = (date)=>(0, import_some.default)(currentValue, (item)=>compareDate(item, date) === 0);
        if (isActive(day)) {
            const prevDay = createPreviousDay(day);
            const nextDay = createNextDay(day);
            const prevActive = isActive(prevDay);
            const nextActive = isActive(nextDay);
            if (prevActive && nextActive) {
                return "middle";
            }
            if (prevActive) {
                return "end";
            }
            if (nextActive) {
                return "start";
            }
            return "active";
        }
        return "";
    }, [
        currentValue
    ]);
    const getRangeDayType = (0, import_react86.useCallback)((day)=>{
        const [startDay, endDay] = currentValue;
        if (!startDay) {
            return "";
        }
        const compareToStart = compareDate(day, startDay);
        if (!endDay) {
            return compareToStart === 0 ? "start" : "";
        }
        const compareToEnd = compareDate(day, endDay);
        if (compareToStart === 0 && compareToEnd === 0) {
            return "active";
        }
        if (compareToStart === 0) {
            return "start";
        }
        if (compareToEnd === 0) {
            return "end";
        }
        if (compareToStart > 0 && compareToEnd < 0) {
            return "middle";
        }
        return "";
    }, [
        currentValue
    ]);
    const getDayType = (0, import_react86.useCallback)((dayValue)=>{
        if (compareDate(dayValue, min) < 0 || compareDate(dayValue, max) > 0) {
            return "disabled";
        }
        if (Array.isArray(currentValue)) {
            if (type === "multiple") {
                return getMultipleDayType(dayValue);
            }
            if (type === "range") {
                return getRangeDayType(dayValue);
            }
        } else if (type === "single") {
            return compareDate(dayValue, currentValue) === 0 ? "active" : "";
        }
        return "";
    }, [
        currentValue,
        getMultipleDayType,
        getRangeDayType,
        max,
        min,
        type
    ]);
    const days = (0, import_react86.useMemo)(()=>{
        const days2 = [];
        const year = monthValue === null || monthValue === void 0 ? void 0 : monthValue.getFullYear();
        const month2 = monthValue === null || monthValue === void 0 ? void 0 : monthValue.getMonth();
        for(let dayValue = 1; dayValue <= totalDay; dayValue++){
            const dateValue = new Date(year, month2, dayValue);
            const dayType = getDayType(dateValue);
            const oldDay = {
                value: dateValue,
                type: dayType,
                bottom: getBottom(type, dayType),
                children: dayValue
            };
            const newDay = formatter ? formatter(oldDay) : oldDay;
            days2.push(newDay);
        }
        return days2;
    }, [
        monthValue,
        totalDay,
        getDayType,
        type,
        formatter
    ]);
    const disabledDays = (0, import_react86.useMemo)(()=>days.filter((day)=>day.type === "disabled"), [
        days
    ]);
    const getRectTop = (0, import_react86.useCallback)(()=>{
        return getRect(monthRef).then(({ top })=>top);
    }, []);
    (0, import_react86.useImperativeHandle)(ref, ()=>({
            getRectTop,
            disabledDays,
            getHeight: ()=>height,
            getValue: ()=>monthValue
        }), [
        disabledDays,
        getRectTop,
        monthValue,
        height
    ]);
    const content = (0, import_react86.useMemo)(()=>(0, import_map13.default)(days, (day, index)=>React68.createElement(calendar_day_default, {
                key: `${day.value}-${index}`,
                className: day.className,
                style: {
                    marginLeft: index === 0 ? `${100 * offset / 7}%` : ""
                },
                value: day.value,
                type: day.type,
                top: day.top,
                bottom: day.bottom,
                children: day.children
            })), [
        days,
        offset
    ]);
    return React68.createElement(View, {
        id,
        ref: monthRef,
        className: prefixClassname("calendar__month")
    }, showMonthTitle && React68.createElement(View, {
        className: prefixClassname("calendar__month-title"),
        children: title
    }), React68.createElement(View, {
        className: prefixClassname("calendar__days")
    }, watermark && React68.createElement(CalendarMonthWatermark, {
        children: month
    }), content));
});
var calendar_month_default = CalendarMonth;
// node_modules/@taroify/core/calendar/calendar.js
function defaultSubtitleRender(date) {
    return `${date.getFullYear()}\u5E74${date.getMonth() + 1}\u6708`;
}
function defaultFormatter(day) {
    return day;
}
function Calendar(props) {
    const { className, style, title = "\u65E5\u671F\u9009\u62E9", subtitle = defaultSubtitleRender, showSubtitle = true, type = "single", poppable = false, showPopup = false, popupPlacement = "bottom", popupRounded = true, popupCloseIcon = true, showConfirm = true, confirmText = "\u786E\u8BA4", confirmDisabledText = "\u786E\u8BA4", defaultValue: defaultValueProp, value: valueProp, min: minValue = MIN_DATE2, max: maxValue = MAX_DATE2, firstDayOfWeek, readonly = false, watermark = true, formatter = defaultFormatter, children: childrenProp, onChange: onChangeProp, onConfirm, onClose } = props;
    const scrollToDateLoadingRef = (0, import_react87.useRef)(false);
    const Wrapper = (0, import_react87.useMemo)(()=>poppable ? popup_default2 : ({ children: children2 })=>React69.createElement(React69.Fragment, null, children2), [
        poppable
    ]);
    const defaultValue = (0, import_react87.useMemo)(()=>getInitialDate(defaultValueProp), []);
    const { value, setValue } = useUncontrolled({
        defaultValue,
        value: valueProp,
        onChange: onChangeProp
    });
    const renderFooter = ()=>{
        let _footer = null;
        import_react87.Children.forEach(childrenProp, (child)=>{
            if ((0, import_react87.isValidElement)(child)) {
                const element = child;
                const { type: elementType } = element;
                if (elementType === calendar_footer_default) {
                    _footer = element;
                }
            }
        });
        if (!_footer && showConfirm) {
            _footer = React69.createElement(calendar_footer_default, null, React69.createElement(calendar_button_default, {
                type: "confirm",
                confirmText,
                confirmDisabledText
            }));
        }
        return _footer;
    };
    const scrollViewRef = (0, import_react87.useRef)();
    const scrollViewHeightRef = (0, import_react87.useRef)(0);
    const hasConfirmRef = (0, import_react87.useRef)(false);
    const [currentMonth, setCurrentMonth] = (0, import_react87.useState)();
    const changeValueRef = (0, import_react87.useRef)();
    const [scrollIntoView, setScrollIntoView] = (0, import_react87.useState)("");
    const { getRef: getMonthRef, getRefs: getMonthRefs, setRefs: setMonthRefs, clearRefs: clearMonthRefs } = useRefs();
    const dayOffset = (0, import_react87.useMemo)(()=>firstDayOfWeek ? +firstDayOfWeek % 7 : 0, [
        firstDayOfWeek
    ]);
    const months = (0, import_react87.useMemo)(()=>{
        const months2 = [];
        const cursor = new Date(minValue);
        cursor.setDate(1);
        do {
            months2.push(new Date(cursor));
            cursor.setMonth(cursor.getMonth() + 1);
        }while (compareYearMonth(cursor, maxValue) !== 1)
        return months2;
    }, [
        maxValue,
        minValue
    ]);
    function limitDateRange(date, minDate = minValue, maxDate = maxValue) {
        if (compareDate(date, minDate) === -1) {
            return minDate;
        }
        if (compareDate(date, maxDate) === 1) {
            return maxDate;
        }
        return date;
    }
    function getInitialDate(defaultDate) {
        if (defaultDate === null) {
            return defaultDate;
        }
        const now = createToday();
        let defaultDateCache = defaultDate;
        if (type === "range") {
            if (!Array.isArray(defaultDateCache)) {
                defaultDateCache = [];
            }
            const start = limitDateRange(defaultDateCache[0] || now, minValue, createPreviousDay(maxValue));
            const end = limitDateRange(defaultDateCache[1] || now, createNextDay(minValue));
            return [
                start,
                end
            ];
        }
        if (type === "multiple") {
            if (Array.isArray(defaultDateCache)) {
                return defaultDateCache.map((date)=>limitDateRange(date));
            }
            return [
                limitDateRange(now)
            ];
        }
        if (!defaultDateCache || Array.isArray(defaultDateCache)) {
            defaultDateCache = now;
        }
        return limitDateRange(defaultDateCache);
    }
    function getDisabledDate(disabledDays, startDay, date) {
        var _disabledDays_find;
        return (_disabledDays_find = disabledDays.find((day)=>compareDate(startDay, day.value) === -1 && compareDate(day.value, date) === -1)) === null || _disabledDays_find === void 0 ? void 0 : _disabledDays_find.value;
    }
    function getDisabledDays() {
        return getMonthRefs().reduce((arr, ref)=>{
            var _ref_current;
            var _ref_current_disabledDays;
            arr.push(...(_ref_current_disabledDays = (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.disabledDays) !== null && _ref_current_disabledDays !== void 0 ? _ref_current_disabledDays : []);
            return arr;
        }, []);
    }
    function change(dateValue, complete) {
        changeValueRef.current = dateValue;
        setValue === null || setValue === void 0 ? void 0 : setValue(dateValue);
        if (complete && !hasConfirmRef.current) {
            onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm(dateValue);
        }
    }
    function onDayClick(day) {
        const { value: date } = day;
        if (readonly || !date) {
            return;
        }
        if (type === "range") {
            const disabledDays = getDisabledDays();
            if (!value) {
                change([
                    date
                ]);
                return;
            }
            const [startDay, endDay] = value;
            if (startDay && !endDay) {
                const compareToStart = compareDate(date, startDay);
                if (compareToStart === 1) {
                    const disabledDay = getDisabledDate(disabledDays, startDay, date);
                    if (disabledDay) {
                        change([
                            startDay,
                            createPreviousDay(disabledDay)
                        ]);
                    } else {
                        change([
                            startDay,
                            date
                        ], true);
                    }
                } else if (compareToStart === -1) {
                    change([
                        date
                    ]);
                } else {
                    change([
                        date,
                        date
                    ], true);
                }
            } else {
                change([
                    date
                ]);
            }
        } else if (type === "multiple") {
            if (!value) {
                change([
                    date
                ]);
                return;
            }
            const dates = value;
            const newDates = (0, import_filter2.default)(dates, (dateItem)=>compareDate(dateItem, date) !== 0);
            if ((0, import_size9.default)(newDates) !== (0, import_size9.default)(dates)) {
                change(newDates);
            } else {
                change([
                    ...dates,
                    date
                ]);
            }
        } else {
            change(date, true);
        }
    }
    function onScroll() {
        return _onScroll.apply(this, arguments);
    }
    function _onScroll() {
        _onScroll = _async_to_generator(function*() {
            if (scrollToDateLoadingRef.current) {
                return;
            }
            const top = yield getScrollTop(scrollViewRef);
            const bottom = top + scrollViewHeightRef.current;
            const heights = months.map((item, index)=>getMonthRef(index).current.getHeight());
            const heightSum = heights.reduce((a, b)=>a + b, 0);
            if (bottom > heightSum && top > 0) {
                return;
            }
            let height = 0;
            let currentMonthRef;
            for(let i = 0; i < months.length; i++){
                const month = getMonthRef(i);
                const visible = height <= bottom && height + heights[i] >= top;
                if (visible && !currentMonthRef) {
                    currentMonthRef = month;
                    break;
                }
                height += heights[i];
            }
            if (currentMonthRef) {
                setCurrentMonth(currentMonthRef.current.getValue());
            }
        });
        return _onScroll.apply(this, arguments);
    }
    function scrollToDate(targetDate) {
        return _scrollToDate.apply(this, arguments);
    }
    function _scrollToDate() {
        _scrollToDate = _async_to_generator(function*(targetDate) {
            months.some((month, index)=>{
                if (compareYearMonth(month, targetDate) === 0) {
                    scrollToDateLoadingRef.current = true;
                    const currentMonthRef = getMonthRef(index);
                    const month2 = currentMonthRef.current.getValue();
                    setCurrentMonth(month2);
                    if (getEnv() === "WEB") {
                        nextTick(()=>{
                            if (scrollViewRef.current) {
                                var _currentMonthRef_current;
                                Promise.all([
                                    getRect(scrollViewRef),
                                    getScrollTop(scrollViewRef),
                                    (_currentMonthRef_current = currentMonthRef.current) === null || _currentMonthRef_current === void 0 ? void 0 : _currentMonthRef_current.getRectTop()
                                ]).then(([{ top: scrollViewRectTop }, currentScrollTop, currentMonthRectTop])=>{
                                    const newBodyScrollTop = currentMonthRectTop - scrollViewRectTop + currentScrollTop;
                                    scrollViewRef.current.scrollTop = newBodyScrollTop;
                                    nextTick(()=>{
                                        scrollToDateLoadingRef.current = false;
                                    });
                                });
                            }
                        });
                    } else {
                        setScrollIntoView(genMonthId(month2));
                        nextTick(()=>{
                            scrollToDateLoadingRef.current = false;
                        });
                    }
                    return true;
                }
                return false;
            });
        });
        return _scrollToDate.apply(this, arguments);
    }
    function scrollToCurrentDate(newValue) {
        return _scrollToCurrentDate.apply(this, arguments);
    }
    function _scrollToCurrentDate() {
        _scrollToCurrentDate = _async_to_generator(function*(newValue) {
            if (poppable && !showPopup) {
                return;
            }
            if (newValue) {
                const targetDate = type === "single" ? newValue : newValue[0];
                if ((0, import_isDate.default)(targetDate)) {
                    scrollToDate(targetDate);
                }
            }
        });
        return _scrollToCurrentDate.apply(this, arguments);
    }
    const reset = (date)=>nextTick(()=>scrollToCurrentDate(date).then());
    const init = useMemoizedFn(()=>{
        if (poppable && !showPopup) {
            setScrollIntoView("");
            return;
        }
        raf_default(/*#__PURE__*/ _async_to_generator(function*() {
            const bodyHeight = (yield getRect(scrollViewRef)).height;
            scrollViewHeightRef.current = Math.floor(bodyHeight);
            reset(getInitialDate(value));
        }));
    });
    (0, import_react87.useEffect)(()=>{
        if (value !== changeValueRef.current) {
            reset(getInitialDate(value));
        }
    }, [
        value
    ]);
    (0, import_react87.useEffect)(()=>{
        reset(getInitialDate(value));
    }, [
        type,
        minValue,
        maxValue
    ]);
    (0, import_react87.useEffect)(()=>{
        init();
    }, [
        showPopup
    ]);
    const monthsRender = (0, import_react87.useMemo)(()=>{
        clearMonthRefs === null || clearMonthRefs === void 0 ? void 0 : clearMonthRefs();
        return (0, import_map14.default)(months, (month, index)=>React69.createElement(calendar_month_default, {
                ref: setMonthRefs(index),
                key: month.getTime(),
                value: month,
                showMonthTitle: index !== 0 || !showSubtitle,
                watermark
            }));
    }, [
        clearMonthRefs,
        months,
        setMonthRefs,
        watermark,
        showSubtitle
    ]);
    function notifyConfirm(hasConfirm) {
        hasConfirmRef.current = hasConfirm;
    }
    function handleConfirm() {
        onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm(value);
    }
    return React69.createElement(calendar_context_default.Provider, {
        value: {
            type,
            firstDayOfWeek: dayOffset,
            min: minValue,
            max: maxValue,
            value,
            formatter,
            onDayClick,
            notifyConfirm,
            onConfirm: handleConfirm
        }
    }, React69.createElement(Wrapper, {
        rounded: popupRounded,
        placement: popupPlacement,
        open: showPopup,
        onClose,
        className: (0, import_classnames48.default)(prefixClassname("calendar--popup"))
    }, poppable && showPopup && popupCloseIcon && React69.createElement(popup_default2.Close, null), React69.createElement(View, {
        className: (0, import_classnames48.default)(prefixClassname("calendar"), prefixClassname(`calendar--${type}`), className),
        style
    }, React69.createElement(calendar_header_default, {
        title,
        subtitle,
        date: currentMonth,
        showSubtitle
    }), React69.createElement(ScrollView, {
        ref: scrollViewRef,
        className: prefixClassname("calendar__body"),
        scrollY: true,
        scrollIntoView,
        onScroll
    }, monthsRender), renderFooter())));
}
var calendar_default = Calendar;
// node_modules/@taroify/core/calendar/index.js
var Calendar2 = calendar_default;
Calendar2.Footer = calendar_footer_default;
Calendar2.Button = calendar_button_default;
var calendar_default2 = Calendar2;
// node_modules/@taroify/core/checkbox/checkbox.js
var import_classnames49 = __toESM(require_classnames());
var import_size10 = __toESM(require_size());
var import_toArray = __toESM(require_toArray());
var React70 = __toESM(require_react());
var import_react89 = __toESM(require_react());
// node_modules/@taroify/core/checkbox/checkbox-group.context.js
var import_react88 = __toESM(require_react());
var CheckboxGroupContext = (0, import_react88.createContext)({});
var checkbox_group_context_default = CheckboxGroupContext;
// node_modules/@taroify/core/checkbox/checkbox.js
function Checkbox(props) {
    const { className, name, defaultChecked, checked: checkedProp, disabled: disabledProp, shape = "round", icon = React70.createElement(Success_default, null), size, children: children2, onChange: onChangeProp } = props, restProps = _object_without_properties(props, [
        "className",
        "name",
        "defaultChecked",
        "checked",
        "disabled",
        "shape",
        "icon",
        "size",
        "children",
        "onChange"
    ]);
    const { value: names, max: namesMax = 0, direction, onChange: onNamesChange, disabled: disabledGroup } = (0, import_react89.useContext)(checkbox_group_context_default);
    const { value: checked, setValue } = useUncontrolled({
        value: checkedProp !== null && checkedProp !== void 0 ? checkedProp : names === null || names === void 0 ? void 0 : names.includes(name),
        defaultValue: defaultChecked,
        onChange: onChangeProp
    });
    const disabled = disabledProp !== null && disabledProp !== void 0 ? disabledProp : disabledGroup;
    function onClick() {
        if (disabled) {
            return;
        }
        setValue(!checked);
        if (name) {
            if (names === null || names === void 0 ? void 0 : names.includes(name)) {
                onNamesChange === null || onNamesChange === void 0 ? void 0 : onNamesChange(names.filter((aName)=>aName !== name));
            } else if (namesMax === 0 || (0, import_size10.default)(names) < namesMax) {
                onNamesChange === null || onNamesChange === void 0 ? void 0 : onNamesChange([
                    ...(0, import_toArray.default)(names),
                    name
                ]);
            }
        }
    }
    return React70.createElement(View, _object_spread({
        className: (0, import_classnames49.default)(prefixClassname("checkbox"), {
            [prefixClassname("checkbox--horizontal")]: direction === "horizontal",
            [prefixClassname("checkbox--vertical")]: direction === "vertical"
        }, className),
        onClick
    }, restProps), React70.createElement(View, {
        className: (0, import_classnames49.default)(prefixClassname("checkbox__icon"), prefixClassname(`checkbox__icon--${shape}`), {
            [prefixClassname("checkbox__icon--disabled")]: disabled,
            [prefixClassname("checkbox__icon--checked")]: checked
        }),
        style: {
            fontSize: size ? addUnitPx(size) : ""
        },
        children: icon
    }), children2 && React70.createElement(View, {
        className: (0, import_classnames49.default)(prefixClassname("checkbox__label"), {
            [prefixClassname("checkbox__label--disabled")]: disabled
        }),
        children: children2
    }));
}
// node_modules/@taroify/core/checkbox/checkbox-group.js
var import_classnames50 = __toESM(require_classnames());
var React71 = __toESM(require_react());
function CheckboxGroup(props) {
    const { defaultValue, value: valueProp, disabled, max, direction = "vertical", children: children2, onChange: onChangeProp } = props, restProps = _object_without_properties(props, [
        "defaultValue",
        "value",
        "disabled",
        "max",
        "direction",
        "children",
        "onChange"
    ]);
    const { value, setValue } = useUncontrolled({
        value: valueProp,
        defaultValue,
        onChange: onChangeProp
    });
    return React71.createElement(checkbox_group_context_default.Provider, {
        value: {
            value,
            max,
            disabled,
            direction,
            onChange: setValue
        }
    }, React71.createElement(View, _object_spread({
        className: (0, import_classnames50.default)(prefixClassname("checkbox-group"), {
            [prefixClassname("checkbox-group--horizontal")]: direction === "horizontal",
            [prefixClassname("checkbox-group--vertical")]: direction === "vertical"
        }),
        children: children2
    }, restProps)));
}
var checkbox_group_default = CheckboxGroup;
// node_modules/@taroify/core/checkbox/index.js
var Checkbox2 = Checkbox;
Checkbox2.Group = checkbox_group_default;
var checkbox_default = Checkbox2;
// node_modules/@taroify/core/datetime-picker/datetime-picker.js
var React72 = __toESM(require_react());
// node_modules/@taroify/core/datetime-picker/use-datetime-picker.js
var import_map15 = __toESM(require_map());
var import_times = __toESM(require_times());
var import_padStart = __toESM(require_padStart());
var import_forEach4 = __toESM(require_forEach());
var import_size11 = __toESM(require_size());
var import_toNumber2 = __toESM(require_toNumber());
var import_isUndefined11 = __toESM(require_isUndefined());
var import_toString2 = __toESM(require_toString());
var import_react90 = __toESM(require_react());
var defaultFormatter2 = (type, value)=>value;
function useDatetimePicker(options = {}) {
    const { defaultValue = void 0, value = void 0, min: minDate = MIN_DATE, max: maxDate = MAX_DATE, type = "datetime", fields = [], filter: filter2, formatter = defaultFormatter2 } = options;
    const clampDefaultValue = clampDate(defaultValue, minDate, maxDate);
    const clampValue = clampDate(value !== null && value !== void 0 ? value : defaultValue, minDate, maxDate);
    const ranges = useDatetimeRanges(clampValue, minDate, maxDate, type, fields);
    const columns = (0, import_react90.useMemo)(()=>(0, import_map15.default)(ranges, ({ type: type2, range })=>{
            let values2 = (0, import_times.default)(range[1] - range[0] + 1, (index)=>(0, import_padStart.default)(`${range[0] + index}`, 2, "0"));
            if (filter2) {
                values2 = filter2(type2, values2);
            }
            const children2 = (0, import_map15.default)(values2, (value2)=>({
                    value: value2,
                    children: formatter(type2, value2)
                }));
            return {
                type: type2,
                value: type2,
                children: children2
            };
        }), [
        filter2,
        formatter,
        ranges
    ]);
    function toDate(datetimeValue) {
        const date = new Date(minDate.getTime());
        (0, import_forEach4.default)(columns, ({ type: type2 }, index)=>{
            switch(type2){
                case "year":
                    if ((0, import_size11.default)(datetimeValue) > index) {
                        date.setFullYear((0, import_toNumber2.default)(datetimeValue[index]));
                    }
                    break;
                case "month":
                    date.setDate(1);
                    if ((0, import_size11.default)(datetimeValue) > index) {
                        date.setMonth((0, import_toNumber2.default)(datetimeValue[index]) - 1);
                    }
                    break;
                case "day":
                    if ((0, import_size11.default)(datetimeValue) > index) {
                        const endDayOfMonth = getEndDayOfMonth(date.getFullYear(), date.getMonth() + 1);
                        const day = (0, import_toNumber2.default)(datetimeValue[index]);
                        date.setDate(day > endDayOfMonth ? endDayOfMonth : day);
                    }
                    break;
                case "hour":
                    if ((0, import_size11.default)(datetimeValue) > index) {
                        date.setHours((0, import_toNumber2.default)(datetimeValue[index]));
                    }
                    break;
                case "minute":
                    if ((0, import_size11.default)(datetimeValue) > index) {
                        date.setMinutes((0, import_toNumber2.default)(datetimeValue[index]));
                    }
                    break;
                case "second":
                    if ((0, import_size11.default)(datetimeValue) > index) {
                        date.setSeconds((0, import_toNumber2.default)(datetimeValue[index]));
                    }
                    break;
            }
        });
        return clampDate(date, minDate, maxDate);
    }
    function toValue(date) {
        if ((0, import_isUndefined11.default)(date)) {
            return date;
        }
        const [year, month, day, hour, minute, second] = getDatetime(date);
        return (0, import_map15.default)(columns, (column)=>{
            switch(column.type){
                case "year":
                    return (0, import_toString2.default)(year);
                case "month":
                    return (0, import_padStart.default)((0, import_toString2.default)(month), 2, "0");
                case "day":
                    return (0, import_padStart.default)((0, import_toString2.default)(day), 2, "0");
                case "hour":
                    return (0, import_padStart.default)((0, import_toString2.default)(hour), 2, "0");
                case "minute":
                    return (0, import_padStart.default)((0, import_toString2.default)(minute), 2, "0");
                case "second":
                    return (0, import_padStart.default)((0, import_toString2.default)(second), 2, "0");
                default:
                    return "";
            }
        });
    }
    return {
        toDate,
        defaultValue: toValue((0, import_isUndefined11.default)(defaultValue) ? defaultValue : clampDefaultValue),
        value: toValue((0, import_isUndefined11.default)(value) ? value : clampValue),
        columns
    };
}
var use_datetime_picker_default = useDatetimePicker;
// node_modules/@taroify/core/datetime-picker/datetime-picker.js
function DatetimePicker(props) {
    const { className, readonly, loading, type, fields, filter: filter2, formatter, min, max, defaultValue: defaultValueProp, value: valueProp, siblingCount, children: children2, onChange: onChangeProp, onConfirm, onCancel } = props, restProps = _object_without_properties(props, [
        "className",
        "readonly",
        "loading",
        "type",
        "fields",
        "filter",
        "formatter",
        "min",
        "max",
        "defaultValue",
        "value",
        "siblingCount",
        "children",
        "onChange",
        "onConfirm",
        "onCancel"
    ]);
    const { value: dateValue, setValue: setDateValue } = useUncontrolled({
        value: valueProp,
        onChange: onChangeProp
    });
    const { defaultValue, value, columns, toDate } = use_datetime_picker_default({
        defaultValue: defaultValueProp,
        value: dateValue,
        min,
        max,
        type,
        fields,
        filter: filter2,
        formatter
    });
    return React72.createElement(picker_default2, _object_spread({
        className,
        readonly,
        loading,
        siblingCount,
        defaultValue,
        value,
        onChange: (aValue)=>setDateValue(toDate(aValue)),
        onConfirm: (aValue)=>onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm(toDate(aValue)),
        onCancel: (aValue)=>onCancel === null || onCancel === void 0 ? void 0 : onCancel(toDate(aValue))
    }, restProps), children2, React72.createElement(picker_default2.Columns, {
        children: columns
    }));
}
var datetime_picker_default = DatetimePicker;
// node_modules/@taroify/core/datetime-picker/index.js
var DatetimePicker2 = datetime_picker_default;
DatetimePicker2.Toolbar = picker_default2.Toolbar;
DatetimePicker2.Title = picker_default2.Title;
DatetimePicker2.Button = picker_default2.Button;
var datetime_picker_default2 = DatetimePicker2;
// node_modules/@taroify/core/input/input.js
var import_classnames52 = __toESM(require_classnames());
var import_isPlainObject4 = __toESM(require_isPlainObject());
var import_isEmpty11 = __toESM(require_isEmpty());
var React74 = __toESM(require_react());
var import_react91 = __toESM(require_react());
// node_modules/@taroify/core/input/native-input.js
var import_classnames51 = __toESM(require_classnames());
var React73 = __toESM(require_react());
function NativeInput(props) {
    const { nativeProps = {}, readonly, color } = props, restProps = _object_without_properties(props, [
        "nativeProps",
        "readonly",
        "color"
    ]);
    const { className: nativeClassname } = nativeProps, restNativeProps = _object_without_properties(nativeProps, [
        "className"
    ]);
    return React73.createElement(Input, _object_spread({
        nativeProps: _object_spread({
            className: (0, import_classnames51.default)(prefixClassname("native-input"), {
                [prefixClassname("native-input--readonly")]: readonly,
                [prefixClassname("native-input--colorful")]: color || readonly
            }, nativeClassname),
            readonly
        }, restNativeProps)
    }, restProps));
}
var native_input_default = NativeInput;
// node_modules/@taroify/core/input/input.js
function resolveOnChange(e, onChange, detailValue) {
    if (!onChange) {
        return;
    }
    if (e.type === "click" || e.type === "tap") {
        const { detail } = e;
        const event = Object.assign({}, e, {
            detail: _object_spread_props(_object_spread({}, (0, import_isPlainObject4.default)(detail) ? detail : {}), {
                value: ""
            })
        });
        onChange(event);
        return;
    }
    if (detailValue !== void 0) {
        const { detail } = e;
        const event = Object.assign({}, e, {
            detail: _object_spread_props(_object_spread({}, (0, import_isPlainObject4.default)(detail) ? detail : {}), {
                value: detailValue
            })
        });
        onChange(event);
        return;
    }
    onChange(e);
}
function Input2(props) {
    const { className, placeholderClass, placeholderClassName, value: valueProp, readonly, disabled, align, color, clearable, clearTrigger = "focus", clearIcon = React74.createElement(Clear_default, null), onInput, onChange, onFocus, onBlur, onClear } = props, restProps = _object_without_properties(props, [
        "className",
        "placeholderClass",
        "placeholderClassName",
        "value",
        "readonly",
        "disabled",
        "align",
        "color",
        "clearable",
        "clearTrigger",
        "clearIcon",
        "onInput",
        "onChange",
        "onFocus",
        "onBlur",
        "onClear"
    ]);
    const { value, setValue } = useUncontrolled({
        value: valueProp
    });
    const [focused, setFocused] = (0, import_react91.useState)(false);
    const allowClear = (0, import_react91.useMemo)(()=>{
        if (clearable && !disabled) {
            const hasValue = !(0, import_isEmpty11.default)(value);
            const trigger = clearTrigger === "always" || clearTrigger === "focus" && focused;
            return hasValue && trigger;
        }
        return false;
    }, [
        clearTrigger,
        clearable,
        disabled,
        focused,
        value
    ]);
    const handleClear = (event)=>{
        preventDefault(event, true);
        resolveOnChange(event, onChange, "");
        resolveOnChange(event, onInput, "");
        onClear === null || onClear === void 0 ? void 0 : onClear(event);
        setValue("");
    };
    const handleFocus = (event)=>{
        setFocused(true);
        onFocus === null || onFocus === void 0 ? void 0 : onFocus(event);
    };
    const handleInput = (event)=>{
        onInput === null || onInput === void 0 ? void 0 : onInput(event);
        onChange === null || onChange === void 0 ? void 0 : onChange(event);
        setValue(event.detail.value);
    };
    const handleBlur = (event)=>{
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(event);
        setTimeout(()=>setFocused(false), 80);
    };
    return React74.createElement(React74.Fragment, null, React74.createElement(native_input_default, _object_spread({
        className: (0, import_classnames52.default)(prefixClassname("input"), {
            [prefixClassname("input--disabled")]: disabled,
            [prefixClassname("input--readonly")]: readonly,
            [prefixClassname("input--right")]: align === "right",
            [prefixClassname("input--center")]: align === "center",
            [prefixClassname("input--left")]: align === "left",
            [prefixClassname("input--primary")]: color === "primary",
            [prefixClassname("input--info")]: color === "info",
            [prefixClassname("input--success")]: color === "success"
        }, className),
        placeholderClass: (0, import_classnames52.default)(placeholderClass, placeholderClassName, prefixClassname("input__placeholder"), {
            [prefixClassname("input__placeholder--primary")]: color === "primary",
            [prefixClassname("input__placeholder--info")]: color === "info",
            [prefixClassname("input__placeholder--success")]: color === "success"
        }),
        disabled: inBrowser ? disabled : disabled || readonly,
        readonly,
        color,
        value,
        onFocus: handleFocus,
        onInput: handleInput,
        onBlur: handleBlur
    }, restProps)), allowClear && cloneIconElement(clearIcon, {
        className: prefixClassname("input__clear"),
        onClick: handleClear
    }));
}
var input_default = Input2;
// node_modules/@taroify/core/textarea/textarea.js
var import_classnames54 = __toESM(require_classnames());
var import_isNumber10 = __toESM(require_isNumber());
var React76 = __toESM(require_react());
// node_modules/@taroify/core/textarea/native-textarea.js
var import_classnames53 = __toESM(require_classnames());
var React75 = __toESM(require_react());
function NativeTextarea(props) {
    const { nativeProps = {}, readonly } = props, restProps = _object_without_properties(props, [
        "nativeProps",
        "readonly"
    ]);
    const { className: nativeClassname } = nativeProps, restNativeProps = _object_without_properties(nativeProps, [
        "className"
    ]);
    return React75.createElement(Textarea, _object_spread({
        nativeProps: _object_spread({
            className: (0, import_classnames53.default)(prefixClassname("native-textarea"), {
                [prefixClassname("native-textarea--readonly")]: readonly
            }, nativeClassname)
        }, restNativeProps)
    }, restProps));
}
var native_textarea_default = NativeTextarea;
// node_modules/@taroify/core/textarea/textarea.shared.js
function getStringLength(chars = "") {
    return chars.normalize().length;
}
// node_modules/@taroify/core/textarea/textarea.js
function Textarea2(props) {
    const { className, placeholderClass, value: valueProp, readonly, disabled, limit, maxlength: maxlengthProp, onInput, onChange } = props, restProps = _object_without_properties(props, [
        "className",
        "placeholderClass",
        "value",
        "readonly",
        "disabled",
        "limit",
        "maxlength",
        "onInput",
        "onChange"
    ]);
    const maxlength = (0, import_isNumber10.default)(limit) ? limit : maxlengthProp;
    const { value, setValue } = useUncontrolled({
        value: valueProp
    });
    return React76.createElement(View, {
        className: prefixClassname("textarea__wrapper")
    }, React76.createElement(native_textarea_default, _object_spread({
        className: (0, import_classnames54.default)(prefixClassname("textarea"), {
            [prefixClassname("textarea--readonly")]: readonly
        }, className),
        placeholderClass: (0, import_classnames54.default)(prefixClassname("textarea__placeholder"), {
            [prefixClassname("textarea__placeholder--readonly")]: readonly
        }, placeholderClass),
        disabled: readonly || disabled,
        readonly,
        maxlength,
        value,
        onInput: (e)=>{
            setValue(e.detail.value);
            onInput === null || onInput === void 0 ? void 0 : onInput(e);
            onChange === null || onChange === void 0 ? void 0 : onChange(e);
        }
    }, restProps)), limit && React76.createElement(View, {
        className: prefixClassname("textarea__limit")
    }, getStringLength(value), "/", maxlength));
}
var textarea_default = Textarea2;
// node_modules/@taroify/core/form/form-feedback.js
var import_classnames55 = __toESM(require_classnames());
var React77 = __toESM(require_react());
var import_react93 = __toESM(require_react());
// node_modules/@taroify/core/form/form.context.js
var import_react92 = __toESM(require_react());
var FormContext = (0, import_react92.createContext)({});
var form_context_default = FormContext;
// node_modules/@taroify/core/form/form-feedback.js
function FormFeedback(props) {
    const { className, align: alignProp, status } = props, restProps = _object_without_properties(props, [
        "className",
        "align",
        "status"
    ]);
    const { controlAlign } = (0, import_react93.useContext)(form_context_default);
    var _ref;
    const align = (_ref = alignProp !== null && alignProp !== void 0 ? alignProp : controlAlign) !== null && _ref !== void 0 ? _ref : "left";
    return React77.createElement(View, _object_spread({
        className: (0, import_classnames55.default)(prefixClassname("form-feedback"), {
            [prefixClassname("form-feedback--left")]: align === "left",
            [prefixClassname("form-feedback--center")]: align === "center",
            [prefixClassname("form-feedback--right")]: align === "right",
            [prefixClassname("form-feedback--valid")]: status === "valid",
            [prefixClassname("form-feedback--warning")]: status === "warning",
            [prefixClassname("form-feedback--invalid")]: status === "invalid"
        }, className)
    }, restProps));
}
FormFeedback.displayName = "FormFeedback";
var form_feedback_default = FormFeedback;
// node_modules/@taroify/core/form/form-label.js
var import_classnames56 = __toESM(require_classnames());
var React78 = __toESM(require_react());
var import_react94 = __toESM(require_react());
function FormLabel(props) {
    const { align: alignProp, colon: colonProp, children: children2, className } = props, restProps = _object_without_properties(props, [
        "align",
        "colon",
        "children",
        "className"
    ]);
    const { colon: ctxColon, labelAlign } = (0, import_react94.useContext)(form_context_default);
    const align = alignProp !== null && alignProp !== void 0 ? alignProp : labelAlign;
    const colon = colonProp !== null && colonProp !== void 0 ? colonProp : ctxColon;
    return React78.createElement(cell_title_default, _object_spread({
        className: (0, import_classnames56.default)(prefixClassname("form-label"), {
            [prefixClassname("form-label--left")]: align === "left",
            [prefixClassname("form-label--center")]: align === "center",
            [prefixClassname("form-label--right")]: align === "right"
        }, className)
    }, restProps), children2, colon ? ":" : void 0);
}
FormLabel.displayName = "FormLabel";
var form_label_default = FormLabel;
// node_modules/@taroify/core/field/field.js
var React98 = __toESM(require_react());
var import_react127 = __toESM(require_react());
// node_modules/@taroify/core/form/form.js
var React79 = __toESM(require_react());
var import_react96 = __toESM(require_react());
// node_modules/@taroify/core/form/use-form.js
var import_filter4 = __toESM(require_filter());
var import_isUndefined12 = __toESM(require_isUndefined());
var import_isArray7 = __toESM(require_isArray());
var import_isEmpty13 = __toESM(require_isEmpty());
var import_reduce = __toESM(require_reduce());
var import_get8 = __toESM(require_get());
var import_forEach5 = __toESM(require_forEach());
var import_isEqual6 = __toESM(require_isEqual());
var import_set2 = __toESM(require_set());
var import_cloneDeep = __toESM(require_cloneDeep());
var import_includes = __toESM(require_includes());
var import_toArray2 = __toESM(require_toArray());
var import_isPlainObject5 = __toESM(require_isPlainObject());
var import_react95 = __toESM(require_react());
// node_modules/@taroify/core/form/form.validate.js
var import_flatMap = __toESM(require_flatMap());
var import_filter3 = __toESM(require_filter());
var import_isEmpty12 = __toESM(require_isEmpty());
function validateAll(fields) {
    return new Promise((resolve, reject)=>{
        Promise.all(fields.map((field)=>field.validate().then(()=>[], (reason)=>[
                    reason
                ]))).then((errors)=>(0, import_flatMap.default)(errors, (error)=>error)).then((errors)=>(0, import_filter3.default)(errors, (error)=>!(0, import_isEmpty12.default)(error.errors))).then((errors)=>{
            if (!(0, import_isEmpty12.default)(errors)) {
                reject(errors);
            } else {
                resolve();
            }
        });
    });
}
// node_modules/@taroify/core/form/use-form.js
var { warn: warn2 } = getLogger("useForm");
var containerForms = /* @__PURE__ */ new Map();
var containerFormRefs = /* @__PURE__ */ new Map();
function toMapValueArray(map2) {
    const array = [];
    map2 === null || map2 === void 0 ? void 0 : map2.forEach((value)=>array.push(value));
    return array;
}
function getAttributiveForm(formName) {
    return containerForms.get(formName);
}
var FormAttributes = (_fields = /*#__PURE__*/ new WeakMap(), _inFormListFields = /*#__PURE__*/ new WeakMap(), _defaultValues = /*#__PURE__*/ new WeakMap(), _values = /*#__PURE__*/ new WeakMap(), _errors = /*#__PURE__*/ new WeakMap(), _events = /*#__PURE__*/ new WeakMap(), class {
    get fields() {
        return _class_private_field_get(this, _fields);
    }
    get inFormListFields() {
        return _class_private_field_get(this, _inFormListFields);
    }
    get defaultValues() {
        return _class_private_field_get(this, _defaultValues);
    }
    set defaultValues(defaultValues) {
        _class_private_field_set(this, _defaultValues, defaultValues);
    }
    get values() {
        return _class_private_field_get(this, _values);
    }
    set values(value) {
        _class_private_field_set(this, _values, value);
    }
    get errors() {
        return _class_private_field_get(this, _errors);
    }
    set errors(errors) {
        _class_private_field_set(this, _errors, errors);
    }
    addEventListener(event, listener) {
        var _class_private_field_get1;
        (_class_private_field_get1 = _class_private_field_get(this, _events)) === null || _class_private_field_get1 === void 0 ? void 0 : _class_private_field_get1.on(event, listener);
    }
    removeEventListener(event, listener) {
        var _class_private_field_get1;
        (_class_private_field_get1 = _class_private_field_get(this, _events)) === null || _class_private_field_get1 === void 0 ? void 0 : _class_private_field_get1.off(event, listener);
    }
    emitEvent(event, ...args) {
        _class_private_field_get(this, _events).trigger(event, ...args);
    }
    findFields(predicate) {
        const fields = toMapValueArray(this.fields);
        const inFormListFields = toMapValueArray(_class_private_field_get(this, _inFormListFields));
        return (0, import_filter4.default)(fields.concat(inFormListFields), predicate);
    }
    addField(name, field, inFormList) {
        if (inFormList) {
            _class_private_field_get(this, _inFormListFields).set(name, field);
        } else {
            _class_private_field_get(this, _fields).set(name, field);
        }
    }
    removeField(name, inFormList) {
        if (inFormList) {
            _class_private_field_get(this, _inFormListFields).delete(name);
        } else {
            _class_private_field_get(this, _fields).delete(name);
        }
    }
    hasField(name) {
        return _class_private_field_get(this, _fields).has(name);
    }
    getErrors(nameNames) {
        const names = (0, import_isUndefined12.default)(nameNames) ? [] : (0, import_isArray7.default)(nameNames) ? nameNames : [
            nameNames
        ];
        const { errors } = this;
        if ((0, import_isEmpty13.default)(names)) {
            return errors;
        }
        return (0, import_reduce.default)(names, (nameErrors, name)=>{
            const error = (0, import_get8.default)(errors, name);
            if (error) {
                nameErrors[name] = error;
            }
            return nameErrors;
        }, {});
    }
    setErrors(newErrors, emitChange = true) {
        const { errors } = this;
        (0, import_forEach5.default)(newErrors, (error)=>{
            const { name } = error;
            if (name) {
                const oldError = (0, import_get8.default)(errors, name);
                if (!(0, import_isEqual6.default)(oldError === null || oldError === void 0 ? void 0 : oldError.errors, error === null || error === void 0 ? void 0 : error.errors)) {
                    (0, import_set2.default)(errors, name, error);
                    if (emitChange) {
                        this.emitEvent(`fields.${name}.error.change`, errors);
                    }
                }
            }
        });
    }
    resetErrors(errors = {}) {
        this.errors = errors;
    }
    getValues(nameNames) {
        const names = (0, import_isUndefined12.default)(nameNames) ? [] : (0, import_isArray7.default)(nameNames) ? nameNames : [
            nameNames
        ];
        const values2 = {};
        if ((0, import_isEmpty13.default)(names)) {
            for (const field of this.fields.values()){
                if (field.name) {
                    values2[field.name] = (0, import_get8.default)(this.values, field.name);
                }
            }
            return values2;
        }
        for (const attr of names){
            (0, import_set2.default)(values2, attr, (0, import_get8.default)(this.values, attr));
        }
        return values2;
    }
    setValues(newValues, emitChange = true) {
        let changed = false;
        const { values: values2 } = this;
        let prevValues;
        (0, import_forEach5.default)(newValues, (value, name)=>{
            const oldValue = (0, import_get8.default)(values2, name);
            if (oldValue !== value) {
                if (!changed) {
                    changed = true;
                    prevValues = (0, import_cloneDeep.default)(values2);
                }
                const copyValue = (0, import_cloneDeep.default)(value);
                (0, import_set2.default)(values2, name, copyValue);
                if (emitChange) {
                    this.emitEvent(`fields.${name}.value.change`, copyValue);
                }
            }
        });
        if (changed) {
            this.emitEvent("shouldUpdate", prevValues, values2);
            this.emitEvent("change", newValues, values2);
        }
    }
    resetValues(newValues = {}) {
        this.values = newValues;
    }
    release() {
        var _class_private_field_get1;
        (_class_private_field_get1 = _class_private_field_get(this, _events)) === null || _class_private_field_get1 === void 0 ? void 0 : _class_private_field_get1.off();
    }
    constructor(){
        _class_private_field_init(this, _fields, {
            writable: true,
            value: /* @__PURE__ */ new Map()
        });
        _class_private_field_init(this, _inFormListFields, {
            writable: true,
            value: /* @__PURE__ */ new Map()
        });
        _class_private_field_init(this, _defaultValues, {
            writable: true,
            value: {}
        });
        _class_private_field_init(this, _values, {
            writable: true,
            value: {}
        });
        _class_private_field_init(this, _errors, {
            writable: true,
            value: {}
        });
        _class_private_field_init(this, _events, {
            writable: true,
            value: new Events()
        });
    }
});
function validateForm(formName, name) {
    return new Promise((resolve, reject)=>{
        const form = getAttributiveForm(formName);
        Promise.resolve((0, import_isUndefined12.default)(name) ? [] : (0, import_isArray7.default)(name) ? name : [
            name
        ]).then((names)=>form === null || form === void 0 ? void 0 : form.findFields((field)=>(0, import_isEmpty13.default)(names) || (0, import_includes.default)(names, field.name))).then((items)=>items && validateAll(items)).then(()=>form === null || form === void 0 ? void 0 : form.getValues(name)).then(resolve).catch((errors)=>{
            form === null || form === void 0 ? void 0 : form.resetErrors();
            form === null || form === void 0 ? void 0 : form.setErrors(errors);
            reject(errors);
        });
    });
}
function defineForm(formName) {
    return class DelegatingForm {
        get name() {
            return formName;
        }
        addEventListener(event, listener) {
            var _getAttributiveForm;
            (_getAttributiveForm = getAttributiveForm(formName)) === null || _getAttributiveForm === void 0 ? void 0 : _getAttributiveForm.addEventListener(event, listener);
        }
        removeEventListener(event, listener) {
            var _getAttributiveForm;
            (_getAttributiveForm = getAttributiveForm(formName)) === null || _getAttributiveForm === void 0 ? void 0 : _getAttributiveForm.removeEventListener(event, listener);
        }
        linkField(name, field, inFormList) {
            if (name && field) {
                var _getAttributiveForm;
                (_getAttributiveForm = getAttributiveForm(formName)) === null || _getAttributiveForm === void 0 ? void 0 : _getAttributiveForm.addField(name, field, inFormList);
            }
        }
        hasField(name) {
            var _getAttributiveForm;
            return !!(name && ((_getAttributiveForm = getAttributiveForm(formName)) === null || _getAttributiveForm === void 0 ? void 0 : _getAttributiveForm.hasField(name)));
        }
        unlinkField(name, inFormList) {
            if (name) {
                var _getAttributiveForm;
                (_getAttributiveForm = getAttributiveForm(formName)) === null || _getAttributiveForm === void 0 ? void 0 : _getAttributiveForm.removeField(name, inFormList);
            }
        }
        getFields() {
            var _getAttributiveForm;
            return toMapValueArray((_getAttributiveForm = getAttributiveForm(formName)) === null || _getAttributiveForm === void 0 ? void 0 : _getAttributiveForm.fields);
        }
        findFields(predicate) {
            var _getAttributiveForm;
            return (_getAttributiveForm = getAttributiveForm(formName)) === null || _getAttributiveForm === void 0 ? void 0 : _getAttributiveForm.findFields(predicate);
        }
        setErrors(errors) {
            var _getAttributiveForm;
            (_getAttributiveForm = getAttributiveForm(formName)) === null || _getAttributiveForm === void 0 ? void 0 : _getAttributiveForm.setErrors(errors);
        }
        resetErrors() {
            var _getAttributiveForm;
            (_getAttributiveForm = getAttributiveForm(formName)) === null || _getAttributiveForm === void 0 ? void 0 : _getAttributiveForm.resetErrors();
        }
        getErrors(name) {
            const form = getAttributiveForm(formName);
            return (0, import_reduce.default)(form === null || form === void 0 ? void 0 : form.getErrors(name), (errors, error)=>{
                errors.push(error);
                return errors;
            }, []);
        }
        setDefaultValues(defaultValues, inFormList) {
            const form = getAttributiveForm(formName);
            if (form) {
                const newValues = {};
                (0, import_forEach5.default)(defaultValues, (value, name)=>{
                    if (!inFormList) {
                        (0, import_set2.default)(form.defaultValues, name, value);
                    }
                    newValues[name] = (0, import_get8.default)(form.values, name) || value;
                });
                form === null || form === void 0 ? void 0 : form.setValues(newValues);
            }
        }
        setValues(newValues, emitChange) {
            var _getAttributiveForm;
            (_getAttributiveForm = getAttributiveForm(formName)) === null || _getAttributiveForm === void 0 ? void 0 : _getAttributiveForm.setValues(newValues, emitChange);
        }
        resetValues(values2) {}
        getValues(name) {
            var _getAttributiveForm;
            return (_getAttributiveForm = getAttributiveForm(formName)) === null || _getAttributiveForm === void 0 ? void 0 : _getAttributiveForm.getValues(name);
        }
        validate(name) {
            return validateForm(formName, name);
        }
        reset() {
            const form = getAttributiveForm(formName);
            const newValues = (0, import_cloneDeep.default)(form === null || form === void 0 ? void 0 : form.defaultValues);
            form === null || form === void 0 ? void 0 : form.resetValues(newValues);
            form === null || form === void 0 ? void 0 : form.resetErrors();
            form === null || form === void 0 ? void 0 : form.emitEvent("change", newValues, newValues);
            form === null || form === void 0 ? void 0 : form.emitEvent("reset");
        }
        setFieldsValue(newValues, emitChange) {
            var _getAttributiveForm;
            warn2("Please use setValues instead of setFieldsValue");
            (_getAttributiveForm = getAttributiveForm(formName)) === null || _getAttributiveForm === void 0 ? void 0 : _getAttributiveForm.setValues(newValues);
        }
        getFieldsValue(name) {
            var _getAttributiveForm;
            warn2("Please use getValues instead of getFieldsValue");
            return (_getAttributiveForm = getAttributiveForm(formName)) === null || _getAttributiveForm === void 0 ? void 0 : _getAttributiveForm.getValues(name);
        }
        validateFields(name) {
            warn2("Please use validate instead of validateFields");
            return validateForm(formName, name);
        }
        getAttributiveForm() {
            return getAttributiveForm(this.name);
        }
    };
}
var FormContainer = class _FormContainer {
    static increaseFormRef(name) {
        const count = containerFormRefs.get(name);
        containerFormRefs.set(name, (count !== null && count !== void 0 ? count : 0) + 1);
    }
    static decreaseFormRef(name) {
        const count = containerFormRefs.get(name);
        containerFormRefs.set(name, (count !== null && count !== void 0 ? count : 0) - 1);
    }
    static hasFormRef(name) {
        const count = containerFormRefs.get(name);
        return !(0, import_isUndefined12.default)(count) && count > 0;
    }
    getForms() {
        return (0, import_toArray2.default)(containerForms.values());
    }
    getForm(name) {
        if (!containerForms.has(name)) {
            return void 0;
        }
        _FormContainer.increaseFormRef(name);
        const DelegatingForm = defineForm(name);
        return new DelegatingForm();
    }
    hasForm(name) {
        return name && containerForms.has(name);
    }
    newForm(name) {
        if ((0, import_isEmpty13.default)(name)) {
            return;
        }
        containerForms.set(name, new FormAttributes());
    }
    releaseForm(name) {
        if ((0, import_isEmpty13.default)(name)) {
            return;
        }
        _FormContainer.decreaseFormRef(name);
        if (!_FormContainer.hasFormRef(name)) {
            var _containerForms_get;
            (_containerForms_get = containerForms.get(name)) === null || _containerForms_get === void 0 ? void 0 : _containerForms_get.release();
            containerForms.delete(name);
        }
    }
};
var formContainer = new FormContainer();
function useConstant(value) {
    const [constant] = (0, import_react95.useState)(value);
    return constant;
}
function useForm(name = "", options = {}) {
    const { defaultValues, values: values2 } = options;
    const hasForm = formContainer.hasForm(name);
    const immutableHasForm = useConstant(hasForm);
    const nameRef = useToRef(name);
    if (!hasForm && !(0, import_isEmpty13.default)(name)) {
        formContainer.newForm(name);
    }
    (0, import_react95.useEffect)(()=>{
        if (!immutableHasForm && (0, import_isPlainObject5.default)(defaultValues)) {
            var _formContainer_getForm;
            (_formContainer_getForm = formContainer.getForm(nameRef.current)) === null || _formContainer_getForm === void 0 ? void 0 : _formContainer_getForm.setDefaultValues(defaultValues);
        }
    }, []);
    (0, import_react95.useEffect)(()=>{
        if (!immutableHasForm && (0, import_isPlainObject5.default)(values2)) {
            var _formContainer_getForm;
            (_formContainer_getForm = formContainer.getForm(nameRef.current)) === null || _formContainer_getForm === void 0 ? void 0 : _formContainer_getForm.setValues(values2);
        }
    }, [
        nameRef,
        values2
    ]);
    (0, import_react95.useEffect)(()=>()=>formContainer.releaseForm(name), [
        name
    ]);
    return (0, import_react95.useMemo)(()=>formContainer.getForm(name), [
        name
    ]);
}
// node_modules/@taroify/core/form/form.js
var Form2 = (0, import_react96.forwardRef)((props, ref)=>{
    const { name: nameProp, defaultValues, values: values2, labelAlign, controlAlign, validateTrigger = "onBlur", colon, disabled, children: childrenProp, onValidate, onValuesChange, onSubmit, onReset } = props, restProps = _object_without_properties(props, [
        "name",
        "defaultValues",
        "values",
        "labelAlign",
        "controlAlign",
        "validateTrigger",
        "colon",
        "disabled",
        "children",
        "onValidate",
        "onValuesChange",
        "onSubmit",
        "onReset"
    ]);
    const forceUpdate = use_force_update_default();
    const nameId = use_unique_id_default();
    const name = nameProp !== null && nameProp !== void 0 ? nameProp : nameId;
    const { getErrors, setErrors, setValues, getValues, validate, reset, setFieldsValue, getFieldsValue, validateFields, addEventListener, removeEventListener } = useForm(name, {
        defaultValues,
        values: values2
    });
    const delegatingReset = (0, import_react96.useCallback)((e)=>{
        nextTick(()=>{
            reset();
            onReset === null || onReset === void 0 ? void 0 : onReset(e);
        });
    }, [
        onReset,
        reset
    ]);
    const handleSubmit = (0, import_react96.useCallback)((e)=>{
        validate().then((values3)=>{
            const event = Object.assign({}, e, {
                detail: _object_spread_props(_object_spread({}, e.detail), {
                    value: values3
                })
            });
            onSubmit === null || onSubmit === void 0 ? void 0 : onSubmit(event);
        }).catch((errors)=>onValidate === null || onValidate === void 0 ? void 0 : onValidate(errors));
    }, [
        onSubmit,
        onValidate,
        validate
    ]);
    const handleReset = (0, import_react96.useCallback)((e)=>{
        preventDefault(e);
        delegatingReset(e);
    }, [
        delegatingReset
    ]);
    (0, import_react96.useImperativeHandle)(ref, ()=>({
            submit: ()=>handleSubmit({}),
            getErrors,
            setErrors,
            getValues,
            setValues,
            validate,
            reset: ()=>delegatingReset(),
            setFieldsValue,
            getFieldsValue,
            validateFields
        }), [
        handleSubmit,
        delegatingReset,
        getErrors,
        getFieldsValue,
        getValues,
        setErrors,
        setFieldsValue,
        setValues,
        validate,
        validateFields
    ]);
    (0, import_react96.useEffect)(()=>{
        if (onValuesChange) {
            addEventListener("change", onValuesChange);
        }
        return ()=>{
            if (onValuesChange) {
                removeEventListener("change", onValuesChange);
            }
        };
    }, [
        addEventListener,
        onValuesChange,
        removeEventListener
    ]);
    (0, import_react96.useEffect)(()=>{
        addEventListener("reset", forceUpdate);
        return ()=>removeEventListener("reset", forceUpdate);
    }, [
        addEventListener,
        forceUpdate,
        onValuesChange,
        removeEventListener
    ]);
    return React79.createElement(form_context_default.Provider, {
        value: {
            name,
            colon,
            disabled,
            labelAlign,
            controlAlign,
            validateTrigger
        }
    }, React79.createElement(Form, _object_spread({
        onSubmit: handleSubmit,
        onReset: handleReset,
        children: childrenProp
    }, restProps)));
});
var form_default = Form2;
// node_modules/@taroify/core/form/form-control.js
var import_classnames71 = __toESM(require_classnames());
var import_isFunction6 = __toESM(require_isFunction());
var React95 = __toESM(require_react());
var import_react116 = __toESM(require_react());
// node_modules/@taroify/core/form/control/form-control-handlers.js
var import_react114 = __toESM(require_react());
// node_modules/@taroify/core/radio/radio.js
var import_classnames57 = __toESM(require_classnames());
var React80 = __toESM(require_react());
var import_react98 = __toESM(require_react());
// node_modules/@taroify/core/radio/radio-group.context.js
var import_react97 = __toESM(require_react());
var RadioGroupContext = (0, import_react97.createContext)({});
var radio_group_context_default = RadioGroupContext;
// node_modules/@taroify/core/radio/radio.js
function Radio(props) {
    const { className, name, disabled: disabledProp, shape = "round", icon = React80.createElement(Success_default, null), size: sizeProp, children: children2, onClick } = props, restProps = _object_without_properties(props, [
        "className",
        "name",
        "disabled",
        "shape",
        "icon",
        "size",
        "children",
        "onClick"
    ]);
    const { value, direction, disabled: disabledGroup, size: sizeGroup, onChange } = (0, import_react98.useContext)(radio_group_context_default);
    const size = sizeProp !== null && sizeProp !== void 0 ? sizeProp : sizeGroup;
    const disabled = disabledProp !== null && disabledProp !== void 0 ? disabledProp : disabledGroup;
    const checked = name === value;
    function handleClick(event) {
        onClick === null || onClick === void 0 ? void 0 : onClick(event);
        if (!disabled && name !== value) {
            onChange === null || onChange === void 0 ? void 0 : onChange(name);
        }
    }
    return React80.createElement(View, _object_spread({
        className: (0, import_classnames57.default)(prefixClassname("radio"), {
            [prefixClassname("radio--horizontal")]: direction === "horizontal",
            [prefixClassname("radio--vertical")]: direction === "vertical"
        }, className),
        onClick: handleClick
    }, restProps), React80.createElement(View, {
        className: (0, import_classnames57.default)(prefixClassname("radio__icon"), prefixClassname(`radio__icon--${shape}`), {
            [prefixClassname("radio__icon--disabled")]: disabled,
            [prefixClassname("radio__icon--checked")]: checked
        }),
        style: {
            fontSize: size ? addUnitPx(size) : ""
        },
        children: icon
    }), children2 && React80.createElement(View, {
        className: (0, import_classnames57.default)(prefixClassname("radio__label"), {
            [prefixClassname("radio__label--disabled")]: disabled
        }),
        children: children2
    }));
}
// node_modules/@taroify/core/radio/radio-group.js
var import_classnames58 = __toESM(require_classnames());
var React81 = __toESM(require_react());
function RadioGroup(props) {
    const { className, defaultValue, value: valueProp, disabled, direction = "vertical", size, children: children2, onChange: onChangeProp } = props, restProps = _object_without_properties(props, [
        "className",
        "defaultValue",
        "value",
        "disabled",
        "direction",
        "size",
        "children",
        "onChange"
    ]);
    const { value, setValue } = useUncontrolled({
        value: valueProp,
        defaultValue,
        onChange: onChangeProp
    });
    return React81.createElement(radio_group_context_default.Provider, {
        value: {
            value,
            disabled,
            direction,
            size,
            onChange: setValue
        }
    }, React81.createElement(View, _object_spread({
        className: (0, import_classnames58.default)(prefixClassname("radio-group"), prefixClassname(`radio-group--${direction}`), className),
        children: children2
    }, restProps)));
}
var radio_group_default = RadioGroup;
// node_modules/@taroify/core/radio/index.js
var Radio2 = Radio;
Radio2.Group = radio_group_default;
var radio_default = Radio2;
// node_modules/@taroify/core/rate/rate.js
var import_classnames60 = __toESM(require_classnames());
var React83 = __toESM(require_react());
var import_react101 = __toESM(require_react());
// node_modules/@taroify/core/rate/rate-item.js
var import_classnames59 = __toESM(require_classnames());
var React82 = __toESM(require_react());
var import_react100 = __toESM(require_react());
// node_modules/@taroify/core/rate/rate.context.js
var import_react99 = __toESM(require_react());
var RateContext = (0, import_react99.createContext)({});
var rate_context_default = RateContext;
// node_modules/@taroify/core/rate/rate.shared.js
var RateStatus;
(function(RateStatus2) {
    RateStatus2["Full"] = "full";
    RateStatus2["Half"] = "half";
    RateStatus2["Void"] = "void";
})(RateStatus || (RateStatus = {}));
// node_modules/@taroify/core/rate/rate-item.js
function RateItem(props) {
    const { className, style, score, value, half, disabled, size, status } = props, restProps = _object_without_properties(props, [
        "className",
        "style",
        "score",
        "value",
        "half",
        "disabled",
        "size",
        "status"
    ]);
    const { gutter, count, emptyIcon, icon } = (0, import_react100.useContext)(rate_context_default);
    const empty = status === RateStatus.Void;
    const full = status === RateStatus.Full;
    return React82.createElement(View, _object_spread({
        className: (0, import_classnames59.default)(prefixClassname("rate__item"), className),
        style: _object_spread({
            paddingRight: score !== count ? addUnitPx(gutter) : ""
        }, style)
    }, restProps), cloneIconElement(full ? icon : emptyIcon, {
        size,
        className: (0, import_classnames59.default)(prefixClassname("rate__icon"), {
            [prefixClassname("rate__icon--disabled")]: disabled,
            [prefixClassname("rate__icon--full")]: full
        })
    }), half && cloneIconElement(icon, {
        style: {
            width: `${value}em`
        },
        size,
        className: (0, import_classnames59.default)(prefixClassname("rate__icon"), prefixClassname("rate__icon--half"), {
            [prefixClassname("rate__icon--disabled")]: disabled,
            [prefixClassname("rate__icon--full")]: !empty
        })
    }));
}
var rate_item_default = RateItem;
// node_modules/@taroify/core/rate/rate.js
function getRateStatus(value, index, allowHalf, readonly) {
    if (value >= index) {
        return {
            status: RateStatus.Full,
            value: 1
        };
    }
    if (value + 0.5 >= index && allowHalf && !readonly) {
        return {
            status: RateStatus.Half,
            value: 0.5
        };
    }
    if (value + 1 >= index && allowHalf && readonly) {
        const cardinal = Math.pow(10, 10);
        return {
            status: RateStatus.Half,
            value: Math.round((value - index + 1) * cardinal) / cardinal
        };
    }
    return {
        status: RateStatus.Void,
        value: 0
    };
}
function Rate(props) {
    const { className, defaultValue, value: valueProp, count = 5, size, gutter, allowHalf = false, readonly = false, disabled = false, touchable = true, icon = React83.createElement(Star_default, null), emptyIcon = React83.createElement(StarOutlined_default, null), onClick, onTouchStart, onTouchMove, onChange: onChangeProp } = props, restProps = _object_without_properties(props, [
        "className",
        "defaultValue",
        "value",
        "count",
        "size",
        "gutter",
        "allowHalf",
        "readonly",
        "disabled",
        "touchable",
        "icon",
        "emptyIcon",
        "onClick",
        "onTouchStart",
        "onTouchMove",
        "onChange"
    ]);
    const { value = 0, setValue } = useUncontrolled({
        value: valueProp,
        defaultValue,
        onChange: onChangeProp
    });
    const rootRef = (0, import_react101.useRef)();
    const untouchable = readonly || disabled || !touchable;
    const touch = useTouch();
    const getRanges = (0, import_react101.useCallback)(()=>getRects(rootRef, ` .${prefixClassname("rate__item")}`).then((rects)=>rects.flatMap((rect, index)=>allowHalf ? [
                    {
                        score: index + 0.5,
                        left: rect.left
                    },
                    {
                        score: index + 1,
                        left: rect.left + rect.width / 2
                    }
                ] : [
                    {
                        score: index + 1,
                        left: rect.left
                    }
                ])), [
        allowHalf
    ]);
    const getScoreByPosition = (0, import_react101.useCallback)((x)=>getRanges().then((ranges)=>{
            for(let i = ranges.length - 1; i > 0; i--){
                if (x > ranges[i].left) {
                    return ranges[i].score;
                }
            }
            return allowHalf ? 0.5 : 1;
        }), [
        allowHalf,
        getRanges
    ]);
    const onItemClick = (0, import_react101.useCallback)((event)=>{
        onClick === null || onClick === void 0 ? void 0 : onClick(event);
        if (untouchable) {
            return;
        }
        const { clientX } = getClientCoordinates(event);
        getScoreByPosition(clientX).then((newValue)=>{
            setValue(newValue);
        });
    }, [
        onClick,
        untouchable,
        getScoreByPosition,
        setValue
    ]);
    const handleTouchStart = (0, import_react101.useCallback)((event)=>{
        if (untouchable) {
            return;
        }
        touch.start(event);
    }, [
        touch,
        untouchable
    ]);
    const handleTouchMove = (0, import_react101.useCallback)((event)=>{
        if (untouchable) {
            return;
        }
        touch.move(event);
        if (touch.isHorizontal()) {
            preventDefault(event);
            onItemClick(event);
        }
    }, [
        untouchable,
        touch,
        onItemClick
    ]);
    const renderStar = (0, import_react101.useCallback)((item, index)=>{
        const renderHalf = allowHalf && item.value > 0 && item.value < 1;
        return React83.createElement(rate_item_default, {
            key: index,
            score: index + 1,
            disabled,
            size,
            half: renderHalf,
            value: item.value,
            status: item.status
        });
    }, [
        allowHalf,
        disabled,
        size
    ]);
    const stars = (0, import_react101.useMemo)(()=>Array(count).fill("").map((__, i)=>getRateStatus(value, i + 1, allowHalf, readonly)).map(renderStar), [
        allowHalf,
        count,
        readonly,
        renderStar,
        value
    ]);
    return React83.createElement(View, _object_spread({
        ref: rootRef,
        className: (0, import_classnames60.default)(prefixClassname("rate"), {
            [prefixClassname("rate--disabled")]: disabled,
            [prefixClassname("rate--readonly")]: readonly
        }, className),
        catchMove: true,
        onClick: onItemClick,
        onTouchStart: (event)=>{
            handleTouchStart(event);
            onTouchStart === null || onTouchStart === void 0 ? void 0 : onTouchStart(event);
        },
        onTouchMove: (event)=>{
            handleTouchMove(event);
            onTouchMove === null || onTouchMove === void 0 ? void 0 : onTouchMove(event);
        }
    }, restProps), React83.createElement(rate_context_default.Provider, {
        value: {
            gutter,
            count,
            icon,
            emptyIcon
        },
        children: stars
    }));
}
var rate_default = Rate;
// node_modules/@taroify/core/slider/slider.js
var import_classnames62 = __toESM(require_classnames());
var import_clamp6 = __toESM(require_clamp());
var React85 = __toESM(require_react());
var import_react104 = __toESM(require_react());
// node_modules/@taroify/core/utils/format/number.js
var import_toNumber3 = __toESM(require_toNumber());
var import_padStart2 = __toESM(require_padStart());
var import_toString3 = __toESM(require_toString());
function trimExtraChar(value, char, regExp) {
    const index = value.indexOf(char);
    if (index === -1) {
        return value;
    }
    if (char === "-" && index !== 0) {
        return value.slice(0, index);
    }
    return value.slice(0, index + 1) + value.slice(index).replace(regExp, "");
}
function formatNumber(value, allowDot = true, allowMinus = true) {
    let valueCache = value;
    if (allowDot) {
        valueCache = trimExtraChar(valueCache, ".", /\./g);
    } else {
        valueCache = valueCache.split(".")[0];
    }
    if (allowMinus) {
        valueCache = trimExtraChar(valueCache, "-", /-/g);
    } else {
        valueCache = valueCache.replace(/-/, "");
    }
    const regExp = allowDot ? /[^-0-9.]/g : /[^-0-9]/g;
    return valueCache.replace(regExp, "");
}
function addNumber(num1, num2) {
    const cardinal = Math.pow(10, 10);
    return Math.round(((0, import_toNumber3.default)(num1) + (0, import_toNumber3.default)(num2)) * cardinal) / cardinal;
}
function padZero(num, targetLength = 2) {
    return (0, import_padStart2.default)((0, import_toString3.default)(num), targetLength, "0");
}
// node_modules/@taroify/core/slider/slider-thumb.js
var import_classnames61 = __toESM(require_classnames());
var React84 = __toESM(require_react());
var import_react103 = __toESM(require_react());
// node_modules/@taroify/core/slider/slider.context.js
var import_react102 = __toESM(require_react());
var SliderContext = (0, import_react102.createContext)({});
var slider_context_default = SliderContext;
// node_modules/@taroify/core/slider/slider-thumb.js
function SliderThumb(props) {
    const { className, size, index, children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "size",
        "index",
        "children"
    ]);
    const { onTouchStart, onTouchMove, onTouchEnd } = (0, import_react103.useContext)(slider_context_default);
    return React84.createElement(View, {
        className: (0, import_classnames61.default)({
            [prefixClassname("slider__thumb-wrapper")]: index === void 0,
            [prefixClassname("slider__thumb-wrapper-left")]: index === 0,
            [prefixClassname("slider__thumb-wrapper-right")]: index === 1
        }),
        style: _object_spread({}, getSizeStyle(size)),
        catchMove: true,
        onTouchStart: (event)=>onTouchStart === null || onTouchStart === void 0 ? void 0 : onTouchStart(event, index),
        onTouchMove: (event)=>onTouchMove === null || onTouchMove === void 0 ? void 0 : onTouchMove(event, index),
        onTouchEnd: (event)=>onTouchEnd === null || onTouchEnd === void 0 ? void 0 : onTouchEnd(event, index),
        onTouchCancel: (event)=>onTouchEnd === null || onTouchEnd === void 0 ? void 0 : onTouchEnd(event, index),
        onClick: stopPropagation
    }, children2 !== null && children2 !== void 0 ? children2 : React84.createElement(View, _object_spread({
        className: (0, import_classnames61.default)(prefixClassname("slider__thumb"), className)
    }, restProps)));
}
var slider_thumb_default = SliderThumb;
// node_modules/@taroify/core/slider/slider.js
var SliderDragStatus;
(function(SliderDragStatus2) {
    SliderDragStatus2["Start"] = "start";
    SliderDragStatus2["Dragging"] = "dragging";
    SliderDragStatus2["End"] = "end";
})(SliderDragStatus || (SliderDragStatus = {}));
function useSliderChildren(children2, range) {
    return (0, import_react104.useMemo)(()=>{
        const __children__ = {
            thumb1: void 0,
            thumb2: void 0
        };
        import_react104.Children.forEach(children2, (child)=>{
            if (!(0, import_react104.isValidElement)(child)) {
                return;
            }
            const element = child;
            if (__children__.thumb1 === void 0) {
                __children__.thumb1 = element;
            } else if (__children__.thumb2 === void 0) {
                __children__.thumb2 = element;
            }
        });
        var __children___thumb1;
        __children__.thumb1 = (__children___thumb1 = __children__.thumb1) !== null && __children___thumb1 !== void 0 ? __children___thumb1 : React85.createElement(slider_thumb_default, null);
        if (range) {
            __children__.thumb1 = (0, import_react104.cloneElement)(__children__.thumb1, {
                key: 0,
                index: 0
            });
            var __children___thumb2;
            __children__.thumb2 = (__children___thumb2 = __children__.thumb2) !== null && __children___thumb2 !== void 0 ? __children___thumb2 : React85.createElement(slider_thumb_default, null);
            __children__.thumb2 = (0, import_react104.cloneElement)(__children__.thumb2, {
                key: 1,
                index: 1
            });
        } else {
            __children__.thumb1 = (0, import_react104.cloneElement)(__children__.thumb1, {
                index: void 0
            });
        }
        return __children__;
    }, [
        children2,
        range
    ]);
}
function Slider(props) {
    const { className, style = {}, defaultValue, value: valueProp = void 0, min = 0, max = 100, step = 1, range = false, size, orientation = "horizontal", disabled = false, children: children2, onClick, onChange: onChangeProp } = props, restProps = _object_without_properties(props, [
        "className",
        "style",
        "defaultValue",
        "value",
        "min",
        "max",
        "step",
        "range",
        "size",
        "orientation",
        "disabled",
        "children",
        "onClick",
        "onChange"
    ]);
    const { value = 0, setValue } = useUncontrolled({
        defaultValue,
        value: valueProp,
        onChange: onChangeProp
    });
    const { thumb1, thumb2 } = useSliderChildren(children2, range);
    const vertical = orientation === "vertical";
    const rootRef = (0, import_react104.useRef)();
    const dragStatusRef = (0, import_react104.useRef)();
    const startValueRef = (0, import_react104.useRef)(0);
    const currentValueRef = (0, import_react104.useRef)(0);
    const buttonIndexRef = (0, import_react104.useRef)();
    const touch = useTouch();
    const scope = (0, import_react104.useMemo)(()=>Number(max) - Number(min), [
        max,
        min
    ]);
    const isRange = (0, import_react104.useCallback)((val)=>range && Array.isArray(val), [
        range
    ]);
    const calcMainAxis = (0, import_react104.useCallback)(()=>{
        if (isRange(value)) {
            return `${(value[1] - value[0]) * 100 / scope}%`;
        }
        return `${(value - Number(min)) * 100 / scope}%`;
    }, [
        isRange,
        min,
        scope,
        value
    ]);
    const calcOffset = (0, import_react104.useCallback)(()=>{
        if (isRange(value)) {
            return `${(value[0] - Number(min)) * 100 / scope}%`;
        }
        return "0%";
    }, [
        isRange,
        min,
        scope,
        value
    ]);
    const wrapperStyle = (0, import_react104.useMemo)(()=>{
        const crossAxis = vertical ? "width" : "height";
        var _addUnitPx;
        return _object_spread_props(_object_spread({}, style), {
            [crossAxis]: (_addUnitPx = addUnitPx(size)) !== null && _addUnitPx !== void 0 ? _addUnitPx : ""
        });
    }, [
        size,
        style,
        vertical
    ]);
    const trackStyle = (0, import_react104.useMemo)(()=>{
        const mainAxis = vertical ? "height" : "width";
        return {
            [mainAxis]: calcMainAxis(),
            left: vertical ? "" : calcOffset(),
            top: vertical ? calcOffset() : "",
            transition: dragStatusRef.current ? "none" : ""
        };
    }, [
        calcMainAxis,
        calcOffset,
        vertical
    ]);
    const formatValue = (value2)=>{
        const valueCache = (0, import_clamp6.default)(value2, min, max);
        const diff = Math.round((valueCache - min) / step) * step;
        return addNumber(min, diff);
    };
    const isSameValue = (newValue, oldValue)=>JSON.stringify(newValue) === JSON.stringify(oldValue);
    const handleOverlap = (value2)=>{
        if (value2[0] > value2[1]) {
            return value2.slice(0).reverse();
        }
        return value2;
    };
    const updateValue = (newValue)=>{
        let newValueCache = newValue;
        if (isRange(newValueCache)) {
            newValueCache = handleOverlap(newValueCache).map(formatValue);
        } else {
            newValueCache = formatValue(newValueCache);
        }
        if (!isSameValue(newValueCache, value)) {
            setValue(newValueCache);
        }
    };
    const handleClick = (event)=>{
        onClick === null || onClick === void 0 ? void 0 : onClick(event);
        stopPropagation(event);
        if (disabled) {
            return;
        }
        getRect(rootRef).then((rect)=>{
            const { clientX, clientY } = getClientCoordinates(event);
            const delta = vertical ? clientY - rect.top : clientX - rect.left;
            const total = vertical ? rect.height : rect.width;
            const newValue = Number(min) + delta / total * scope;
            if (isRange(value)) {
                const [left, right] = value;
                const middle = (left + right) / 2;
                if (newValue <= middle) {
                    updateValue([
                        newValue,
                        right
                    ]);
                } else {
                    updateValue([
                        left,
                        newValue
                    ]);
                }
            } else {
                updateValue(newValue);
            }
        });
    };
    const onTouchStart = (event, index)=>{
        if (typeof index === "number") {
            buttonIndexRef.current = index;
        }
        if (disabled) {
            return;
        }
        touch.start(event);
        currentValueRef.current = value;
        if (isRange(currentValueRef.current)) {
            startValueRef.current = currentValueRef.current.map(formatValue);
        } else {
            startValueRef.current = formatValue(currentValueRef.current);
        }
        dragStatusRef.current = SliderDragStatus.Start;
    };
    const onTouchMove = (event)=>{
        if (disabled) {
            return;
        }
        preventDefault(event, true);
        touch.move(event);
        dragStatusRef.current = SliderDragStatus.Dragging;
        getRect(rootRef).then((rect)=>{
            const delta = vertical ? touch.deltaY : touch.deltaX;
            const total = vertical ? rect.height : rect.width;
            const diff = delta / total * scope;
            if (isRange(startValueRef.current)) {
                ;
                currentValueRef.current[buttonIndexRef.current] = startValueRef.current[buttonIndexRef.current] + diff;
            } else {
                currentValueRef.current = startValueRef.current + diff;
            }
            updateValue(currentValueRef.current);
        });
    };
    const onTouchEnd = ()=>{
        if (disabled) {
            return;
        }
        if (dragStatusRef.current === SliderDragStatus.Dragging) {
            updateValue(currentValueRef.current);
        }
        dragStatusRef.current = SliderDragStatus.End;
    };
    return React85.createElement(View, _object_spread({
        ref: rootRef,
        className: (0, import_classnames62.default)((0, import_classnames62.default)(prefixClassname("slider"), {
            [prefixClassname("slider--vertical")]: vertical,
            [prefixClassname("slider--disabled")]: disabled
        }), className),
        style: wrapperStyle,
        onClick: handleClick
    }, restProps), React85.createElement(slider_context_default.Provider, {
        value: {
            onTouchStart,
            onTouchMove,
            onTouchEnd
        }
    }, React85.createElement(View, {
        className: prefixClassname("slider__track"),
        style: trackStyle
    }, range ? [
        thumb1,
        thumb2
    ] : thumb1)));
}
var slider_default = Slider;
// node_modules/@taroify/core/slider/index.js
var Slider2 = slider_default;
Slider2.Thumb = slider_thumb_default;
var slider_default2 = Slider2;
// node_modules/@taroify/core/stepper/stepper.js
var import_classnames64 = __toESM(require_classnames());
var React88 = __toESM(require_react());
var import_react108 = __toESM(require_react());
// node_modules/@taroify/core/stepper/stepper-button.js
var import_classnames63 = __toESM(require_classnames());
var React86 = __toESM(require_react());
var import_react106 = __toESM(require_react());
// node_modules/@taroify/core/stepper/stepper.context.js
var import_react105 = __toESM(require_react());
var StepperContext = (0, import_react105.createContext)({});
var stepper_context_default = StepperContext;
// node_modules/@taroify/core/stepper/stepper-button.js
var LONG_PRESS_INTERVAL = 200;
var LONG_PRESS_START_TIME = 600;
function StepperButton(props) {
    const { className, style, type = "decrease", disabled: disabledProp, onClick, onTouchStart, onTouchEnd, onTouchCancel } = props, restProps = _object_without_properties(props, [
        "className",
        "style",
        "type",
        "disabled",
        "onClick",
        "onTouchStart",
        "onTouchEnd",
        "onTouchCancel"
    ]);
    const { value = 0, min = 0, max = 0, size, disabled: disabledCtx, longPress, onStep } = (0, import_react106.useContext)(stepper_context_default);
    const disabled = disabledProp || disabledCtx || type === "decrease" && Number(value) <= min || type === "increase" && Number(value) >= max;
    const longPressRef = (0, import_react106.useRef)(false);
    const longPressTimerRef = (0, import_react106.useRef)();
    const longPressStep = (0, import_react106.useCallback)(()=>{
        longPressTimerRef.current = setTimeout(()=>{
            onStep === null || onStep === void 0 ? void 0 : onStep(type);
            longPressStep();
        }, LONG_PRESS_INTERVAL);
    }, [
        onStep,
        type
    ]);
    const handleTouchStart = (0, import_react106.useCallback)(()=>{
        if (longPress) {
            longPressRef.current = false;
            if (longPressTimerRef.current) {
                clearTimeout(longPressTimerRef.current);
            }
            longPressTimerRef.current = setTimeout(()=>{
                longPressRef.current = true;
                onStep === null || onStep === void 0 ? void 0 : onStep(type);
                longPressStep();
            }, LONG_PRESS_START_TIME);
        }
    }, [
        longPress,
        longPressStep,
        onStep,
        type
    ]);
    const handleTouchEnd = (0, import_react106.useCallback)((event)=>{
        if (longPress) {
            if (longPressTimerRef.current) {
                clearTimeout(longPressTimerRef.current);
            }
            if (longPressRef.current) {
                preventDefault(event);
            }
        }
    }, [
        longPress
    ]);
    return React86.createElement(View, _object_spread({
        className: (0, import_classnames63.default)(prefixClassname(`stepper__${type}`), {
            [prefixClassname(`stepper__${type}--disabled`)]: disabled
        }, className),
        style: getSizeStyle(size),
        onClick: (event)=>{
            preventDefault(event);
            onClick === null || onClick === void 0 ? void 0 : onClick(event);
            if (!disabled) {
                onStep === null || onStep === void 0 ? void 0 : onStep(type);
            }
        },
        onTouchStart: (event)=>{
            onTouchStart === null || onTouchStart === void 0 ? void 0 : onTouchStart(event);
            if (!disabled) {
                handleTouchStart();
            }
        },
        onTouchEnd: (event)=>{
            onTouchEnd === null || onTouchEnd === void 0 ? void 0 : onTouchEnd(event);
            handleTouchEnd(event);
        },
        onTouchCancel: (event)=>{
            onTouchCancel === null || onTouchCancel === void 0 ? void 0 : onTouchCancel(event);
            handleTouchEnd(event);
        }
    }, restProps));
}
var stepper_button_default = StepperButton;
// node_modules/@taroify/core/stepper/stepper-input.js
var React87 = __toESM(require_react());
var import_react107 = __toESM(require_react());
function StepperInput(props) {
    const { width, disabled: disabledProp, cursor, onFocus } = props;
    const { value: valueProp, size, disabled, precision = 0, formatValue, onChange } = (0, import_react107.useContext)(stepper_context_default);
    const digit = precision > 0;
    const rootRef = (0, import_react107.useRef)();
    const [value, setValue] = (0, import_react107.useState)();
    (0, import_react107.useEffect)(()=>setValue(valueProp), [
        valueProp
    ]);
    const onTouchEnd = (0, import_react107.useCallback)((event)=>{
        if (disabledProp) {
            preventDefault(event);
        }
    }, [
        disabledProp
    ]);
    const handleFocus = (0, import_react107.useCallback)((event)=>{
        if (disabledProp) {
            var _rootRef_current;
            (_rootRef_current = rootRef.current) === null || _rootRef_current === void 0 ? void 0 : _rootRef_current.blur();
        } else {
            onFocus === null || onFocus === void 0 ? void 0 : onFocus(event);
        }
    }, [
        disabledProp,
        onFocus
    ]);
    const onInput = (0, import_react107.useCallback)(({ detail })=>{
        const { value: inputValue } = detail;
        let formatted = formatNumber(String(inputValue), digit);
        if (precision > 0 && formatted.includes(".")) {
            const pair = formatted.split(".");
            formatted = `${pair[0]}.${pair[1].slice(0, precision)}`;
        }
        const isNumeric = formatted === String(+formatted);
        setValue(isNumeric ? +formatted : formatted);
    }, [
        digit,
        precision
    ]);
    const onBlur = (0, import_react107.useCallback)(({ detail })=>{
        const { value: inputValue } = detail;
        const value2 = formatValue === null || formatValue === void 0 ? void 0 : formatValue(inputValue);
        setValue(value2);
        onChange === null || onChange === void 0 ? void 0 : onChange(value2);
    }, [
        formatValue,
        onChange
    ]);
    return React87.createElement(Input, {
        ref: rootRef,
        className: prefixClassname("stepper__input"),
        style: {
            width: width ? addUnitPx(width) : "",
            height: size ? addUnitPx(size) : ""
        },
        disabled: disabledProp || disabled,
        type: digit ? "digit" : "number",
        cursor,
        value,
        onTouchEnd,
        onFocus: handleFocus,
        onInput,
        onBlur
    });
}
var stepper_input_default = StepperInput;
// node_modules/@taroify/core/stepper/stepper.js
var { deprecated } = getLogger("Stepper");
function useStepperChildren(children2) {
    return (0, import_react108.useMemo)(()=>{
        const __children__ = {};
        import_react108.Children.forEach(children2, (child)=>{
            if (!(0, import_react108.isValidElement)(child)) {
                return;
            }
            const element = child;
            const elementType = element.type;
            if (elementType === stepper_button_default) {
                if (__children__.decrease === void 0) {
                    __children__.decrease = (0, import_react108.cloneElement)(element, {
                        type: "decrease"
                    });
                } else if (__children__.increase === void 0) {
                    __children__.increase = (0, import_react108.cloneElement)(element, {
                        type: "increase"
                    });
                }
            } else if (elementType === stepper_input_default) {
                __children__.input = element;
            }
        });
        if (!children2) {
            const element = React88.createElement(stepper_button_default, null);
            if (__children__.decrease === void 0) {
                __children__.decrease = (0, import_react108.cloneElement)(element, {
                    type: "decrease"
                });
            }
            if (__children__.input === void 0) {
                __children__.input = React88.createElement(stepper_input_default, null);
            }
            if (__children__.increase === void 0) {
                __children__.increase = (0, import_react108.cloneElement)(element, {
                    type: "increase"
                });
            }
        }
        return __children__;
    }, [
        children2
    ]);
}
function Stepper(props) {
    const { className, defaultValue, value: valueProp, min = 1, max = Number.MAX_VALUE, step = 1, size, disabled, precision = 0, longPress = true, shape = "rounded", children: childrenProp, onChange: onChangeProp } = props, restProps = _object_without_properties(props, [
        "className",
        "defaultValue",
        "value",
        "min",
        "max",
        "step",
        "size",
        "disabled",
        "precision",
        "longPress",
        "shape",
        "children",
        "onChange"
    ]);
    if (shape === "round") {
        deprecated('Use the shape="circular" prop instead of the shape="round" prop');
    }
    const { decrease, input, increase } = useStepperChildren(childrenProp);
    const { value = 0, setValue } = useUncontrolled({
        value: valueProp,
        defaultValue,
        onChange: onChangeProp
    });
    const formatValue = (0, import_react108.useCallback)((value2)=>{
        if (value2 === "") {
            return value2;
        }
        let valueCache = value2;
        valueCache = formatNumber(String(valueCache), precision > 0);
        valueCache = valueCache === "" ? 0 : +valueCache;
        valueCache = Number.isNaN(valueCache) ? +min : valueCache;
        valueCache = Math.max(Math.min(+max, valueCache), +min);
        if (precision > 0) {
            valueCache = valueCache.toFixed(+precision);
        }
        return valueCache;
    }, [
        max,
        min,
        precision
    ]);
    const valueRef = useToRef(formatValue(value));
    const onStep = (0, import_react108.useCallback)((actionType)=>{
        const diff = actionType === "decrease" ? -step : +step;
        setValue(formatValue(addNumber(valueRef.current, diff)));
    }, [
        formatValue,
        setValue,
        step,
        valueRef
    ]);
    return React88.createElement(stepper_context_default.Provider, {
        value: {
            value: valueRef.current,
            min,
            max,
            size,
            disabled,
            precision,
            longPress,
            formatValue,
            onChange: setValue,
            onStep
        }
    }, React88.createElement(View, _object_spread({
        className: (0, import_classnames64.default)(prefixClassname("stepper"), {
            [prefixClassname("stepper--square")]: shape === "square",
            [prefixClassname("stepper--rounded")]: shape === "rounded",
            [prefixClassname("stepper--circular")]: shape === "circular" || shape === "round"
        }, className)
    }, restProps), decrease, input, increase));
}
var stepper_default = Stepper;
// node_modules/@taroify/core/stepper/index.js
var Stepper2 = stepper_default;
Stepper2.Input = stepper_input_default;
Stepper2.Button = stepper_button_default;
var stepper_default2 = Stepper2;
// node_modules/@taroify/core/switch/switch.js
var import_classnames65 = __toESM(require_classnames());
var React89 = __toESM(require_react());
function Switch2(props) {
    const { className, style, defaultChecked, checked: checkedProp, loading = false, disabled = false, size, onChange: onChangeProp, onClick } = props, restProps = _object_without_properties(props, [
        "className",
        "style",
        "defaultChecked",
        "checked",
        "loading",
        "disabled",
        "size",
        "onChange",
        "onClick"
    ]);
    const { value: checked = false, setValue } = useUncontrolled({
        value: checkedProp,
        defaultValue: defaultChecked,
        onChange: onChangeProp
    });
    function handleClick(event) {
        onClick === null || onClick === void 0 ? void 0 : onClick(event);
        if (disabled || loading) {
            return;
        }
        setValue(!checked);
    }
    return React89.createElement(View, _object_spread({
        className: (0, import_classnames65.default)(prefixClassname("switch"), {
            [prefixClassname("switch--checked")]: checked,
            [prefixClassname("switch--loading")]: loading,
            [prefixClassname("switch--disabled")]: disabled
        }, className),
        style: _object_spread({
            fontSize: addUnitPx(size)
        }, style),
        onClick: handleClick
    }, restProps), React89.createElement(View, {
        className: prefixClassname("switch__node")
    }, loading && React89.createElement(Loading, {
        className: prefixClassname("switch__loading")
    })));
}
var switch_default = Switch2;
// node_modules/@taroify/core/uploader/uploader.js
var import_classnames70 = __toESM(require_classnames());
var import_filter5 = __toESM(require_filter());
var import_map16 = __toESM(require_map());
var import_isEmpty14 = __toESM(require_isEmpty());
var React94 = __toESM(require_react());
var import_react113 = __toESM(require_react());
// node_modules/@taroify/core/uploader/uploader-image.js
var import_classnames67 = __toESM(require_classnames());
var React91 = __toESM(require_react());
var import_react110 = __toESM(require_react());
// node_modules/@taroify/core/uploader/uploader-remove.js
var import_classnames66 = __toESM(require_classnames());
var React90 = __toESM(require_react());
function UploaderRemove(props) {
    const { className, icon = React90.createElement(Cross_default, null) } = props, restProps = _object_without_properties(props, [
        "className",
        "icon"
    ]);
    return React90.createElement(View, _object_spread({
        className: (0, import_classnames66.default)(prefixClassname("uploader__preview-remove"), className)
    }, restProps), cloneIconElement(icon, {
        className: prefixClassname("uploader__preview-remove-icon")
    }));
}
var uploader_remove_default = UploaderRemove;
// node_modules/@taroify/core/uploader/uploader.context.js
var import_react109 = __toESM(require_react());
var UploaderContext = (0, import_react109.createContext)({});
var uploader_context_default = UploaderContext;
// node_modules/@taroify/core/uploader/uploader.utils.js
var IMAGE_REGEXP = /\.(jpeg|jpg|gif|png|svg|webp|jfif|bmp|dpg)/i;
function isImageFile(item) {
    if (item.type) {
        return item.type.indexOf("image") === 0;
    }
    if (item.url) {
        return IMAGE_REGEXP.test(item.url);
    }
    return false;
}
// node_modules/@taroify/core/uploader/uploader-image.js
function UploaderImage(props) {
    const { className, type, url, name, removable: removableProp, mode, alt, round, children: children2, onRemove } = props, restProps = _object_without_properties(props, [
        "className",
        "type",
        "url",
        "name",
        "removable",
        "mode",
        "alt",
        "round",
        "children",
        "onRemove"
    ]);
    const { removable: ctxRemovable } = (0, import_react110.useContext)(uploader_context_default);
    const removable = removableProp !== null && removableProp !== void 0 ? removableProp : ctxRemovable;
    function renderFile() {
        if (isImageFile({
            type,
            url
        })) {
            return React91.createElement(Image3, {
                wrapperClassName: prefixClassname("uploader__preview-image-wrapper"),
                className: prefixClassname("uploader__preview-image"),
                src: url,
                mode,
                alt,
                round
            });
        }
        return React91.createElement(View, {
            className: prefixClassname("uploader__file")
        }, React91.createElement(Description_default, {
            className: prefixClassname("uploader__file-icon")
        }), React91.createElement(View, {
            className: (0, import_classnames67.default)(prefixClassname("uploader__file-name"), prefixClassname("ellipsis")),
            children: name !== null && name !== void 0 ? name : url
        }));
    }
    return React91.createElement(View, _object_spread({
        className: (0, import_classnames67.default)(prefixClassname("uploader__preview"), className)
    }, restProps), renderFile(), children2, removable && React91.createElement(uploader_remove_default, {
        onClick: onRemove
    }));
}
var uploader_image_default = UploaderImage;
// node_modules/@taroify/core/uploader/uploader-mask.js
var import_classnames68 = __toESM(require_classnames());
var React92 = __toESM(require_react());
var import_react111 = __toESM(require_react());
function renderIcon(icon) {
    if (isIconElement(icon)) {
        return cloneIconElement(icon, {
            className: prefixClassname("uploader__mask-icon")
        });
    }
    if ((0, import_react111.isValidElement)(icon) && icon.type === Loading) {
        const _icon_props = icon.props, { className } = _icon_props, restProps = _object_without_properties(_icon_props, [
            "className"
        ]);
        return (0, import_react111.cloneElement)(icon, _object_spread_props(_object_spread({}, restProps), {
            className: (0, import_classnames68.default)(prefixClassname("uploader__loading"), className)
        }));
    }
}
function UploaderMask(props) {
    const { className, icon, message } = props;
    return React92.createElement(View, {
        className: (0, import_classnames68.default)(prefixClassname("uploader__mask"), className)
    }, renderIcon(icon), message && React92.createElement(View, {
        className: prefixClassname("uploader__mask-message"),
        children: message
    }));
}
var uploader_mask_default = UploaderMask;
// node_modules/@taroify/core/uploader/uploader-upload.js
var import_classnames69 = __toESM(require_classnames());
var React93 = __toESM(require_react());
var import_react112 = __toESM(require_react());
function UploaderUpload(props) {
    const { className, readonly, icon = React93.createElement(Photograph_default, null), onClick, children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "readonly",
        "icon",
        "onClick",
        "children"
    ]);
    const { disabled, onUpload } = (0, import_react112.useContext)(uploader_context_default);
    function handleClick(event) {
        onClick === null || onClick === void 0 ? void 0 : onClick(event);
        if (!readonly && !disabled) {
            onUpload === null || onUpload === void 0 ? void 0 : onUpload();
        }
    }
    if (children2) {
        return React93.createElement(View, {
            onClick: handleClick
        }, children2);
    }
    return React93.createElement(View, _object_spread({
        className: (0, import_classnames69.default)(prefixClassname("uploader__upload"), {
            [prefixClassname("uploader__upload--readonly")]: readonly
        }, className),
        onClick: handleClick
    }, restProps), cloneIconElement(icon, {
        className: prefixClassname("uploader__upload-icon")
    }));
}
var uploader_upload_default = UploaderUpload;
// node_modules/@taroify/core/uploader/uploader.shared.js
var import_isArray8 = __toESM(require_isArray());
function getOneUploadFile(files) {
    return (0, import_isArray8.default)(files) ? files[0] : files;
}
function getUploadFiles(files) {
    return (0, import_isArray8.default)(files) ? files : [
        files
    ];
}
// node_modules/@taroify/core/uploader/uploader.js
function renderUploaderMask(file) {
    return ((file === null || file === void 0 ? void 0 : file.status) === "uploading" || (file === null || file === void 0 ? void 0 : file.status) === "failed") && React94.createElement(uploader_mask_default, {
        icon: (file === null || file === void 0 ? void 0 : file.status) === "uploading" ? React94.createElement(Loading, null) : (file === null || file === void 0 ? void 0 : file.status) === "failed" ? React94.createElement(Close_default, null) : void 0,
        message: file.message
    });
}
function UploadFilesRender(props) {
    const { defaultValue, value: valueProp, disabled, multiple, maxFiles = Number.MAX_VALUE, children: children2, onChange: onChangeProp } = props;
    const { value = [], setValue } = useUncontrolled({
        defaultValue,
        value: valueProp,
        onChange: onChangeProp
    });
    const renderImage = (0, import_react113.useCallback)((file, index)=>React94.createElement(uploader_image_default, {
            key: index,
            type: file === null || file === void 0 ? void 0 : file.type,
            url: file === null || file === void 0 ? void 0 : file.url,
            name: file === null || file === void 0 ? void 0 : file.name,
            removable: (file === null || file === void 0 ? void 0 : file.removable) && (file === null || file === void 0 ? void 0 : file.status) !== "uploading" ? true : void 0,
            children: renderUploaderMask(file),
            onRemove: ()=>{
                if (!disabled) {
                    if (multiple) {
                        setValue((0, import_filter5.default)(value, (item)=>item !== file));
                    } else {
                        setValue(null);
                    }
                }
            }
        }), [
        disabled,
        multiple,
        setValue,
        value
    ]);
    const files = (0, import_react113.useMemo)(()=>{
        if (!multiple) {
            return [];
        }
        const __files__ = (0, import_map16.default)(getUploadFiles(value), renderImage);
        if (__files__.length < maxFiles) {
            __files__.push(React94.createElement(uploader_upload_default, {
                key: "upload",
                children: children2
            }));
        }
        return __files__;
    }, [
        maxFiles,
        multiple,
        renderImage,
        value,
        children2
    ]);
    if ((0, import_isEmpty14.default)(value)) {
        return React94.createElement(uploader_upload_default, {
            children: children2
        });
    }
    if (!multiple) {
        const file = getOneUploadFile(value);
        return renderImage(file);
    }
    return files;
}
function Uploader(props) {
    const { className, defaultValue, value, disabled = false, removable = true, maxFiles, multiple, children: children2, onUpload, onChange } = props, restProps = _object_without_properties(props, [
        "className",
        "defaultValue",
        "value",
        "disabled",
        "removable",
        "maxFiles",
        "multiple",
        "children",
        "onUpload",
        "onChange"
    ]);
    return React94.createElement(uploader_context_default.Provider, {
        value: {
            removable,
            disabled,
            onUpload
        }
    }, React94.createElement(View, _object_spread({
        className: (0, import_classnames70.default)(prefixClassname("uploader"), className)
    }, restProps), React94.createElement(View, {
        className: (0, import_classnames70.default)(prefixClassname("uploader__wrapper"), {
            [prefixClassname("uploader__wrapper--disabled")]: disabled
        })
    }, React94.createElement(UploadFilesRender, {
        defaultValue,
        value,
        disabled,
        maxFiles,
        multiple,
        onChange,
        children: children2
    }))));
}
// node_modules/@taroify/core/uploader/index.js
var Uploader2 = Uploader;
Uploader2.Upload = uploader_upload_default;
Uploader2.Image = uploader_image_default;
var uploader_default = Uploader2;
// node_modules/@taroify/core/form/control/form-control-handler.js
var CONTROL_HANDLERS = [];
function doFormControlHandler(element, controller) {
    const { type } = element;
    for (const handler of CONTROL_HANDLERS){
        if (handler.supportsControlType(type)) {
            return handler.doControlRender(element, controller);
        }
    }
    return element;
}
function registerFormControlHandler(handler) {
    CONTROL_HANDLERS.push(handler);
}
// node_modules/@taroify/core/form/control/form-control-handlers.js
registerFormControlHandler(new class {
    doControlRender(element, controller) {
        const { name, value, validateStatus, disabled: disabledProp, onBlur: onDelegatingBlur, onChange: onDelegatingChange } = controller;
        const { props: elementProps } = element;
        const { name: nameProp, value: valueProp, color, onBlur, onInput, disabled } = elementProps;
        return (0, import_react114.cloneElement)(element, {
            name: nameProp !== null && nameProp !== void 0 ? nameProp : name,
            value: valueProp !== null && valueProp !== void 0 ? valueProp : value,
            color: color !== null && color !== void 0 ? color : validateStatus === "invalid" ? "danger" : void 0,
            disabled: disabled !== null && disabled !== void 0 ? disabled : disabledProp,
            onInput: (e)=>{
                onInput === null || onInput === void 0 ? void 0 : onInput(e);
                onDelegatingChange === null || onDelegatingChange === void 0 ? void 0 : onDelegatingChange(e.detail.value);
            },
            onBlur: (e)=>{
                onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
                onDelegatingBlur === null || onDelegatingBlur === void 0 ? void 0 : onDelegatingBlur(e.detail.value);
            }
        });
    }
    supportsControlType(elementType) {
        return elementType === Input || elementType === Textarea || elementType === input_default || elementType === textarea_default;
    }
}());
registerFormControlHandler(new class {
    doControlRender(element, controller) {
        const { name, value, onChange: onDelegatingChange, disabled: disabledProp } = controller;
        const { props: elementProps } = element;
        const { name: nameProp, checked: checkedProp, onChange, disabled } = elementProps;
        return (0, import_react114.cloneElement)(element, {
            name: nameProp !== null && nameProp !== void 0 ? nameProp : name,
            checked: checkedProp !== null && checkedProp !== void 0 ? checkedProp : value,
            disabled: disabled !== null && disabled !== void 0 ? disabled : disabledProp,
            onChange: (e)=>{
                onChange === null || onChange === void 0 ? void 0 : onChange(e);
                onDelegatingChange === null || onDelegatingChange === void 0 ? void 0 : onDelegatingChange(e.detail.value);
            }
        });
    }
    supportsControlType(elementType) {
        return elementType === Switch;
    }
}());
registerFormControlHandler(new class {
    doControlRender(element, controller) {
        const { value, onChange: onDelegatingChange, disabled: disabledProp } = controller;
        const { props: elementProps } = element;
        const { checked: checkedProp, onChange, disabled } = elementProps;
        return (0, import_react114.cloneElement)(element, {
            checked: checkedProp !== null && checkedProp !== void 0 ? checkedProp : value,
            disabled: disabled !== null && disabled !== void 0 ? disabled : disabledProp,
            onChange: (checked)=>{
                onChange === null || onChange === void 0 ? void 0 : onChange(checked);
                onDelegatingChange === null || onDelegatingChange === void 0 ? void 0 : onDelegatingChange(checked);
            }
        });
    }
    supportsControlType(elementType) {
        return elementType === checkbox_default || elementType === switch_default;
    }
}());
registerFormControlHandler(new class {
    doControlRender(element, controller) {
        const { value, onChange: onDelegatingChange, disabled: disabledProp } = controller;
        const { props: elementProps } = element;
        const { value: valueProp, onChange, disabled } = elementProps;
        return (0, import_react114.cloneElement)(element, {
            value: valueProp !== null && valueProp !== void 0 ? valueProp : value,
            disabled: disabled !== null && disabled !== void 0 ? disabled : disabledProp,
            onChange: (nextValue)=>{
                onChange === null || onChange === void 0 ? void 0 : onChange(nextValue);
                onDelegatingChange === null || onDelegatingChange === void 0 ? void 0 : onDelegatingChange(nextValue);
            }
        });
    }
    supportsControlType(elementType) {
        return elementType === checkbox_default.Group || elementType === radio_default.Group || elementType === rate_default || elementType === slider_default2 || elementType === stepper_default2 || elementType === uploader_default;
    }
}());
// node_modules/@taroify/core/form/form-item.context.js
var import_react115 = __toESM(require_react());
var FormItemContext = (0, import_react115.createContext)({});
var form_item_context_default = FormItemContext;
// node_modules/@taroify/core/form/form-control.js
function FormControl(props) {
    const { className, name, value, disabled, align: alignProp, children: children2 = React95.createElement(input_default, null), onChange: onDelegatingChange, onBlur: onDelegatingBlur } = props, restProps = _object_without_properties(props, [
        "className",
        "name",
        "value",
        "disabled",
        "align",
        "children",
        "onChange",
        "onBlur"
    ]);
    const { name: formName, controlAlign } = (0, import_react116.useContext)(form_context_default);
    const align = alignProp !== null && alignProp !== void 0 ? alignProp : controlAlign;
    const { validateStatus } = (0, import_react116.useContext)(form_item_context_default);
    const field = (0, import_react116.useMemo)(()=>{
        if ((0, import_isFunction6.default)(children2)) {
            return children2 === null || children2 === void 0 ? void 0 : children2({
                name,
                value: formName ? value : void 0,
                validateStatus,
                disabled,
                onChange: onDelegatingChange,
                onBlur: onDelegatingBlur
            });
        }
        return import_react116.Children.map(children2, (child)=>{
            if (!(0, import_react116.isValidElement)(child)) {
                return child;
            }
            const element = child;
            return doFormControlHandler(element, {
                name,
                value,
                validateStatus,
                disabled,
                onChange: onDelegatingChange,
                onBlur: onDelegatingBlur
            });
        });
    }, [
        children2,
        formName,
        name,
        onDelegatingBlur,
        onDelegatingChange,
        validateStatus,
        disabled,
        value
    ]);
    return React95.createElement(View, _object_spread({
        className: (0, import_classnames71.default)(prefixClassname("form-control"), {
            [prefixClassname("form-control--left")]: align === "left",
            [prefixClassname("form-control--center")]: align === "center",
            [prefixClassname("form-control--right")]: align === "right"
        }, className),
        children: field
    }, restProps));
}
var form_control_default = FormControl;
// node_modules/@taroify/core/form/form-item.js
var import_classnames72 = __toESM(require_classnames());
var import_isFunction9 = __toESM(require_isFunction());
var import_isEmpty16 = __toESM(require_isEmpty());
var import_map17 = __toESM(require_map());
var React96 = __toESM(require_react());
var import_react120 = __toESM(require_react());
// node_modules/@taroify/core/form/form.rule.js
var import_isFunction7 = __toESM(require_isFunction());
var import_isBoolean5 = __toESM(require_isBoolean());
var import_isError = __toESM(require_isError());
var import_isString6 = __toESM(require_isString());
function isEmptyValue(value) {
    if (Array.isArray(value)) {
        return !value.length;
    }
    if (value === 0) {
        return false;
    }
    return !value;
}
function getRuleMessage(value, rule) {
    const { message } = rule;
    if ((0, import_isFunction7.default)(message)) {
        return message(value, rule);
    }
    return message;
}
function getSyncRule(value, rule) {
    if (rule.required && isEmptyValue(value)) {
        return Promise.resolve(getRuleMessage(value, rule));
    }
    if (rule.pattern && !rule.pattern.test(String(value))) {
        return Promise.resolve(getRuleMessage(value, rule));
    }
}
function getValidatorRule(value, rule) {
    function obtainInvalidMessage(error) {
        if ((0, import_isBoolean5.default)(error) && !error) {
            return getRuleMessage(value, rule);
        }
        if ((0, import_isError.default)(error)) {
            return error.message;
        }
        return error;
    }
    return new Promise((resolve)=>{
        var _rule_validator;
        const promise = (_rule_validator = rule.validator) === null || _rule_validator === void 0 ? void 0 : _rule_validator.call(rule, value, rule);
        if (isPromise(promise)) {
            promise.then(obtainInvalidMessage).catch(obtainInvalidMessage).then(resolve);
        } else {
            resolve(obtainInvalidMessage(promise));
        }
    });
}
function validateRule(value, rule) {
    var _getSyncRule;
    return (_getSyncRule = getSyncRule(value, rule)) !== null && _getSyncRule !== void 0 ? _getSyncRule : getValidatorRule(value, rule);
}
function validateRules(value, rules, validateFirst) {
    return rules.reduce((promise, rule)=>promise.then((errors)=>{
            if (validateFirst && errors.length > 0) {
                return errors;
            }
            let formattedValue = value;
            if (rule.formatter) {
                formattedValue = rule.formatter(value, rule);
            }
            return validateRule(formattedValue, rule).then((error)=>{
                if ((0, import_isString6.default)(error)) {
                    errors.push(error);
                }
                return errors;
            });
        }), Promise.resolve([]));
}
// node_modules/@taroify/core/form/use-form-error.js
var import_first5 = __toESM(require_first());
var import_isEmpty15 = __toESM(require_isEmpty());
var import_react117 = __toESM(require_react());
function useFormError(name) {
    const { name: formName } = (0, import_react117.useContext)(form_context_default);
    const form = useForm(formName);
    const forceUpdate = use_force_update_default();
    const onErrorChange = (0, import_react117.useCallback)(()=>forceUpdate(), [
        forceUpdate
    ]);
    (0, import_react117.useEffect)(()=>{
        form === null || form === void 0 ? void 0 : form.addEventListener(`fields.${name}.error.change`, onErrorChange);
        return ()=>form === null || form === void 0 ? void 0 : form.removeEventListener(`fields.${name}.error.change`, onErrorChange);
    }, [
        form,
        name,
        onErrorChange
    ]);
    const getError = (0, import_react117.useCallback)(()=>{
        if (name) return (0, import_first5.default)(form === null || form === void 0 ? void 0 : form.getErrors(name));
    }, [
        form,
        name
    ]);
    const setError = (0, import_react117.useCallback)((error)=>{
        if (name) {
            form === null || form === void 0 ? void 0 : form.setErrors([
                _object_spread_props(_object_spread({}, error), {
                    name
                })
            ]);
        }
    }, [
        form,
        name
    ]);
    const resetError = (0, import_react117.useCallback)(()=>setError({
            errors: []
        }), [
        setError
    ]);
    const validateStatus = useRendered(()=>{
        var _getError;
        return (0, import_isEmpty15.default)((_getError = getError()) === null || _getError === void 0 ? void 0 : _getError.errors) ? "valid" : "invalid";
    });
    return (0, import_react117.useMemo)(()=>({
            validateStatus,
            get error () {
                return getError();
            },
            getError,
            setError,
            resetError
        }), [
        getError,
        resetError,
        setError,
        validateStatus
    ]);
}
// node_modules/@taroify/core/form/use-form-field-value-effect.js
var import_react118 = __toESM(require_react());
function useFormFieldValueEffect(effect, deps) {
    const { name: formName } = (0, import_react118.useContext)(form_context_default);
    const form = useForm(formName);
    const mountedRef = (0, import_react118.useRef)(false);
    const onReset = (0, import_react118.useCallback)(()=>mountedRef.current = false, []);
    (0, import_react118.useEffect)(()=>{
        form === null || form === void 0 ? void 0 : form.addEventListener("reset", onReset);
        return ()=>form === null || form === void 0 ? void 0 : form.removeEventListener("reset", onReset);
    }, [
        form,
        onReset
    ]);
    (0, import_react118.useEffect)(()=>{
        if (mountedRef.current) {
            effect === null || effect === void 0 ? void 0 : effect();
        } else {
            mountedRef.current = true;
        }
    }, deps);
}
var use_form_field_value_effect_default = useFormFieldValueEffect;
// node_modules/@taroify/core/form/use-form-item.js
var import_react119 = __toESM(require_react());
var import_isFunction8 = __toESM(require_isFunction());
function useDependenciesChange(dependencies, validate) {
    const { name: formName } = (0, import_react119.useContext)(form_context_default);
    const form = useForm(formName);
    const validateMemo = useMemoizedFn(()=>validate());
    useDeepCompareEffect(()=>{
        const validFields = dependencies || [];
        validFields.forEach((dep)=>{
            form === null || form === void 0 ? void 0 : form.addEventListener(`fields.${dep}.value.change`, validateMemo);
        });
        return ()=>{
            validFields.forEach((dep)=>{
                form === null || form === void 0 ? void 0 : form.removeEventListener(`fields.${dep}.value.change`, validateMemo);
            });
        };
    }, [
        dependencies,
        validateMemo
    ]);
}
function useShouldUpdateSignal(shouldUpdate) {
    const { name: formName } = (0, import_react119.useContext)(form_context_default);
    const form = useForm(formName);
    const [signal, setSignal] = (0, import_react119.useState)(0);
    const shouldUpdateMemo = useMemoizedFn((oldVal, newVal)=>{
        if ((0, import_isFunction8.default)(shouldUpdate) ? shouldUpdate(oldVal, newVal) : shouldUpdate) {
            setSignal((prev)=>prev + 1);
        }
    });
    (0, import_react119.useEffect)(()=>{
        form === null || form === void 0 ? void 0 : form.addEventListener("shouldUpdate", shouldUpdateMemo);
        return ()=>form === null || form === void 0 ? void 0 : form.removeEventListener("shouldUpdate", shouldUpdateMemo);
    }, [
        form,
        shouldUpdateMemo
    ]);
    return signal;
}
// node_modules/@taroify/core/form/form-item.js
function useFormItemChildren(childrenProps, shouldUpdateSignal, noStyle) {
    return (0, import_react120.useMemo)(()=>{
        if (noStyle) {
            if ((0, import_isFunction9.default)(childrenProps)) {
                const children3 = childrenProps();
                return {
                    children: (0, import_react120.isValidElement)(children3) ? children3 : void 0
                };
            } else {
                console.warn('[Taroify] FormItem(noStyle): "children" should be function');
                return {};
            }
        }
        const __children__ = {
            feedbacks: []
        };
        const children2 = (0, import_isFunction9.default)(childrenProps) ? childrenProps() : childrenProps;
        import_react120.Children.forEach(children2, (child)=>{
            if (!(0, import_react120.isValidElement)(child)) {
                return;
            }
            if (isElementOf(child, form_default2.Label)) {
                __children__.label = child;
            } else if (isElementOf(child, form_default2.Control)) {
                __children__.control = child;
            } else if (isElementOf(child, form_default2.Feedback)) {
                var __children___feedbacks;
                (__children___feedbacks = __children__.feedbacks) === null || __children___feedbacks === void 0 ? void 0 : __children___feedbacks.push(child);
            }
        });
        return __children__;
    }, [
        childrenProps,
        shouldUpdateSignal,
        noStyle
    ]);
}
var FormItem = (0, import_react120.forwardRef)((props, ref)=>{
    const { className, style, name, defaultValue, align, bordered, icon, rightIcon: rightIconProp, size, isLink = false, arrowDirection = "right", clickable, required, children: childrenProp, rules: rulesProp, dependencies, shouldUpdate, noStyle, disabled: disabledProp, validateFirst = false, onClick } = props;
    const shouldUpdateSignal = useShouldUpdateSignal(shouldUpdate);
    const { label, control, feedbacks, children: children2 } = useFormItemChildren(childrenProp, shouldUpdateSignal, noStyle);
    const rightIcon = (0, import_react120.useMemo)(()=>{
        if (rightIconProp) {
            return cloneIconElement(rightIconProp, {
                className: prefixClassname("form-item__right-icon")
            });
        } else if (isLink && iconMap[arrowDirection]) {
            const Icon = iconMap[arrowDirection];
            return React96.createElement(Icon, {
                className: prefixClassname("form-item__right-icon")
            });
        }
        return null;
    }, [
        rightIconProp,
        isLink,
        arrowDirection
    ]);
    const rulesRef = useToRef(rulesProp);
    const { validateTrigger, disabled: disabledContext } = (0, import_react120.useContext)(form_context_default);
    const disabled = disabledProp !== null && disabledProp !== void 0 ? disabledProp : disabledContext;
    const { validateStatus, error, setError, resetError } = useFormError(name);
    const { value, getValue, setValue } = useFormValue(name, {
        defaultValue
    });
    const validate = (0, import_react120.useCallback)((rules = rulesRef.current)=>{
        return new Promise((resolve, reject)=>{
            if (rules) {
                resetError();
                validateRules(getValue(), rules, validateFirst).then((errors)=>{
                    if ((0, import_isEmpty16.default)(errors)) {
                        resetError();
                        resolve();
                    } else {
                        setError({
                            errors
                        });
                        reject({
                            name,
                            errors
                        });
                    }
                });
            } else {
                resolve();
            }
        });
    }, [
        getValue,
        name,
        resetError,
        rulesRef,
        setError
    ]);
    const validateWithTrigger = (0, import_react120.useCallback)((trigger)=>{
        if (validateTrigger && rulesProp) {
            const defaultTrigger = validateTrigger === trigger;
            const rules = rulesProp.filter((rule)=>{
                if (rule.trigger) {
                    return rule.trigger === trigger;
                }
                return defaultTrigger;
            });
            if (rules.length) {
                fulfillPromise(validate(rules));
            } else if (defaultTrigger) {
                resetError();
            }
        }
    }, [
        resetError,
        rulesProp,
        validate,
        validateTrigger
    ]);
    const instance = (0, import_react120.useMemo)(()=>({
            name,
            validate,
            getValue,
            setValue
        }), [
        getValue,
        name,
        setValue,
        validate
    ]);
    (0, import_react120.useImperativeHandle)(ref, ()=>instance, [
        instance
    ]);
    useFormField(name, instance);
    use_form_field_value_effect_default(()=>validateWithTrigger("onChange"), [
        value
    ]);
    useDependenciesChange(dependencies, ()=>fulfillPromise(validate()));
    const explain = (0, import_react120.useMemo)(()=>!(0, import_isEmpty16.default)(feedbacks) || !(0, import_isEmpty16.default)(error === null || error === void 0 ? void 0 : error.errors), [
        error === null || error === void 0 ? void 0 : error.errors,
        feedbacks
    ]);
    const Control = (0, import_react120.useMemo)(()=>control && (0, import_react120.cloneElement)(control, {
            name,
            value,
            disabled,
            onBlur: ()=>validateWithTrigger("onBlur"),
            onChange: setValue
        }), [
        control,
        name,
        setValue,
        validateWithTrigger,
        value,
        disabled
    ]);
    if (noStyle) {
        return React96.createElement(form_item_context_default.Provider, {
            value: {
                validateStatus
            }
        }, children2);
    }
    return React96.createElement(form_item_context_default.Provider, {
        value: {
            validateStatus
        }
    }, React96.createElement(cell_base_default, _object_spread({
        className: (0, import_classnames72.default)(prefixClassname("form-item"), className),
        style,
        bordered,
        align,
        clickable,
        size,
        icon: cloneIconElement(icon, {
            className: prefixClassname("form-item__icon")
        }),
        rightIcon,
        required
    }, onClick && {
        onClick
    }), label, React96.createElement(cell_value_default, {
        alone: false
    }, Control, explain && React96.createElement(View, {
        className: (0, import_classnames72.default)(prefixClassname("form__feedbacks"))
    }, feedbacks, (0, import_map17.default)(error === null || error === void 0 ? void 0 : error.errors, (message, messageKey)=>React96.createElement(form_feedback_default, {
            key: messageKey,
            status: "invalid",
            children: message
        }))))));
});
var form_item_default = FormItem;
// node_modules/@taroify/core/form/form-list.js
var React97 = __toESM(require_react());
var import_react125 = __toESM(require_react());
var import_isFunction10 = __toESM(require_isFunction());
// node_modules/@taroify/core/form/form-list.context.js
var import_react121 = __toESM(require_react());
var formListContext = (0, import_react121.createContext)({
    inFormList: false
});
var form_list_context_default = formListContext;
// node_modules/@taroify/core/form/use-form-list.js
var import_react124 = __toESM(require_react());
var import_map18 = __toESM(require_map());
var import_filter6 = __toESM(require_filter());
var import_cloneDeep2 = __toESM(require_cloneDeep());
// node_modules/@taroify/core/form/use-form-field.js
var import_react122 = __toESM(require_react());
function useFormField(name, field) {
    const { name: formName } = (0, import_react122.useContext)(form_context_default);
    const { inFormList } = (0, import_react122.useContext)(form_list_context_default);
    const form = useForm(formName);
    (0, import_react122.useEffect)(()=>{
        var _form_linkField;
        form === null || form === void 0 ? void 0 : (_form_linkField = form.linkField) === null || _form_linkField === void 0 ? void 0 : _form_linkField.call(form, name, field, inFormList);
        return ()=>{
            form === null || form === void 0 ? void 0 : form.unlinkField(name, inFormList);
        };
    }, [
        name,
        field,
        inFormList
    ]);
}
// node_modules/@taroify/core/form/use-form-value.js
var import_get9 = __toESM(require_get());
var import_react123 = __toESM(require_react());
function useFormValue(name, options) {
    const { defaultValue, valueChangeHandler } = options !== null && options !== void 0 ? options : {};
    const { name: formName } = (0, import_react123.useContext)(form_context_default);
    const { inFormList } = (0, import_react123.useContext)(form_list_context_default);
    const form = useForm(formName);
    const forceUpdate = use_force_update_default();
    const onValueChange = useMemoizedFn((values2)=>{
        valueChangeHandler === null || valueChangeHandler === void 0 ? void 0 : valueChangeHandler(values2);
        forceUpdate();
    });
    (0, import_react123.useEffect)(()=>{
        form === null || form === void 0 ? void 0 : form.addEventListener(`fields.${name}.value.change`, onValueChange);
        return ()=>form === null || form === void 0 ? void 0 : form.removeEventListener(`fields.${name}.value.change`, onValueChange);
    }, [
        form,
        name,
        onValueChange
    ]);
    (0, import_react123.useEffect)(()=>{
        if (name && defaultValue) {
            form === null || form === void 0 ? void 0 : form.setDefaultValues({
                [name]: defaultValue
            }, inFormList);
        }
    }, []);
    const getValue = (0, import_react123.useCallback)(()=>{
        if (form) {
            var _ref;
            return (_ref = (0, import_get9.default)(form.getValues(name), name)) !== null && _ref !== void 0 ? _ref : "";
        }
    }, [
        form,
        name
    ]);
    return (0, import_react123.useMemo)(()=>({
            get value () {
                return getValue();
            },
            setValue: (value)=>{
                if (name) {
                    form === null || form === void 0 ? void 0 : form.setValues({
                        [name]: value
                    });
                }
            },
            getValue
        }), [
        form,
        getValue,
        name
    ]);
}
// node_modules/@taroify/core/form/use-form-list.js
var fieldKey = 0;
function useFormList(field, options) {
    const { defaultValue } = options !== null && options !== void 0 ? options : {};
    const { name: formName } = (0, import_react124.useContext)(form_context_default);
    const form = useForm(formName);
    const [fields, setFields] = (0, import_react124.useState)([]);
    const valueChangeHandler = useMemoizedFn((values2)=>{
        var _formAttributes_errors;
        if ((values2 || []).length !== fields.length) {
            setFields((0, import_map18.default)(values2, (_, i)=>({
                    name: `${field}.${i}`,
                    key: ++fieldKey
                })));
        }
        const formAttributes = form === null || form === void 0 ? void 0 : form.getAttributiveForm();
        if (formAttributes === null || formAttributes === void 0 ? void 0 : (_formAttributes_errors = formAttributes.errors) === null || _formAttributes_errors === void 0 ? void 0 : _formAttributes_errors[field]) {
            formAttributes.errors = _object_spread_props(_object_spread({}, formAttributes.errors), {
                [field]: []
            });
        }
    });
    const resetHandler = useMemoizedFn(()=>{
        setFields((0, import_map18.default)(getValue(), (_, i)=>({
                name: `${field}.${i}`,
                key: ++fieldKey
            })));
    });
    (0, import_react124.useEffect)(()=>{
        form === null || form === void 0 ? void 0 : form.addEventListener("reset", resetHandler);
        return ()=>form === null || form === void 0 ? void 0 : form.removeEventListener("reset", resetHandler);
    }, [
        form
    ]);
    const { getValue, setValue } = useFormValue(field, {
        defaultValue,
        valueChangeHandler
    });
    const instance = (0, import_react124.useMemo)(()=>({
            name: field,
            validate: ()=>Promise.resolve(),
            getValue,
            setValue
        }), [
        getValue,
        field,
        setValue
    ]);
    useFormField(field, instance);
    const add = useMemoizedFn((value)=>{
        setFields(fields.concat([
            {
                name: `${field}.${fields.length}`,
                key: ++fieldKey
            }
        ]));
        form === null || form === void 0 ? void 0 : form.setValues({
            [`${field}.${fields.length}`]: value
        });
    });
    const remove = useMemoizedFn((index)=>{
        var _form_getValues, _formAttributes_errors;
        const values2 = (form === null || form === void 0 ? void 0 : (_form_getValues = form.getValues(field)) === null || _form_getValues === void 0 ? void 0 : _form_getValues[field]) || [];
        form === null || form === void 0 ? void 0 : form.setValues({
            [field]: (0, import_filter6.default)(values2.slice(), (_, i)=>i !== index)
        }, false);
        const formAttributes = form === null || form === void 0 ? void 0 : form.getAttributiveForm();
        if (formAttributes === null || formAttributes === void 0 ? void 0 : (_formAttributes_errors = formAttributes.errors) === null || _formAttributes_errors === void 0 ? void 0 : _formAttributes_errors[field]) {
            const errors = formAttributes.errors[field];
            const newErrors = (0, import_cloneDeep2.default)((0, import_filter6.default)(errors.slice(), (_, i)=>i !== index));
            for(let i = 0; i < newErrors.length; i++){
                if (newErrors[i]) {
                    const keys = Object.keys(newErrors[i]);
                    if (keys.includes("name") && typeof newErrors[i]["name"] === "string") {
                        newErrors[i]["name"] = `${field}.${i}`;
                    } else {
                        keys.forEach((key)=>{
                            newErrors[i][key]["name"] = `${field}.${i}.${key}`;
                        });
                    }
                }
            }
            formAttributes.errors = _object_spread_props(_object_spread({}, formAttributes.errors), {
                [field]: newErrors
            });
        }
        setFields((0, import_filter6.default)(fields, (_, i)=>i !== index).map((item, i)=>({
                name: `${field}.${i}`,
                key: item.key
            })));
    });
    const operation = (0, import_react124.useMemo)(()=>({
            add,
            remove
        }), []);
    return [
        fields,
        operation
    ];
}
// node_modules/@taroify/core/form/form-list.js
var form_list_default = (0, import_react125.forwardRef)(function FormList({ name: field, children: children2, defaultValue }, ref) {
    const [fields, operation] = useFormList(field, {
        defaultValue
    });
    (0, import_react125.useImperativeHandle)(ref, ()=>operation, [
        operation
    ]);
    return React97.createElement(form_list_context_default.Provider, {
        value: {
            inFormList: true
        }
    }, (0, import_isFunction10.default)(children2) && children2(fields, operation));
});
// node_modules/@taroify/core/form/index.js
var Form3 = form_default;
Form3.Item = form_item_default;
Form3.Label = form_label_default;
Form3.Control = form_control_default;
Form3.Feedback = form_feedback_default;
Form3.List = form_list_default;
var form_default2 = Form3;
// node_modules/@taroify/core/utils/element.js
var import_react126 = __toESM(require_react());
function createVariantComponentWrapper(children2, displayName) {
    const Component = ()=>children2;
    Component.displayName = displayName;
    return Component;
}
function createVariantElement(type, node) {
    if (isTextElement(node)) {
        return (0, import_react126.createElement)(type, {
            children: node
        });
    }
    if (isObjectElement(node)) {
        return (0, import_react126.createElement)(type, node);
    }
    if ((0, import_react126.isValidElement)(node)) {
        const ComponentWrapper = createVariantComponentWrapper(node, type.displayName);
        return (0, import_react126.createElement)(ComponentWrapper);
    }
    return node;
}
// node_modules/@taroify/core/field/field.js
function _Field(props, ref) {
    const { label: labelProp, feedback: feedbackProp, children: children2 } = props, restProps = _object_without_properties(props, [
        "label",
        "feedback",
        "children"
    ]);
    const label = createVariantElement(form_default2.Label, labelProp);
    const feedback = createVariantElement(form_default2.Feedback, feedbackProp);
    const formItemRef = (0, import_react127.useRef)();
    (0, import_react127.useImperativeHandle)(ref, ()=>formItemRef.current, [
        formItemRef
    ]);
    if ("noStyle" in restProps || "shouldUpdate" in restProps) {
        console.warn("[Taroify] Field: not support noStyle & shouldUpdate property");
    }
    return React98.createElement(form_default2.Item, _object_spread_props(_object_spread({}, restProps), {
        ref: formItemRef
    }), label, children2 && React98.createElement(form_default2.Control, {
        children: children2
    }), feedback);
}
var Field = (0, import_react127.forwardRef)(_Field);
var field_default = Field;
// node_modules/@taroify/core/field/index.js
var Field2 = field_default;
Field2.Label = form_label_default;
Field2.Feedback = form_feedback_default;
var field_default2 = Field2;
// node_modules/@taroify/core/number-keyboard/number-keyboard.js
var import_classnames78 = __toESM(require_classnames());
var import_isString7 = __toESM(require_isString());
var import_isNumber11 = __toESM(require_isNumber());
var import_isArray9 = __toESM(require_isArray());
var import_size12 = __toESM(require_size());
var React104 = __toESM(require_react());
var import_react133 = __toESM(require_react());
// node_modules/@taroify/core/number-keyboard/number-keyboard-header.js
var import_classnames74 = __toESM(require_classnames());
var React100 = __toESM(require_react());
var import_react130 = __toESM(require_react());
// node_modules/@taroify/core/number-keyboard/number-keyboard-button.js
var import_classnames73 = __toESM(require_classnames());
var React99 = __toESM(require_react());
var import_react129 = __toESM(require_react());
// node_modules/@taroify/core/number-keyboard/number-keyboard.context.js
var import_react128 = __toESM(require_react());
var NumberKeyboardContext = (0, import_react128.createContext)({});
var number_keyboard_context_default = NumberKeyboardContext;
// node_modules/@taroify/core/number-keyboard/number-keyboard-button.js
function NumberKeyboardButton(props) {
    const { className, type = "hide", children: children2, onClick } = props, restProps = _object_without_properties(props, [
        "className",
        "type",
        "children",
        "onClick"
    ]);
    const { onKeyPress } = (0, import_react129.useContext)(number_keyboard_context_default);
    function handleClick(event) {
        onClick === null || onClick === void 0 ? void 0 : onClick(event);
        if (type === "hide") {
            onKeyPress === null || onKeyPress === void 0 ? void 0 : onKeyPress(children2, "keyboard-hide");
        }
    }
    return React99.createElement(View, _object_spread({
        className: (0, import_classnames73.default)({
            [prefixClassname("number-keyboard__hide")]: type === "hide"
        }, className),
        children: children2,
        onClick: handleClick
    }, restProps));
}
var number_keyboard_button_default = NumberKeyboardButton;
// node_modules/@taroify/core/number-keyboard/number-keyboard-header.js
function useNumberKeyboardHeaderChildren(children2) {
    const { title } = (0, import_react130.useContext)(number_keyboard_context_default);
    return (0, import_react130.useMemo)(()=>{
        const __children__ = {
            title: title && React100.createElement(View, {
                className: prefixClassname("number-keyboard__title"),
                children: title
            })
        };
        import_react130.Children.forEach(children2, (child)=>{
            if ((0, import_react130.isValidElement)(child)) {
                const element = child;
                const elementType = element.type;
                if (elementType === number_keyboard_button_default) {
                    const { type } = element.props;
                    if (type === void 0 || type === "hide") {
                        __children__.right = element;
                    }
                }
            }
        });
        return __children__;
    }, [
        children2,
        title
    ]);
}
function NumberKeyboardHeader(props) {
    const { className, children: childrenProp } = props, restProps = _object_without_properties(props, [
        "className",
        "children"
    ]);
    const { left, title, right } = useNumberKeyboardHeaderChildren(childrenProp);
    return React100.createElement(View, _object_spread({
        className: (0, import_classnames74.default)(prefixClassname("number-keyboard__header"), className)
    }, restProps), left, title, right);
}
var number_keyboard_header_default = NumberKeyboardHeader;
// node_modules/@taroify/core/number-keyboard/number-keyboard-key.js
var import_classnames75 = __toESM(require_classnames());
var React101 = __toESM(require_react());
var import_react131 = __toESM(require_react());
function NumberKeyboardKey(props) {
    const { wider, code = "extra", size, color, children: children2, onPress } = props;
    const { onKeyPress } = (0, import_react131.useContext)(number_keyboard_context_default);
    const value = children2 !== null && children2 !== void 0 ? children2 : "";
    const [active, setActive] = (0, import_react131.useState)(false);
    const touch = useTouch();
    const onTouchStart = (event)=>{
        touch.start(event);
        setActive(true);
    };
    const onTouchMove = (event)=>{
        touch.move(event);
        if (touch.direction) {
            setActive(false);
        }
    };
    const onTouchEnd = (event)=>{
        if (active) {
            if (!children2) {
                event.preventDefault();
            }
            setActive(false);
            onPress === null || onPress === void 0 ? void 0 : onPress(value, code !== null && code !== void 0 ? code : value);
            onKeyPress === null || onKeyPress === void 0 ? void 0 : onKeyPress(value, code !== null && code !== void 0 ? code : value);
        }
    };
    const renderContent2 = ()=>{
        switch(code){
            case "backspace":
                return children2 !== null && children2 !== void 0 ? children2 : React101.createElement(View, {
                    className: "taroify-backspace"
                });
            case "keyboard-hide":
                return children2 !== null && children2 !== void 0 ? children2 : React101.createElement(View, {
                    className: "taroify-keyboard-hide"
                });
            default:
                return children2;
        }
    };
    return React101.createElement(View, {
        className: (0, import_classnames75.default)(prefixClassname("key__wrapper"), {
            [prefixClassname("key__wrapper--wider")]: wider
        }),
        onTouchStart,
        onTouchMove,
        onTouchEnd,
        onTouchCancel: onTouchEnd
    }, React101.createElement(View, {
        className: (0, import_classnames75.default)(prefixClassname("key"), {
            [prefixClassname("key--active")]: active,
            [prefixClassname("key--large")]: size === "large",
            [prefixClassname("key--blue")]: color === "blue"
        })
    }, renderContent2()));
}
var number_keyboard_key_default = NumberKeyboardKey;
// node_modules/@taroify/core/number-keyboard/number-keyboard-key.shared.js
var import_react132 = __toESM(require_react());
function isNumberKeyboardKeyElement(node) {
    return (0, import_react132.isValidElement)(node) && node.type === number_keyboard_key_default;
}
// node_modules/@taroify/core/number-keyboard/number-keyboard-keys.js
var import_classnames76 = __toESM(require_classnames());
var React102 = __toESM(require_react());
function NumberKeyboardKeys(props) {
    const { className, children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "children"
    ]);
    return React102.createElement(View, _object_spread({
        className: (0, import_classnames76.default)(prefixClassname("number-keyboard__keys"), className),
        children: children2
    }, restProps));
}
var number_keyboard_keys_default = NumberKeyboardKeys;
// node_modules/@taroify/core/number-keyboard/number-keyboard-sidebar.js
var import_classnames77 = __toESM(require_classnames());
var React103 = __toESM(require_react());
function NumberKeyboardSidebar(props) {
    const { className } = props, restProps = _object_without_properties(props, [
        "className"
    ]);
    return React103.createElement(View, _object_spread({
        className: (0, import_classnames77.default)(prefixClassname("number-keyboard__sidebar"), className)
    }, restProps));
}
var number_keyboard_sidebar_default = NumberKeyboardSidebar;
// node_modules/@taroify/core/number-keyboard/number-keyboard.js
function createBasicKeys(random) {
    const keys = Array(9).fill("").map((_, i)=>React104.createElement(number_keyboard_key_default, {
            key: i + 1,
            children: i + 1
        }));
    if (random) {
        keys.sort(()=>Math.random() > 0.5 ? 1 : -1);
    }
    return keys;
}
function createExtraNumberKeyboardKey(extraKey) {
    if ((0, import_isString7.default)(extraKey) || (0, import_isNumber11.default)(extraKey)) {
        return React104.createElement(number_keyboard_key_default, {
            key: extraKey,
            children: extraKey
        });
    } else if (isNumberKeyboardKeyElement(extraKey)) {
        const element = extraKey;
        const elementProps = element.props;
        var _element_key, _ref;
        return (0, import_react133.cloneElement)(extraKey, {
            key: (_ref = (_element_key = element.key) !== null && _element_key !== void 0 ? _element_key : elementProps.children) !== null && _ref !== void 0 ? _ref : elementProps.code
        });
    }
    return void 0;
}
function createCustomKeys(extraKey) {
    if (extraKey === void 0) {
        return [
            React104.createElement(number_keyboard_key_default, {
                key: "keyboard-hide",
                code: "keyboard-hide"
            }),
            React104.createElement(number_keyboard_key_default, {
                key: 0,
                children: 0
            }),
            React104.createElement(number_keyboard_key_default, {
                key: "backspace",
                code: "backspace"
            })
        ];
    }
    if ((0, import_isString7.default)(extraKey) || (0, import_isNumber11.default)(extraKey) || isNumberKeyboardKeyElement(extraKey)) {
        return [
            createExtraNumberKeyboardKey(extraKey),
            React104.createElement(number_keyboard_key_default, {
                key: 0,
                children: 0
            }),
            React104.createElement(number_keyboard_key_default, {
                key: "backspace",
                code: "backspace"
            })
        ];
    }
    if ((0, import_isArray9.default)(extraKey) && (0, import_size12.default)(extraKey) === 1) {
        return [
            createExtraNumberKeyboardKey(extraKey[0]),
            React104.createElement(number_keyboard_key_default, {
                key: 0,
                wider: true,
                children: 0
            })
        ];
    }
    if ((0, import_isArray9.default)(extraKey) && (0, import_size12.default)(extraKey) === 2) {
        const wider = extraKey.filter((key)=>key !== void 0).length === 1;
        return [
            createExtraNumberKeyboardKey(extraKey[0]),
            React104.createElement(number_keyboard_key_default, {
                key: 0,
                wider,
                children: 0
            }),
            createExtraNumberKeyboardKey(extraKey[1])
        ];
    }
    return [];
}
function useNumberKeyboardChildren(children2, title) {
    return (0, import_react133.useMemo)(()=>{
        const __children__ = {
            sidebar: void 0
        };
        import_react133.Children.forEach(children2, (child)=>{
            if ((0, import_react133.isValidElement)(child)) {
                const element = child;
                const elementType = element.type;
                if (elementType === number_keyboard_header_default) {
                    __children__.header = element;
                }
                if (elementType === number_keyboard_sidebar_default) {
                    __children__.sidebar = element;
                }
            }
        });
        if (title && !__children__.header) {
            __children__.header = React104.createElement(number_keyboard_header_default, null);
        }
        return __children__;
    }, [
        children2,
        title
    ]);
}
function NumberKeyboard(props) {
    const { className, open, title, extraKey, random = false, children: childrenProp, onKeyPress, onBackspace, onHide } = props, restProps = _object_without_properties(props, [
        "className",
        "open",
        "title",
        "extraKey",
        "random",
        "children",
        "onKeyPress",
        "onBackspace",
        "onHide"
    ]);
    const { header, sidebar } = useNumberKeyboardChildren(childrenProp, title);
    const basicKeys = (0, import_react133.useMemo)(()=>createBasicKeys(random), [
        random
    ]);
    const keys = (0, import_react133.useMemo)(()=>[
            ...basicKeys,
            ...createCustomKeys(extraKey)
        ], [
        basicKeys,
        extraKey
    ]);
    const handleKeyPress = (value, code)=>{
        onKeyPress === null || onKeyPress === void 0 ? void 0 : onKeyPress(value, code);
        if (code === "backspace") {
            onBackspace === null || onBackspace === void 0 ? void 0 : onBackspace();
        } else if (code === "keyboard-hide") {
            onHide === null || onHide === void 0 ? void 0 : onHide();
        }
    };
    return React104.createElement(number_keyboard_context_default.Provider, {
        value: {
            title,
            onKeyPress: handleKeyPress
        }
    }, React104.createElement(Transition2, {
        in: open,
        appear: true,
        name: "slide-up"
    }, React104.createElement(View, _object_spread({
        className: (0, import_classnames78.default)(prefixClassname("number-keyboard"), {
            [prefixClassname("number-keyboard--with-title")]: header
        }, className)
    }, restProps), header, React104.createElement(View, {
        className: prefixClassname("number-keyboard__body")
    }, React104.createElement(number_keyboard_keys_default, {
        children: keys
    }), sidebar))));
}
var number_keyboard_default = NumberKeyboard;
// node_modules/@taroify/core/number-keyboard/index.js
var NumberKeyboard2 = number_keyboard_default;
NumberKeyboard2.Key = number_keyboard_key_default;
NumberKeyboard2.Button = number_keyboard_button_default;
NumberKeyboard2.Header = number_keyboard_header_default;
NumberKeyboard2.Sidebar = number_keyboard_sidebar_default;
var number_keyboard_default2 = NumberKeyboard2;
// node_modules/@taroify/core/password-input/password-input.js
var import_classnames80 = __toESM(require_classnames());
var import_isBoolean6 = __toESM(require_isBoolean());
var React106 = __toESM(require_react());
var import_react134 = __toESM(require_react());
// node_modules/@taroify/core/password-input/password-input-feedback.js
var import_classnames79 = __toESM(require_classnames());
var React105 = __toESM(require_react());
function PasswordInputFeedback(props) {
    const { className, color } = props, restProps = _object_without_properties(props, [
        "className",
        "color"
    ]);
    return React105.createElement(View, _object_spread({
        className: (0, import_classnames79.default)(prefixClassname("password-input__feedback"), {
            [prefixClassname("password-input__feedback--primary")]: color === "primary",
            [prefixClassname("password-input__feedback--info")]: color === "info",
            [prefixClassname("password-input__feedback--success")]: color === "success",
            [prefixClassname("password-input__feedback--warning")]: color === "warning",
            [prefixClassname("password-input__feedback--danger")]: color === "danger"
        }, className)
    }, restProps));
}
var password_input_feedback_default = PasswordInputFeedback;
// node_modules/@taroify/core/password-input/password-input.js
function PasswordInput(props) {
    const { className, value = "", length = 6, gutter, mask = true, focused: focusedProp, focus: focusProp = false, feedback: feedbackProp, onFocus } = props, restProps = _object_without_properties(props, [
        "className",
        "value",
        "length",
        "gutter",
        "mask",
        "focused",
        "focus",
        "feedback",
        "onFocus"
    ]);
    const feedback = createVariantElement(password_input_feedback_default, feedbackProp);
    const focus = (0, import_react134.useMemo)(()=>(0, import_isBoolean6.default)(focusedProp) ? focusedProp : focusProp, [
        focusProp,
        focusedProp
    ]);
    if ((0, import_isBoolean6.default)(focusedProp)) {
        console.warn("[Deprecated] The focused prop is deprecated. Please use the focus prop.");
    }
    const onTouchStart = (0, import_react134.useCallback)((event)=>{
        stopPropagation(event);
        onFocus === null || onFocus === void 0 ? void 0 : onFocus(event);
    }, [
        onFocus
    ]);
    const points = (0, import_react134.useMemo)(()=>{
        const Points2 = [];
        for(let i = 0; i < length; i++){
            const char = value[i];
            const bordered = i !== 0 && !gutter;
            const showCursor = focus && i === value.length;
            let style = {};
            if (i !== 0 && gutter) {
                style = {
                    marginLeft: addUnitPx(gutter)
                };
            }
            Points2.push(React106.createElement(View, {
                key: i,
                className: (0, import_classnames80.default)(prefixClassname("password-input__item"), {
                    [HAIRLINE_BORDER_LEFT]: bordered,
                    [prefixClassname("password-input__item--focus")]: showCursor
                }),
                style
            }, mask ? React106.createElement(View, {
                className: prefixClassname("password-input__item--mask"),
                style: {
                    visibility: char ? "visible" : "hidden"
                }
            }) : char, showCursor && React106.createElement(View, {
                className: prefixClassname("password-input__cursor")
            })));
        }
        return Points2;
    }, [
        focus,
        gutter,
        length,
        mask,
        value
    ]);
    return React106.createElement(View, _object_spread({
        className: (0, import_classnames80.default)(prefixClassname("password-input"), className)
    }, restProps), React106.createElement(View, {
        className: (0, import_classnames80.default)(prefixClassname("password-input__security"), {
            [HAIRLINE_BORDER_SURROUND]: !gutter
        }),
        onTouchStart,
        children: points
    }), feedback);
}
var password_input_default = PasswordInput;
// node_modules/@taroify/core/password-input/index.js
var PasswordInput2 = password_input_default;
PasswordInput2.Feedback = password_input_feedback_default;
var password_input_default2 = PasswordInput2;
// node_modules/@taroify/core/search/search.js
var import_classnames81 = __toESM(require_classnames());
var import_isBoolean7 = __toESM(require_isBoolean());
var React107 = __toESM(require_react());
var { deprecated: deprecated2 } = getLogger("Search");
function Search2(props) {
    const { className, value, icon = React107.createElement(Search_default, null), rightIcon, label, shape, maxlength, autoFocus, focus, disabled, readonly, enableNative = true, placeholder, placeholderClassName, clearable = true, clearIcon, clearTrigger, inputAlign, inputColor, feedback, action, onClear, onCancel, onSearch, onChange, onFocus, onBlur } = props, restProps = _object_without_properties(props, [
        "className",
        "value",
        "icon",
        "rightIcon",
        "label",
        "shape",
        "maxlength",
        "autoFocus",
        "focus",
        "disabled",
        "readonly",
        "enableNative",
        "placeholder",
        "placeholderClassName",
        "clearable",
        "clearIcon",
        "clearTrigger",
        "inputAlign",
        "inputColor",
        "feedback",
        "action",
        "onClear",
        "onCancel",
        "onSearch",
        "onChange",
        "onFocus",
        "onBlur"
    ]);
    if (shape === "round") {
        deprecated2('Use the shape="rounded" prop instead of the shape="round" prop');
    }
    function handleSearch(event) {
        preventDefault(event);
        onSearch === null || onSearch === void 0 ? void 0 : onSearch(event);
    }
    return React107.createElement(View, _object_spread({
        className: (0, import_classnames81.default)(prefixClassname("search"), {
            [prefixClassname("search--action")]: action
        }, className)
    }, restProps), React107.createElement(View, {
        className: (0, import_classnames81.default)(prefixClassname("search__content"), {
            [prefixClassname("search__content--square")]: shape === "square",
            [prefixClassname("search__content--rounded")]: shape === "rounded" || shape === "round"
        })
    }, label && React107.createElement(View, {
        className: prefixClassname("search__label"),
        children: label
    }), React107.createElement(field_default2, {
        className: prefixClassname("search__field"),
        icon,
        rightIcon,
        feedback
    }, React107.createElement(input_default, {
        className: prefixClassname("search__input"),
        placeholderClassName,
        value,
        maxlength,
        placeholder,
        clearable,
        clearIcon,
        clearTrigger,
        align: inputAlign,
        color: inputColor,
        autoFocus,
        focus,
        disabled,
        readonly,
        confirmType: "search",
        enableNative,
        onConfirm: handleSearch,
        onClear,
        onChange,
        onFocus,
        onBlur
    }))), action && React107.createElement(View, {
        className: prefixClassname("search__action"),
        children: (0, import_isBoolean7.default)(action) ? "\u53D6\u6D88" : action,
        onClick: (0, import_isBoolean7.default)(action) ? onCancel : void 0
    }));
}
var search_default = Search2;
// node_modules/@taroify/core/signature/signature.js
var import_react135 = __toESM(require_react());
var React108 = __toESM(require_react());
var import_classnames82 = __toESM(require_classnames());
var _canvasIdx = 0;
var Signature = (0, import_react135.forwardRef)(function Signature2(props, ref) {
    const { type = "png", lineWidth = 3, penColor = "#000", backgroundColor, className, canvasId: canvasIdProp, onStart, onSigning, onEnd } = props, rest = _object_without_properties(props, [
        "type",
        "lineWidth",
        "penColor",
        "backgroundColor",
        "className",
        "canvasId",
        "onStart",
        "onSigning",
        "onEnd"
    ]);
    const wrapRef = (0, import_react135.useRef)(null);
    const canvasRectRef = (0, import_react135.useRef)();
    const canvasId = (0, import_react135.useMemo)(()=>canvasIdProp ? canvasIdProp : `taroify-canvas${_canvasIdx++}`, []);
    const [canvas, ctx] = use_canvas_default(canvasId, wrapRef, {
        onLoaded (_, _ctx) {
            return _async_to_generator(function*() {
                canvasRectRef.current = yield getRect(wrapRef);
                setCanvasBgColor(_ctx);
            })();
        }
    });
    const emptyRef = (0, import_react135.useRef)(true);
    const touchStartHandler = function() {
        var _ref = _async_to_generator(function*() {
            if (ctx) {
                ctx.beginPath();
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = penColor;
                canvasRectRef.current = yield getRect(wrapRef);
                onStart === null || onStart === void 0 ? void 0 : onStart();
            }
        });
        return function touchStartHandler() {
            return _ref.apply(this, arguments);
        };
    }();
    const touchMoveHandler = (event)=>{
        if (ctx) {
            preventDefault(event);
            emptyRef.current = false;
            const touch = event.touches[0];
            const env = getEnv();
            let mouseX = touch.x;
            let mouseY = touch.y;
            if (env === "WEB") {
                var _canvasRectRef_current, _canvasRectRef_current1;
                mouseX = touch.clientX - (((_canvasRectRef_current = canvasRectRef.current) === null || _canvasRectRef_current === void 0 ? void 0 : _canvasRectRef_current.left) || 0);
                mouseY = touch.clientY - (((_canvasRectRef_current1 = canvasRectRef.current) === null || _canvasRectRef_current1 === void 0 ? void 0 : _canvasRectRef_current1.top) || 0);
            }
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.lineTo(mouseX, mouseY);
            ctx.stroke();
            onSigning === null || onSigning === void 0 ? void 0 : onSigning();
        }
    };
    const touchEndHandler = (event)=>{
        if (ctx) {
            event.preventDefault();
            onEnd === null || onEnd === void 0 ? void 0 : onEnd();
        }
    };
    const setCanvasBgColor = (ctxParam)=>{
        if (ctxParam) {
            var _canvasRectRef_current, _canvasRectRef_current1;
            ctxParam.clearRect(0, 0, (_canvasRectRef_current = canvasRectRef.current) === null || _canvasRectRef_current === void 0 ? void 0 : _canvasRectRef_current.width, (_canvasRectRef_current1 = canvasRectRef.current) === null || _canvasRectRef_current1 === void 0 ? void 0 : _canvasRectRef_current1.height);
            if (backgroundColor) {
                var _canvasRectRef_current2, _canvasRectRef_current3;
                ctxParam.fillStyle = backgroundColor;
                ctxParam.fillRect(0, 0, (_canvasRectRef_current2 = canvasRectRef.current) === null || _canvasRectRef_current2 === void 0 ? void 0 : _canvasRectRef_current2.width, (_canvasRectRef_current3 = canvasRectRef.current) === null || _canvasRectRef_current3 === void 0 ? void 0 : _canvasRectRef_current3.height);
            }
        }
    };
    const getImage = ()=>{
        if (canvas) {
            var _type, _this;
            return {
                image: emptyRef.current ? "" : ((_type = (_this = {
                    jpg: ()=>canvas.toDataURL("image/jpeg", 0.8),
                    jpeg: ()=>canvas.toDataURL("image/jpeg", 0.8)
                })[type]) === null || _type === void 0 ? void 0 : _type.call(_this)) || canvas.toDataURL(`image/${type}`),
                canvas
            };
        }
        return {
            image: "",
            canvas: null
        };
    };
    const clearHandler = ()=>{
        if (ctx) {
            emptyRef.current = true;
            setCanvasBgColor(ctx);
        }
    };
    (0, import_react135.useImperativeHandle)(ref, ()=>{
        return {
            getImage,
            clear: clearHandler
        };
    });
    return React108.createElement(View, _object_spread({
        className: (0, import_classnames82.default)(prefixClassname("signature"), className)
    }, rest), React108.createElement(View, {
        className: prefixClassname("signature__content")
    }, React108.createElement(Canvas, {
        id: canvasId,
        canvasId,
        ref: wrapRef,
        disableScroll: true,
        type: "2d",
        onTouchStart: touchStartHandler,
        onTouchMove: touchMoveHandler,
        onTouchEnd: touchEndHandler
    })));
});
var signature_default = Signature;
// node_modules/@taroify/core/signature/index.js
var signature_default2 = signature_default;
// node_modules/@taroify/core/sheet/sheet.js
var import_classnames84 = __toESM(require_classnames());
var React110 = __toESM(require_react());
var import_react137 = __toESM(require_react());
// node_modules/@taroify/core/sheet/sheet-header.js
var import_classnames83 = __toESM(require_classnames());
var React109 = __toESM(require_react());
function SheetHeader(props) {
    const { className, title, children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "title",
        "children"
    ]);
    return React109.createElement(View, _object_spread({
        className: (0, import_classnames83.default)(prefixClassname("sheet__header"), className)
    }, restProps), title && React109.createElement(View, {
        className: (0, import_classnames83.default)(prefixClassname("sheet__title")),
        children: title
    }), children2 && React109.createElement(View, {
        className: (0, import_classnames83.default)(prefixClassname("sheet__description")),
        children: children2
    }));
}
// node_modules/@taroify/core/sheet/sheet.context.js
var import_react136 = __toESM(require_react());
var SheetContext = (0, import_react136.createContext)({});
var sheet_context_default = SheetContext;
// node_modules/@taroify/core/sheet/sheet.js
function useSheetChildren(children2) {
    return (0, import_react137.useMemo)(()=>{
        const __children__ = {
            backdrop: void 0,
            header: void 0,
            content: []
        };
        import_react137.Children.forEach(children2, (child)=>{
            if ((0, import_react137.isValidElement)(child)) {
                const element = child;
                if (isElementOf(element, Backdrop)) {
                    __children__.backdrop = element;
                } else if (isElementOf(element, SheetHeader)) {
                    __children__.header = element;
                } else {
                    __children__.content.push(child);
                }
            } else {
                __children__.content.push(child);
            }
        });
        return __children__;
    }, [
        children2
    ]);
}
function SheetContent(props) {
    const { children: children2 } = props;
    return React110.createElement(View, {
        className: prefixClassname("sheet__content"),
        children: children2
    });
}
function Sheet(props) {
    const { className, defaultOpen, open, rounded = true, children: children2, onSelect, onCancel, onClose } = props, restProps = _object_without_properties(props, [
        "className",
        "defaultOpen",
        "open",
        "rounded",
        "children",
        "onSelect",
        "onCancel",
        "onClose"
    ]);
    const { backdrop, header, content } = useSheetChildren(children2);
    return React110.createElement(sheet_context_default.Provider, {
        value: {
            onSelect,
            onCancel
        }
    }, React110.createElement(popup_default2, _object_spread({
        className: (0, import_classnames84.default)(prefixClassname("sheet"), className),
        placement: "bottom",
        rounded,
        defaultOpen,
        open,
        onClose
    }, restProps), backdrop, header, React110.createElement(SheetContent, {
        children: content
    })));
}
var sheet_default = Sheet;
// node_modules/@taroify/core/sheet/sheet-button.js
var import_classnames86 = __toESM(require_classnames());
var React113 = __toESM(require_react());
var import_react138 = __toESM(require_react());
// node_modules/@taroify/core/sheet/sheet-gap.js
var React111 = __toESM(require_react());
function SheetGap() {
    return React111.createElement(View, {
        className: prefixClassname("sheet__gap")
    });
}
// node_modules/@taroify/core/sheet/sheet-item.js
var import_classnames85 = __toESM(require_classnames());
var React112 = __toESM(require_react());
function SheetItem(props) {
    const { className, loading, disabled, children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "loading",
        "disabled",
        "children"
    ]);
    return React112.createElement(View, _object_spread({
        className: (0, import_classnames85.default)(prefixClassname("sheet__item"), {
            [prefixClassname("sheet__item--loading")]: loading,
            [prefixClassname("sheet__item--disabled")]: disabled
        }, className),
        children: loading ? React112.createElement(Loading, null) : children2
    }, restProps));
}
// node_modules/@taroify/core/sheet/sheet-button.js
function SheetButton(props) {
    const { className, type, onClick } = props, restProps = _object_without_properties(props, [
        "className",
        "type",
        "onClick"
    ]);
    const { onCancel } = (0, import_react138.useContext)(sheet_context_default);
    function handleClick(event) {
        onClick === null || onClick === void 0 ? void 0 : onClick(event);
        if (type === "cancel") {
            onCancel === null || onCancel === void 0 ? void 0 : onCancel();
        }
    }
    return React113.createElement(React113.Fragment, null, React113.createElement(SheetGap, null), React113.createElement(SheetItem, _object_spread({
        className: (0, import_classnames86.default)(prefixClassname("sheet__button"), {
            [prefixClassname("sheet__button--cancel")]: type === "cancel"
        }, className),
        onClick: handleClick
    }, restProps)));
}
// node_modules/@taroify/core/sheet/index.js
var Sheet2 = sheet_default;
Sheet2.Backdrop = popup_default2.Backdrop;
Sheet2.Header = SheetHeader;
Sheet2.Item = SheetItem;
Sheet2.Button = SheetButton;
var sheet_default2 = Sheet2;
// node_modules/@taroify/core/share-sheet/share-sheet-header.js
var import_classnames87 = __toESM(require_classnames());
var React114 = __toESM(require_react());
function ShareSheetHeader(props) {
    const { className } = props, restProps = _object_without_properties(props, [
        "className"
    ]);
    return React114.createElement(sheet_default2.Header, _object_spread({
        className: (0, import_classnames87.default)(prefixClassname("share-sheet__header"), className)
    }, restProps));
}
// node_modules/@taroify/core/action-sheet/action-sheet.js
var import_classnames90 = __toESM(require_classnames());
var React117 = __toESM(require_react());
// node_modules/@taroify/core/action-sheet/action-sheet.context.js
var import_react139 = __toESM(require_react());
var ActionSheetContext = (0, import_react139.createContext)({});
var action_sheet_context_default = ActionSheetContext;
// node_modules/@taroify/core/action-sheet/action-sheet-header.js
var import_classnames88 = __toESM(require_classnames());
var React115 = __toESM(require_react());
function ActionSheetHeader(props) {
    const { className } = props, restProps = _object_without_properties(props, [
        "className"
    ]);
    return React115.createElement(sheet_default2.Header, _object_spread({
        className: (0, import_classnames88.default)(prefixClassname("action-sheet__header"), className)
    }, restProps));
}
// node_modules/@taroify/core/action-sheet/action-sheet-action.js
var import_classnames89 = __toESM(require_classnames());
var React116 = __toESM(require_react());
var import_react140 = __toESM(require_react());
function ActionSheetAction(props) {
    const { className, style, disabled, loading, name, value, children: children2, onClick } = props, restProps = _object_without_properties(props, [
        "className",
        "style",
        "disabled",
        "loading",
        "name",
        "value",
        "children",
        "onClick"
    ]);
    const { onSelect } = (0, import_react140.useContext)(action_sheet_context_default);
    return React116.createElement(sheet_default2.Item, {
        style,
        className: (0, import_classnames89.default)(prefixClassname("action-sheet__action"), className),
        disabled,
        loading
    }, name && React116.createElement(View, {
        className: prefixClassname("action-sheet__name"),
        children: name
    }), children2 && React116.createElement(View, {
        className: prefixClassname("action-sheet__subname"),
        children: children2
    }), React116.createElement(button_base_default, _object_spread({
        className: prefixClassname("action-sheet__button"),
        onClick: (event)=>{
            if (!disabled && !loading) {
                onClick === null || onClick === void 0 ? void 0 : onClick(event);
                onSelect === null || onSelect === void 0 ? void 0 : onSelect({
                    disabled,
                    loading,
                    name,
                    value,
                    children: children2
                });
            }
        }
    }, restProps)));
}
// node_modules/@taroify/core/action-sheet/action-sheet.js
function ActionSheet(_param) {
    var { description, cancelText, actions, className, onSelect, children: childrenProp, safeArea = "bottom" } = _param, restProps = _object_without_properties(_param, [
        "description",
        "cancelText",
        "actions",
        "className",
        "onSelect",
        "children",
        "safeArea"
    ]);
    const renderChildren = ()=>{
        if (childrenProp) {
            return childrenProp;
        }
        return React117.createElement(React117.Fragment, null, description && React117.createElement(ActionSheetHeader, {
            children: description
        }), (actions || []).map((_param, index)=>{
            var { subname } = _param, rest = _object_without_properties(_param, [
                "subname"
            ]);
            return React117.createElement(ActionSheetAction, _object_spread_props(_object_spread({
                key: `${index}-${subname}`
            }, rest), {
                children: subname
            }));
        }), cancelText && React117.createElement(sheet_default2.Button, {
            type: "cancel",
            children: cancelText
        }), React117.createElement(safe_area_default, {
            position: safeArea
        }));
    };
    return React117.createElement(action_sheet_context_default.Provider, {
        value: {
            onSelect
        }
    }, React117.createElement(sheet_default2, _object_spread({
        className: (0, import_classnames90.default)(prefixClassname("action-sheet"), className)
    }, restProps), renderChildren()));
}
var action_sheet_default = ActionSheet;
// node_modules/@taroify/core/action-sheet/index.js
var ActionSheet2 = action_sheet_default;
ActionSheet2.Backdrop = sheet_default2.Backdrop;
ActionSheet2.Header = ShareSheetHeader;
ActionSheet2.Action = ActionSheetAction;
ActionSheet2.Button = sheet_default2.Button;
var action_sheet_default2 = ActionSheet2;
// node_modules/@taroify/core/dialog/dialog.js
var import_classnames94 = __toESM(require_classnames());
var React121 = __toESM(require_react());
var import_react142 = __toESM(require_react());
// node_modules/@taroify/core/dialog/dialog-actions.js
var import_classnames91 = __toESM(require_classnames());
var React118 = __toESM(require_react());
var import_react141 = __toESM(require_react());
var { deprecated: deprecated3 } = getLogger("Dialog.Actions");
function useActionButtons(props) {
    return (0, import_react141.useMemo)(()=>{
        const { children: children2, variant } = props;
        if (children2 === void 0) {
            return children2;
        }
        const __rounded__ = variant === "rounded";
        const count = import_react141.Children.count(children2);
        const zeroIndex = 0;
        const lastIndex = count - 1;
        const __children__ = [];
        import_react141.Children.forEach(children2, (action, index)=>{
            if (!(0, import_react141.isValidElement)(action)) {
                __children__.push(action);
                return;
            }
            const element = action;
            const actionClassNames = [
                element.props.className
            ];
            if (index !== zeroIndex && !__rounded__) {
                actionClassNames.push(HAIRLINE_BORDER_LEFT);
            }
            if (index !== lastIndex) {
                actionClassNames.push(prefixClassname("dialog__cancel"));
            }
            if (index === lastIndex) {
                actionClassNames.push(prefixClassname("dialog__confirm"));
            }
            var _action_key;
            __children__.push((0, import_react141.cloneElement)(action, {
                key: (_action_key = action.key) !== null && _action_key !== void 0 ? _action_key : index,
                className: (0, import_classnames91.default)(action.props.className, actionClassNames),
                size: "large",
                shape: "square",
                variant: __rounded__ ? "contained" : "text"
            }));
        });
        return __children__;
    }, [
        props
    ]);
}
function DialogActions(props) {
    const { theme, variant: variantProp, children: childrenProp } = props;
    if (theme === "round") {
        deprecated3('Use the variant="rounded" prop instead of the theme="round" prop');
    }
    const variant = variantProp !== null && variantProp !== void 0 ? variantProp : theme === "round" ? "rounded" : void 0;
    const children2 = useActionButtons({
        children: childrenProp,
        variant
    });
    return React118.createElement(View, {
        className: (0, import_classnames91.default)(prefixClassname("dialog__footer"), {
            [HAIRLINE_BORDER_TOP]: variant !== "rounded",
            [prefixClassname("dialog__footer--rounded")]: variant === "rounded"
        }),
        children: children2
    });
}
// node_modules/@taroify/core/dialog/dialog-content.js
var import_classnames92 = __toESM(require_classnames());
var React119 = __toESM(require_react());
function DialogContent(props) {
    const { isolated, align = "center", children: children2 } = props;
    return React119.createElement(View, {
        className: (0, import_classnames92.default)(prefixClassname("dialog__content"), {
            [prefixClassname("dialog__content--isolated")]: isolated
        })
    }, React119.createElement(View, {
        className: (0, import_classnames92.default)(prefixClassname("dialog__message"), {
            [prefixClassname("dialog__message--left")]: align === "left",
            [prefixClassname("dialog__message--right")]: align === "right"
        }),
        children: children2
    }));
}
// node_modules/@taroify/core/dialog/dialog-header.js
var import_classnames93 = __toESM(require_classnames());
var React120 = __toESM(require_react());
function DialogHeader(props) {
    const { className, children: children2 } = props;
    return React120.createElement(View, {
        className: (0, import_classnames93.default)(prefixClassname("dialog__header"), className),
        children: children2
    });
}
// node_modules/@taroify/core/dialog/dialog.shared.js
var dialogEvents = new Events();
var dialogSelectorSet = /* @__PURE__ */ new Set();
// node_modules/@taroify/core/dialog/dialog.js
function useDialogOpen(cb) {
    (0, import_react142.useEffect)(()=>{
        dialogEvents.on("open", cb);
        return ()=>{
            dialogEvents.off("open", cb);
        };
    }, []);
}
function useDialogCancel(cb) {
    (0, import_react142.useEffect)(()=>{
        dialogEvents.on("cancel", cb);
        return ()=>{
            dialogEvents.off("cancel", cb);
        };
    }, []);
}
function useDialogChildren(nodes) {
    return (0, import_react142.useMemo)(()=>{
        const __children__ = {
            header: void 0,
            content: void 0,
            actions: void 0
        };
        if (nodes === void 0) {
            return __children__;
        }
        import_react142.Children.forEach(nodes, (node)=>{
            if (!(0, import_react142.isValidElement)(node)) {
                return;
            }
            const { header, content, actions } = __children__;
            if (header !== void 0 && content !== void 0 && actions !== void 0) {
                return;
            }
            const element = node;
            if (isElementOf(element, Backdrop)) {
                __children__.backdrop = element;
            } else if (element.type === DialogHeader) {
                __children__.header = element;
            } else if (element.type === DialogContent) {
                __children__.content = element;
            } else if (element.type === DialogActions) {
                __children__.actions = element;
            }
        });
        return __children__;
    }, [
        nodes
    ]);
}
function renderDialogHeader(header, props) {
    if (!(0, import_react142.isValidElement)(header)) {
        return header;
    }
    return (0, import_react142.cloneElement)(header, props);
}
function renderDialogContent(content, props) {
    if (!(0, import_react142.isValidElement)(content)) {
        return content;
    }
    return (0, import_react142.cloneElement)(content, props);
}
function renderHeader(title, key) {
    if (title === void 0) {
        return null;
    }
    return React121.createElement(DialogHeader, {
        key,
        children: title
    });
}
function renderContent(message, messageAlign, key) {
    return React121.createElement(DialogContent, {
        key,
        align: messageAlign,
        children: message
    });
}
function renderActions(confirm, cancel2, variant, confirmLoading, cancelLoading, key) {
    if (cancel2 === void 0 && confirm === void 0) {
        return null;
    }
    const actions = [];
    if (cancel2) {
        actions.push(createButton(cancel2, {
            key: 1,
            loading: cancelLoading
        }));
    }
    if (confirm) {
        actions.push(createButton(confirm, {
            key: 0,
            loading: confirmLoading
        }));
    }
    return React121.createElement(DialogActions, {
        key,
        children: actions,
        variant
    });
}
var transactionTimeout = {
    enter: 100,
    exit: 300,
    appear: 100
};
function Dialog(props) {
    const _useObject = useObject(props), { object: { id, className, defaultOpen, open: openProp, children: children2, backdrop: backdropOptions = {
        closeable: false
    }, title: titleProp, message: messageProp, messageAlign: messageAlignProp, theme: themeProp, confirm: confirmProp, cancel: cancelProp, onBeforeClose: onBeforeCloseProp, onClose, onConfirm: onConfirmProp, onCancel: onCancelProp }, setObject } = _useObject, restProps = _object_without_properties(_useObject.object, [
        "id",
        "className",
        "defaultOpen",
        "open",
        "children",
        "backdrop",
        "title",
        "message",
        "messageAlign",
        "theme",
        "confirm",
        "cancel",
        "onBeforeClose",
        "onClose",
        "onConfirm",
        "onCancel"
    ]);
    const rootSelectorRef = useToRef(usePrependPageSelector(getElementSelector(id)));
    const { value: open = false, setValue: setOpen } = useUncontrolled({
        defaultValue: defaultOpen,
        value: openProp
    });
    const [confirmLoading, setConfirmLoading] = (0, import_react142.useState)(false);
    const [cancelLoading, setCancelLoading] = (0, import_react142.useState)(false);
    const { onClick } = (0, import_react142.useContext)(button_context_default);
    const { backdrop: backdropElement, header: headerChildren, content: contentChildren, actions: actionsChildren } = useDialogChildren(children2);
    const backdrop = usePopupBackdrop(backdropElement, backdropOptions);
    const header = (0, import_react142.useMemo)(()=>headerChildren !== null && headerChildren !== void 0 ? headerChildren : renderHeader(titleProp), [
        headerChildren,
        titleProp
    ]);
    const content = (0, import_react142.useMemo)(()=>contentChildren !== null && contentChildren !== void 0 ? contentChildren : renderContent(messageProp, messageAlignProp), [
        contentChildren,
        messageProp,
        messageAlignProp
    ]);
    const actions = (0, import_react142.useMemo)(()=>actionsChildren !== null && actionsChildren !== void 0 ? actionsChildren : renderActions(confirmProp, cancelProp, themeProp, confirmLoading, cancelLoading), [
        actionsChildren,
        confirmProp,
        cancelProp,
        themeProp,
        confirmLoading,
        cancelLoading
    ]);
    const onConfirm = useMemoizedFn(/*#__PURE__*/ _async_to_generator(function*() {
        try {
            let boolean = true;
            if (onBeforeCloseProp) {
                setConfirmLoading(true);
                boolean = yield onBeforeCloseProp("confirm");
                setConfirmLoading(false);
            }
            if (boolean) {
                onConfirmProp === null || onConfirmProp === void 0 ? void 0 : onConfirmProp();
                setOpen(false);
            }
        } catch (err) {
            console.error(err);
        }
    }));
    const onCancel = useMemoizedFn(/*#__PURE__*/ _async_to_generator(function*() {
        try {
            let boolean = true;
            if (onBeforeCloseProp) {
                setCancelLoading(true);
                boolean = yield onBeforeCloseProp("cancel");
                setCancelLoading(false);
            }
            if (boolean) {
                onCancelProp === null || onCancelProp === void 0 ? void 0 : onCancelProp();
                setOpen(false);
            }
        } catch (err) {
            console.error(err);
        }
    }));
    const hasHeader = header !== void 0;
    const hasContent = content !== void 0;
    const handleClick = (event, btnProps)=>{
        onClick === null || onClick === void 0 ? void 0 : onClick(event, btnProps);
        const { className: className2 } = btnProps;
        if (className2 === null || className2 === void 0 ? void 0 : className2.includes(prefixClassname("dialog__confirm"))) {
            onConfirm();
        } else if (className2 === null || className2 === void 0 ? void 0 : className2.includes(prefixClassname("dialog__cancel"))) {
            onCancel();
        } else {
            setOpen(false);
        }
    };
    const handleClose = (0, import_react142.useCallback)((opened)=>{
        onClose === null || onClose === void 0 ? void 0 : onClose(opened);
        setOpen(false);
    }, [
        onClose,
        setOpen
    ]);
    const { selector } = (0, import_react142.useMemo)(()=>{
        return {
            selector: (props === null || props === void 0 ? void 0 : props.id) ? prependPageSelector(getElementSelector(props === null || props === void 0 ? void 0 : props.id)) : prependPageSelector(`${getElementSelector(id)}`)
        };
    }, [
        id,
        props === null || props === void 0 ? void 0 : props.id
    ]);
    (0, import_react142.useEffect)(()=>{
        if (selector) {
            dialogSelectorSet.add(selector);
            return ()=>{
                dialogSelectorSet.delete(selector);
            };
        }
        return void 0;
    }, [
        selector
    ]);
    useDialogOpen((_param)=>{
        var { selector: selector2, title, message, messageAlign, confirm, cancel: cancel2, theme } = _param, restOptions = _object_without_properties(_param, [
            "selector",
            "title",
            "message",
            "messageAlign",
            "confirm",
            "cancel",
            "theme"
        ]);
        if (matchSelector(prependPageSelector(selector2), rootSelectorRef.current)) {
            const children3 = [];
            if (title) {
                children3.push(renderHeader(title, 0));
            }
            if (message) {
                children3.push(renderContent(message, messageAlign, 1));
            }
            children3.push(renderActions(confirm, cancel2, theme, false, false, 2));
            setObject(_object_spread({
                children: children3
            }, restOptions));
            setOpen(true);
        }
    });
    useDialogCancel((selector2)=>{
        if (matchSelector(prependPageSelector(selector2), rootSelectorRef.current)) {
            onCancel();
            setOpen(false);
        }
    });
    return React121.createElement(button_context_default.Provider, {
        value: {
            onClick: handleClick
        }
    }, React121.createElement(popup_default2, _object_spread({
        id,
        open,
        className: (0, import_classnames94.default)(prefixClassname("dialog"), className),
        transaction: prefixClassname("dialog-bounce"),
        transactionTimeout,
        onClose: handleClose
    }, restProps), backdrop, renderDialogHeader(header, {
        isolated: hasHeader && !hasContent
    }), renderDialogContent(content, {
        isolated: !hasHeader && hasContent
    }), actions));
}
var dialog_default = Dialog;
// node_modules/@taroify/core/dialog/dialog.imperative.js
var import_assign2 = __toESM(require_assign());
var import_isPlainObject6 = __toESM(require_isPlainObject());
var import_react143 = __toESM(require_react());
var initialDialogOptions = {
    className: void 0,
    style: void 0,
    backdrop: void 0,
    message: void 0,
    title: void 0,
    messageAlign: void 0,
    confirm: void 0,
    cancel: void 0
};
var DEFAULT_DIALOG_SELECTOR = "#dialog";
var defaultDialogOptions = {};
var dialogViewMap = /* @__PURE__ */ new Map();
resetDefaultDialogOptions();
function setDefaultDialogOptions(options) {
    (0, import_assign2.default)(defaultDialogOptions, options);
}
function resetDefaultDialogOptions() {
    (0, import_assign2.default)(defaultDialogOptions, {
        selector: DEFAULT_DIALOG_SELECTOR
    });
}
function parseDialogOptions(message) {
    const options = !(0, import_react143.isValidElement)(message) && (0, import_isPlainObject6.default)(message) ? message : {
        message
    };
    return (0, import_assign2.default)({}, initialDialogOptions, defaultDialogOptions, options);
}
function generateDialogId(selector = DEFAULT_DIALOG_SELECTOR) {
    return `${getPagePath()}__${selector}__${Date.now()}`;
}
function openDialog(args) {
    const _parseDialogOptions = parseDialogOptions(args), { selector = "#dialog" } = _parseDialogOptions, restOptions = _object_without_properties(_parseDialogOptions, [
        "selector"
    ]);
    const pageSelector = `${getPagePath()}__${selector}`;
    if (selector && dialogSelectorSet.has(pageSelector)) {
        dialogEvents.trigger("open", _object_spread({
            selector
        }, restOptions));
    } else {
        const dialogId = generateDialogId(selector);
        const dialogView = document$1.createElement("view");
        const onTransitionExited = restOptions.onTransitionExited;
        const unmountFn = ()=>{
            unmountPortal(dialogView);
            dialogViewMap.delete(dialogId);
        };
        restOptions.onTransitionExited = ()=>{
            onTransitionExited === null || onTransitionExited === void 0 ? void 0 : onTransitionExited();
            unmountFn();
        };
        mountPortal((0, import_react143.createElement)(dialog_default, _object_spread_props(_object_spread({}, restOptions), {
            defaultOpen: true,
            id: dialogId
        })), dialogView);
        dialogViewMap.set(dialogId, {
            view: dialogView,
            unmountFn
        });
        return dialogId;
    }
}
function confirmDialog(args) {
    const _parseDialogOptions = parseDialogOptions(args), { cancel: cancel2 = "\u53D6\u6D88", confirm = "\u786E\u5B9A" } = _parseDialogOptions, restOptions = _object_without_properties(_parseDialogOptions, [
        "cancel",
        "confirm"
    ]);
    return openDialog(_object_spread({
        confirm,
        cancel: cancel2
    }, restOptions));
}
function alertDialog(args) {
    const _parseDialogOptions = parseDialogOptions(args), { confirm = "\u786E\u5B9A" } = _parseDialogOptions, restOptions = _object_without_properties(_parseDialogOptions, [
        "confirm"
    ]);
    return openDialog(_object_spread({
        confirm
    }, restOptions));
}
function cancelDialog(selector) {
    dialogEvents.trigger("cancel", selector !== null && selector !== void 0 ? selector : defaultDialogOptions.selector);
}
// node_modules/@taroify/core/dialog/index.js
var Dialog2 = dialog_default;
Dialog2.Header = DialogHeader;
Dialog2.Content = DialogContent;
Dialog2.Actions = DialogActions;
Dialog2.confirm = confirmDialog;
Dialog2.alert = alertDialog;
Dialog2.open = openDialog;
Dialog2.cancel = cancelDialog;
Dialog2.setDefaultOptions = setDefaultDialogOptions;
Dialog2.resetDefaultOptions = resetDefaultDialogOptions;
var dialog_default2 = Dialog2;
// node_modules/@taroify/core/dropdown-menu/dropdown-menu.js
var import_classnames98 = __toESM(require_classnames());
var import_size13 = __toESM(require_size());
var import_isNull3 = __toESM(require_isNull());
var import_isNumber12 = __toESM(require_isNumber());
var import_isString8 = __toESM(require_isString());
var React125 = __toESM(require_react());
var import_react149 = __toESM(require_react());
// node_modules/@taroify/core/dropdown-menu/dropdown-menu-item.js
var import_classnames96 = __toESM(require_classnames());
var import_isArray10 = __toESM(require_isArray());
var import_isBoolean8 = __toESM(require_isBoolean());
var React123 = __toESM(require_react());
var import_react147 = __toESM(require_react());
// node_modules/@taroify/core/dropdown-menu/dropdown-menu-item.context.js
var import_react144 = __toESM(require_react());
var DropdownMenuItemContext = (0, import_react144.createContext)({});
var dropdown_menu_item_context_default = DropdownMenuItemContext;
// node_modules/@taroify/core/dropdown-menu/dropdown-menu.context.js
var import_react145 = __toESM(require_react());
var DropdownMenuContext = (0, import_react145.createContext)({});
var dropdown_menu_context_default = DropdownMenuContext;
// node_modules/@taroify/core/dropdown-menu/dropdown-menu-option.js
var import_classnames95 = __toESM(require_classnames());
var React122 = __toESM(require_react());
var import_react146 = __toESM(require_react());
function DropdownMenuOption(props) {
    const { className, value, disabled, clickable = true, icon, children: children2, onClick } = props, restProps = _object_without_properties(props, [
        "className",
        "value",
        "disabled",
        "clickable",
        "icon",
        "children",
        "onClick"
    ]);
    const { isOptionToggle, toggleOption } = (0, import_react146.useContext)(dropdown_menu_item_context_default);
    const active = isOptionToggle === null || isOptionToggle === void 0 ? void 0 : isOptionToggle(value);
    const handleClick = (0, import_react146.useCallback)((event)=>{
        onClick === null || onClick === void 0 ? void 0 : onClick(event);
        if (!disabled) {
            toggleOption === null || toggleOption === void 0 ? void 0 : toggleOption({
                active: !active,
                value,
                children: children2
            });
        }
    }, [
        active,
        children2,
        disabled,
        onClick,
        toggleOption,
        value
    ]);
    return React122.createElement(cell_default2, _object_spread({
        className: (0, import_classnames95.default)(prefixClassname("dropdown-menu-option"), {
            [prefixClassname("dropdown-menu-option--active")]: active,
            [prefixClassname("dropdown-menu-option--disabled")]: disabled
        }, className),
        clickable,
        icon,
        title: children2,
        onClick: handleClick
    }, restProps), active && React122.createElement(Success_default, {
        className: prefixClassname("dropdown-menu-option__icon")
    }));
}
var dropdown_menu_option_default = DropdownMenuOption;
// node_modules/@taroify/core/dropdown-menu/dropdown-menu-item.js
function DropdownMenuItem(props) {
    const { style: styleProp, __dataKey__: dataKey, defaultValue, value: valueProp, disabled, lock = false, children: childProp, options, onOpen, onClose, onOpened, onClosed, onChange: onChangeProp, onTransitionExited } = props, restProps = _object_without_properties(props, [
        "style",
        "__dataKey__",
        "defaultValue",
        "value",
        "disabled",
        "lock",
        "children",
        "options",
        "onOpen",
        "onClose",
        "onOpened",
        "onClosed",
        "onChange",
        "onTransitionExited"
    ]);
    const { getValue, setValue } = useUncontrolled({
        value: valueProp,
        defaultValue,
        onChange: onChangeProp
    });
    const children2 = (0, import_react147.useMemo)(()=>{
        return childProp ? childProp : (options || []).map((option, idx)=>React123.createElement(dropdown_menu_option_default, _object_spread({
                key: option.value || idx
            }, option)));
    }, [
        childProp,
        options
    ]);
    const { direction = "down", itemOffset, backdropType = "inner", isItemToggle, toggleItem: triggerItem } = (0, import_react147.useContext)(dropdown_menu_context_default);
    const active = (0, import_react147.useMemo)(()=>isItemToggle === null || isItemToggle === void 0 ? void 0 : isItemToggle(dataKey), [
        dataKey,
        isItemToggle
    ]);
    const [opened, setOpened] = (0, import_react147.useState)(false);
    const down = direction === "down";
    const toggleItem = (0, import_react147.useCallback)(()=>{
        if (!disabled) {
            triggerItem === null || triggerItem === void 0 ? void 0 : triggerItem(dataKey);
        }
    }, [
        dataKey,
        disabled,
        triggerItem
    ]);
    const isOptionToggle = (0, import_react147.useCallback)((aValue)=>(0, import_isArray10.default)(getValue()) ? getValue().includes(aValue) : getValue() === aValue, [
        getValue
    ]);
    const toggleOption = (0, import_react147.useCallback)(({ value: evtValue, active: active2 })=>{
        const value = getValue();
        const multiselect = (0, import_isArray10.default)(value);
        if (multiselect) {
            if (active2) {
                setValue(value.concat(evtValue));
            } else {
                setValue(value.filter((aValue)=>aValue !== evtValue));
            }
        } else {
            setValue(value === evtValue && !active2 ? void 0 : evtValue);
        }
        toggleItem();
    }, [
        getValue,
        setValue,
        toggleItem
    ]);
    const rootStyle = (0, import_react147.useMemo)(()=>{
        const style = {};
        if (opened) {
            if (down) {
                style.top = itemOffset ? addUnitPx(itemOffset) : "";
            } else {
                style.bottom = itemOffset ? addUnitPx(itemOffset) : "";
            }
        }
        style.display = !active && !opened ? "none" : "";
        return style;
    }, [
        opened,
        active,
        down,
        itemOffset
    ]);
    return React123.createElement(dropdown_menu_item_context_default.Provider, {
        value: {
            toggleOption,
            isOptionToggle
        }
    }, React123.createElement(View, _object_spread({
        style: _object_spread({}, styleProp, rootStyle),
        className: (0, import_classnames96.default)(prefixClassname("dropdown-menu-item"), prefixClassname(`dropdown-menu-item--${direction}`))
    }, restProps), React123.createElement(popup_default2, {
        open: (0, import_isBoolean8.default)(active) && active,
        className: prefixClassname("dropdown-menu-item__content"),
        placement: down ? "top" : "bottom",
        lock,
        onTransitionEnter: ()=>{
            setOpened(true);
            onOpen === null || onOpen === void 0 ? void 0 : onOpen();
        },
        onTransitionEntered: ()=>{
            onOpened === null || onOpened === void 0 ? void 0 : onOpened();
        },
        onTransitionExit: ()=>{
            onClose === null || onClose === void 0 ? void 0 : onClose();
        },
        onTransitionExited: (...args)=>{
            setOpened(false);
            onTransitionExited === null || onTransitionExited === void 0 ? void 0 : onTransitionExited(...args);
            onClosed === null || onClosed === void 0 ? void 0 : onClosed();
        }
    }, React123.createElement(popup_default2.Backdrop, {
        lock,
        style: {
            position: backdropType === "inner" ? "absolute" : "fixed"
        },
        onClick: toggleItem
    }), lock ? React123.createElement(ScrollView, {
        className: prefixClassname("dropdown-menu-item__content--scroll"),
        scrollY: true
    }, children2) : children2)));
}
var dropdown_menu_item_default = DropdownMenuItem;
// node_modules/@taroify/core/dropdown-menu/dropdown-menu-title.js
var import_classnames97 = __toESM(require_classnames());
var React124 = __toESM(require_react());
var import_react148 = __toESM(require_react());
function DropdownMenuTitle(props) {
    const { className, __dataKey__: dataKey, disabled, children: children2, onClick } = props, restProps = _object_without_properties(props, [
        "className",
        "__dataKey__",
        "disabled",
        "children",
        "onClick"
    ]);
    const { isItemToggle, toggleItem } = (0, import_react148.useContext)(dropdown_menu_context_default);
    const active = (0, import_react148.useMemo)(()=>isItemToggle === null || isItemToggle === void 0 ? void 0 : isItemToggle(dataKey), [
        dataKey,
        isItemToggle
    ]);
    return React124.createElement(View, _object_spread({
        className: (0, import_classnames97.default)(prefixClassname("dropdown-menu-title"), {
            [prefixClassname("dropdown-menu-title--active")]: active,
            [prefixClassname("dropdown-menu-title--disabled")]: disabled,
            [prefixClassname("dropdown-menu-title--down")]: active
        }, className),
        onClick: (event)=>{
            onClick === null || onClick === void 0 ? void 0 : onClick(event);
            if (!disabled) {
                toggleItem === null || toggleItem === void 0 ? void 0 : toggleItem(dataKey);
            }
        }
    }, restProps), React124.createElement(View, {
        className: prefixClassname("dropdown-menu-title__content")
    }, React124.createElement(View, {
        className: prefixClassname("ellipsis"),
        children: children2
    })));
}
var dropdown_menu_title_default = DropdownMenuTitle;
// node_modules/@taroify/core/dropdown-menu/dropdown-menu.js
function getDropdownMenuTitle(children2, options, dropdownValue) {
    const firstRef = {
        current: void 0
    };
    const nodeRef = {
        current: void 0
    };
    import_react149.Children.forEach(children2, (child, index)=>{
        if (!(0, import_react149.isValidElement)(child)) {
            return;
        }
        const element = child;
        const elementType = element.type;
        if (elementType === dropdown_menu_option_default) {
            const { props } = element;
            const { title, value, children: children3 } = props;
            if (index === 0) {
                firstRef.current = title !== null && title !== void 0 ? title : children3;
            }
            if (dropdownValue === value) {
                nodeRef.current = title !== null && title !== void 0 ? title : children3;
            }
        }
    });
    if (!nodeRef.current) {
        if (options) {
            var _options_find;
            nodeRef.current = ((_options_find = options.find((option)=>option.value === dropdownValue)) === null || _options_find === void 0 ? void 0 : _options_find.title) || options[0].title;
        } else {
            nodeRef.current = firstRef.current;
        }
    }
    return nodeRef.current;
}
function useDropdownMenuChildren(children2) {
    return (0, import_react149.useMemo)(()=>{
        const __children__ = {
            titles: [],
            items: []
        };
        import_react149.Children.forEach(children2, (child)=>{
            if (!(0, import_react149.isValidElement)(child)) {
                return;
            }
            const element = child;
            const elementType = element.type;
            if (elementType === dropdown_menu_item_default) {
                const { key, props } = element;
                const { disabled, title, value, children: itemChildren, options } = props;
                const index = (0, import_size13.default)(__children__.items);
                const itemKey = key !== null && key !== void 0 ? key : index;
                __children__.items.push((0, import_react149.cloneElement)(element, {
                    key: itemKey,
                    __dataKey__: itemKey
                }));
                __children__.titles.push(React125.createElement(dropdown_menu_title_default, {
                    key: itemKey,
                    __dataKey__: itemKey,
                    disabled,
                    children: title !== null && title !== void 0 ? title : getDropdownMenuTitle(itemChildren, options, value)
                }));
            }
        });
        return __children__;
    }, [
        children2
    ]);
}
function DropdownMenu(props) {
    const { className, defaultValue, value: valueProp, direction = "down", backdropType = "inner", children: childrenProp, onChange: onChangeProp } = props, restProps = _object_without_properties(props, [
        "className",
        "defaultValue",
        "value",
        "direction",
        "backdropType",
        "children",
        "onChange"
    ]);
    const { value, setValue } = useUncontrolled({
        value: valueProp,
        onChange: onChangeProp
    });
    const barRef = (0, import_react149.useRef)();
    const [opened, setOpened] = (0, import_react149.useState)();
    const [itemOffset, setItemOffset] = (0, import_react149.useState)(0);
    const { titles, items } = useDropdownMenuChildren(childrenProp);
    const toggleKeyRef = (0, import_react149.useRef)();
    const windowHeight = (0, import_react149.useMemo)(()=>getWindowInfo().windowHeight, []);
    const updateItemOffset = (0, import_react149.useCallback)(()=>{
        getRect(barRef).then((rect)=>{
            if (rect) {
                if (direction === "down") {
                    setItemOffset(rect.bottom);
                } else {
                    setItemOffset(windowHeight - rect.top);
                }
            }
        });
    }, [
        direction,
        windowHeight
    ]);
    const toggleItem = (0, import_react149.useCallback)((itemKey)=>{
        const itemActive = value === itemKey ? null : itemKey;
        if (itemActive !== null) {
            updateItemOffset();
        }
        setValue(itemActive);
    }, [
        setValue,
        updateItemOffset,
        value
    ]);
    const isItemToggle = (0, import_react149.useCallback)((itemKey)=>{
        const active = toggleKeyRef.current === itemKey;
        if (active && (0, import_isNull3.default)(value)) {
            return null;
        }
        return value === itemKey;
    }, [
        value
    ]);
    (0, import_react149.useEffect)(()=>{
        const val = value !== false && value !== null && value !== void 0;
        if (val) {
            setOpened(val);
        } else {
            setTimeout(()=>{
                setOpened(val);
            }, 300);
        }
    }, [
        value
    ]);
    usePageScroll(updateItemOffset);
    useMounted(()=>{
        if ((0, import_isNumber12.default)(defaultValue) || (0, import_isString8.default)(defaultValue)) {
            toggleItem(defaultValue);
            setTimeout(updateItemOffset, 120);
        }
    });
    return React125.createElement(dropdown_menu_context_default.Provider, {
        value: {
            direction,
            itemOffset,
            backdropType,
            toggleItem,
            isItemToggle
        }
    }, React125.createElement(View, _object_spread({
        className: (0, import_classnames98.default)(prefixClassname("dropdown-menu"), className)
    }, restProps), React125.createElement(View, {
        ref: barRef,
        className: (0, import_classnames98.default)(prefixClassname("dropdown-menu__bar"), {
            [prefixClassname("dropdown-menu__bar--opened")]: opened
        }),
        children: titles
    }), items));
}
var dropdown_menu_default = DropdownMenu;
// node_modules/@taroify/core/dropdown-menu/index.js
var DropdownMenu2 = dropdown_menu_default;
DropdownMenu2.Item = dropdown_menu_item_default;
DropdownMenu2.Option = dropdown_menu_option_default;
var dropdown_menu_default2 = DropdownMenu2;
// node_modules/@taroify/core/notify/notify.js
var import_classnames99 = __toESM(require_classnames());
var React126 = __toESM(require_react());
var import_react150 = __toESM(require_react());
// node_modules/@taroify/core/notify/notify.shared.js
var notifyEvents = new Events();
var notifySelectorSet = /* @__PURE__ */ new Set();
// node_modules/@taroify/core/notify/notify.js
var PRESET_COLORS = [
    "primary",
    "success",
    "warning",
    "danger"
];
function useNotifyOpen(cb) {
    (0, import_react150.useEffect)(()=>{
        notifyEvents.on("open", cb);
        return ()=>{
            notifyEvents.off("open", cb);
        };
    }, []);
}
function useNotifyClose(cb) {
    (0, import_react150.useEffect)(()=>{
        notifyEvents.on("close", cb);
        return ()=>{
            notifyEvents.off("close", cb);
        };
    }, []);
}
function Notify(props) {
    const _useObject = useObject(props), { object: { id, style: styleProp, className, defaultOpen, open: openProp, duration = 3e3, type: typeProp, background: backgroundProp, color: colorProp = "danger", children: children2, onClose }, setObject } = _useObject, restProps = _object_without_properties(_useObject.object, [
        "id",
        "style",
        "className",
        "defaultOpen",
        "open",
        "duration",
        "type",
        "background",
        "color",
        "children",
        "onClose"
    ]);
    const style = mergeStyle(styleProp, _object_spread({
        background: backgroundProp
    }, !PRESET_COLORS.includes(colorProp) && {
        "--notify-color": colorProp
    }));
    const rootSelectorRef = useToRef(usePrependPageSelector(getElementSelector(id)));
    const { value: open = false, setValue: setOpen } = useUncontrolled({
        defaultValue: defaultOpen,
        value: openProp,
        onChange: (aOpened)=>!aOpened && (onClose === null || onClose === void 0 ? void 0 : onClose(aOpened))
    });
    const { stop: stopAutoClose, restart: restartAutoClose } = use_timeout_default();
    (0, import_react150.useEffect)(()=>{
        rootSelectorRef.current && notifySelectorSet.add(rootSelectorRef.current);
        return ()=>{
            rootSelectorRef.current && notifySelectorSet.delete(rootSelectorRef.current);
        };
    }, []);
    (0, import_react150.useEffect)(()=>{
        if (open) {
            restartAutoClose(()=>{
                setOpen(false);
                stopAutoClose();
            }, duration);
        } else {
            stopAutoClose();
        }
        return ()=>stopAutoClose();
    }, [
        duration,
        open,
        restartAutoClose,
        setObject,
        setOpen,
        stopAutoClose
    ]);
    useNotifyOpen((_param)=>{
        var { selector, message } = _param, restOptions = _object_without_properties(_param, [
            "selector",
            "message"
        ]);
        if (matchSelector(prependPageSelector(selector), rootSelectorRef.current)) {
            restartAutoClose();
            setObject(_object_spread({
                children: message
            }, restOptions));
            setOpen(true);
        }
    });
    useNotifyClose((selector)=>{
        if (matchSelector(prependPageSelector(selector), rootSelectorRef.current)) {
            setOpen(false);
        }
    });
    return React126.createElement(popup_default2, _object_spread({
        id,
        className: (0, import_classnames99.default)(prefixClassname("notify"), {
            [prefixClassname(`notify--${typeProp || colorProp}`)]: PRESET_COLORS.includes(typeProp || colorProp)
        }, className),
        style,
        placement: "top",
        open,
        duration: 200
    }, restProps), React126.createElement(popup_default2.Backdrop, {
        open: false
    }), children2);
}
var notify_default = Notify;
// node_modules/@taroify/core/notify/notify.imperative.js
var import_assign3 = __toESM(require_assign());
var import_isPlainObject7 = __toESM(require_isPlainObject());
var import_react151 = __toESM(require_react());
var initialNotifyOptions = {
    className: void 0,
    style: void 0,
    duration: void 0,
    message: void 0,
    color: void 0
};
var DEFAULT_NOTIFY_SELECTOR = "#notify";
var DEFAULT_NOTIFY_SELECTOR_CREATE = "notify";
var defaultNotifyOptions = {};
resetDefaultNotifyOptions();
function setDefaultNotifyOptions(options) {
    (0, import_assign3.default)(defaultNotifyOptions, options);
}
function resetDefaultNotifyOptions() {
    (0, import_assign3.default)(defaultNotifyOptions, {
        selector: DEFAULT_NOTIFY_SELECTOR
    });
}
function parseNotifyOptions(message) {
    const options = !(0, import_react151.isValidElement)(message) && (0, import_isPlainObject7.default)(message) ? message : {
        message
    };
    return (0, import_assign3.default)({}, initialNotifyOptions, defaultNotifyOptions, options);
}
var notifyView = document$1.createElement("view");
function openNotify(args) {
    const _parseNotifyOptions = parseNotifyOptions(args), { selector = "#notify" } = _parseNotifyOptions, restOptions = _object_without_properties(_parseNotifyOptions, [
        "selector"
    ]);
    if (selector && notifySelectorSet.has(`${getPagePath()}__${selector}`)) {
        notifyEvents.trigger("open", _object_spread({
            selector
        }, restOptions));
    } else {
        const onTransitionExited = restOptions.onTransitionExited;
        restOptions.onTransitionExited = ()=>{
            onTransitionExited === null || onTransitionExited === void 0 ? void 0 : onTransitionExited();
            unmountPortal(notifyView);
        };
        mountPortal((0, import_react151.createElement)(notify_default, _object_spread_props(_object_spread({}, restOptions), {
            children: restOptions.message,
            defaultOpen: true,
            id: selector === DEFAULT_NOTIFY_SELECTOR ? DEFAULT_NOTIFY_SELECTOR_CREATE : selector
        })), notifyView);
    }
}
function closeNotify(selector) {
    notifyEvents.trigger("close", selector ? `#${selector}` : defaultNotifyOptions.selector);
}
// node_modules/@taroify/core/notify/index.js
var Notify2 = notify_default;
Notify2.open = openNotify;
Notify2.close = closeNotify;
Notify2.setDefaultOptions = setDefaultNotifyOptions;
Notify2.resetDefaultOptions = resetDefaultNotifyOptions;
var notify_default2 = Notify2;
// node_modules/@taroify/core/pull-refresh/pull-refresh.js
var import_classnames100 = __toESM(require_classnames());
var React128 = __toESM(require_react());
var import_react154 = __toESM(require_react());
// node_modules/@taroify/core/utils/lodash-polyfill.js
var import_debounce = __toESM(require_debounce());
var import_throttle = __toESM(require_throttle());
function isNodeOrWeb() {
    const freeGlobal = (typeof global === "undefined" ? "undefined" : typeof global) === "object" && global && global.Object === Object && global;
    const freeSelf = typeof self === "object" && self && self.Object === Object && self;
    return freeGlobal || freeSelf;
}
if (!isNodeOrWeb()) {
    global.Date = Date;
}
// node_modules/@taroify/core/pull-refresh/pull-refresh-children.js
var import_isFunction11 = __toESM(require_isFunction());
var React127 = __toESM(require_react());
var import_react153 = __toESM(require_react());
// node_modules/@taroify/core/pull-refresh/pull-refresh.context.js
var import_react152 = __toESM(require_react());
var PullRefreshContext = (0, import_react152.createContext)({
    distance: 0,
    onTouchStart: ()=>{},
    onTouchMove: ()=>{},
    onTouchEnd: ()=>{}
});
var pull_refresh_context_default = PullRefreshContext;
// node_modules/@taroify/core/pull-refresh/pull-refresh-children.js
function PullRefreshPulling(props) {
    const { children: children2 } = props;
    const { distance } = (0, import_react153.useContext)(pull_refresh_context_default);
    if ((0, import_isFunction11.default)(children2)) {
        return React127.createElement(React127.Fragment, null, children2 === null || children2 === void 0 ? void 0 : children2({
            distance
        }));
    }
    return React127.createElement(React127.Fragment, null, children2);
}
function PullRefreshLoosing(props) {
    const { children: children2 } = props;
    return React127.createElement(React127.Fragment, null, children2);
}
function PullRefreshLoading(props) {
    const { children: children2 } = props;
    return React127.createElement(React127.Fragment, null, children2);
}
function PullRefreshCompleted(props) {
    const { children: children2 } = props;
    return React127.createElement(React127.Fragment, null, children2);
}
// node_modules/@taroify/core/pull-refresh/pull-refresh.js
var PullRefreshStatus;
(function(PullRefreshStatus2) {
    PullRefreshStatus2["Awaiting"] = "awaiting";
    PullRefreshStatus2["Pulling"] = "pulling";
    PullRefreshStatus2["Loosing"] = "loosing";
    PullRefreshStatus2["Loading"] = "loading";
    PullRefreshStatus2["Completed"] = "completed";
})(PullRefreshStatus || (PullRefreshStatus = {}));
var TEXT_STATUS = [
    "pulling",
    "loosing",
    "success"
];
function usePullRefreshChildren(children2) {
    return (0, import_react154.useMemo)(()=>{
        const __children__ = {
            content: []
        };
        import_react154.Children.forEach(children2, (child)=>{
            if ((0, import_react154.isValidElement)(child)) {
                const element = child;
                const elementType = element.type;
                if (elementType === PullRefreshPulling) {
                    __children__.pulling = element;
                } else if (elementType === PullRefreshLoosing) {
                    __children__.loosing = element;
                } else if (elementType === PullRefreshLoading) {
                    __children__.loading = element;
                } else if (elementType === PullRefreshCompleted) {
                    __children__.completed = element;
                } else {
                    var __children___content;
                    (__children___content = __children__.content) === null || __children___content === void 0 ? void 0 : __children___content.push(child);
                }
            } else {
                var __children___content1;
                (__children___content1 = __children__.content) === null || __children___content1 === void 0 ? void 0 : __children___content1.push(child);
            }
        });
        return __children__;
    }, [
        children2
    ]);
}
function getCompletedProps(node) {
    if ((0, import_react154.isValidElement)(node)) {
        const element = node;
        return element.props;
    }
    return {};
}
function PullRefresh(props) {
    const { className, loading, disabled = false, headHeight = 50, reachTop: reachTopProp = true, pullDistance: pullDistanceProp, duration: durationProp = 300, children: childrenProp, onRefresh } = props, restProps = _object_without_properties(props, [
        "className",
        "loading",
        "disabled",
        "headHeight",
        "reachTop",
        "pullDistance",
        "duration",
        "children",
        "onRefresh"
    ]);
    const children2 = usePullRefreshChildren(childrenProp);
    const { completed: completedElement, content } = children2;
    const { duration: completedDuration = 500 } = getCompletedProps(completedElement);
    const statusRef = (0, import_react154.useRef)(PullRefreshStatus.Awaiting);
    const [distance, setDistance] = (0, import_react154.useState)(0);
    const reachTopPreviousRef = usePreviousRef(reachTopProp);
    const reachTopRef = useToRef(reachTopProp);
    const durationRef = (0, import_react154.useRef)(0);
    const touch = useTouch();
    function resetDuration() {
        durationRef.current = 0;
    }
    const isTouchable = (0, import_react154.useCallback)(()=>PullRefreshStatus.Loading !== statusRef.current && PullRefreshStatus.Completed !== statusRef.current && !disabled, [
        disabled
    ]);
    const easeDistance = (0, import_react154.useCallback)((distance2)=>{
        const pullDistance = +(pullDistanceProp || headHeight);
        let easedDistance = distance2;
        if (easedDistance > pullDistance) {
            if (easedDistance < pullDistance * 2) {
                easedDistance = pullDistance + (easedDistance - pullDistance) / 2;
            } else {
                easedDistance = pullDistance * 1.5 + (easedDistance - pullDistance * 2) / 4;
            }
        }
        return Math.round(easedDistance);
    }, [
        headHeight,
        pullDistanceProp
    ]);
    const checkPosition = (0, import_react154.useCallback)((event)=>{
        if (reachTopRef.current) {
            resetDuration();
            touch.start(event);
        }
    }, [
        reachTopRef,
        touch
    ]);
    const onTouchStart = (0, import_react154.useCallback)((event)=>{
        if (isTouchable()) {
            checkPosition(event);
        }
    }, [
        checkPosition,
        isTouchable
    ]);
    const updateStatus = (0, import_react154.useCallback)((distance2, isLoading)=>{
        const pullDistance = +(pullDistanceProp || headHeight);
        if (isLoading) {
            statusRef.current = PullRefreshStatus.Loading;
        } else if (distance2 === 0) {
            statusRef.current = PullRefreshStatus.Awaiting;
        } else if (distance2 < pullDistance) {
            statusRef.current = PullRefreshStatus.Pulling;
        } else {
            statusRef.current = PullRefreshStatus.Loosing;
        }
        setDistance(distance2);
    }, [
        headHeight,
        pullDistanceProp
    ]);
    const onTouchMove = (0, import_react154.useMemo)(()=>(0, import_throttle.default)((event)=>{
            if (isTouchable()) {
                if (!reachTopPreviousRef.current) {
                    checkPosition(event);
                }
                const { deltaY } = touch;
                touch.move(event);
                if (reachTopRef.current && deltaY >= 0 && touch.isVertical()) {
                    preventDefault(event);
                    updateStatus(easeDistance(deltaY));
                }
            }
        }, 16.7), [
        checkPosition,
        easeDistance,
        isTouchable,
        reachTopPreviousRef,
        reachTopRef,
        touch,
        updateStatus
    ]);
    const onTouchEnd = (0, import_react154.useCallback)(()=>{
        if (reachTopRef.current && isTouchable()) {
            durationRef.current = durationProp;
            if (statusRef.current === PullRefreshStatus.Loosing) {
                updateStatus(headHeight, true);
                onRefresh === null || onRefresh === void 0 ? void 0 : onRefresh();
            } else {
                updateStatus(0);
            }
        }
    }, [
        durationProp,
        headHeight,
        isTouchable,
        onRefresh,
        reachTopRef,
        updateStatus
    ]);
    const showCompleted = (0, import_react154.useCallback)(()=>{
        statusRef.current = PullRefreshStatus.Completed;
        resetDuration();
        setTimeout(()=>nextTick(()=>updateStatus(0)), +completedDuration);
    }, [
        completedDuration,
        updateStatus
    ]);
    const contextValue = (0, import_react154.useMemo)(()=>({
            distance,
            onTouchStart,
            onTouchMove,
            onTouchEnd
        }), [
        distance,
        onTouchStart,
        onTouchMove,
        onTouchEnd
    ]);
    (0, import_react154.useEffect)(()=>{
        if (loading) {
            updateStatus(headHeight, true);
        }
    }, [
        headHeight,
        loading,
        updateStatus
    ]);
    (0, import_react154.useEffect)(()=>{
        if (!loading && !isTouchable() && !completedElement) {
            durationRef.current = durationProp;
            updateStatus(0, false);
        }
    }, [
        completedElement,
        durationProp,
        isTouchable,
        loading,
        updateStatus
    ]);
    (0, import_react154.useEffect)(()=>{
        if (!loading && completedElement) {
            showCompleted();
        }
    }, [
        completedElement,
        loading,
        showCompleted
    ]);
    const getStatusText = (0, import_react154.useCallback)(()=>{
        if (statusRef.current === PullRefreshStatus.Pulling) {
            return "\u4E0B\u62C9\u5373\u53EF\u5237\u65B0...";
        }
        if (statusRef.current === PullRefreshStatus.Loosing) {
            return "\u91CA\u653E\u5373\u53EF\u5237\u65B0...";
        }
        if (statusRef.current === PullRefreshStatus.Loading) {
            return "\u52A0\u8F7D\u4E2D...";
        }
        return "";
    }, []);
    const renderStatus = (0, import_react154.useCallback)(()=>{
        const statusSlot = children2[statusRef.current];
        if (statusSlot) {
            return statusSlot;
        }
        const nodes = [];
        if (TEXT_STATUS.includes(statusRef.current)) {
            nodes.push(React128.createElement(View, {
                key: "text",
                className: prefixClassname("pull-refresh__text"),
                children: getStatusText()
            }));
        }
        if (statusRef.current === PullRefreshStatus.Loading) {
            nodes.push(React128.createElement(Loading, {
                key: "loading",
                className: prefixClassname("pull-refresh__loading"),
                children: getStatusText()
            }));
        }
        return nodes;
    }, [
        children2,
        getStatusText
    ]);
    const trackStyle = {
        transitionDuration: `${durationRef.current}ms`,
        transform: distance ? `translate3d(0,${addUnitPx(distance)}, 0)` : ""
    };
    const headStyle = (0, import_react154.useMemo)(()=>{
        if (headHeight !== 50) {
            return {
                height: addUnitPx(headHeight)
            };
        }
    }, [
        headHeight
    ]);
    return React128.createElement(pull_refresh_context_default.Provider, {
        value: contextValue
    }, React128.createElement(View, _object_spread({
        className: (0, import_classnames100.default)(prefixClassname("pull-refresh"), className)
    }, restProps), React128.createElement(View, {
        className: prefixClassname("pull-refresh__track"),
        style: trackStyle,
        onTouchStart,
        onTouchMove,
        onTouchEnd,
        onTouchCancel: onTouchEnd
    }, React128.createElement(View, {
        className: prefixClassname("pull-refresh__head"),
        style: headStyle,
        children: renderStatus()
    }), content)));
}
var pull_refresh_default = PullRefresh;
// node_modules/@taroify/core/pull-refresh/index.js
var PullRefresh2 = pull_refresh_default;
PullRefresh2.Pulling = PullRefreshPulling;
PullRefresh2.Loosing = PullRefreshLoosing;
PullRefresh2.Loading = PullRefreshLoading;
PullRefresh2.Completed = PullRefreshCompleted;
var pull_refresh_default2 = PullRefresh2;
// node_modules/@taroify/core/share-sheet/share-sheet.js
var import_classnames101 = __toESM(require_classnames());
var React129 = __toESM(require_react());
// node_modules/@taroify/core/share-sheet/share-sheet.context.js
var import_react155 = __toESM(require_react());
var ShareSheetContext = (0, import_react155.createContext)({});
var share_sheet_context_default = ShareSheetContext;
// node_modules/@taroify/core/share-sheet/share-sheet.js
function ShareSheet(props) {
    const { className, onSelect } = props, restProps = _object_without_properties(props, [
        "className",
        "onSelect"
    ]);
    return React129.createElement(share_sheet_context_default.Provider, {
        value: {
            onSelect
        }
    }, React129.createElement(sheet_default2, _object_spread({
        className: (0, import_classnames101.default)(prefixClassname("share-sheet"), className)
    }, restProps)));
}
var share_sheet_default = ShareSheet;
// node_modules/@taroify/core/share-sheet/share-sheet-option.js
var import_classnames102 = __toESM(require_classnames());
var import_isString9 = __toESM(require_isString());
var React130 = __toESM(require_react());
var import_react156 = __toESM(require_react());
var PRESET_ICONS = [
    "qq",
    "link",
    "weibo",
    "wechat",
    "poster",
    "qrcode",
    "weapp-qrcode",
    "wechat-moments"
];
function renderShareSheetOptionIcon(node) {
    if (!(0, import_react156.isValidElement)(node)) {
        if ((0, import_isString9.default)(node) && PRESET_ICONS.includes(node)) {
            return renderShareSheetOptionIcon(React130.createElement(Image3, {
                src: `https://img.yzcdn.cn/vant/share-sheet-${node}.png`
            }));
        }
        return node;
    }
    const element = node;
    if (element.type === Image3) {
        return (0, import_react156.cloneElement)(element, {
            className: (0, import_classnames102.default)(element.props.className, prefixClassname("share-sheet__option-icon"))
        });
    } else if (isIconElement(element)) {
        return cloneIconElement(element, {
            className: prefixClassname("share-sheet__option-icon")
        });
    }
    return node;
}
function useShareSheetOptionIcon(node) {
    return (0, import_react156.useMemo)(()=>renderShareSheetOptionIcon(node), [
        node
    ]);
}
function ShareSheetOption(props) {
    const { className, style, value, icon, name, description, onClick } = props, restProps = _object_without_properties(props, [
        "className",
        "style",
        "value",
        "icon",
        "name",
        "description",
        "onClick"
    ]);
    const { onSelect } = (0, import_react156.useContext)(share_sheet_context_default);
    const image = useShareSheetOptionIcon(icon);
    return React130.createElement(View, _object_spread({
        className: (0, import_classnames102.default)(prefixClassname("share-sheet__option"), className),
        style
    }, restProps), icon && image, name && React130.createElement(View, {
        className: prefixClassname("share-sheet__option-name"),
        children: name
    }), description && React130.createElement(View, {
        className: prefixClassname("share-sheet__option-description"),
        children: description
    }), React130.createElement(button_base_default, _object_spread({
        className: prefixClassname("share-sheet__button"),
        onClick: (event)=>{
            onClick === null || onClick === void 0 ? void 0 : onClick(event);
            onSelect === null || onSelect === void 0 ? void 0 : onSelect({
                value,
                icon,
                name,
                description
            });
        }
    }, restProps)));
}
var share_sheet_option_default = ShareSheetOption;
// node_modules/@taroify/core/share-sheet/share-sheet-options.js
var import_classnames103 = __toESM(require_classnames());
var React131 = __toESM(require_react());
function ShareSheetOptions(props) {
    const { className } = props, restProps = _object_without_properties(props, [
        "className"
    ]);
    return React131.createElement(View, _object_spread({
        className: (0, import_classnames103.default)(prefixClassname("share-sheet__options"), className)
    }, restProps));
}
// node_modules/@taroify/core/share-sheet/index.js
var ShareSheet2 = share_sheet_default;
ShareSheet2.Backdrop = sheet_default2.Backdrop;
ShareSheet2.Header = ShareSheetHeader;
ShareSheet2.Options = ShareSheetOptions;
ShareSheet2.Option = share_sheet_option_default;
ShareSheet2.Button = sheet_default2.Button;
var share_sheet_default2 = ShareSheet2;
// node_modules/@taroify/core/swipe-cell/swipe-cell.js
var import_classnames105 = __toESM(require_classnames());
var import_clamp7 = __toESM(require_clamp());
var React133 = __toESM(require_react());
var import_react158 = __toESM(require_react());
// node_modules/@taroify/core/swipe-cell/swipe-cell-actions.js
var import_classnames104 = __toESM(require_classnames());
var React132 = __toESM(require_react());
var import_react157 = __toESM(require_react());
var SwipeCellActions = (0, import_react157.forwardRef)((props, ref)=>{
    const { className, side } = props, restProps = _object_without_properties(props, [
        "className",
        "side"
    ]);
    return React132.createElement(View, _object_spread({
        ref,
        className: (0, import_classnames104.default)(prefixClassname("swipe-cell__actions"), {
            [prefixClassname("swipe-cell__left")]: side === "left",
            [prefixClassname("swipe-cell__right")]: side === "right"
        }, className)
    }, restProps));
});
var swipe_cell_actions_default = SwipeCellActions;
// node_modules/@taroify/core/swipe-cell/swipe-cell.js
function useSwipeCellChildren(children2, leftRef, rightRef, createClickHandler) {
    return (0, import_react158.useMemo)(()=>{
        const __children__ = {
            left: void 0,
            content: [],
            right: void 0
        };
        import_react158.Children.forEach(children2, (child)=>{
            if ((0, import_react158.isValidElement)(child)) {
                const element = child;
                const elementType = element.type;
                if (elementType === swipe_cell_actions_default) {
                    const { props } = element;
                    const { side, onClick } = props;
                    if (side === "left") {
                        __children__.left = (0, import_react158.cloneElement)(element, _object_spread_props(_object_spread({}, props), {
                            ref: leftRef,
                            onClick: (event)=>{
                                onClick === null || onClick === void 0 ? void 0 : onClick(event);
                                createClickHandler === null || createClickHandler === void 0 ? void 0 : createClickHandler("left", true)(event);
                            }
                        }));
                    } else if (side === "right") {
                        __children__.right = (0, import_react158.cloneElement)(element, _object_spread_props(_object_spread({}, props), {
                            ref: rightRef,
                            onClick: (event)=>{
                                onClick === null || onClick === void 0 ? void 0 : onClick(event);
                                createClickHandler === null || createClickHandler === void 0 ? void 0 : createClickHandler("right", true)(event);
                            }
                        }));
                    }
                } else {
                    var __children___content;
                    (__children___content = __children__.content) === null || __children___content === void 0 ? void 0 : __children___content.push(element);
                }
            } else {
                var __children___content1;
                (__children___content1 = __children__.content) === null || __children___content1 === void 0 ? void 0 : __children___content1.push(child);
            }
        });
        return __children__;
    }, [
        children2,
        createClickHandler,
        leftRef,
        rightRef
    ]);
}
function SwipeCell(props) {
    const { className, defaultOpen, open: openProp, disabled, stopPropagation: stopPropagation2, beforeClose: beforeCloseProp, onOpen, onClose, onClick: onClickProp, onTouchStart, onTouchMove, onTouchEnd, onTouchCancel, children: childrenProp, catchMove } = props, restProps = _object_without_properties(props, [
        "className",
        "defaultOpen",
        "open",
        "disabled",
        "stopPropagation",
        "beforeClose",
        "onOpen",
        "onClose",
        "onClick",
        "onTouchStart",
        "onTouchMove",
        "onTouchEnd",
        "onTouchCancel",
        "children",
        "catchMove"
    ]);
    const beforeClose = useFunctionInterceptor(beforeCloseProp);
    const { value } = useUncontrolled({
        defaultValue: defaultOpen,
        value: openProp
    });
    const openedRef = (0, import_react158.useRef)(false);
    const lockClickRef = (0, import_react158.useRef)(false);
    const startOffsetRef = (0, import_react158.useRef)(0);
    const rootRef = (0, import_react158.useRef)();
    const leftRef = (0, import_react158.useRef)();
    const rightRef = (0, import_react158.useRef)();
    const leftWidthRef = (0, import_react158.useRef)(0);
    const rightWidthRef = (0, import_react158.useRef)(0);
    const positionRef = (0, import_react158.useRef)("outside");
    const draggingRef = (0, import_react158.useRef)(false);
    const [offset, setOffset] = (0, import_react158.useState)(0);
    const touch = useTouch();
    const updateLeftWidth = ()=>getRect(leftRef).then(({ width })=>width !== null && width !== void 0 ? width : 0).then((leftWidth)=>leftWidthRef.current = leftWidth);
    const updateRightWidth = ()=>getRect(rightRef).then(({ width })=>width !== null && width !== void 0 ? width : 0).then((rightWidth)=>rightWidthRef.current = rightWidth);
    const open = (0, import_react158.useCallback)((side, emitOpen = true)=>{
        openedRef.current = true;
        setOffset(side === "left" ? leftWidthRef.current : -rightWidthRef.current);
        if (emitOpen) {
            onOpen === null || onOpen === void 0 ? void 0 : onOpen(side);
        }
    }, [
        onOpen
    ]);
    const close = (0, import_react158.useCallback)((position, emitClose = true)=>{
        openedRef.current = false;
        setOffset(0);
        if (emitClose) {
            onClose === null || onClose === void 0 ? void 0 : onClose(position);
        }
    }, [
        onClose
    ]);
    const toggle = (0, import_react158.useCallback)((side)=>{
        const THRESHOLD = 0.15;
        const threshold = openedRef.current ? 1 - THRESHOLD : THRESHOLD;
        const width = side === "left" ? leftWidthRef.current : rightWidthRef.current;
        const offsetAbs = Math.abs(offset);
        if (width && offsetAbs > width * threshold) {
            open(side);
        } else {
            close(side);
        }
    }, [
        close,
        offset,
        open
    ]);
    const handleTouchStart = (event)=>{
        if (disabled) {
            return;
        }
        fulfillPromise(Promise.all([
            updateLeftWidth(),
            updateRightWidth()
        ]));
        startOffsetRef.current = offset;
        touch.start(event);
    };
    const handleTouchMove = (0, import_react158.useCallback)(function() {
        var _ref = _async_to_generator(function*(event) {
            if (disabled) {
                return;
            }
            const { deltaX } = touch;
            touch.move(event);
            if (touch.isHorizontal()) {
                const offset2 = (0, import_clamp7.default)(deltaX + startOffsetRef.current, -rightWidthRef.current, leftWidthRef.current);
                if (!draggingRef.current) {
                    draggingRef.current = true;
                }
                lockClickRef.current = true;
                const isEdge = !openedRef.current || deltaX * startOffsetRef.current < 0;
                if (isEdge) {
                    preventDefault(event, stopPropagation2);
                }
                positionRef.current = offset2 > 0 ? "left" : "right";
                setOffset(offset2);
            }
        });
        return function(event) {
            return _ref.apply(this, arguments);
        };
    }(), [
        disabled,
        stopPropagation2,
        touch
    ]);
    const handleTouchEnd = ()=>{
        if (disabled) {
            return;
        }
        draggingRef.current = false;
        toggle(positionRef.current);
        setTimeout(()=>{
            lockClickRef.current = false;
        }, 0);
    };
    const onClick = (0, import_react158.useCallback)((position = "outside")=>{
        if (openedRef.current && !lockClickRef.current) {
            beforeClose(position).then(()=>close(position));
        }
    }, [
        beforeClose,
        close
    ]);
    const createClickHandler = (0, import_react158.useCallback)((position, stop)=>(event)=>{
            if (stop) {
                event.stopPropagation();
            }
            onClick(position);
        }, [
        onClick
    ]);
    const { left, content, right } = useSwipeCellChildren(childrenProp, leftRef, rightRef, createClickHandler);
    const valueChange = (side)=>{
        if (side === "left" || side === "right") {
            new Promise((resolve)=>{
                if (inBrowser) {
                    setTimeout(()=>{
                        if (side === "left") {
                            updateLeftWidth().then(resolve);
                        } else {
                            updateRightWidth().then(resolve);
                        }
                    }, 150);
                } else {
                    resolve(true);
                }
            }).then(()=>{
                draggingRef.current = false;
                open(side, false);
            });
        } else {
            close("outside", false);
        }
    };
    use_rendered_effect_default(()=>{
        if (!inBrowser) {
            fulfillPromise(updateLeftWidth());
        }
    }, [
        left
    ]);
    use_rendered_effect_default(()=>{
        if (!inBrowser) {
            fulfillPromise(updateRightWidth());
        }
    }, [
        right
    ]);
    use_rendered_effect_default(()=>valueChange(value), [
        value
    ]);
    return React133.createElement(View, _object_spread({
        catchMove,
        ref: rootRef,
        className: (0, import_classnames105.default)(prefixClassname("swipe-cell"), className),
        onTouchStart: (event)=>{
            onTouchStart === null || onTouchStart === void 0 ? void 0 : onTouchStart(event);
            handleTouchStart(event);
        },
        onTouchMove: (event)=>{
            onTouchMove === null || onTouchMove === void 0 ? void 0 : onTouchMove(event);
            handleTouchMove === null || handleTouchMove === void 0 ? void 0 : handleTouchMove(event);
        },
        onTouchEnd: (event)=>{
            onTouchEnd === null || onTouchEnd === void 0 ? void 0 : onTouchEnd(event);
            handleTouchEnd();
        },
        onTouchCancel: (event)=>{
            onTouchCancel === null || onTouchCancel === void 0 ? void 0 : onTouchCancel(event);
            handleTouchEnd();
        },
        onClick: (event)=>{
            onClickProp === null || onClickProp === void 0 ? void 0 : onClickProp(event);
            createClickHandler("cell")(event);
        }
    }, restProps), React133.createElement(View, {
        className: prefixClassname("swipe-cell__wrapper"),
        style: _object_spread({
            transform: `translate3d(${addUnitPx(offset)}, 0, 0)`
        }, inBrowser ? {
            transitionDuration: draggingRef.current ? "0s" : ".3s"
        } : {})
    }, left, content, right));
}
var swipe_cell_default = SwipeCell;
// node_modules/@taroify/core/swipe-cell/index.js
var SwipeCell2 = swipe_cell_default;
SwipeCell2.Actions = swipe_cell_actions_default;
var swipe_cell_default2 = SwipeCell2;
// node_modules/@taroify/core/floating-panel/floating-panel.js
var React134 = __toESM(require_react());
var import_react159 = __toESM(require_react());
var import_classnames106 = __toESM(require_classnames());
// node_modules/@taroify/core/utils/closest.js
var closest = (arr, target)=>arr.reduce((pre, cur)=>Math.abs(pre - target) < Math.abs(cur - target) ? pre : cur);
// node_modules/@taroify/core/floating-panel/floating-panel.js
var DAMP = 0.2;
var FloatingPanel = (0, import_react159.forwardRef)((props, ref)=>{
    const { className, style: styleProp, anchors: anchorsProp = [], height: heightProp = 0, duration = 0.3, contentDraggable = true, safeAreaInsetBottom = true, children: children2, handleChange } = props;
    const contentRef = (0, import_react159.useRef)();
    const headerRef = (0, import_react159.useRef)();
    const startY = (0, import_react159.useRef)(0);
    const [height, setHeight] = (0, import_react159.useState)(heightProp);
    const [dragging, setDragging] = (0, import_react159.useState)(false);
    const [scrollContentTop, setScrollContentTop] = (0, import_react159.useState)(0);
    const touch = useTouch();
    const windowHeight = (0, import_react159.useMemo)(()=>getWindowInfo().windowHeight, []);
    (0, import_react159.useImperativeHandle)(ref, ()=>({
            setHeight
        }));
    const ease = (moveY)=>{
        const absDistance = Math.abs(moveY);
        const { min, max } = boundary;
        if (absDistance > max) {
            return -(max + (absDistance - max) * DAMP);
        }
        if (absDistance < min) {
            return -(min - (min - absDistance) * DAMP);
        }
        return moveY;
    };
    const boundary = (0, import_react159.useMemo)(()=>{
        var _anchorsProp_, _anchorsProp_1;
        return {
            min: (_anchorsProp_ = anchorsProp[0]) !== null && _anchorsProp_ !== void 0 ? _anchorsProp_ : 100,
            max: (_anchorsProp_1 = anchorsProp[anchorsProp.length - 1]) !== null && _anchorsProp_1 !== void 0 ? _anchorsProp_1 : Math.round(windowHeight * 0.6)
        };
    }, [
        anchorsProp,
        windowHeight
    ]);
    const anchors = (0, import_react159.useMemo)(()=>anchorsProp.length >= 2 ? anchorsProp : [
            boundary.min,
            boundary.max
        ], [
        anchorsProp,
        boundary.min,
        boundary.max
    ]);
    (0, import_react159.useEffect)(()=>{
        setHeight(closest(anchors, height));
    }, [
        boundary.max,
        boundary.min
    ]);
    const rootStyle = (0, import_react159.useMemo)(()=>({
            height: addUnitPx(boundary.max),
            transform: `translateY(calc(100% + ${addUnitPx(-height)}))`,
            transition: !dragging ? `transform ${duration}s cubic-bezier(0.18, 0.89, 0.32, 1.28)` : "none"
        }), [
        boundary.max,
        height,
        dragging,
        duration
    ]);
    const onTouchStart = (event)=>{
        touch.start(event);
        setDragging(true);
        startY.current = -height;
    };
    const onTouchMove = function() {
        var _ref = _async_to_generator(function*(event) {
            touch.move(event);
            const target = event.target;
            let isHeader = false;
            if (getEnv() === "WEB") {
                isHeader = target.dataset.id === "floating-panel__header";
            } else {
                isHeader = target.dataset.id === "floating-panel__header";
            }
            if (!isHeader) {
                if (!contentDraggable) return;
                let scrollTop = 0;
                if (getEnv() === "WEB") {
                    scrollTop = contentRef.current.scrollTop;
                } else {
                    scrollTop = scrollContentTop;
                }
                if (-startY.current < boundary.max) {
                    preventDefault(event, true);
                } else if (!(scrollTop <= 0 && touch.deltaY > 0)) {
                    return;
                }
            }
            const moveY = touch.deltaY + startY.current;
            setHeight(-ease(moveY));
        });
        return function onTouchMove(event) {
            return _ref.apply(this, arguments);
        };
    }();
    const onTouchEnd = ()=>{
        setDragging(false);
        setHeight(closest(anchors, height));
        if (height !== -startY.current) {
            handleChange === null || handleChange === void 0 ? void 0 : handleChange(height);
        }
    };
    const onContentScroll = (e)=>{
        setScrollContentTop(e.detail.scrollTop);
    };
    return React134.createElement(View, {
        ref,
        className: (0, import_classnames106.default)(prefixClassname("floating-panel"), className),
        style: _object_spread({}, rootStyle, styleProp),
        onTouchStart,
        onTouchMove,
        onTouchEnd,
        onTouchCancel: onTouchEnd
    }, React134.createElement(View, {
        className: (0, import_classnames106.default)(prefixClassname("floating-panel__header")),
        ref: headerRef,
        "data-id": "floating-panel__header"
    }, React134.createElement(View, {
        className: (0, import_classnames106.default)(prefixClassname("floating-panel__header-bar"))
    })), getEnv() === "WEB" ? React134.createElement(View, {
        className: (0, import_classnames106.default)(prefixClassname("floating-panel__content")),
        ref: contentRef
    }, children2, safeAreaInsetBottom && React134.createElement(safe_area_default, {
        position: "bottom"
    })) : React134.createElement(ScrollView, {
        scrollY: true,
        className: (0, import_classnames106.default)(prefixClassname("floating-panel__content")),
        ref: contentRef,
        onScroll: onContentScroll
    }, children2, safeAreaInsetBottom && React134.createElement(safe_area_default, {
        position: "bottom"
    })));
});
var floating_panel_default = FloatingPanel;
// node_modules/@taroify/core/floating-panel/index.js
var FloatingPanel2 = floating_panel_default;
var floating_panel_default2 = FloatingPanel2;
// node_modules/@taroify/core/floating-bubble/floating-bubble.js
var React135 = __toESM(require_react());
var import_react160 = __toESM(require_react());
var import_classnames107 = __toESM(require_classnames());
var FloatingBubble = (props)=>{
    const { className, style: styleProp, icon, gap = 24, axis = "y", magnetic, offset = {
        x: -1,
        y: -1
    }, onClick: onClickProp, onOffsetChange } = props;
    const touch = useTouch();
    const contentRef = (0, import_react160.useRef)();
    const [stateVal, setStateVal] = (0, import_react160.useState)({
        x: 0,
        y: 0,
        width: 0,
        height: 0
    });
    const [dragging, setDragging] = (0, import_react160.useState)(false);
    const initialized = (0, import_react160.useRef)(false);
    const prevX = (0, import_react160.useRef)(0);
    const prevY = (0, import_react160.useRef)(0);
    const windowHeight = (0, import_react160.useMemo)(()=>getWindowInfo().windowHeight, []);
    const windowWidth = (0, import_react160.useMemo)(()=>getWindowInfo().windowWidth, []);
    const boundary = (0, import_react160.useMemo)(()=>{
        return {
            top: gap,
            right: windowWidth - stateVal.width - gap,
            bottom: windowHeight - stateVal.height - gap,
            left: gap
        };
    }, [
        gap,
        stateVal.height,
        stateVal.width,
        windowHeight,
        windowWidth
    ]);
    const rootStyle = (0, import_react160.useMemo)(()=>{
        const style = {};
        const x = addUnitPx(stateVal.x);
        const y = addUnitPx(stateVal.y);
        style.transform = `translate3d(${x}, ${y}, 0)`;
        if (dragging || !initialized) {
            style.transition = "none";
        }
        return style;
    }, [
        dragging,
        stateVal.x,
        stateVal.y
    ]);
    const updateState = function() {
        var _ref = _async_to_generator(function*() {
            const { width, height } = yield getRect(contentRef.current);
            setStateVal({
                x: offset.x > -1 ? offset.x : windowWidth - width - gap,
                y: offset.y > -1 ? offset.y : windowHeight - height - gap,
                width,
                height
            });
        });
        return function updateState() {
            return _ref.apply(this, arguments);
        };
    }();
    const onTouchStart = (event)=>{
        touch.start(event);
        setDragging(true);
        prevX.current = stateVal.x;
        prevY.current = stateVal.y;
    };
    const onTouchMove = (event)=>{
        preventDefault(event, true);
        touch.move(event);
        if (axis === "lock") return;
        if (!touch.isTap) {
            if (axis === "x") {
                let nextX = prevX.current + touch.deltaX;
                if (nextX < boundary.left) nextX = boundary.left;
                if (nextX > boundary.right) nextX = boundary.right;
                setStateVal(_object_spread_props(_object_spread({}, stateVal), {
                    x: nextX
                }));
            }
            if (axis === "y") {
                let nextY = prevY.current + touch.deltaY;
                if (nextY < boundary.top) nextY = boundary.top;
                if (nextY > boundary.bottom) nextY = boundary.bottom;
                setStateVal(_object_spread_props(_object_spread({}, stateVal), {
                    y: nextY
                }));
            }
            if (axis === "xy") {
                let nextX = prevX.current + touch.deltaX;
                if (nextX < boundary.left) nextX = boundary.left;
                if (nextX > boundary.right) nextX = boundary.right;
                let nextY = prevY.current + touch.deltaY;
                if (nextY < boundary.top) nextY = boundary.top;
                if (nextY > boundary.bottom) nextY = boundary.bottom;
                setStateVal(_object_spread_props(_object_spread({}, stateVal), {
                    x: nextX,
                    y: nextY
                }));
            }
        }
    };
    const onTouchEnd = ()=>{
        setDragging(false);
        nextTick(()=>{
            if (magnetic === "x") {
                const nextX = closest([
                    boundary.left,
                    boundary.right
                ], stateVal.x);
                setStateVal(_object_spread_props(_object_spread({}, stateVal), {
                    x: nextX
                }));
            }
            if (magnetic === "y") {
                const nextY = closest([
                    boundary.top,
                    boundary.bottom
                ], stateVal.y);
                setStateVal(_object_spread_props(_object_spread({}, stateVal), {
                    y: nextY
                }));
            }
            if (!touch.isTap) {
                if (prevX.current !== stateVal.x || prevY.current !== stateVal.y) {
                    onOffsetChange === null || onOffsetChange === void 0 ? void 0 : onOffsetChange(stateVal.x, stateVal.y);
                }
            }
        });
    };
    const onClick = (event)=>{
        if (touch.isTap) onClickProp === null || onClickProp === void 0 ? void 0 : onClickProp(event);
        else preventDefault(event, true);
    };
    (0, import_react160.useEffect)(()=>{
        updateState();
        nextTick(()=>{
            initialized.current = true;
        });
    }, []);
    (0, import_react160.useEffect)(()=>{
        updateState();
    }, [
        windowWidth,
        windowHeight,
        gap,
        offset.y,
        offset.x
    ]);
    return React135.createElement(View, {
        className: (0, import_classnames107.default)(prefixClassname("floating-bubble"), className),
        ref: contentRef,
        style: _object_spread({}, rootStyle, styleProp),
        onTouchStart,
        onTouchMove,
        onTouchEnd,
        onTouchCancel: onTouchEnd,
        onClick
    }, icon && isIconElement(icon) ? cloneIconElement(icon, {
        className: prefixClassname("floating-bubble__icon")
    }) : icon);
};
var floating_bubble_default = FloatingBubble;
// node_modules/@taroify/core/avatar/avatar.js
var import_classnames108 = __toESM(require_classnames());
var React136 = __toESM(require_react());
function Avatar(props) {
    const { className, src, alt, shape = "circle", size = "medium", children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "src",
        "alt",
        "shape",
        "size",
        "children"
    ]);
    return React136.createElement(View, _object_spread({
        className: (0, import_classnames108.default)(prefixClassname("avatar"), {
            [prefixClassname("avatar--circle")]: shape === "circle",
            [prefixClassname("avatar--square")]: shape === "square",
            [prefixClassname("avatar--rounded")]: shape === "rounded"
        }, {
            [prefixClassname("avatar--mini")]: size === "mini",
            [prefixClassname("avatar--small")]: size === "small",
            [prefixClassname("avatar--medium")]: size === "medium",
            [prefixClassname("avatar--large")]: size === "large"
        }, className)
    }, restProps), src ? React136.createElement(Image3, {
        alt,
        shape,
        src,
        className: (0, import_classnames108.default)({
            [prefixClassname("avatar__image--mini")]: size === "mini",
            [prefixClassname("avatar__image--small")]: size === "small",
            [prefixClassname("avatar__image--medium")]: size === "medium",
            [prefixClassname("avatar__image--large")]: size === "large"
        })
    }) : children2);
}
var avatar_default = Avatar;
// node_modules/@taroify/core/avatar/avatar-group.js
var import_classnames109 = __toESM(require_classnames());
var import_size14 = __toESM(require_size());
var import_get10 = __toESM(require_get());
var React137 = __toESM(require_react());
var import_react161 = __toESM(require_react());
var useAvatars = (children2, shape, limit)=>{
    return (0, import_react161.useMemo)(()=>{
        const avatars = import_react161.Children.toArray(children2).filter((child)=>(0, import_react161.isValidElement)(child) && isElementOf(child, avatar_default));
        const avatarsSize = (0, import_size14.default)(avatars);
        const luckyAvatars = [];
        const length = Math.min(avatarsSize, limit);
        const size = avatars[length] ? avatars[length].props.size || "medium" : "medium";
        for(let index = 0; index < length; index++){
            const child = (0, import_get10.default)(avatars, index);
            const element = child;
            const { key, props } = element;
            const { style, children: children3 } = props, restProps = _object_without_properties(props, [
                "style",
                "children"
            ]);
            luckyAvatars.push((0, import_react161.cloneElement)(element, _object_spread({
                key: key !== null && key !== void 0 ? key : index,
                shape,
                style: _object_spread_props(_object_spread({}, style), {
                    zIndex: index
                })
            }, restProps), children3));
        }
        return [
            luckyAvatars,
            avatarsSize,
            size
        ];
    }, [
        children2,
        limit,
        shape
    ]);
};
function AvatarGroup(props) {
    const { className, shape = "circle", limit = Number.MAX_VALUE, spacing = "small", total, children: children2 } = props;
    const [avatars, avatarsSize, size] = useAvatars(children2, shape, limit);
    return React137.createElement(View, {
        className: (0, import_classnames109.default)(prefixClassname("avatar-group"), {
            [prefixClassname("avatar-group--spacing-mini")]: spacing === "mini",
            [prefixClassname("avatar-group--spacing-small")]: spacing === "small",
            [prefixClassname("avatar-group--spacing-medium")]: spacing === "medium",
            [prefixClassname("avatar-group--spacing-large")]: spacing === "large"
        }, className)
    }, avatars, avatarsSize >= limit && React137.createElement(avatar_default, {
        shape,
        size,
        style: {
            zIndex: avatarsSize
        }
    }, "+", total ? total - limit : avatarsSize - limit));
}
// node_modules/@taroify/core/avatar/index.js
var Avatar2 = avatar_default;
Avatar2.Group = AvatarGroup;
var avatar_default2 = Avatar2;
// node_modules/@taroify/core/circle/circle.js
var React139 = __toESM(require_react());
// node_modules/@taroify/core/circle/circle-canvas.js
var import_clamp8 = __toESM(require_clamp());
var import_isObject5 = __toESM(require_isObject());
var React138 = __toESM(require_react());
var import_react163 = __toESM(require_react());
// node_modules/@taroify/core/styles/variables.js
var BLUE = "#1989fa";
var WHITE = "#fff";
// node_modules/@taroify/core/circle/circle.hooks.js
var import_isNaN = __toESM(require_isNaN());
var import_react162 = __toESM(require_react());
function useAnimatePercent(percentProp, speed) {
    const [percent, setPercent] = (0, import_react162.useState)(percentProp);
    const currentRateRef = useToRef(percent);
    (0, import_react162.useEffect)(()=>{
        let rafId;
        const startTime = Date.now();
        const startRate = currentRateRef.current;
        const endRate = percentProp;
        const duration = Math.abs((startRate - endRate) * 1e3 / speed);
        const animate = ()=>{
            const now = Date.now();
            let progress = (now - startTime) / duration;
            progress = Math.min((0, import_isNaN.default)(progress) ? 1 : progress, 1);
            const rate = progress * (endRate - startRate) + startRate;
            setPercent(rate);
            if (endRate > startRate ? rate < endRate : rate > endRate) {
                rafId = raf(animate);
            }
        };
        if (speed) {
            if (rafId) {
                cancelRaf(rafId);
            }
            rafId = raf(animate);
        } else {
            setPercent(endRate);
        }
    }, [
        currentRateRef,
        speed,
        percentProp
    ]);
    return percent;
}
// node_modules/@taroify/core/circle/circle-canvas.js
function clampFormat(rate) {
    return (0, import_clamp8.default)(rate, 0, 100);
}
var PERIMETER = 2 * Math.PI;
var BEGIN_ANGLE_MAP = {
    top: 1.5 * Math.PI,
    right: 0,
    bottom: 0.5 * Math.PI,
    left: Math.PI
};
function CircleCanvas(props) {
    const { percent: percentProp = 0, speed = 100, color = BLUE, layerColor = WHITE, fill, clockwise = true, strokeWidth: strokeWidthProp = 40, strokeLinecap = "round", size = 100, startPosition = "top", onChange } = props;
    const canvasId = use_unique_id_default();
    const canvasRef = (0, import_react163.useRef)();
    const [__, canvasContext] = use_canvas_default(canvasId, canvasRef);
    const strokeWidth = (0, import_react163.useMemo)(()=>strokeWidthProp / 10, [
        strokeWidthProp
    ]);
    const percent = useAnimatePercent(percentProp, speed);
    const hoverColor = (0, import_react163.useMemo)(()=>{
        if ((0, import_isObject5.default)(color) && canvasContext) {
            const LinearColor = canvasContext.createLinearGradient(size, 0, 0, 0);
            if (LinearColor) {
                Object.keys(color).sort((a, b)=>Number.parseFloat(a) - Number.parseFloat(b)).forEach((key)=>LinearColor.addColorStop(Number.parseFloat(key) / 100, color[key]));
                return LinearColor;
            }
        } else {
            return color;
        }
    }, [
        canvasContext,
        color,
        size
    ]);
    (0, import_react163.useEffect)(()=>{
        if (canvasContext) {
            canvasContext.clearRect(0, 0, size, size);
            const position = size / 2;
            const radius = position - strokeWidth / 2;
            canvasContext.lineWidth = strokeWidth;
            canvasContext.lineCap = strokeLinecap;
            canvasContext.strokeStyle = layerColor;
            canvasContext.beginPath();
            canvasContext.arc(position, position, radius, 0, PERIMETER, !clockwise);
            canvasContext.stroke();
            const formatValue = clampFormat(percent);
            if (formatValue !== 0) {
                const progressAngle = PERIMETER * (formatValue / 100);
                const beginAngle = BEGIN_ANGLE_MAP[startPosition];
                const endAngle = clockwise ? beginAngle + progressAngle : beginAngle - progressAngle + 2 * Math.PI;
                canvasContext.strokeStyle = hoverColor;
                canvasContext.beginPath();
                canvasContext.arc(position, position, radius, beginAngle, beginAngle === endAngle ? endAngle + 1e-4 : endAngle, !clockwise);
                canvasContext.stroke();
            }
            if (fill) {
                canvasContext.fillStyle = fill;
                canvasContext.fill();
            }
        }
    }, [
        canvasContext,
        clockwise,
        fill,
        hoverColor,
        layerColor,
        percent,
        size,
        startPosition,
        strokeLinecap,
        strokeWidth
    ]);
    (0, import_react163.useEffect)(()=>onChange === null || onChange === void 0 ? void 0 : onChange(percent), [
        percent
    ]);
    return React138.createElement(Canvas, {
        ref: canvasRef,
        id: canvasId,
        canvasId,
        type: "2d",
        style: {
            width: addUnitPx(size),
            height: addUnitPx(size)
        }
    });
}
var circle_canvas_default = CircleCanvas;
// node_modules/@taroify/core/circle/circle.js
function Circle2(_param) {
    var { size = 100, children: children2 } = _param, props = _object_without_properties(_param, [
        "size",
        "children"
    ]);
    return React139.createElement(View, {
        className: prefixClassname("circle"),
        style: {
            width: addUnitPx(size),
            height: addUnitPx(size)
        }
    }, React139.createElement(circle_canvas_default, _object_spread({
        size
    }, props)), children2 && React139.createElement(View, {
        className: prefixClassname("circle__text"),
        children: children2
    }));
}
var circle_default = Circle2;
// node_modules/@taroify/core/collapse/collapse.js
var import_classnames111 = __toESM(require_classnames());
var import_size15 = __toESM(require_size());
var React141 = __toESM(require_react());
var import_react166 = __toESM(require_react());
// node_modules/@taroify/core/collapse/collapse-item.js
var import_classnames110 = __toESM(require_classnames());
var React140 = __toESM(require_react());
var import_react165 = __toESM(require_react());
// node_modules/@taroify/core/collapse/collapse.context.js
var import_react164 = __toESM(require_react());
var CollapseContext = (0, import_react164.createContext)({});
var collapse_context_default = CollapseContext;
// node_modules/@taroify/core/collapse/collapse-item.js
function CollapseItem(props) {
    const { className, value, size = "medium", bordered = true, disabled = false, clickable = true, icon, expandIcon = React140.createElement(ArrowRight_default, null), title, brief, extra, children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "value",
        "size",
        "bordered",
        "disabled",
        "clickable",
        "icon",
        "expandIcon",
        "title",
        "brief",
        "extra",
        "children"
    ]);
    const contentRef = (0, import_react165.useRef)();
    const { isExpanded, toggleItem } = (0, import_react165.useContext)(collapse_context_default);
    const expanded = isExpanded === null || isExpanded === void 0 ? void 0 : isExpanded(value);
    const [visibility, setVisibility] = (0, import_react165.useState)(expanded);
    const [expandHeight, setExpandHeight] = (0, import_react165.useState)("0");
    const onTransitionEnd = (0, import_react165.useCallback)(()=>{
        if (!expanded) {
            setVisibility(false);
        } else {
            setExpandHeight("");
        }
    }, [
        expanded
    ]);
    (0, import_react165.useEffect)(()=>{
        if (expanded) {
            setVisibility(true);
        }
        const tickRaf = expanded ? nextTick : raf;
        tickRaf(/*#__PURE__*/ _async_to_generator(function*() {
            const { height } = yield getRect(contentRef);
            if (height) {
                const heightPx = addUnitPx(height);
                setExpandHeight(expanded ? "0" : heightPx);
                doubleRaf(()=>{
                    setExpandHeight(expanded ? heightPx : "0");
                });
            } else {
                onTransitionEnd();
            }
        }));
    }, [
        expanded,
        onTransitionEnd
    ]);
    const toggle = (0, import_react165.useCallback)((newExpanded = !expanded)=>{
        toggleItem === null || toggleItem === void 0 ? void 0 : toggleItem(value, newExpanded);
    }, [
        value,
        expanded,
        toggleItem
    ]);
    const onTitleClick = (0, import_react165.useCallback)(()=>{
        if (!disabled) {
            toggle();
        }
    }, [
        disabled,
        toggle
    ]);
    const wrapperStyle = (0, import_react165.useMemo)(()=>({
            display: visibility ? "" : "none",
            height: expandHeight
        }), [
        expandHeight,
        visibility
    ]);
    return React140.createElement(View, _object_spread({
        className: (0, import_classnames110.default)(prefixClassname("collapse-item"), {
            [prefixClassname("collapse-item--bordered")]: value && bordered
        }, className)
    }, restProps), React140.createElement(cell_default2, {
        className: (0, import_classnames110.default)(prefixClassname("collapse-item__title"), {
            [prefixClassname("collapse-item__title--disabled")]: disabled,
            [prefixClassname("collapse-item__title--expanded")]: expanded,
            [prefixClassname("collapse-item__title--borderless")]: !bordered
        }),
        size,
        icon,
        rightIcon: expandIcon,
        title,
        clickable: !disabled && clickable,
        brief,
        children: extra,
        onClick: onTitleClick
    }), React140.createElement(View, {
        className: prefixClassname("collapse-item__wrapper"),
        style: wrapperStyle,
        onTransitionEnd
    }, React140.createElement(View, {
        ref: contentRef,
        className: prefixClassname("collapse-item__content"),
        children: children2
    })));
}
var collapse_item_default = CollapseItem;
// node_modules/@taroify/core/collapse/collapse.js
function validateActiveValue(value, accordion) {
    if (accordion && Array.isArray(value)) {
        console.error('[Taroify] Collapse: "value" should not be Array in accordion mode');
        return false;
    }
    if (!accordion && !Array.isArray(value)) {
        console.error('[Taroify] Collapse: "value" should be Array in non-accordion mode');
        return false;
    }
    return true;
}
function useCollapseChildren(children2) {
    const __children__ = {
        items: []
    };
    import_react166.Children.forEach(children2, (child)=>{
        if ((0, import_react166.isValidElement)(child)) {
            const element = child;
            const elementType = element.type;
            if (elementType === collapse_item_default) {
                var __children___items;
                const { key, props } = element;
                const index = (0, import_size15.default)(__children__.items);
                const { value } = props;
                (__children___items = __children__.items) === null || __children___items === void 0 ? void 0 : __children___items.push((0, import_react166.cloneElement)(element, {
                    key: key !== null && key !== void 0 ? key : index,
                    value: value !== null && value !== void 0 ? value : index
                }));
            } else {
                var __children___items1;
                (__children___items1 = __children__.items) === null || __children___items1 === void 0 ? void 0 : __children___items1.push(element);
            }
        } else {
            var __children___items2;
            (__children___items2 = __children__.items) === null || __children___items2 === void 0 ? void 0 : __children___items2.push(child);
        }
    });
    return __children__;
}
function Collapse(props) {
    const { className, bordered, defaultValue, value: valueProp, accordion = false, onChange: onChangeProp, children: childrenProp } = props, restProps = _object_without_properties(props, [
        "className",
        "bordered",
        "defaultValue",
        "value",
        "accordion",
        "onChange",
        "children"
    ]);
    const { value, setValue } = useUncontrolled({
        value: valueProp,
        defaultValue,
        onChange: onChangeProp
    });
    const { items } = useCollapseChildren(childrenProp);
    const toggleItem = (0, import_react166.useCallback)((itemValue, expanded)=>{
        if (accordion) {
            setValue(itemValue === value ? "" : itemValue);
        } else if (expanded) {
            setValue(value.concat(itemValue));
        } else {
            setValue(value.filter((activeKey)=>activeKey !== itemValue));
        }
    }, [
        accordion,
        setValue,
        value
    ]);
    const isExpanded = (0, import_react166.useCallback)((itemValue)=>{
        if (!validateActiveValue(value, accordion)) {
            return false;
        }
        return accordion ? value === itemValue : value.includes(itemValue);
    }, [
        accordion,
        value
    ]);
    return React141.createElement(collapse_context_default.Provider, {
        value: {
            isExpanded,
            toggleItem
        }
    }, React141.createElement(View, _object_spread({
        className: (0, import_classnames111.default)(prefixClassname("collapse"), {
            [HAIRLINE_BORDER_TOP_BOTTOM]: bordered
        }, className),
        children: items
    }, restProps)));
}
var collapse_default = Collapse;
// node_modules/@taroify/core/collapse/index.js
var Collapse2 = collapse_default;
Collapse2.Item = collapse_item_default;
var collapse_default2 = Collapse2;
// node_modules/@taroify/core/countdown/countdown.js
var import_classnames112 = __toESM(require_classnames());
var import_isFunction12 = __toESM(require_isFunction());
var React142 = __toESM(require_react());
var import_react168 = __toESM(require_react());
// node_modules/@taroify/core/countdown/countdown.shared.js
var import_replace = __toESM(require_replace());
var import_get11 = __toESM(require_get());
var REGEX_FORMAT = /\[([^\]]+)]|D{1,2}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|S{1,3}/g;
function rightCurrentTime(format, currentTime) {
    const { total, days } = currentTime;
    let { hours, minutes, seconds, milliseconds } = currentTime;
    if (!format.includes("D")) {
        hours += days * 24;
    }
    if (!format.includes("H") && !format.includes("h")) {
        minutes += hours * 60;
    }
    if (!format.includes("m")) {
        seconds += minutes * 60;
    }
    if (!format.includes("s")) {
        milliseconds += seconds * 1e3;
    }
    return {
        total,
        days,
        hours,
        minutes,
        seconds,
        milliseconds
    };
}
function parseFormat(format, currentTime) {
    const { days, hours, minutes, seconds, milliseconds } = rightCurrentTime(format, currentTime);
    const matches = {
        D: days,
        DD: padZero(days),
        H: hours,
        HH: padZero(hours),
        m: minutes,
        mm: padZero(minutes),
        s: seconds,
        ss: padZero(seconds),
        S: padZero(milliseconds, 3).charAt(0),
        SS: padZero(milliseconds, 3).slice(0, 2),
        SSS: padZero(milliseconds, 3)
    };
    return (0, import_replace.default)(format, REGEX_FORMAT, (match, $1)=>$1 || (0, import_get11.default)(matches, match));
}
// node_modules/@taroify/core/countdown/use-countdown.js
var import_react167 = __toESM(require_react());
var SECOND = 1e3;
var MINUTE = 60 * SECOND;
var HOUR = 60 * MINUTE;
var DAY = 24 * HOUR;
function parseTime(time) {
    const days = Math.floor(time / DAY);
    const hours = Math.floor(time % DAY / HOUR);
    const minutes = Math.floor(time % HOUR / MINUTE);
    const seconds = Math.floor(time % MINUTE / SECOND);
    const milliseconds = Math.floor(time % SECOND);
    return {
        total: time,
        days,
        hours,
        minutes,
        seconds,
        milliseconds
    };
}
function isSameTime(time1, time2, interval) {
    return Math.floor(time1 / interval) === Math.floor(time2 / interval);
}
function useCountdown(options) {
    const { value: valueProp, autostart: autostartProp, interval: intervalOption = 1e3, onChange, onComplete } = options;
    const update = use_update_default();
    const intervalRef = useToRef(Math.max(intervalOption, 1));
    const valueRef = useToRef(valueProp);
    const autostartRef = useToRef(autostartProp);
    const rafIdRef = (0, import_react167.useRef)();
    const statusRef = (0, import_react167.useRef)();
    const endTimeRef = (0, import_react167.useRef)(0);
    const remainRef = (0, import_react167.useRef)(valueProp);
    const current = parseTime(remainRef.current);
    const currentRef = useToRef(current);
    const macroTick = useMemoizedFn(()=>{
        rafIdRef.current = raf(()=>{
            if (statusRef.current === "started") {
                const remain = Math.max(endTimeRef.current - Date.now(), 0);
                if (!isSameTime(remain, remainRef.current, intervalRef.current) || remain === 0) {
                    remainRef.current = remain;
                    update();
                    onChange === null || onChange === void 0 ? void 0 : onChange(currentRef.current);
                    if (remain === 0) {
                        stop();
                        onComplete === null || onComplete === void 0 ? void 0 : onComplete();
                    }
                }
                if (remainRef.current > 0) {
                    macroTick();
                }
            }
        });
    });
    const clearRaf = (0, import_react167.useCallback)(()=>{
        if (rafIdRef.current) {
            cancelRaf(rafIdRef.current);
        }
    }, []);
    const pause = (0, import_react167.useCallback)(()=>{
        clearRaf();
        statusRef.current = "paused";
    }, [
        clearRaf
    ]);
    const stop = (0, import_react167.useCallback)(()=>{
        clearRaf();
        statusRef.current = "stopped";
    }, [
        clearRaf
    ]);
    const start = (0, import_react167.useCallback)(()=>{
        if (statusRef.current !== "started") {
            endTimeRef.current = Date.now() + (statusRef.current === "paused" ? remainRef.current : valueRef.current);
            statusRef.current = "started";
            macroTick();
        }
    }, []);
    const autostart = (0, import_react167.useCallback)(()=>{
        if (autostartRef.current) {
            start();
        }
    }, []);
    const reset = (0, import_react167.useCallback)(()=>{
        stop();
        autostart();
    }, []);
    const restart = (0, import_react167.useCallback)(()=>{
        stop();
        start();
    }, []);
    (0, import_react167.useEffect)(()=>{
        autostart();
        return ()=>{
            stop();
        };
    }, []);
    (0, import_react167.useEffect)(()=>restart(), [
        valueProp
    ]);
    return (0, import_react167.useMemo)(()=>({
            current,
            start,
            reset,
            restart,
            pause,
            stop
        }), [
        current,
        pause,
        reset,
        restart,
        start,
        stop
    ]);
}
// node_modules/@taroify/core/countdown/countdown.js
var Countdown = (0, import_react168.forwardRef)((props, ref)=>{
    const { className, value = 0, autostart = true, interval, format = "HH:mm:ss", onChange, onComplete, children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "value",
        "autostart",
        "interval",
        "format",
        "onChange",
        "onComplete",
        "children"
    ]);
    const { current, pause, reset, restart, start, stop } = useCountdown({
        value,
        autostart,
        interval,
        onChange,
        onComplete
    });
    (0, import_react168.useImperativeHandle)(ref, ()=>({
            pause,
            reset,
            restart,
            start,
            stop
        }), [
        pause,
        reset,
        restart,
        start,
        stop
    ]);
    const childrenRender = (0, import_react168.useMemo)(()=>{
        if ((0, import_isFunction12.default)(children2)) {
            return children2(current);
        }
        if (children2) {
            return children2;
        }
        if ((0, import_isFunction12.default)(format)) {
            return format(current);
        }
        if (format) {
            return parseFormat(format, current);
        }
    }, [
        children2,
        current,
        format
    ]);
    return React142.createElement(View, _object_spread({
        className: (0, import_classnames112.default)(prefixClassname("countdown"), className),
        children: childrenRender
    }, restProps));
});
var countdown_default = Countdown;
// node_modules/@taroify/core/divider/divider.js
var import_classnames113 = __toESM(require_classnames());
var React143 = __toESM(require_react());
function findDividerText(node) {
    if (node === void 0) {
        return {
            children: void 0
        };
    }
    if (!React143.isValidElement(node)) {
        return {
            children: node
        };
    }
    const element = node;
    if (element.type !== Divider.Text) {
        return {
            children: node
        };
    }
    const { props } = element;
    const { orientation } = props;
    return {
        orientation,
        children: element
    };
}
function Divider(props) {
    const { className, dashed = false, hairline = true, type = "horizontal", children: childrenProp } = props, restProps = _object_without_properties(props, [
        "className",
        "dashed",
        "hairline",
        "type",
        "children"
    ]);
    const { orientation = "center", children: children2 } = findDividerText(childrenProp);
    return React143.createElement(View, _object_spread({
        className: (0, import_classnames113.default)(prefixClassname("divider"), {
            [prefixClassname("divider--hairline")]: hairline && !dashed,
            [prefixClassname("divider--dashed")]: dashed,
            [prefixClassname("divider--vertical")]: type === "vertical",
            [prefixClassname("divider--content-left")]: children2 && orientation === "left",
            [prefixClassname("divider--content-center")]: children2 && orientation === "center",
            [prefixClassname("divider--content-right")]: children2 && orientation === "right"
        }, className),
        children: children2
    }, restProps));
}
(function(Divider2) {
    function Text2(props) {
        const { children: children2 } = props;
        return children2;
    }
    Divider2.Text = Text2;
})(Divider || (Divider = {}));
var divider_default = Divider;
// node_modules/@taroify/core/empty/empty.js
var import_classnames114 = __toESM(require_classnames());
var React144 = __toESM(require_react());
var PRESET_IMAGES = [
    "default",
    "error",
    "search",
    "network"
];
function obtainImageUrl(image) {
    if (image && PRESET_IMAGES.includes(image)) {
        return `https://img.yzcdn.cn/vant/empty-image-${image}.png`;
    }
    return image;
}
function Empty(props) {
    const { className } = props, restProps = _object_without_properties(props, [
        "className"
    ]);
    return React144.createElement(View, _object_spread({
        className: (0, import_classnames114.default)(prefixClassname("empty"), className)
    }, restProps));
}
(function(Empty2) {
    function Image4(props) {
        const { className, style, src = "default" } = props;
        const __src__ = obtainImageUrl(src);
        return React144.createElement(Image3, {
            className: (0, import_classnames114.default)(prefixClassname("empty__image"), className),
            style,
            src: __src__
        });
    }
    Empty2.Image = Image4;
    function Description3(props) {
        const { className } = props, restProps = _object_without_properties(props, [
            "className"
        ]);
        return React144.createElement(View, _object_spread({
            className: (0, import_classnames114.default)(prefixClassname("empty__description"), className)
        }, restProps));
    }
    Empty2.Description = Description3;
})(Empty || (Empty = {}));
var empty_default = Empty;
// node_modules/@taroify/core/list/list.js
var import_classnames115 = __toESM(require_classnames());
var React145 = __toESM(require_react());
var import_react169 = __toESM(require_react());
var import_react170 = __toESM(require_react());
function useAssignLoading(state) {
    const getState = useGetter(state);
    const value = getState();
    const valueRef = (0, import_react170.useRef)();
    if (valueRef.current !== value) {
        valueRef.current = value;
    }
    const isLoading = (0, import_react170.useCallback)(()=>valueRef.current, []);
    const setLoading = (0, import_react170.useCallback)((newValue)=>valueRef.current = newValue, []);
    return (0, import_react170.useMemo)(()=>({
            isLoading,
            setLoading
        }), [
        isLoading,
        setLoading
    ]);
}
function List(props, ref) {
    const { className, loading: loadingProp = false, hasMore = true, direction = "down", offset = 100, immediateCheck: immediateCheckProp = true, fixedHeight = false, disabled = false, children: children2, onLoad, onScroll: onScrollProp } = props, restProps = _object_without_properties(props, [
        "className",
        "loading",
        "hasMore",
        "direction",
        "offset",
        "immediateCheck",
        "fixedHeight",
        "disabled",
        "children",
        "onLoad",
        "onScroll"
    ]);
    const rootRef = (0, import_react170.useRef)();
    const scrollRef = (0, import_react170.useRef)();
    const edgeRef = (0, import_react170.useRef)();
    const onLoadRef = useToRef(onLoad);
    const immediateCheck = useToRef(immediateCheckProp);
    const { isLoading, setLoading } = useAssignLoading(loadingProp);
    const { onTouchStart: onPullRefreshTouchStart, onTouchEnd: onPullRefreshTouchEnd, onTouchMove: onPullRefreshTouchMove } = React145.useContext(pull_refresh_context_default);
    const check = useMemoizedFn((0, import_debounce.default)(()=>{
        raf(/*#__PURE__*/ _async_to_generator(function*() {
            if (isLoading() || !hasMore || disabled) {
                return;
            }
            const scrollParentRect = yield getRect(scrollRef);
            if (!(scrollParentRect === null || scrollParentRect === void 0 ? void 0 : scrollParentRect.height)) {
                return;
            }
            let isReachEdge;
            const edgeRect = yield getRect(edgeRef);
            if (direction === "up") {
                isReachEdge = scrollParentRect.top - edgeRect.top <= offset;
            } else {
                isReachEdge = edgeRect.bottom - scrollParentRect.bottom <= offset;
            }
            if (isLoading() || !hasMore || disabled) {
                return;
            }
            if (isReachEdge) {
                var _onLoadRef_current;
                setLoading(true);
                (_onLoadRef_current = onLoadRef.current) === null || _onLoadRef_current === void 0 ? void 0 : _onLoadRef_current.call(onLoadRef);
            }
        }));
    }, 50));
    (0, import_react169.useImperativeHandle)(ref, ()=>({
            check
        }));
    usePageScroll(()=>{
        if (!fixedHeight) {
            check();
        }
    });
    const onScroll = (e)=>{
        onScrollProp === null || onScrollProp === void 0 ? void 0 : onScrollProp(e);
        if (fixedHeight) {
            check();
        }
    };
    const onTouchStart = (e)=>{
        if (fixedHeight) {
            onPullRefreshTouchStart === null || onPullRefreshTouchStart === void 0 ? void 0 : onPullRefreshTouchStart(e);
        }
    };
    const onTouchMove = (e)=>{
        if (fixedHeight) {
            onPullRefreshTouchMove === null || onPullRefreshTouchMove === void 0 ? void 0 : onPullRefreshTouchMove(e);
        }
    };
    const onTouchEnd = (e)=>{
        if (fixedHeight) {
            onPullRefreshTouchEnd === null || onPullRefreshTouchEnd === void 0 ? void 0 : onPullRefreshTouchEnd(e);
        }
    };
    use_did_effect_default(()=>{
        check();
    }, [
        loadingProp,
        hasMore,
        check
    ]);
    (0, import_react170.useEffect)(()=>{
        nextTick(/*#__PURE__*/ _async_to_generator(function*() {
            if (fixedHeight) {
                scrollRef.current = rootRef.current;
            } else {
                scrollRef.current = yield getScrollParent(rootRef);
            }
            if (immediateCheck.current) {
                check();
            }
        }));
    }, [
        fixedHeight
    ]);
    const Wrapper = (0, import_react170.useMemo)(()=>fixedHeight ? ScrollView : View, [
        fixedHeight
    ]);
    const listEdge = (0, import_react170.useMemo)(()=>React145.createElement(View, {
            ref: edgeRef,
            className: prefixClassname("list__edge")
        }), []);
    return React145.createElement(Wrapper, _object_spread_props(_object_spread({
        ref: rootRef,
        scrollY: fixedHeight,
        className: (0, import_classnames115.default)(prefixClassname("list"), className)
    }, restProps), {
        onScroll,
        onTouchStart,
        onTouchMove,
        onTouchEnd
    }), direction === "down" ? children2 : listEdge, direction === "up" ? children2 : listEdge);
}
var list_default = (0, import_react169.forwardRef)(List);
// node_modules/@taroify/core/list/list-placeholder.js
var import_classnames116 = __toESM(require_classnames());
var React146 = __toESM(require_react());
function ListPlaceholder(props) {
    const { className, children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "children"
    ]);
    return React146.createElement(View, _object_spread({
        className: (0, import_classnames116.default)(prefixClassname("list__placeholder"), className),
        children: children2
    }, restProps));
}
var list_placeholder_default = ListPlaceholder;
// node_modules/@taroify/core/list/index.js
var List2 = list_default;
List2.Placeholder = list_placeholder_default;
var list_default2 = List2;
// node_modules/@taroify/core/notice-bar/notice-bar.js
var import_classnames119 = __toESM(require_classnames());
var React147 = __toESM(require_react());
var import_react171 = __toESM(require_react());
var import_react172 = __toESM(require_react());
// node_modules/@taroify/core/notice-bar/notice-bar-action.js
var import_classnames117 = __toESM(require_classnames());
function NoticeBarAction(props) {
    const { className, children: children2, onClick } = props, restProps = _object_without_properties(props, [
        "className",
        "children",
        "onClick"
    ]);
    return cloneIconElement(children2, _object_spread({
        className: (0, import_classnames117.default)(prefixClassname("notice-bar__action"), className),
        onClick (e) {
            e.stopPropagation();
            onClick === null || onClick === void 0 ? void 0 : onClick(e);
        }
    }, restProps));
}
// node_modules/@taroify/core/notice-bar/notice-bar-icon.js
var import_classnames118 = __toESM(require_classnames());
function NoticeBarIcon(props) {
    const { className, children: children2, onClick } = props, restProps = _object_without_properties(props, [
        "className",
        "children",
        "onClick"
    ]);
    return cloneIconElement(children2, _object_spread({
        className: (0, import_classnames118.default)(prefixClassname("notice-bar__icon"), className),
        onClick (e) {
            e.stopPropagation();
            onClick === null || onClick === void 0 ? void 0 : onClick(e);
        }
    }, restProps));
}
// node_modules/@taroify/core/notice-bar/notice-bar.js
function useChildren(children2) {
    const __children__ = {
        icon: void 0,
        text: [],
        action: void 0
    };
    import_react172.Children.forEach(children2, (child)=>{
        if ((0, import_react172.isValidElement)(child)) {
            const element = child;
            const elementType = element.type;
            if (elementType === NoticeBarIcon) {
                __children__.icon = element;
            } else if (elementType === NoticeBarAction) {
                __children__.action = element;
            } else {
                __children__.text.push(child);
            }
        } else {
            __children__.text.push(child);
        }
    });
    return __children__;
}
function NoticeBar(props, ref) {
    const { className, delay = 1e3, speed = 60, wordwrap, scrollable = false, children: childrenProp, onReplay } = props, restProps = _object_without_properties(props, [
        "className",
        "delay",
        "speed",
        "wordwrap",
        "scrollable",
        "children",
        "onReplay"
    ]);
    const { icon, text, action } = useChildren(childrenProp);
    const ellipsis = !scrollable && !wordwrap;
    const startTimerRef = (0, import_react172.useRef)();
    const wrapRef = (0, import_react172.useRef)();
    const contentRef = (0, import_react172.useRef)();
    const [offset, setOffset] = (0, import_react172.useState)(0);
    const [duration, setDuration] = (0, import_react172.useState)(0);
    const wrapWidthRef = (0, import_react172.useRef)(0);
    const contentWidthRef = (0, import_react172.useRef)(0);
    const contentStyle = (0, import_react172.useMemo)(()=>({
            transform: offset ? `translateX(${addUnitPx(offset)})` : "",
            transitionDuration: `${duration}s`
        }), [
        offset,
        duration
    ]);
    function onTransitionEnd() {
        setOffset(wrapWidthRef.current);
        setDuration(0);
        nextTick(()=>{
            doubleRaf(()=>{
                setOffset(-contentWidthRef.current);
                setDuration((contentWidthRef.current + wrapWidthRef.current) / +speed);
                onReplay === null || onReplay === void 0 ? void 0 : onReplay();
            });
        });
    }
    function reset() {
        wrapWidthRef.current = 0;
        contentWidthRef.current = 0;
        setOffset(0);
        setDuration(0);
        if (startTimerRef.current) {
            clearTimeout(startTimerRef.current);
        }
        startTimerRef.current = setTimeout(/*#__PURE__*/ _async_to_generator(function*() {
            if (!wrapRef.current || !contentRef.current || !scrollable) {
                return;
            }
            nextTick(()=>Promise.all([
                    getRect(wrapRef),
                    getRect(contentRef)
                ]).then(([{ width: wrapRefWidth }, { width: contentRefWidth }])=>{
                    if (scrollable || contentRefWidth > wrapRefWidth) {
                        doubleRaf(()=>{
                            wrapWidthRef.current = wrapRefWidth;
                            contentWidthRef.current = contentRefWidth;
                            setOffset(-contentRefWidth);
                            setDuration(contentRefWidth / +speed);
                        });
                    }
                }));
        }), +delay);
    }
    (0, import_react171.useImperativeHandle)(ref, ()=>({
            reset
        }));
    (0, import_react172.useEffect)(reset, []);
    return React147.createElement(View, _object_spread({
        className: (0, import_classnames119.default)(prefixClassname("notice-bar"), {
            [prefixClassname("notice-bar--wordwrap")]: wordwrap
        }, className)
    }, restProps), icon, React147.createElement(View, {
        ref: wrapRef,
        className: prefixClassname("notice-bar__wrap")
    }, React147.createElement(View, {
        ref: contentRef,
        style: contentStyle,
        className: (0, import_classnames119.default)(prefixClassname("notice-bar__content"), {
            [prefixClassname("ellipsis")]: ellipsis
        }),
        children: text,
        onTransitionEnd
    })), action);
}
var notice_bar_default = (0, import_react171.forwardRef)(NoticeBar);
// node_modules/@taroify/core/notice-bar/index.js
var NoticeBar2 = notice_bar_default;
NoticeBar2.Icon = NoticeBarIcon;
NoticeBar2.Action = NoticeBarAction;
var notice_bar_default2 = NoticeBar2;
// node_modules/@taroify/core/progress/progress.js
var import_classnames120 = __toESM(require_classnames());
var React148 = __toESM(require_react());
var import_react173 = __toESM(require_react());
function Progress(props) {
    const { className, animated, striped, inactive, label, color = "primary", percent: percentProp = 0 } = props, restProps = _object_without_properties(props, [
        "className",
        "animated",
        "striped",
        "inactive",
        "label",
        "color",
        "percent"
    ]);
    const percent = Math.min(Math.max(0, percentProp), 100);
    function renderLabel() {
        if (label === void 0) {
            return `${percent}%`;
        } else if (!label) {
            return void 0;
        }
        return label;
    }
    const barStyle = (0, import_react173.useMemo)(()=>({
            width: `${percent}%`
        }), [
        percent
    ]);
    return React148.createElement(View, _object_spread({
        className: (0, import_classnames120.default)(prefixClassname("progress"), {
            [prefixClassname("progress--inactive")]: inactive,
            [prefixClassname("progress--striped")]: !inactive && striped,
            [prefixClassname("progress--animated")]: !inactive && striped && animated,
            [prefixClassname("progress--primary")]: !inactive && color === "primary",
            [prefixClassname("progress--info")]: !inactive && color === "info",
            [prefixClassname("progress--success")]: !inactive && color === "success",
            [prefixClassname("progress--warning")]: !inactive && color === "warning",
            [prefixClassname("progress--danger")]: !inactive && color === "danger"
        }, className)
    }, restProps), React148.createElement(View, {
        className: (0, import_classnames120.default)(prefixClassname("progress__portion")),
        style: barStyle
    }, renderLabel()));
}
var progress_default = Progress;
// node_modules/@taroify/core/progress/index.js
var progress_default2 = progress_default;
// node_modules/@taroify/core/skeleton/skeleton.js
var React152 = __toESM(require_react());
var import_classnames124 = __toESM(require_classnames());
// node_modules/@taroify/core/skeleton/skeleton-avatar.js
var React149 = __toESM(require_react());
var import_classnames121 = __toESM(require_classnames());
function SkeletonAvatar(props) {
    const { avatarSize, avatarShape } = props;
    return React149.createElement(View, {
        className: (0, import_classnames121.default)(prefixClassname("skeleton__avatar"), {
            [prefixClassname("skeleton__avatar--round")]: avatarShape === "round"
        }),
        style: _object_spread({}, getSizeStyle(avatarSize))
    });
}
var skeleton_avatar_default = SkeletonAvatar;
// node_modules/@taroify/core/skeleton/skeleton-title.js
var React150 = __toESM(require_react());
var import_classnames122 = __toESM(require_classnames());
function SkeletonTitle(props) {
    const { round, titleWidth } = props;
    return React150.createElement(View, {
        className: (0, import_classnames122.default)(prefixClassname("skeleton__title"), {
            [prefixClassname("skeleton__title--round")]: round
        }),
        style: {
            width: addUnitPx(titleWidth)
        }
    });
}
var skeleton_title_default = SkeletonTitle;
// node_modules/@taroify/core/skeleton/skeleton-paragraph.js
var React151 = __toESM(require_react());
var import_classnames123 = __toESM(require_classnames());
var DEFAULT_ROW_WIDTH = "100%";
function SkeletonParagraph(props) {
    const { round, rowWidth = DEFAULT_ROW_WIDTH } = props;
    return React151.createElement(View, {
        className: (0, import_classnames123.default)(prefixClassname("skeleton__paragraph"), {
            [prefixClassname("skeleton__paragraph--round")]: round
        }),
        style: {
            width: rowWidth
        }
    });
}
var skeleton_paragraph_default = SkeletonParagraph;
// node_modules/@taroify/core/skeleton/skeleton.js
var DEFAULT_LAST_ROW_WIDTH = "60%";
function Skeleton(props) {
    const { className, loading = true, round = true, animate = true, row = 0, rowWidth = DEFAULT_ROW_WIDTH, avatar, avatarSize, avatarShape = "round", title, titleWidth, children: children2, template } = props, restProps = _object_without_properties(props, [
        "className",
        "loading",
        "round",
        "animate",
        "row",
        "rowWidth",
        "avatar",
        "avatarSize",
        "avatarShape",
        "title",
        "titleWidth",
        "children",
        "template"
    ]);
    const getRowWidth = (index)=>{
        const { rowWidth: rowWidth2 } = props;
        if (rowWidth2 === DEFAULT_ROW_WIDTH && index === +row - 1) {
            return DEFAULT_LAST_ROW_WIDTH;
        }
        if (Array.isArray(rowWidth2)) {
            return rowWidth2[index];
        }
        return rowWidth2;
    };
    const renderContent2 = ()=>{
        if (template) {
            return template;
        }
        return React152.createElement(React152.Fragment, null, avatar && React152.createElement(skeleton_avatar_default, {
            avatarSize,
            avatarShape
        }), React152.createElement(View, {
            className: prefixClassname("skeleton__content")
        }, title && React152.createElement(skeleton_title_default, {
            round,
            titleWidth
        }), Array(+row).fill("").map((_, i)=>React152.createElement(skeleton_paragraph_default, {
                key: i,
                round,
                rowWidth: addUnitPx(getRowWidth(i))
            }))));
    };
    if (!loading) {
        return children2;
    }
    return React152.createElement(View, _object_spread({
        className: (0, import_classnames124.default)(prefixClassname("skeleton"), {
            [prefixClassname("skeleton--round")]: round,
            [prefixClassname("skeleton--animate")]: animate
        }, className)
    }, restProps), renderContent2());
}
var skeleton_default = Skeleton;
// node_modules/@taroify/core/skeleton/skeleton-image.js
var React153 = __toESM(require_react());
var import_classnames125 = __toESM(require_classnames());
function SkeletonImage(props) {
    const { imageSize, imageShape } = props;
    return React153.createElement(View, {
        className: (0, import_classnames125.default)(prefixClassname("skeleton__image"), {
            [prefixClassname("skeleton__image--round")]: imageShape === "round"
        }),
        style: getSizeStyle(imageSize)
    }, React153.createElement(VanIcon, {
        name: "photo",
        className: prefixClassname("skeleton__image-icon")
    }));
}
var skeleton_image_default = SkeletonImage;
// node_modules/@taroify/core/skeleton/index.js
var Skeleton2 = skeleton_default;
Skeleton2.Avatar = skeleton_avatar_default;
Skeleton2.Title = skeleton_title_default;
Skeleton2.Paragraph = skeleton_paragraph_default;
Skeleton2.Image = skeleton_image_default;
var skeleton_default2 = Skeleton2;
// node_modules/@taroify/core/steps/step.js
var import_classnames126 = __toESM(require_classnames());
var React154 = __toESM(require_react());
var import_react175 = __toESM(require_react());
// node_modules/@taroify/core/steps/steps.context.js
var import_react174 = __toESM(require_react());
var StepsContext = (0, import_react174.createContext)({});
var steps_context_default = StepsContext;
// node_modules/@taroify/core/steps/step.js
function Step(props) {
    const { className, index = -1, active: activeProp = false, completed: completedProp = false, icon, label, children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "index",
        "active",
        "completed",
        "icon",
        "label",
        "children"
    ]);
    const { value = -1, direction, alternativeLabel } = (0, import_react175.useContext)(steps_context_default);
    const active = (0, import_react175.useMemo)(()=>activeProp || index === value, [
        activeProp,
        index,
        value
    ]);
    const completed = (0, import_react175.useMemo)(()=>completedProp || index < value, [
        completedProp,
        index,
        value
    ]);
    return React154.createElement(View, _object_spread({
        className: (0, import_classnames126.default)(HAIRLINE_BORDER, prefixClassname("step"), prefixClassname(`step--${direction}`), {
            [prefixClassname("step--alternative-label")]: alternativeLabel && direction === "horizontal",
            [prefixClassname("step--active")]: active,
            [prefixClassname("step--completed")]: completed
        }, className)
    }, restProps), React154.createElement(View, {
        className: (0, import_classnames126.default)(prefixClassname("step__label")),
        children: children2 !== null && children2 !== void 0 ? children2 : label
    }), React154.createElement(View, {
        className: prefixClassname("step__circle-container")
    }, icon ? cloneIconElement(icon, {
        className: prefixClassname("step__icon")
    }) : React154.createElement(View, {
        className: prefixClassname("step__circle")
    })), React154.createElement(View, {
        className: (0, import_classnames126.default)(prefixClassname("step__line"))
    }));
}
var step_default = Step;
// node_modules/@taroify/core/steps/steps.js
var import_classnames127 = __toESM(require_classnames());
var React155 = __toESM(require_react());
var import_react176 = __toESM(require_react());
function useStepsChildren(children2) {
    const __children__ = {
        steps: []
    };
    let index = 0;
    import_react176.Children.forEach(children2, (child, i)=>{
        if (!(0, import_react176.isValidElement)(child)) {
            return;
        }
        const element = child;
        const elementType = element.type;
        if (elementType === step_default) {
            const { key } = element;
            __children__.steps.push((0, import_react176.cloneElement)(child, _object_spread_props(_object_spread({}, element.props), {
                key: key !== null && key !== void 0 ? key : i,
                index: index++
            })));
        }
    });
    return __children__;
}
function Steps(props) {
    const { className, defaultValue, value: valueProp, direction = "horizontal", alternativeLabel = false, children: childrenProp } = props, restProps = _object_without_properties(props, [
        "className",
        "defaultValue",
        "value",
        "direction",
        "alternativeLabel",
        "children"
    ]);
    const { value } = useUncontrolled({
        value: valueProp,
        defaultValue
    });
    const { steps } = useStepsChildren(childrenProp);
    return React155.createElement(steps_context_default.Provider, {
        value: {
            value,
            direction,
            alternativeLabel
        }
    }, React155.createElement(View, _object_spread({
        className: (0, import_classnames127.default)(prefixClassname("steps"), {
            [prefixClassname("steps--horizontal")]: direction === "horizontal",
            [prefixClassname("steps--vertical")]: direction === "vertical"
        }, className)
    }, restProps), React155.createElement(View, {
        className: prefixClassname("steps__items"),
        children: steps
    })));
}
var steps_default = Steps;
// node_modules/@taroify/core/steps/index.js
var Steps2 = steps_default;
Steps2.Step = step_default;
var steps_default2 = Steps2;
// node_modules/@taroify/core/tag/tag.js
var import_classnames128 = __toESM(require_classnames());
var React156 = __toESM(require_react());
function Tag(props) {
    const { className, variant = "contained", size = "small", color = "default", shape = "square", closeable, closeIcon = React156.createElement(Cross_default, null), onClose, children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "variant",
        "size",
        "color",
        "shape",
        "closeable",
        "closeIcon",
        "onClose",
        "children"
    ]);
    return React156.createElement(View, _object_spread({
        className: (0, import_classnames128.default)(prefixClassname("tag"), {
            [prefixClassname("tag--outlined")]: variant === "outlined",
            [prefixClassname("tag--medium")]: size === "medium",
            [prefixClassname("tag--large")]: size === "large",
            [prefixClassname("tag--default")]: color === "default",
            [prefixClassname("tag--primary")]: color === "primary",
            [prefixClassname("tag--info")]: color === "info",
            [prefixClassname("tag--success")]: color === "success",
            [prefixClassname("tag--warning")]: color === "warning",
            [prefixClassname("tag--danger")]: color === "danger",
            [prefixClassname("tag--rounded")]: shape === "rounded",
            [prefixClassname("tag--rounded-right")]: shape === "roundedRight",
            [prefixClassname("tag--rounded-left")]: shape === "roundedLeft"
        }, className)
    }, restProps), children2, closeable && cloneIconElement(closeIcon, {
        className: prefixClassname("tag__close"),
        onClick: onClose
    }));
}
var tag_default = Tag;
// node_modules/@taroify/core/timeline/timeline.js
var import_classnames129 = __toESM(require_classnames());
var React157 = __toESM(require_react());
// node_modules/@taroify/core/timeline/timeline.context.js
var import_react177 = __toESM(require_react());
var TimelineContext = (0, import_react177.createContext)({});
var timeline_context_default = TimelineContext;
// node_modules/@taroify/core/timeline/timeline.js
function Timeline(props) {
    const { className, position } = props, restProps = _object_without_properties(props, [
        "className",
        "position"
    ]);
    return React157.createElement(timeline_context_default.Provider, {
        value: {
            position
        }
    }, React157.createElement(View, _object_spread({
        className: (0, import_classnames129.default)(prefixClassname("timeline"), className)
    }, restProps)));
}
var timeline_default = Timeline;
// node_modules/@taroify/core/timeline/timeline-connector.js
var import_classnames130 = __toESM(require_classnames());
var React158 = __toESM(require_react());
function TimelineConnector(props) {
    const { className } = props, restProps = _object_without_properties(props, [
        "className"
    ]);
    return React158.createElement(View, _object_spread({
        className: (0, import_classnames130.default)(prefixClassname("timeline-connector"), className)
    }, restProps));
}
var timeline_connector_default = TimelineConnector;
// node_modules/@taroify/core/timeline/timeline-content.js
var import_classnames131 = __toESM(require_classnames());
var React159 = __toESM(require_react());
function TimeLineContent(props) {
    const { className, justify, align } = props, restProps = _object_without_properties(props, [
        "className",
        "justify",
        "align"
    ]);
    return React159.createElement(flex_default2, _object_spread({
        className: (0, import_classnames131.default)(prefixClassname("timeline-content"), {
            [prefixClassname("timeline-content--justify-start")]: justify === "start",
            [prefixClassname("timeline-content--justify-center")]: justify === "center",
            [prefixClassname("timeline-content--justify-end")]: justify === "end",
            [prefixClassname("timeline-content--justify-space-around")]: justify === "space-around",
            [prefixClassname("timeline-content--justify-space-between")]: justify === "space-between",
            [prefixClassname("timeline-content--align-start")]: align === "start",
            [prefixClassname("timeline-content--align-center")]: align === "center",
            [prefixClassname("timeline-content--align-end")]: align === "end",
            [prefixClassname("timeline-content--align-baseline")]: align === "baseline",
            [prefixClassname("timeline-content--align-stretch")]: align === "stretch"
        }, className)
    }, restProps));
}
var timeline_content_default = TimeLineContent;
// node_modules/@taroify/core/timeline/timeline-dot.js
var import_classnames132 = __toESM(require_classnames());
var React160 = __toESM(require_react());
var TIMELINE_DOT_COLORS = [
    "default",
    "primary",
    "info",
    "success",
    "warning",
    "danger"
];
var TIMELINE_DOT_VARIANTS = [
    "filled",
    "outlined"
];
function isPresetColor(color) {
    return TIMELINE_DOT_COLORS.includes(color);
}
function isPresetVariant(variant) {
    return TIMELINE_DOT_VARIANTS.includes(variant);
}
function TimelineDot(props) {
    const { className, variant = "filled", color = "default" } = props, restProps = _object_without_properties(props, [
        "className",
        "variant",
        "color"
    ]);
    return React160.createElement(View, _object_spread({
        className: (0, import_classnames132.default)(prefixClassname("timeline-dot"), {
            [prefixClassname(`timeline-dot--${variant}-${color}`)]: isPresetVariant(variant) && isPresetColor(color)
        }, className)
    }, restProps));
}
var timeline_dot_default = TimelineDot;
// node_modules/@taroify/core/timeline/timeline-item.js
var import_classnames135 = __toESM(require_classnames());
var import_isObject6 = __toESM(require_isObject());
var React163 = __toESM(require_react());
var import_react178 = __toESM(require_react());
// node_modules/@taroify/core/timeline/timeline-item-base.js
var import_classnames133 = __toESM(require_classnames());
var React161 = __toESM(require_react());
function TimeLineItemBase(props) {
    const { className } = props, restProps = _object_without_properties(props, [
        "className"
    ]);
    return React161.createElement(View, _object_spread({
        className: (0, import_classnames133.default)(prefixClassname("timeline-item"), className)
    }, restProps));
}
var timeline_item_base_default = TimeLineItemBase;
// node_modules/@taroify/core/timeline/timeline-separator.js
var import_classnames134 = __toESM(require_classnames());
var React162 = __toESM(require_react());
function TimeLineSeparator(props) {
    const { className } = props, restProps = _object_without_properties(props, [
        "className"
    ]);
    return React162.createElement(View, _object_spread({
        className: (0, import_classnames134.default)(prefixClassname("timeline-separator"), className)
    }, restProps));
}
TimeLineSeparator.displayName = "TimeLineSeparator";
var timeline_separator_default = TimeLineSeparator;
// node_modules/@taroify/core/timeline/timeline-item.js
function useTimelineItemChildren(children2, options) {
    const { position, dot } = options;
    const separator = [
        false,
        void 0
    ];
    const leftContent = [
        false,
        void 0
    ];
    const rightContent = [
        false,
        void 0
    ];
    import_react178.Children.forEach(children2, (child)=>{
        if (isElementOf(child, timeline_separator_default)) {
            separator[0] = true;
            separator[1] = child;
        }
        if (leftContent[0] && isElementOf(child, timeline_content_default)) {
            rightContent[0] = true;
            rightContent[1] = child;
        }
        if (!leftContent[0] && isElementOf(child, timeline_content_default)) {
            leftContent[0] = true;
            leftContent[1] = child;
        }
    });
    if (!leftContent[0] && !rightContent[0]) {
        leftContent[0] = true;
        leftContent[1] = React163.createElement(timeline_content_default, {
            children: children2
        });
    }
    if (!separator[0]) {
        separator[0] = true;
        separator[1] = React163.createElement(timeline_separator_default, null, dot, React163.createElement(timeline_connector_default, null));
    }
    if (position === "left") {
        return React163.createElement(React163.Fragment, null, leftContent[1], separator[1]);
    }
    if (position === "right") {
        return React163.createElement(React163.Fragment, null, separator[1], leftContent[1]);
    }
    if (!rightContent[0]) {
        rightContent[0] = true;
        rightContent[1] = React163.createElement(timeline_content_default, null);
    }
    return React163.createElement(React163.Fragment, null, leftContent[1], separator[1], rightContent[1]);
}
function useTimelineDot(dot) {
    if ((0, import_react178.isValidElement)(dot)) {
        return dot;
    }
    if ((0, import_isObject6.default)(dot)) {
        const dotProps = dot;
        return React163.createElement(timeline_dot_default, _object_spread({}, dotProps));
    }
}
function TimelineItem(props) {
    const { className, dot: dotProp = React163.createElement(timeline_dot_default, null), children: childrenProp } = props, restProps = _object_without_properties(props, [
        "className",
        "dot",
        "children"
    ]);
    const { position } = (0, import_react178.useContext)(timeline_context_default);
    const dot = useTimelineDot(dotProp);
    const children2 = useTimelineItemChildren(childrenProp, {
        position,
        dot
    });
    return React163.createElement(timeline_item_base_default, _object_spread({
        className: (0, import_classnames135.default)(className, {
            [prefixClassname("timeline-item--right")]: position === "right",
            [prefixClassname("timeline-item--left")]: position === "left",
            [prefixClassname("timeline-item--alternate")]: position === "alternate",
            [prefixClassname("timeline-item--alternate-reverse")]: position === "alternate-reverse"
        })
    }, restProps), children2);
}
var timeline_item_default = TimelineItem;
// node_modules/@taroify/core/timeline/index.js
var Timeline2 = timeline_default;
Timeline2.Connector = timeline_connector_default;
Timeline2.Content = timeline_content_default;
Timeline2.Dot = timeline_dot_default;
Timeline2.Item = timeline_item_default;
Timeline2.Separator = timeline_separator_default;
var timeline_default2 = Timeline2;
// node_modules/@taroify/core/rolling-text/rolling-text.js
var React165 = __toESM(require_react());
var import_react180 = __toESM(require_react());
var import_classnames137 = __toESM(require_classnames());
// node_modules/@taroify/core/rolling-text/rolling-text-item.js
var React164 = __toESM(require_react());
var import_react179 = __toESM(require_react());
var import_classnames136 = __toESM(require_classnames());
var RollingTextItem = (props)=>{
    const { figureArr = [], delay, duration = 2, isStart, direction = "down", height = 40 } = props;
    const newFigureArr = (0, import_react179.useMemo)(()=>direction === "down" ? figureArr.slice().reverse() : figureArr, [
        direction,
        figureArr
    ]);
    const translatePx = (0, import_react179.useMemo)(()=>{
        const totalHeight = height * (figureArr.length - 1);
        return `-${totalHeight}px`;
    }, [
        height,
        figureArr
    ]);
    const itemStyle = (0, import_react179.useMemo)(()=>({
            lineHeight: addUnitPx(height)
        }), [
        height
    ]);
    const rootStyle = (0, import_react179.useMemo)(()=>({
            height: addUnitPx(height),
            "--rolling-text-translate": translatePx,
            "--rolling-text-duration": `${duration}s`,
            "--rolling-text-delay": `${delay}s`
        }), [
        height,
        translatePx,
        duration,
        delay
    ]);
    return React164.createElement(View, {
        className: (0, import_classnames136.default)(prefixClassname("rolling-text-item"), prefixClassname(`rolling-text-item--${direction}`)),
        style: rootStyle
    }, React164.createElement(View, {
        className: (0, import_classnames136.default)(prefixClassname("rolling-text-item__box"), {
            animate: isStart
        })
    }, Array.isArray(newFigureArr) && newFigureArr.map((v, i)=>React164.createElement(View, {
            className: (0, import_classnames136.default)(prefixClassname("rolling-text-item__item")),
            style: itemStyle,
            key: i
        }, v))));
};
var rolling_text_item_default = RollingTextItem;
// node_modules/@taroify/core/rolling-text/rolling-text.js
var CIRCLE_NUM = 2;
var RollingText = (0, import_react180.forwardRef)((props, ref)=>{
    const { className, startNum = 0, targetNum, textList = [], duration = 2, autoStart = true, direction = "down", stopOrder = "ltr", height = 40 } = props;
    const [rolling, setRolling] = (0, import_react180.useState)(autoStart);
    const isCustomType = (0, import_react180.useMemo)(()=>Array.isArray(textList) && textList.length, [
        textList
    ]);
    const itemLength = (0, import_react180.useMemo)(()=>{
        if (isCustomType) return textList[0].length;
        return `${Math.max(startNum, targetNum)}`.length;
    }, [
        isCustomType,
        textList,
        startNum,
        targetNum
    ]);
    const startNumArr = (0, import_react180.useMemo)(()=>padZero(startNum, itemLength).split(""), [
        startNum,
        itemLength
    ]);
    const targetNumArr = (0, import_react180.useMemo)(()=>{
        if (isCustomType) return new Array(itemLength).fill("");
        return padZero(targetNum, itemLength).split("");
    }, [
        isCustomType,
        itemLength,
        targetNum
    ]);
    const getTextArrByIdx = (idx)=>{
        const result = [];
        for(let i = 0; i < textList.length; i++){
            result.push(textList[i][idx]);
        }
        return result;
    };
    const getFigureArr = (i)=>{
        const start2 = +startNumArr[i];
        const target = +targetNumArr[i];
        const result = [];
        for(let i2 = start2; i2 <= 9; i2++){
            result.push(i2);
        }
        for(let i2 = 0; i2 <= CIRCLE_NUM; i2++){
            for(let j = 0; j <= 9; j++){
                result.push(j);
            }
        }
        for(let i2 = 0; i2 <= target; i2++){
            result.push(i2);
        }
        return result;
    };
    const getDelay = (i, len)=>{
        if (stopOrder === "ltr") return 0.2 * i;
        return 0.2 * (len - 1 - i);
    };
    const start = ()=>{
        setRolling(true);
    };
    const reset = ()=>{
        setRolling(false);
        if (autoStart) {
            start();
        }
    };
    (0, import_react180.useEffect)(()=>{
        if (autoStart) {
            start();
        }
    }, [
        autoStart
    ]);
    (0, import_react180.useImperativeHandle)(ref, ()=>{
        return {
            start () {
                start();
            },
            reset () {
                reset();
            }
        };
    });
    return React165.createElement(View, {
        className: (0, import_classnames137.default)(prefixClassname("rolling-text"), className)
    }, targetNumArr.map((_, i)=>React165.createElement(rolling_text_item_default, {
            key: i,
            figureArr: isCustomType ? getTextArrByIdx(i) : getFigureArr(i),
            duration,
            direction,
            isStart: rolling,
            height,
            delay: getDelay(i, itemLength)
        })));
});
var rolling_text_default = RollingText;
// node_modules/@taroify/core/rolling-text/index.js
var RollingText2 = rolling_text_default;
var rolling_text_default2 = RollingText2;
// node_modules/@taroify/core/text-ellipsis/text-ellipsis.js
var React166 = __toESM(require_react());
var import_react181 = __toESM(require_react());
var import_classnames138 = __toESM(require_classnames());
var zhCharCodeStart = 19968;
var zhChartCodeEnd = 40869;
var numberChartCodeStart = 48;
var numberChartCodeEnd = 57;
var letterLowerChartCodeStart = 97;
var letterLowerChartCodeEnd = 122;
var letterUpperChartCodeStart = 65;
var letterUpperChartCodeEnd = 90;
var placeholderBaseCls = prefixClassname("text-ellipsis__placeholder-base");
var TextEllipsis = (0, import_react181.forwardRef)((props, ref)=>{
    const { rows = 1, content, children: children2, expandText = "", collapseText = "", dots = "...", position = "end", onClickAction: onClickActionProp, className: classNameProp, style: styleProp } = props, rest = _object_without_properties(props, [
        "rows",
        "content",
        "children",
        "expandText",
        "collapseText",
        "dots",
        "position",
        "onClickAction",
        "className",
        "style"
    ]);
    const textProps = content || children2 || "";
    const cloneStyle = useDeepCompareMemo(()=>mergeStyle(styleProp, {
            position: "fixed",
            zIndex: "-9999",
            top: "-9999px",
            height: "auto",
            minHeight: "auto",
            maxHeight: "auto"
        }), [
        styleProp
    ]);
    const [status, setStatus] = (0, import_react181.useState)("beforeInit");
    const [baseString, setBaseString] = (0, import_react181.useState)([]);
    const [unConfirmedText, setUnConfirmedText] = (0, import_react181.useState)("");
    const [unConfirmedIndex, setUnConfirmedIndex] = (0, import_react181.useState)(0);
    const [correctIndex, setCorrectIndex] = (0, import_react181.useState)(0);
    const [hasAction, setHasAction] = (0, import_react181.useState)(false);
    const [expanded, setExpanded] = (0, import_react181.useState)(false);
    const containerRef = (0, import_react181.useRef)();
    const cloneContainerRef = (0, import_react181.useRef)();
    const placeholderBaseDomsRef = (0, import_react181.useRef)([]);
    const widthCacheRef = (0, import_react181.useRef)(/* @__PURE__ */ new Map());
    const charCodesCacheRef = (0, import_react181.useRef)([]);
    const containerHeightRef = (0, import_react181.useRef)(0);
    const hasActionRef = (0, import_react181.useRef)(false);
    const getText = useMemoizedFn((index)=>{
        if (index === 0) {
            return "";
        }
        if (index === textProps.length) {
            return textProps;
        }
        if (Array.isArray(index)) {
            return textProps.slice(0, index[0]) + dots + textProps.slice(index[1]);
        } else if (index > 0) {
            return textProps.slice(0, index) + dots;
        } else {
            return dots + textProps.slice(+index);
        }
    });
    const getPrevIndex = useMemoizedFn((idx)=>{
        if (Array.isArray(idx)) {
            return [
                idx[0] - 1,
                idx[1]
            ];
        } else if (idx >= 0) {
            return idx - 1;
        } else {
            return idx + 1;
        }
    });
    const getNextIndex = useMemoizedFn((idx)=>{
        if (Array.isArray(idx)) {
            return [
                idx[0] + 1,
                idx[1]
            ];
        } else if (idx >= 0) {
            return idx + 1;
        } else {
            return idx - 1;
        }
    });
    (0, import_react181.useLayoutEffect)(()=>{
        setStatus("beforeInit");
        hasActionRef.current = false;
        setUnConfirmedIndex(0);
        nextTick(()=>{
            const tempText = textProps + expandText + dots;
            const tempBaseChar = [];
            const tempCodes = [];
            const widthCache = widthCacheRef.current;
            widthCache.clear();
            for(let i = 0; i < tempText.length; i++){
                const charCode = tempText.charCodeAt(i);
                if (charCode >= zhCharCodeStart && charCode <= zhChartCodeEnd) {
                    tempCodes.push(zhChartCodeEnd);
                    if (!widthCache.has(zhChartCodeEnd)) {
                        widthCache.set(zhChartCodeEnd, 0);
                        tempBaseChar.push("\u9FA5");
                    }
                } else if (charCode >= numberChartCodeStart && charCode <= numberChartCodeEnd) {
                    tempCodes.push(numberChartCodeEnd);
                    if (!widthCache.has(numberChartCodeEnd)) {
                        widthCache.set(numberChartCodeEnd, 0);
                        tempBaseChar.push("9");
                    }
                } else if (charCode >= letterLowerChartCodeStart && charCode <= letterLowerChartCodeEnd) {
                    tempCodes.push(letterLowerChartCodeEnd);
                    if (!widthCache.has(letterLowerChartCodeEnd)) {
                        widthCache.set(letterLowerChartCodeEnd, 0);
                        tempBaseChar.push("z");
                    }
                } else if (charCode >= letterUpperChartCodeStart && charCode <= letterUpperChartCodeEnd) {
                    tempCodes.push(letterUpperChartCodeEnd);
                    if (!widthCache.has(letterUpperChartCodeEnd)) {
                        widthCache.set(letterUpperChartCodeEnd, 0);
                        tempBaseChar.push("Z");
                    }
                } else {
                    tempCodes.push(charCode);
                    if (!widthCache.has(charCode)) {
                        widthCache.set(charCode, 0);
                        tempBaseChar.push(tempText[i]);
                    }
                }
            }
            charCodesCacheRef.current = tempCodes;
            setBaseString(tempBaseChar);
        });
    }, [
        textProps,
        dots,
        expandText
    ]);
    (0, import_react181.useLayoutEffect)(()=>{
        const fn = function() {
            var _ref = _async_to_generator(function*() {
                const { width: containerWidth, height: containerHeight } = yield getRect(containerRef.current);
                containerHeightRef.current = containerHeight;
                if (baseString.length === 0) {
                    hasActionRef.current = false;
                    setUnConfirmedIndex(0);
                    return;
                }
                getRects(cloneContainerRef.current, `.${placeholderBaseCls}`).then((rects)=>{
                    if (rects.length > 0) {
                        baseString.forEach((char, index)=>{
                            var _rects_index;
                            widthCacheRef.current.set(char.charCodeAt(0), ((_rects_index = rects[index]) === null || _rects_index === void 0 ? void 0 : _rects_index.width) || 0);
                        });
                    }
                    const calcCharWidth = (charCode)=>{
                        const widthCache = widthCacheRef.current;
                        if (charCode >= zhCharCodeStart && charCode <= zhChartCodeEnd) {
                            return widthCache.get(zhChartCodeEnd);
                        } else if (charCode >= numberChartCodeStart && charCode <= numberChartCodeEnd) {
                            return widthCache.get(numberChartCodeEnd);
                        } else if (charCode >= letterLowerChartCodeStart && charCode <= letterLowerChartCodeEnd) {
                            return widthCache.get(letterLowerChartCodeEnd);
                        } else if (charCode >= letterUpperChartCodeStart && charCode <= letterUpperChartCodeEnd) {
                            return widthCache.get(letterUpperChartCodeEnd);
                        } else {
                            return widthCache.get(charCode);
                        }
                    };
                    const charCodesCache = charCodesCacheRef.current;
                    let calcWidth = 0;
                    const placeholderWidth = charCodesCache.slice(textProps.length).reduce((acc, cur)=>acc + (calcCharWidth(cur) || 0), 0);
                    const maxWidth = containerWidth * (Number.isNaN(Number(rows)) ? 1 : Number(rows));
                    if (position === "end") {
                        let index = 0;
                        for(let i = 0; i < textProps.length; i++){
                            calcWidth += calcCharWidth(charCodesCacheRef.current[i]) || 0;
                            if (calcWidth + placeholderWidth < maxWidth) {
                                index = i;
                            }
                            if (calcWidth > maxWidth) {
                                setUnConfirmedIndex(index);
                                hasActionRef.current = true;
                                return;
                            }
                        }
                    } else if (position === "start") {
                        let index = textProps.length - 1;
                        for(let i = textProps.length - 1; i >= 0; i--){
                            calcWidth += calcCharWidth(charCodesCacheRef.current[i]) || 0;
                            if (calcWidth + placeholderWidth < maxWidth) {
                                index = i;
                            }
                            if (calcWidth > maxWidth) {
                                setUnConfirmedIndex(index - textProps.length);
                                hasActionRef.current = true;
                                return;
                            }
                        }
                    } else if (position === "middle") {
                        let left = 0;
                        let right = textProps.length - 1;
                        let flag = false;
                        let leftIndex = 0;
                        let rightIndex = textProps.length - 1;
                        while(right > left){
                            if (flag) {
                                calcWidth += calcCharWidth(charCodesCacheRef.current[left]) || 0;
                                if (calcWidth + placeholderWidth < maxWidth) {
                                    leftIndex = left;
                                }
                                left++;
                            } else {
                                calcWidth += calcCharWidth(charCodesCacheRef.current[right]) || 0;
                                if (calcWidth + placeholderWidth < maxWidth) {
                                    rightIndex = right;
                                }
                                right--;
                            }
                            if (calcWidth > maxWidth) {
                                setUnConfirmedIndex([
                                    leftIndex,
                                    rightIndex
                                ]);
                                hasActionRef.current = true;
                                return;
                            }
                            flag = !flag;
                        }
                    }
                    hasActionRef.current = false;
                    setCorrectIndex(textProps.length);
                });
            });
            return function fn() {
                return _ref.apply(this, arguments);
            };
        }();
        nextTick(()=>{
            fn();
        });
    }, [
        baseString,
        position,
        rows
    ]);
    (0, import_react181.useLayoutEffect)(()=>{
        let tempUnConfirmedIndex = unConfirmedIndex;
        const maxHeight = containerHeightRef.current * ((Number.isNaN(Number(rows)) ? 1 : Number(rows)) + 0.01);
        let flag;
        const max = 5;
        let i = 0;
        const fn = ()=>{
            if (i++ > max) {
                setCorrectIndex(tempUnConfirmedIndex);
                return;
            }
            nextTick(()=>{
                getRect(containerRef.current).then((rect)=>{
                    if (flag === void 0) {
                        flag = rect.height > maxHeight;
                        tempUnConfirmedIndex = flag ? getPrevIndex(tempUnConfirmedIndex) : getNextIndex(tempUnConfirmedIndex);
                        setUnConfirmedText(getText(tempUnConfirmedIndex));
                        fn();
                    } else {
                        if (flag) {
                            if (rect.height > maxHeight) {
                                tempUnConfirmedIndex = getPrevIndex(tempUnConfirmedIndex);
                                setUnConfirmedText(getText(tempUnConfirmedIndex));
                                fn();
                            } else {
                                setCorrectIndex(tempUnConfirmedIndex);
                            }
                        } else {
                            if (rect.height < maxHeight) {
                                tempUnConfirmedIndex = getNextIndex(tempUnConfirmedIndex);
                                setUnConfirmedText(getText(tempUnConfirmedIndex));
                                fn();
                            } else {
                                setCorrectIndex(getPrevIndex(tempUnConfirmedIndex));
                            }
                        }
                    }
                });
            });
        };
        if (hasActionRef.current) {
            setStatus("init");
            setUnConfirmedText(getText(tempUnConfirmedIndex));
            fn();
        } else {
            setCorrectIndex(unConfirmedIndex);
        }
    }, [
        unConfirmedIndex
    ]);
    const text = (0, import_react181.useMemo)(()=>{
        setHasAction(hasActionRef.current);
        setStatus("initd");
        return getText(correctIndex);
    }, [
        correctIndex
    ]);
    const onClickAction = ()=>{
        setExpanded(!expanded);
        onClickActionProp === null || onClickActionProp === void 0 ? void 0 : onClickActionProp(!expanded);
    };
    const toggle = (isExpanded = !expanded)=>{
        setExpanded(isExpanded);
    };
    (0, import_react181.useImperativeHandle)(ref, ()=>{
        return {
            toggle
        };
    });
    return React166.createElement(View, _object_spread({
        ref: containerRef,
        className: (0, import_classnames138.default)(prefixClassname("text-ellipsis"), classNameProp, {
            [prefixClassname("text-ellipsis__hidden")]: status !== "initd"
        }),
        style: styleProp
    }, rest), status === "beforeInit" && "\xA0", status === "init" && React166.createElement(React166.Fragment, null, unConfirmedText, React166.createElement(View, {
        className: (0, import_classnames138.default)(prefixClassname("text-ellipsis__expand"))
    }, expandText)), status === "initd" && (!expanded ? text : content || children2), status === "initd" && hasAction && React166.createElement(View, {
        className: (0, import_classnames138.default)(prefixClassname("text-ellipsis__expand")),
        onClick: onClickAction
    }, !expanded ? expandText : collapseText), status !== "initd" && React166.createElement(View, _object_spread({
        ref: cloneContainerRef,
        id: "clone-container",
        style: cloneStyle,
        className: (0, import_classnames138.default)(prefixClassname("text-ellipsis"), classNameProp)
    }, rest), baseString.map((char, index)=>React166.createElement(View, {
            ref: (r)=>placeholderBaseDomsRef.current[index] = r,
            key: index,
            className: placeholderBaseCls,
            style: {
                display: "inline"
            }
        }, char))));
});
var text_ellipsis_default = TextEllipsis;
// node_modules/@taroify/core/text-ellipsis/index.js
var text_ellipsis_default2 = text_ellipsis_default;
// node_modules/@taroify/core/watermark/watermark.js
var React167 = __toESM(require_react());
var import_react182 = __toESM(require_react());
var import_classnames139 = __toESM(require_classnames());
var _canvasIdx2 = 0;
function Watermark(props) {
    const { gapX = 20, gapY = 20, image: imageProp = "", width: widthProp = 80, height: heightProp = 80, rotate = -11, zIndex, opacity = 1, fullPage = false, content = "", textSize = 20, textColor = "#dcdee0" } = props;
    const width = (0, import_react182.useMemo)(()=>widthProp + gapX, [
        widthProp,
        gapX
    ]);
    const height = (0, import_react182.useMemo)(()=>heightProp + gapY, [
        heightProp,
        gapY
    ]);
    const canvasId = (0, import_react182.useMemo)(()=>`taroify-watermark${_canvasIdx2++}`, []);
    const canvasRef = (0, import_react182.useRef)(null);
    const [watermarkUrl, setWatermarkUrl] = (0, import_react182.useState)("");
    const [canvas, ctx, loaded] = use_canvas_default(canvasId, canvasRef);
    (0, import_react182.useEffect)(()=>{
        if (canvas && ctx && loaded) {
            if (imageProp) {
                const image = getEnv() === "WEB" ? new Image() : canvas.createImage();
                image.crossOrigin = "anonymous";
                image.referrerPolicy = "no-referrer";
                image.onload = ()=>{
                    canvas.width = image.width + gapX;
                    canvas.height = image.height + gapY;
                    ctx.globalAlpha = opacity;
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate(rotate * Math.PI / 180);
                    ctx.translate(-canvas.width / 2, -canvas.height / 2);
                    ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, gapX, gapY);
                    setWatermarkUrl(canvas.toDataURL());
                };
                image.src = imageProp;
            } else {
                const ratio = getWindowInfo().pixelRatio || 1;
                canvas.width = width * ratio;
                canvas.height = height * ratio;
                ctx.scale(ratio, ratio);
                ctx.globalAlpha = opacity;
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.rotate(rotate * Math.PI / 180);
                ctx.translate(-canvas.width / 2, -canvas.height / 2);
                ctx.textAlign = "left";
                ctx.font = `${textSize}px sans-serif`;
                ctx.fillStyle = textColor;
                ctx.textBaseline = "top";
                ctx.fillText(content, gapX, gapY);
                setWatermarkUrl(canvas.toDataURL());
            }
        }
    }, [
        gapX,
        gapY,
        imageProp,
        width,
        height,
        rotate,
        opacity,
        content,
        textSize,
        textColor,
        loaded
    ]);
    const style = (0, import_react182.useMemo)(()=>({
            zIndex,
            backgroundImage: `url(${watermarkUrl})`,
            backgroundSize: `${width}px ${height}px`
        }), [
        zIndex,
        watermarkUrl
    ]);
    return React167.createElement(View, {
        className: (0, import_classnames139.default)({
            [prefixClassname("watermark")]: true,
            [prefixClassname("watermark--full")]: fullPage
        }),
        style
    }, React167.createElement(View, {
        className: prefixClassname("watermark__wrapper")
    }, React167.createElement(Canvas, {
        type: "2d",
        id: canvasId,
        canvasId,
        ref: canvasRef
    })));
}
var watermark_default = Watermark;
// node_modules/@taroify/core/grid/grid.js
var import_classnames140 = __toESM(require_classnames());
var React168 = __toESM(require_react());
var import_react184 = __toESM(require_react());
// node_modules/@taroify/core/grid/grid.context.js
var import_react183 = __toESM(require_react());
var GridContext = (0, import_react183.createContext)({
    bordered: false,
    columns: 0,
    centered: false,
    clickable: false
});
var grid_context_default = GridContext;
// node_modules/@taroify/core/grid/grid.js
var DEFAULT_GRID_COLUMNS = 4;
function Grid(props) {
    const { className, style: styleProp, columns = DEFAULT_GRID_COLUMNS, gutter, bordered = true, centered = true, clickable = false, direction = "vertical", square, children: childrenProp } = props, restProps = _object_without_properties(props, [
        "className",
        "style",
        "columns",
        "gutter",
        "bordered",
        "centered",
        "clickable",
        "direction",
        "square",
        "children"
    ]);
    const children2 = (0, import_react184.useMemo)(()=>import_react184.Children.map(childrenProp, (item, index)=>item ? (0, import_react184.cloneElement)(item, {
                __dataIndex__: index
            }) : null), [
        childrenProp
    ]);
    const rootStyle = (0, import_react184.useMemo)(()=>{
        const style = _object_spread({}, styleProp);
        if (gutter) {
            style.paddingLeft = addUnitPx(gutter);
        }
        return style;
    }, [
        gutter,
        styleProp
    ]);
    return React168.createElement(View, _object_spread({
        style: rootStyle,
        className: (0, import_classnames140.default)(prefixClassname("grid"), {
            [HAIRLINE_BORDER_TOP]: bordered && gutter === void 0
        }, className)
    }, restProps), React168.createElement(grid_context_default.Provider, {
        value: {
            bordered,
            centered,
            columns,
            clickable,
            direction,
            gutter,
            square
        }
    }, children2));
}
var grid_default = Grid;
// node_modules/@taroify/core/grid/grid-item.js
var import_classnames141 = __toESM(require_classnames());
var React169 = __toESM(require_react());
var import_react185 = __toESM(require_react());
function useGridItemPercent(columns) {
    return (0, import_react185.useMemo)(()=>`${100 / columns}%`, [
        columns
    ]);
}
function GridItem(props) {
    const { __dataIndex__ = 0, className, style: styleProp, icon: iconProp, text, dot, badge, children: children2 } = props, restProps = _object_without_properties(props, [
        "__dataIndex__",
        "className",
        "style",
        "icon",
        "text",
        "dot",
        "badge",
        "children"
    ]);
    const { columns, gutter, bordered, centered, clickable, direction, square } = (0, import_react185.useContext)(grid_context_default);
    const percent = useGridItemPercent(columns);
    const rootStyle = (0, import_react185.useMemo)(()=>{
        const style = _object_spread({}, styleProp);
        style.flexBasis = `${percent}`;
        if (square) {
            style.paddingTop = percent;
        } else if (gutter) {
            const gutterValue = addUnitPx(gutter);
            style.paddingRight = gutterValue;
            if (__dataIndex__ >= columns) {
                style.marginTop = gutterValue;
            }
        }
        return style;
    }, [
        styleProp,
        percent,
        square,
        gutter,
        __dataIndex__,
        columns
    ]);
    const contentStyle = (0, import_react185.useMemo)(()=>{
        if (square && gutter) {
            const gutterValue = addUnitPx(gutter);
            return {
                right: gutterValue,
                bottom: gutterValue,
                height: "auto"
            };
        }
    }, [
        square,
        gutter
    ]);
    const icon = (0, import_react185.isValidElement)(iconProp) ? (0, import_react185.cloneElement)(iconProp, {
        className: prefixClassname("grid-item__icon")
    }) : iconProp;
    return React169.createElement(View, _object_spread({
        className: (0, import_classnames141.default)(prefixClassname("grid-item"), {
            [prefixClassname("grid-item--square")]: square
        }, className),
        style: rootStyle
    }, restProps), React169.createElement(View, {
        style: contentStyle,
        className: (0, import_classnames141.default)(prefixClassname("grid-item__content"), {
            [prefixClassname("grid-item__content--square")]: square,
            [prefixClassname("grid-item__content--centered")]: centered,
            [prefixClassname("grid-item__content--clickable")]: clickable,
            [prefixClassname("grid-item__content--horizontal")]: direction === "horizontal",
            [prefixClassname("grid-item__content--surround")]: bordered && gutter,
            [HAIRLINE_BORDER]: bordered
        })
    }, children2 === void 0 ? React169.createElement(React169.Fragment, null, badge ? React169.createElement(badge_default2, {
        className: prefixClassname("grid-item__icon-wrapper"),
        content: badge,
        dot,
        children: icon
    }) : icon, React169.createElement(View, {
        className: prefixClassname("grid-item__text")
    }, text)) : children2));
}
var grid_item_default = GridItem;
// node_modules/@taroify/core/grid/index.js
var Grid2 = grid_default;
Grid2.Item = grid_item_default;
var grid_default2 = Grid2;
// node_modules/@taroify/core/index-list/index-list.js
var import_classnames145 = __toESM(require_classnames());
var import_isNumber13 = __toESM(require_isNumber());
var import_size16 = __toESM(require_size());
var import_map19 = __toESM(require_map());
var React173 = __toESM(require_react());
var import_react190 = __toESM(require_react());
var import_react_is = __toESM(require_react_is2());
// node_modules/@taroify/core/index-list/index-list-anchor.js
var import_classnames142 = __toESM(require_classnames());
var React170 = __toESM(require_react());
var import_react187 = __toESM(require_react());
// node_modules/@taroify/core/index-list/index-list.context.js
var import_react186 = __toESM(require_react());
var IndexListContext = (0, import_react186.createContext)({
    activeIndex: -1,
    activeArrayedIndex: -1,
    inner: false,
    getListRect: ()=>makeRect(0, 0),
    getAnchorRects: ()=>[],
    getFirstAnchorTop: ()=>0
});
var index_list_context_default = IndexListContext;
// node_modules/@taroify/core/index-list/index-list-anchor.js
var IndexListAnchor = (0, import_react187.forwardRef)((props, ref)=>{
    const { arrayedIndex, index, children: children2, className } = props, restProps = _object_without_properties(props, [
        "arrayedIndex",
        "index",
        "children",
        "className"
    ]);
    const { activeArrayedIndex, sticky: stickyProp, stickyOffsetTop, inner, getAnchorRects, getListRect, getFirstAnchorTop } = (0, import_react187.useContext)(index_list_context_default);
    const rootRef = (0, import_react187.useRef)();
    const scrollIntoView = (0, import_react187.useCallback)((scrollTop)=>getRect(rootRef).then(({ top })=>pageScrollTo({
                duration: 0,
                scrollTop: Math.ceil(scrollTop + top)
            })), []);
    (0, import_react187.useImperativeHandle)(ref, ()=>({
            scrollIntoView
        }));
    let wrapperStyle = {};
    let anchorStyle = {};
    let active = false;
    if (stickyProp) {
        if (arrayedIndex === activeArrayedIndex) {
            const { top, height } = getAnchorRects()[arrayedIndex];
            const activeAnchorSticky = top - getFirstAnchorTop() <= 0;
            if (activeAnchorSticky) {
                wrapperStyle = {
                    height: addUnitPx(height)
                };
                anchorStyle = {
                    position: inner ? "absolute" : "fixed",
                    top: addUnitPx(stickyOffsetTop)
                };
            }
            active = true;
        } else if (arrayedIndex === activeArrayedIndex - 1) {
            const listRect = getListRect();
            const anchorRects = getAnchorRects();
            const currentAnchor = anchorRects[arrayedIndex];
            const currentOffsetTop = currentAnchor.top;
            const targetOffsetTop = arrayedIndex === anchorRects.length - 1 ? listRect.top : anchorRects[arrayedIndex + 1].top;
            const parentOffsetHeight = targetOffsetTop - currentOffsetTop;
            const translateY = parentOffsetHeight - currentAnchor.height;
            anchorStyle = {
                position: "relative",
                transform: `translate3d(0, ${addUnitPx(translateY)}, 0)`
            };
            active = true;
        } else {
            wrapperStyle = {};
            anchorStyle = {};
            active = false;
        }
    }
    return React170.createElement(View, _object_spread({
        ref: rootRef,
        className: (0, import_classnames142.default)(prefixClassname("index-list__anchor-wrapper"), className),
        style: wrapperStyle
    }, restProps), React170.createElement(View, {
        className: (0, import_classnames142.default)(prefixClassname("index-list__anchor"), {
            [prefixClassname("index-list__anchor--sticky")]: active,
            [HAIRLINE_BORDER_BOTTOM]: active
        }),
        style: anchorStyle,
        children: children2 !== null && children2 !== void 0 ? children2 : index
    }));
});
var index_list_anchor_default = IndexListAnchor;
// node_modules/@taroify/core/index-list/index-list-index.js
var import_classnames143 = __toESM(require_classnames());
var React171 = __toESM(require_react());
var import_react188 = __toESM(require_react());
function IndexListIndex(props) {
    const { index } = props;
    const { activeIndex } = (0, import_react188.useContext)(index_list_context_default);
    return React171.createElement(View, {
        className: (0, import_classnames143.default)(prefixClassname("index-list__index"), {
            [prefixClassname("index-list__index--active")]: activeIndex === index
        }),
        children: index
    });
}
// node_modules/@taroify/core/index-list/index-list-sidebar.js
var React172 = __toESM(require_react());
var import_react189 = __toESM(require_react());
var import_classnames144 = __toESM(require_classnames());
var IndexListSidebar = (0, import_react189.forwardRef)((props, ref)=>{
    const { inner, children: children2, onClick, onTouchStart, onTouchMove, onTouchCancel, onTouchEnd } = props;
    return React172.createElement(View, {
        ref,
        catchMove: true,
        className: (0, import_classnames144.default)(prefixClassname("index-list__sidebar"), {
            inner
        }),
        children: children2,
        onClick,
        onTouchStart,
        onTouchMove,
        onTouchCancel,
        onTouchEnd
    });
});
var index_list_sidebar_default = IndexListSidebar;
// node_modules/@taroify/core/index-list/index-list.js
function childrenIndexBar(children2, __children__, parentIndex) {
    import_react190.Children.forEach(children2, (child, index)=>{
        if (!(0, import_react190.isValidElement)(child)) {
            return;
        }
        const element = child;
        const elementType = element.type;
        const { key, props } = element;
        const { children: childrenProp } = props;
        if ((0, import_react_is.isFragment)(element)) {
            childrenIndexBar(childrenProp, __children__, key !== null && key !== void 0 ? key : index);
            return;
        }
        if (elementType === index_list_anchor_default) {
            var __children___children;
            const { index: indexProp } = props;
            const anchorRef = (0, import_react190.createRef)();
            const { length: arrayedIndex } = __children__.anchorRefs;
            __children__.anchorRefs.push(anchorRef);
            __children__.anchorProps.push(props);
            (__children___children = __children__.children) === null || __children___children === void 0 ? void 0 : __children___children.push((0, import_react190.cloneElement)(element, {
                arrayedIndex,
                key: indexProp,
                ref: anchorRef
            }));
        } else {
            var __children___children1;
            (__children___children1 = __children__.children) === null || __children___children1 === void 0 ? void 0 : __children___children1.push((0, import_react190.cloneElement)(element, {
                key: key !== null && key !== void 0 ? key : `${parentIndex}-${index}`
            }));
        }
    });
}
function useIndexBarChildren(children2) {
    return (0, import_react190.useMemo)(()=>{
        const __children__ = {
            children: [],
            anchorRefs: [],
            anchorProps: []
        };
        childrenIndexBar(children2, __children__);
        return __children__;
    }, [
        children2
    ]);
}
var IndexList = (0, import_react190.forwardRef)((props, ref)=>{
    const { className, sticky = true, stickyOffsetTop = 0, inner = false, delay: delayProp, showSidebar = true, children: childrenProp, onChange } = props, restProps = _object_without_properties(props, [
        "className",
        "sticky",
        "stickyOffsetTop",
        "inner",
        "delay",
        "showSidebar",
        "children",
        "onChange"
    ]);
    const delay = inner ? (0, import_isNumber13.default)(delayProp) ? delayProp : 300 : 0;
    const TagElement = inner ? ScrollView : View;
    const { anchorProps, anchorRefs, children: children2 } = useIndexBarChildren(childrenProp);
    const scrollTopRef = (0, import_react190.useRef)(0);
    const listRef = (0, import_react190.useRef)();
    const sidebarRef = (0, import_react190.useRef)();
    const listRectRef = (0, import_react190.useRef)(makeRect(0, 0));
    const sidebarRectRef = (0, import_react190.useRef)(makeRect(0, 0));
    const anchorRectsRef = (0, import_react190.useRef)([]);
    const anchorRectsCacheRef = (0, import_react190.useRef)([]);
    const firstAnchorTop = (0, import_react190.useRef)(0);
    const scrolling = (0, import_react190.useRef)(false);
    const [activeAnchor, setActiveAnchor] = (0, import_react190.useState)({});
    const [scrollTop, setScrollTop] = (0, import_react190.useState)();
    const getListRect = (0, import_react190.useCallback)(()=>getRect(listRef).then((rect)=>_object_spread_props(_object_spread({}, rect), {
                top: rect.top + scrollTopRef.current
            })), []);
    const getSidebarRect = (0, import_react190.useCallback)(()=>getRect(sidebarRef), []);
    const getAnchorRects = (0, import_react190.useCallback)(()=>getRects(listRef, ` .${prefixClassname("index-list__anchor-wrapper")}`), []);
    const scrollToAnchorIndexRef = (0, import_react190.useRef)();
    const getActiveAnchor = (0, import_react190.useCallback)(()=>{
        const { current: anchorRects } = anchorRectsRef;
        for(let i = anchorRefs.length - 1; i >= 0; i--){
            const prevHeight = i > 0 ? anchorRects[i - 1].height : 0;
            const reachTop = sticky ? prevHeight : 0;
            if (reachTop + firstAnchorTop.current >= anchorRects[i].top) {
                return i;
            }
        }
        return -1;
    }, [
        anchorRefs.length,
        sticky
    ]);
    const onScroll = (0, import_react190.useCallback)(/*#__PURE__*/ _async_to_generator(function*() {
        const arrayedIndex = getActiveAnchor();
        if (arrayedIndex >= 0) {
            setActiveAnchor({
                arrayedIndex,
                index: anchorProps[arrayedIndex].index
            });
            if (scrollToAnchorIndexRef.current !== arrayedIndex) {
                scrollToAnchorIndexRef.current = arrayedIndex;
                onChange === null || onChange === void 0 ? void 0 : onChange(arrayedIndex, anchorProps[arrayedIndex].index);
            }
        } else {
            setActiveAnchor({});
        }
    }), [
        anchorProps,
        getActiveAnchor
    ]);
    const scrollToAnchor = (0, import_react190.useCallback)((anchorArrayedIndex)=>{
        if (anchorArrayedIndex < 0 || scrollToAnchorIndexRef.current === anchorArrayedIndex) {
            return;
        }
        if (inner) {
            setScrollTop(anchorRectsCacheRef.current[anchorArrayedIndex].top - firstAnchorTop.current);
            return;
        }
        scrollToAnchorIndexRef.current = anchorArrayedIndex;
        const { current: matchInstance } = anchorRefs[anchorArrayedIndex];
        matchInstance === null || matchInstance === void 0 ? void 0 : matchInstance.scrollIntoView(scrollTopRef.current);
    }, [
        anchorRefs
    ]);
    const getAnchorArrayedIndex = (0, import_react190.useCallback)((event)=>{
        const { current: sidebarRect } = sidebarRectRef;
        const touch = getClientCoordinates(event);
        const sidebarLength = (0, import_size16.default)(anchorRefs);
        const itemHeight = sidebarRect.height / sidebarLength;
        let index = Math.floor((touch.clientY - sidebarRect.top) / itemHeight);
        if (index < 0) {
            index = 0;
        } else if (index > sidebarLength - 1) {
            index = sidebarLength - 1;
        }
        return index;
    }, [
        anchorRefs
    ]);
    const scrollToEvent = (0, import_react190.useCallback)((event)=>{
        const arrayedIndex = getAnchorArrayedIndex(event);
        scrollToAnchor(arrayedIndex);
    }, [
        getAnchorArrayedIndex,
        scrollToAnchor
    ]);
    const onSidebarClick = (0, import_react190.useCallback)((event)=>scrollToEvent(event), [
        scrollToEvent
    ]);
    const onTouchStart = (0, import_react190.useCallback)(()=>{
        scrolling.current = true;
    }, [
        scrolling
    ]);
    const onTouchMove = (0, import_react190.useCallback)((event)=>{
        preventDefault(event);
        scrollToEvent(event);
    }, [
        scrollToEvent
    ]);
    const onTouchStop = (0, import_react190.useCallback)(()=>scrollToAnchorIndexRef.current = void 0, []);
    const getRectAll = (init)=>{
        setTimeout(()=>{
            Promise.all([
                getListRect(),
                getSidebarRect(),
                getAnchorRects()
            ]).then((rects)=>{
                const [listRect, sidebarRect, anchorRects] = rects;
                listRectRef.current = listRect;
                sidebarRectRef.current = sidebarRect;
                anchorRectsRef.current = anchorRects;
                if (init && inner) {
                    var _anchorRects_;
                    anchorRectsCacheRef.current = anchorRects;
                    firstAnchorTop.current = ((_anchorRects_ = anchorRects[0]) === null || _anchorRects_ === void 0 ? void 0 : _anchorRects_.top) || 0;
                }
            }).then(onScroll);
        }, (0, import_isNumber13.default)(delay) ? delay + 1 : 0);
    };
    (0, import_react190.useEffect)(()=>{
        getRectAll(true);
    }, []);
    usePageScroll(({ scrollTop: scrollTop2 })=>{
        if (inner) {
            return;
        }
        scrollTopRef.current = scrollTop2;
        getRectAll();
    });
    const onPageScroll = (e)=>{
        const { scrollTop: scrollTop2 } = e.detail;
        scrollTopRef.current = scrollTop2;
        getRectAll();
        if (scrolling.current) {
            return;
        }
        getEnv() === "WEB" && setScrollTop(scrollTop2);
    };
    const sidebarIndexes = (0, import_react190.useMemo)(()=>(0, import_map19.default)(anchorProps, (anchorProp)=>React173.createElement(IndexListIndex, {
                key: anchorProp.index,
                index: anchorProp.index
            })), [
        anchorProps
    ]);
    (0, import_react190.useImperativeHandle)(ref, ()=>{
        return {
            scrollTo (index) {
                scrollToAnchor(index);
            }
        };
    });
    var _activeAnchor_index, _activeAnchor_arrayedIndex;
    return React173.createElement(index_list_context_default.Provider, {
        value: {
            sticky,
            stickyOffsetTop,
            inner,
            activeIndex: (_activeAnchor_index = activeAnchor === null || activeAnchor === void 0 ? void 0 : activeAnchor.index) !== null && _activeAnchor_index !== void 0 ? _activeAnchor_index : -1,
            activeArrayedIndex: (_activeAnchor_arrayedIndex = activeAnchor === null || activeAnchor === void 0 ? void 0 : activeAnchor.arrayedIndex) !== null && _activeAnchor_arrayedIndex !== void 0 ? _activeAnchor_arrayedIndex : -1,
            getListRect: ()=>listRectRef.current,
            getAnchorRects: ()=>anchorRectsRef.current,
            getFirstAnchorTop: ()=>firstAnchorTop.current
        }
    }, React173.createElement(View, {
        className: (0, import_classnames145.default)(prefixClassname("index-list"), {
            inner
        }, className)
    }, showSidebar && React173.createElement(index_list_sidebar_default, {
        ref: sidebarRef,
        inner,
        onClick: onSidebarClick,
        onTouchStart,
        onTouchMove,
        onTouchCancel: onTouchStop,
        onTouchEnd: onTouchStop
    }, sidebarIndexes), React173.createElement(TagElement, _object_spread({
        scrollY: true,
        ref: listRef,
        className: (0, import_classnames145.default)({
            [prefixClassname("index-list_scroll")]: inner
        }),
        scrollTop,
        scrollWithAnimation: true,
        scrollAnchoring: true,
        onScroll: onPageScroll,
        onTouchStart: ()=>{
            scrolling.current = false;
        }
    }, restProps), children2)));
});
var index_list_default = IndexList;
// node_modules/@taroify/core/index-list/index.js
var IndexList2 = index_list_default;
IndexList2.Anchor = index_list_anchor_default;
var index_list_default2 = IndexList2;
// node_modules/@taroify/core/navbar/navbar.js
var import_classnames149 = __toESM(require_classnames());
var React177 = __toESM(require_react());
var import_react193 = __toESM(require_react());
// node_modules/@taroify/core/navbar/navbar-left.js
var import_classnames146 = __toESM(require_classnames());
var React174 = __toESM(require_react());
var import_react191 = __toESM(require_react());
function NavBarLeft(props) {
    const { className, icon = React174.createElement(ArrowLeft_default, null), children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "icon",
        "children"
    ]);
    return React174.createElement(View, _object_spread({
        className: (0, import_classnames146.default)(prefixClassname("navbar__left"), className)
    }, restProps), icon && cloneIconElement(icon, {
        className: prefixClassname("navbar__icon")
    }), (0, import_react191.isValidElement)(children2) ? children2 : React174.createElement(View, {
        className: prefixClassname("navbar__text"),
        children: children2
    }));
}
var navbar_left_default = NavBarLeft;
// node_modules/@taroify/core/navbar/navbar-right.js
var import_classnames147 = __toESM(require_classnames());
var React175 = __toESM(require_react());
var import_react192 = __toESM(require_react());
function NavBarRight(props) {
    const { className, icon, children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "icon",
        "children"
    ]);
    return React175.createElement(View, _object_spread({
        className: (0, import_classnames147.default)(prefixClassname("navbar__right"), className)
    }, restProps), icon && cloneIconElement(icon, {
        className: prefixClassname("navbar__icon")
    }), (0, import_react192.isValidElement)(children2) ? children2 : React175.createElement(View, {
        className: prefixClassname("navbar__text"),
        children: children2
    }));
}
var navbar_right_default = NavBarRight;
// node_modules/@taroify/core/navbar/navbar-title.js
var import_classnames148 = __toESM(require_classnames());
var React176 = __toESM(require_react());
function NavBarTitle(props) {
    const { className } = props, restProps = _object_without_properties(props, [
        "className"
    ]);
    return React176.createElement(View, _object_spread({
        className: (0, import_classnames148.default)(prefixClassname("navbar__title"), className)
    }, restProps));
}
var navbar_title_default = NavBarTitle;
// node_modules/@taroify/core/navbar/navbar.js
function useNavbarChildren(children2) {
    return (0, import_react193.useMemo)(()=>{
        const __children__ = {
            left: void 0,
            right: void 0,
            title: void 0
        };
        import_react193.Children.forEach(children2, (child)=>{
            if ((0, import_react193.isValidElement)(child)) {
                const element = child;
                const { type } = element;
                if (type === navbar_left_default) {
                    __children__.left = element;
                } else if (type === navbar_right_default) {
                    __children__.right = element;
                } else if (type === navbar_title_default) {
                    __children__.title = element;
                }
            }
        });
        return __children__;
    }, [
        children2
    ]);
}
function Navbar(props) {
    const { className, bordered, fixed, placeholder, safeArea, nativeSafeTop, title: titleProp, children: childrenProp } = props, restProps = _object_without_properties(props, [
        "className",
        "bordered",
        "fixed",
        "placeholder",
        "safeArea",
        "nativeSafeTop",
        "title",
        "children"
    ]);
    const { left, title, right } = useNavbarChildren(childrenProp);
    return React177.createElement(fixed_view_default, {
        position: fixed && "top",
        safeArea,
        nativeSafeTop,
        placeholder: fixed && placeholder && prefixClassname("navbar__placeholder")
    }, React177.createElement(View, _object_spread({
        className: (0, import_classnames149.default)(prefixClassname("navbar"), {
            [HAIRLINE_BORDER_BOTTOM]: bordered
        }, className)
    }, restProps), React177.createElement(View, {
        className: (0, import_classnames149.default)(prefixClassname("navbar__content"))
    }, left, title !== null && title !== void 0 ? title : React177.createElement(View, {
        className: (0, import_classnames149.default)(prefixClassname("navbar__title")),
        children: titleProp
    }), right)));
}
var navbar_default = Navbar;
// node_modules/@taroify/core/navbar/index.js
var Navbar2 = navbar_default;
Navbar2.NavLeft = navbar_left_default;
Navbar2.NavRight = navbar_right_default;
Navbar2.Title = navbar_title_default;
var navbar_default2 = Navbar2;
// node_modules/@taroify/core/pagination/pagination.shared.js
var ItemType;
(function(ItemType2) {
    ItemType2["Page"] = "page";
    ItemType2["First"] = "first";
    ItemType2["Last"] = "last";
    ItemType2["Previous"] = "previous";
    ItemType2["Next"] = "next";
    ItemType2["StartEllipsis"] = "start-ellipsis";
    ItemType2["EndEllipsis"] = "end-ellipsis";
})(ItemType || (ItemType = {}));
// node_modules/@taroify/core/pagination/pagination.js
var import_classnames150 = __toESM(require_classnames());
var React178 = __toESM(require_react());
var import_react195 = __toESM(require_react());
// node_modules/@taroify/core/pagination/pagination.context.js
var import_react194 = __toESM(require_react());
var PaginationContext = (0, import_react194.createContext)({
    current: 0,
    prevText: "",
    nextText: "",
    count: 0,
    siblingCount: 0
});
var pagination_context_default = PaginationContext;
// node_modules/@taroify/core/pagination/pagination.js
function rangePages(start, end) {
    const length = end - start + 1;
    return Array.from({
        length
    }, (_, i)=>start + i);
}
function makePageItems(start, end) {
    return rangePages(start, end).map((page)=>React178.createElement(Pagination.Item, {
            key: page,
            page
        }));
}
function usePagination(options) {
    const { current, count, siblingCount, children: children2, mode } = options;
    const siblingRange = siblingCount * 2 + 1;
    let start = Math.max(current - siblingCount, 1);
    let end = start + siblingRange - 1;
    if (end > count) {
        end = count;
        start = Math.max(end - siblingRange + 1, 1);
    }
    const hasPrevious = current > 1;
    const hasStartEllipsis = start > 1;
    const hasEndEllipsis = end < count;
    const hasNext = current < count;
    const items = (0, import_react195.useMemo)(()=>mode === "simple" ? void 0 : makePageItems(start, end), [
        start,
        end
    ]);
    const __children__ = {
        previous: void 0,
        startEllipsis: void 0,
        items,
        desc: mode === "simple" ? React178.createElement(Pagination.Desc, null) : void 0,
        next: void 0
    };
    import_react195.Children.forEach(children2, (child)=>{
        if (!(0, import_react195.isValidElement)(child)) {
            return;
        }
        const element = child;
        const elementType = element.type;
        if (elementType === Pagination.Item) {
            const { type: itemType } = element.props;
            if (itemType === ItemType.Previous && __children__.previous === void 0) {
                __children__.previous = (0, import_react195.cloneElement)(element, {
                    disabled: !hasPrevious
                });
            } else if (itemType === ItemType.StartEllipsis && __children__.startEllipsis === void 0 && hasStartEllipsis) {
                __children__.startEllipsis = element;
            } else if (itemType === ItemType.EndEllipsis && hasEndEllipsis) {
                __children__.endEllipsis = element;
            } else if (itemType === ItemType.Next) {
                __children__.next = (0, import_react195.cloneElement)(element, {
                    disabled: !hasNext
                });
            }
        }
    });
    if (__children__.previous === void 0) {
        __children__.previous = React178.createElement(Pagination.Item, {
            page: Number.MIN_SAFE_INTEGER,
            type: "previous",
            disabled: !hasPrevious
        });
    }
    if (__children__.next === void 0) {
        __children__.next = React178.createElement(Pagination.Item, {
            page: Number.MAX_SAFE_INTEGER,
            type: "next",
            disabled: !hasNext
        });
    }
    return __children__;
}
function Pagination(props) {
    const { className, mode = "multi", current = 1, prevText = "\u4E0A\u4E00\u9875", nextText = "\u4E0B\u4E00\u9875", siblingCount = 2, count = 1, children: children2, onChange } = props, restProps = _object_without_properties(props, [
        "className",
        "mode",
        "current",
        "prevText",
        "nextText",
        "siblingCount",
        "count",
        "children",
        "onChange"
    ]);
    const { previous, startEllipsis, items, endEllipsis, next, desc } = usePagination({
        current,
        siblingCount,
        count,
        children: children2,
        mode
    });
    function emitClick(page) {
        const { page: pageNumber } = page;
        const siblingRange = siblingCount * 2 + 1;
        if (page.type === ItemType.Previous) {
            onChange === null || onChange === void 0 ? void 0 : onChange(Math.max(current - 1, 1));
        } else if (page.type === ItemType.StartEllipsis) {
            onChange === null || onChange === void 0 ? void 0 : onChange(Math.max(current - siblingRange, 1));
        } else if (page.type === ItemType.Page) {
            onChange === null || onChange === void 0 ? void 0 : onChange(pageNumber);
        } else if (page.type === ItemType.EndEllipsis) {
            onChange === null || onChange === void 0 ? void 0 : onChange(Math.min(current + siblingRange, count));
        } else if (page.type === ItemType.Next) {
            onChange === null || onChange === void 0 ? void 0 : onChange(Math.min(current + 1, count));
        }
    }
    return React178.createElement(View, _object_spread({
        className: (0, import_classnames150.default)(prefixClassname("pagination"), className)
    }, restProps), React178.createElement(pagination_context_default.Provider, {
        value: {
            current,
            prevText,
            nextText,
            count,
            siblingCount,
            emitClick
        }
    }, previous, mode === "simple" ? desc : React178.createElement(import_react195.Fragment, null, startEllipsis, items, endEllipsis), next));
}
(function(Pagination2) {
    function BaseItem(props) {
        const { className, style, hidden, disabled, children: children2, onClick } = props;
        return React178.createElement(View, {
            className: (0, import_classnames150.default)(prefixClassname("pagination__item"), HAIRLINE_BORDER, {
                [prefixClassname("pagination__item--disabled")]: disabled,
                [prefixClassname("pagination__item--hidden")]: hidden
            }, className),
            style,
            children: children2,
            onClick
        });
    }
    function Item(props) {
        const { className, page = 0, type = ItemType.Page, disabled = false, children: children2, onClick } = props, restProps = _object_without_properties(props, [
            "className",
            "page",
            "type",
            "disabled",
            "children",
            "onClick"
        ]);
        const { current, prevText, nextText, emitClick } = (0, import_react195.useContext)(pagination_context_default);
        const active = page === current;
        function renderChildren() {
            let __children__ = children2;
            if (__children__ === void 0) {
                if (type === ItemType.Previous) {
                    __children__ = prevText;
                } else if (type === ItemType.StartEllipsis || type === ItemType.EndEllipsis) {
                    __children__ = "...";
                } else if (type === ItemType.Next) {
                    __children__ = nextText;
                } else if (type === ItemType.Page) {
                    __children__ = page;
                }
            }
            return __children__;
        }
        return React178.createElement(BaseItem, _object_spread({
            className: (0, import_classnames150.default)({
                [prefixClassname("pagination__item--active")]: !disabled && active,
                [prefixClassname("pagination__page")]: type === ItemType.Page,
                [prefixClassname("pagination__start-ellipsis")]: type === ItemType.StartEllipsis,
                [prefixClassname("pagination__end-ellipsis")]: type === ItemType.EndEllipsis,
                [prefixClassname("pagination__button")]: type === ItemType.Previous || ItemType.Next
            }, className),
            disabled: disabled && !active,
            children: renderChildren(),
            onClick: ()=>emitClick === null || emitClick === void 0 ? void 0 : emitClick({
                    page,
                    type
                })
        }, restProps));
    }
    Pagination2.Item = Item;
    function Desc() {
        const { current, count } = (0, import_react195.useContext)(pagination_context_default);
        return React178.createElement(View, {
            className: (0, import_classnames150.default)(prefixClassname("pagination__desc"))
        }, current, "/", count);
    }
    Pagination2.Desc = Desc;
})(Pagination || (Pagination = {}));
var pagination_default = Pagination;
// node_modules/@taroify/core/sidebar/sidebar.js
var import_classnames152 = __toESM(require_classnames());
var React180 = __toESM(require_react());
var import_react198 = __toESM(require_react());
// node_modules/@taroify/core/sidebar/sidebar-tab.js
var import_classnames151 = __toESM(require_classnames());
var React179 = __toESM(require_react());
var import_react197 = __toESM(require_react());
// node_modules/@taroify/core/sidebar/sidebar.context.js
var import_react196 = __toESM(require_react());
var SidebarContext = (0, import_react196.createContext)({});
var sidebar_context_default = SidebarContext;
// node_modules/@taroify/core/sidebar/sidebar-tab.js
function SidebarTabContent(props) {
    const { badge, children: children2 } = props;
    return React179.createElement(badge_default2, {
        className: prefixClassname("sidebar-tab__content"),
        children: children2,
        content: badge
    });
}
function SidebarTab(props) {
    const { value, className, disabled, badge, children: children2, onClick } = props, restProps = _object_without_properties(props, [
        "value",
        "className",
        "disabled",
        "badge",
        "children",
        "onClick"
    ]);
    const { value: activeValue, onTabClick } = (0, import_react197.useContext)(sidebar_context_default);
    const active = activeValue === value;
    const handleClick = (0, import_react197.useCallback)((event)=>{
        onClick === null || onClick === void 0 ? void 0 : onClick(event);
        onTabClick === null || onTabClick === void 0 ? void 0 : onTabClick({
            value,
            disabled,
            children: children2
        });
    }, [
        children2,
        disabled,
        onClick,
        onTabClick,
        value
    ]);
    return React179.createElement(View, _object_spread({
        className: (0, import_classnames151.default)(prefixClassname("sidebar-tab"), {
            [prefixClassname("sidebar-tab--active")]: active,
            [prefixClassname("sidebar-tab--disabled")]: disabled
        }, className),
        onClick: handleClick
    }, restProps), React179.createElement(SidebarTabContent, {
        badge,
        children: children2
    }));
}
var sidebar_tab_default = SidebarTab;
// node_modules/@taroify/core/sidebar/sidebar.js
function useSidebarChildren(children2) {
    return (0, import_react198.useMemo)(()=>import_react198.Children.map(children2, (node, index)=>{
            if (!(0, import_react198.isValidElement)(node)) {
                return node;
            }
            const element = node;
            if (element.type !== sidebar_tab_default) {
                return element;
            }
            const { key, props } = element;
            const { value: oldValue } = props, restProps = _object_without_properties(props, [
                "value"
            ]);
            const value = oldValue !== null && oldValue !== void 0 ? oldValue : index;
            return (0, import_react198.cloneElement)(element, _object_spread({
                key: key !== null && key !== void 0 ? key : value,
                value
            }, restProps));
        }), [
        children2
    ]);
}
function Sidebar(props) {
    const { className, defaultValue, value: valueProp, onChange, children: childrenProp } = props, restProps = _object_without_properties(props, [
        "className",
        "defaultValue",
        "value",
        "onChange",
        "children"
    ]);
    const { value = 0, setValue } = useUncontrolled({
        value: valueProp,
        defaultValue
    });
    const children2 = useSidebarChildren(childrenProp);
    const onTabClick = (0, import_react198.useCallback)((tab)=>{
        const { disabled, value: value2 } = tab;
        if (!disabled) {
            setValue(value2);
            onChange === null || onChange === void 0 ? void 0 : onChange(value2, tab);
        }
    }, [
        onChange,
        setValue
    ]);
    return React180.createElement(View, _object_spread({
        className: (0, import_classnames152.default)(prefixClassname("sidebar"), className)
    }, restProps), React180.createElement(sidebar_context_default.Provider, {
        value: {
            value,
            onTabClick
        },
        children: children2
    }));
}
var sidebar_default = Sidebar;
// node_modules/@taroify/core/sidebar/index.js
var Sidebar2 = sidebar_default;
Sidebar2.Tab = sidebar_tab_default;
var sidebar_default2 = Sidebar2;
// node_modules/@taroify/core/tabbar/tabbar.js
var import_classnames154 = __toESM(require_classnames());
var React182 = __toESM(require_react());
var import_react201 = __toESM(require_react());
// node_modules/@taroify/core/tabbar/tabbar-item.js
var import_classnames153 = __toESM(require_classnames());
var React181 = __toESM(require_react());
var import_react200 = __toESM(require_react());
// node_modules/@taroify/core/tabbar/tabbar.context.js
var import_react199 = __toESM(require_react());
var TabbarContext = (0, import_react199.createContext)({});
var tabbar_context_default = TabbarContext;
// node_modules/@taroify/core/tabbar/tabbar-item.js
function TabbarItem(props) {
    const { className, icon: iconProp, value: valueProp, badge, children: children2, onClick } = props, restProps = _object_without_properties(props, [
        "className",
        "icon",
        "value",
        "badge",
        "children",
        "onClick"
    ]);
    const { value, onItemClick } = (0, import_react200.useContext)(tabbar_context_default);
    const active = value === valueProp;
    const icon = (0, import_react200.isValidElement)(iconProp) ? (0, import_react200.cloneElement)(iconProp, {
        className: (0, import_classnames153.default)(iconProp.props.className, prefixClassname("tabbar-item__icon"))
    }) : iconProp;
    return React181.createElement(View, _object_spread({
        className: (0, import_classnames153.default)(prefixClassname("tabbar-item"), {
            [prefixClassname("tabbar-item--active")]: active
        }, className),
        onClick: (event)=>{
            onClick === null || onClick === void 0 ? void 0 : onClick(event);
            onItemClick === null || onItemClick === void 0 ? void 0 : onItemClick(valueProp);
        }
    }, restProps), icon && React181.createElement(badge_default2, {
        content: badge,
        children: icon
    }), React181.createElement(View, {
        className: prefixClassname("tabbar-item__label"),
        children: children2
    }));
}
// node_modules/@taroify/core/tabbar/tabbar.js
function useTabbarChildren(children2) {
    return (0, import_react201.useMemo)(()=>import_react201.Children.map(children2, (node, index)=>{
            if (!(0, import_react201.isValidElement)(node)) {
                return node;
            }
            const element = node;
            if (element.type !== TabbarItem) {
                return element;
            }
            const { props } = element;
            var _element_key;
            return (0, import_react201.cloneElement)(element, _object_spread({
                value: (_element_key = element.key) !== null && _element_key !== void 0 ? _element_key : index
            }, props));
        }), [
        children2
    ]);
}
function Tabbar(props) {
    const { className, defaultValue, value: valueProp, bordered, fixed, placeholder = true, safeArea, children: childrenProp, onChange: onChangeProp } = props, restProps = _object_without_properties(props, [
        "className",
        "defaultValue",
        "value",
        "bordered",
        "fixed",
        "placeholder",
        "safeArea",
        "children",
        "onChange"
    ]);
    const { value = 0, setValue } = useUncontrolled({
        value: valueProp,
        defaultValue,
        onChange: onChangeProp
    });
    const children2 = useTabbarChildren(childrenProp);
    function onItemClick(dataKey) {
        if (dataKey !== value) {
            setValue(dataKey);
        }
    }
    return React182.createElement(tabbar_context_default.Provider, {
        value: {
            value,
            onItemClick
        }
    }, React182.createElement(fixed_view_default, {
        position: fixed,
        safeArea,
        placeholder: fixed && placeholder && prefixClassname("tabbar__placeholder")
    }, React182.createElement(View, _object_spread({
        className: (0, import_classnames154.default)(prefixClassname("tabbar"), {
            [HAIRLINE_BORDER_TOP_BOTTOM]: bordered
        }, className),
        children: children2
    }, restProps))));
}
var tabbar_default = Tabbar;
// node_modules/@taroify/core/tabbar/index.js
var Tabbar2 = tabbar_default;
Tabbar2.TabItem = TabbarItem;
var tabbar_default2 = Tabbar2;
// node_modules/@taroify/core/tree-select/tree-select.js
var import_classnames157 = __toESM(require_classnames());
var import_isArray12 = __toESM(require_isArray());
var React185 = __toESM(require_react());
var import_react204 = __toESM(require_react());
// node_modules/@taroify/core/tree-select/tree-select-option.js
var import_classnames155 = __toESM(require_classnames());
var import_isArray11 = __toESM(require_isArray());
var import_includes2 = __toESM(require_includes());
var React183 = __toESM(require_react());
var import_react203 = __toESM(require_react());
// node_modules/@taroify/core/tree-select/tree-select.context.js
var import_react202 = __toESM(require_react());
var TreeSelectContext = (0, import_react202.createContext)({});
var tree_select_context_default = TreeSelectContext;
// node_modules/@taroify/core/tree-select/tree-select-option.js
function TreeSelectOption(props) {
    const { className, style, disabled = false, value, children: children2, onClick } = props, restProps = _object_without_properties(props, [
        "className",
        "style",
        "disabled",
        "value",
        "children",
        "onClick"
    ]);
    const { activeIcon, value: ctxValue, onOptionClick } = (0, import_react203.useContext)(tree_select_context_default);
    const active = (0, import_react203.useMemo)(()=>(0, import_isArray11.default)(ctxValue) ? (0, import_includes2.default)(ctxValue, value) : value === ctxValue, [
        ctxValue,
        value
    ]);
    const handleClick = (0, import_react203.useCallback)((event)=>{
        onClick === null || onClick === void 0 ? void 0 : onClick(event);
        onOptionClick === null || onOptionClick === void 0 ? void 0 : onOptionClick({
            active: !active,
            disabled,
            value,
            children: children2
        });
    }, [
        active,
        children2,
        disabled,
        onClick,
        onOptionClick,
        value
    ]);
    return React183.createElement(View, _object_spread({
        className: (0, import_classnames155.default)(prefixClassname("ellipsis"), prefixClassname("tree-select-option"), {
            [prefixClassname("tree-select-option--disabled")]: disabled,
            [prefixClassname("tree-select-option--active")]: active
        }, className),
        style,
        onClick: handleClick
    }, restProps), children2, active && cloneIconElement(activeIcon, {
        className: prefixClassname("tree-select-option__icon")
    }));
}
var tree_select_option_default = TreeSelectOption;
// node_modules/@taroify/core/tree-select/tree-select-tab.js
var import_classnames156 = __toESM(require_classnames());
var React184 = __toESM(require_react());
function TreeSelectTab(props) {
    const { className, title, children: children2 } = props, restProps = _object_without_properties(props, [
        "className",
        "title",
        "children"
    ]);
    return React184.createElement(sidebar_tab_default, _object_spread({
        className: (0, import_classnames156.default)(prefixClassname("tree-select-tab"), className),
        children: title
    }, restProps));
}
var tree_select_tab_default = TreeSelectTab;
// node_modules/@taroify/core/tree-select/tree-select.js
function getTreeSelectOptions(children2) {
    const options = [];
    import_react204.Children.forEach(children2, (child, index)=>{
        if (!(0, import_react204.isValidElement)(child)) {
            return;
        }
        const element = child;
        const elementType = element.type;
        if (elementType === tree_select_option_default) {
            const { key } = element;
            options.push((0, import_react204.cloneElement)(element, {
                key: key !== null && key !== void 0 ? key : index,
                __dataKey__: key !== null && key !== void 0 ? key : index,
                __dataIndex__: index
            }));
        } else {
            options.push(element);
        }
    });
    return options;
}
function useTreeSelectChildren(children2, tabValue) {
    const __children__ = {
        tabs: [],
        options: []
    };
    import_react204.Children.forEach(children2, (child, index)=>{
        if (!(0, import_react204.isValidElement)(child)) {
            return;
        }
        const element = child;
        const elementType = element.type;
        if (elementType === tree_select_tab_default) {
            const { key, props } = element;
            const { value: oldValue, children: childrenProp } = props, restProps = _object_without_properties(props, [
                "value",
                "children"
            ]);
            const value = oldValue !== null && oldValue !== void 0 ? oldValue : index;
            __children__.tabs.push((0, import_react204.cloneElement)(element, _object_spread({
                key: key !== null && key !== void 0 ? key : value,
                value,
                children: childrenProp
            }, restProps)));
            if (tabValue === value) {
                __children__.options.push(...getTreeSelectOptions(childrenProp));
            }
        }
    });
    return __children__;
}
function TreeSelect(props) {
    const { className, defaultTabValue, tabValue: tabValueProp, defaultValue, value: valueProp, activeIcon = React185.createElement(Success_default, null), children: childrenProp, onTabChange: onTabChangeProp, onChange: onChangeProp } = props, restProps = _object_without_properties(props, [
        "className",
        "defaultTabValue",
        "tabValue",
        "defaultValue",
        "value",
        "activeIcon",
        "children",
        "onTabChange",
        "onChange"
    ]);
    const { value: tabValue = 0, setValue: setTabValue } = useUncontrolled({
        value: tabValueProp,
        defaultValue: defaultTabValue,
        onChange: onTabChangeProp
    });
    const { value = 0, setValue } = useUncontrolled({
        value: valueProp,
        defaultValue,
        onChange: onChangeProp
    });
    const { tabs, options } = useTreeSelectChildren(childrenProp, tabValue);
    const onOptionClick = (0, import_react204.useCallback)(({ disabled, active, value: evtValue })=>{
        if (disabled) {
            return;
        }
        const multiselect = (0, import_isArray12.default)(value);
        if (multiselect) {
            if (active) {
                setValue(value.concat(evtValue));
            } else {
                setValue(value.filter((aValue)=>aValue !== evtValue));
            }
        } else {
            setValue(value === evtValue && !active ? void 0 : evtValue);
        }
    }, [
        value,
        setValue
    ]);
    return React185.createElement(tree_select_context_default.Provider, {
        value: {
            activeIcon,
            value,
            onOptionClick
        }
    }, React185.createElement(View, _object_spread({
        className: (0, import_classnames157.default)(prefixClassname("tree-select"), className)
    }, restProps), React185.createElement(sidebar_default2, {
        className: prefixClassname("tree-select__sidebar"),
        defaultValue: defaultTabValue,
        value: tabValue,
        onChange: (newTab)=>setTabValue(newTab),
        children: tabs
    }), React185.createElement(View, {
        className: prefixClassname("tree-select__content"),
        children: options
    })));
}
var tree_select_default = TreeSelect;
// node_modules/@taroify/core/tree-select/index.js
var TreeSelect2 = tree_select_default;
TreeSelect2.Tab = tree_select_tab_default;
TreeSelect2.Option = tree_select_option_default;
var tree_select_default2 = TreeSelect2;
// node_modules/@taroify/core/back-top/back-top.js
var React186 = __toESM(require_react());
var import_react205 = __toESM(require_react());
var import_classnames158 = __toESM(require_classnames());
var BackTop2 = (props)=>{
    const { className, style: styleProp, right = 30, bottom = 40, offset = 100, zIndex = 100, immediate = false, children: children2, onClick: onClickProp } = props;
    const [visible, setVisible] = (0, import_react205.useState)(false);
    const rootRef = (0, import_react205.useRef)();
    const scrollParent = (0, import_react205.useRef)();
    (0, import_react205.useEffect)(()=>{
        nextTick(/*#__PURE__*/ _async_to_generator(function*() {
            scrollParent.current = yield getScrollParent(rootRef.current);
        }));
    }, []);
    usePageScroll(/*#__PURE__*/ _async_to_generator(function*() {
        const top = yield getScrollTop(scrollParent.current);
        setVisible(scrollParent.current ? top >= offset : false);
    }));
    const rootStyle = (0, import_react205.useMemo)(()=>({
            zIndex,
            right: addUnitPx(right),
            bottom: addUnitPx(bottom)
        }), [
        right,
        bottom,
        offset,
        zIndex
    ]);
    const onClick = (event)=>{
        onClickProp === null || onClickProp === void 0 ? void 0 : onClickProp(event);
        if (inBrowser) {
            var _scrollParent_current;
            (_scrollParent_current = scrollParent.current) === null || _scrollParent_current === void 0 ? void 0 : _scrollParent_current.scrollTo({
                top: 0,
                behavior: immediate ? "auto" : "smooth"
            });
        }
    };
    return React186.createElement(View, {
        ref: rootRef,
        className: (0, import_classnames158.default)(prefixClassname("back-top"), className, {
            active: visible
        }),
        style: _object_spread({}, styleProp, rootStyle),
        onClick
    }, children2 ? children2 : React186.createElement(BackTop_default, null));
};
var back_top_default = BackTop2;
// node_modules/@taroify/core/fixed-nav/fixed-nav.js
var React187 = __toESM(require_react());
var import_react206 = __toESM(require_react());
var import_classnames159 = __toESM(require_classnames());
var FixedNav = (props)=>{
    const { className, style, open = false, backdrop = true, position = {
        top: "auto",
        bottom: "auto"
    }, type = "right", activeText = "\u6536\u8D77\u5BFC\u822A", inactiveText = "\u5FEB\u901F\u5BFC\u822A", data = [], content, children: children2, onChange, onClick } = props;
    const onValueChange = (val)=>{
        onChange === null || onChange === void 0 ? void 0 : onChange(val);
    };
    return React187.createElement(View, {
        className: (0, import_classnames159.default)(prefixClassname("fixed-nav"), {
            [prefixClassname("fixed-nav--active")]: open,
            [prefixClassname("fixed-nav--left")]: type === "left",
            [prefixClassname("fixed-nav--right")]: type === "right"
        }, className),
        style: _object_spread({}, position, style)
    }, React187.createElement(View, {
        className: (0, import_classnames159.default)(prefixClassname("fixed-nav_btn")),
        onClick: ()=>onValueChange(!open)
    }, content || React187.createElement(import_react206.Fragment, null, React187.createElement(ArrowLeft_default, {
        color: "#fff",
        className: (0, import_classnames159.default)(prefixClassname("fixed-nav_btn-icon"))
    }), React187.createElement(View, {
        className: (0, import_classnames159.default)(prefixClassname("fixed-nav_btn-text"))
    }, open ? activeText : inactiveText))), React187.createElement(View, null, children2 || React187.createElement(View, {
        className: (0, import_classnames159.default)(prefixClassname("fixed-nav_content"))
    }, data.map((item, index)=>React187.createElement(View, {
            key: item.id || index,
            className: (0, import_classnames159.default)(prefixClassname("fixed-nav_content--item")),
            onClick: ()=>onClick === null || onClick === void 0 ? void 0 : onClick(item)
        }, (0, import_react206.isValidElement)(item.icon) ? item.icon : React187.createElement(Image2, {
            src: item.icon,
            className: (0, import_classnames159.default)(prefixClassname("fixed-nav_content--img"))
        }), React187.createElement(Text, {
            className: (0, import_classnames159.default)(prefixClassname("fixed-nav_content--text"))
        }, item.text))))), backdrop && React187.createElement(Backdrop, {
        closeable: true,
        open,
        onClose: onValueChange
    }));
};
var fixed_nav_default = FixedNav;
// node_modules/@taroify/core/fixed-nav/index.js
var fixed_nav_default2 = fixed_nav_default;
export { action_sheet_default2 as ActionSheet, area_picker_default2 as AreaPicker, avatar_default2 as Avatar, back_top_default as BackTop, Backdrop, badge_default2 as Badge, button_default as Button, calendar_default2 as Calendar, cascader_default2 as Cascader, cell_default2 as Cell, checkbox_default as Checkbox, circle_default as Circle, col_default as Col, collapse_default2 as Collapse, config_provider_default as ConfigProvider, countdown_default as Countdown, datetime_picker_default2 as DatetimePicker, dialog_default2 as Dialog, divider_default as Divider, dropdown_menu_default2 as DropdownMenu, empty_default as Empty, field_default2 as Field, fixed_nav_default2 as FixedNav, fixed_view_default as FixedView, flex_default2 as Flex, floating_bubble_default as FloatingBubble, floating_panel_default2 as FloatingPanel, form_default2 as Form, grid_default2 as Grid, Image3 as Image, index_list_default2 as IndexList, input_default as Input, list_default2 as List, Loading, navbar_default2 as Navbar, notice_bar_default2 as NoticeBar, notify_default2 as Notify, number_keyboard_default2 as NumberKeyboard, pagination_default as Pagination, password_input_default2 as PasswordInput, picker_default2 as Picker, popup_default2 as Popup, progress_default2 as Progress, pull_refresh_default2 as PullRefresh, radio_default as Radio, rate_default as Rate, rolling_text_default2 as RollingText, row_default as Row, safe_area_default as SafeArea, search_default as Search, share_sheet_default2 as ShareSheet, sheet_default2 as Sheet, sidebar_default2 as Sidebar, signature_default2 as Signature, skeleton_default2 as Skeleton, slider_default2 as Slider, space_default as Space, stepper_default2 as Stepper, steps_default2 as Steps, sticky_default as Sticky, swipe_cell_default2 as SwipeCell, swiper_default2 as Swiper, switch_default as Switch, tabbar_default2 as Tabbar, tabs_default2 as Tabs, tag_default as Tag, text_ellipsis_default2 as TextEllipsis, textarea_default as Textarea, timeline_default2 as Timeline, toast_default as Toast, Transition2 as Transition, tree_select_default2 as TreeSelect, uploader_default as Uploader, watermark_default as Watermark, white_space_default as WhiteSpace }; /*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-reconciler/cjs/react-reconciler.development.js:
  (**
   * @license React
   * react-reconciler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-reconciler/cjs/react-reconciler-constants.development.js:
  (**
   * @license React
   * react-reconciler-constants.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/ 
