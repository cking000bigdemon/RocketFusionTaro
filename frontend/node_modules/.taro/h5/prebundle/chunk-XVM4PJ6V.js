function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self1 = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self1, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
import { useAddToFavorites, useDidHide, useDidShow, useError, useLaunch, useLoad, useOptionMenuClick, usePageNotFound, usePageScroll, usePullDownRefresh, usePullIntercept, useReachBottom, useReady, useResize, useRouter, useSaveExitState, useScope, useShareAppMessage, useShareTimeline, useTabItemTap, useTitleClick, useUnhandledRejection, useUnload } from "./chunk-UA4GZOHK.js";
import { Current, Events, __awaiter, __rest, _raf, addLeadingSlash, createPageConfig, eventCenter, getCurrentInstance, getCurrentPage, getHomePage, hooks, incrementId, isFunction, isObject, isUndefined, nextTick, options, stringify, stripBasename, stripSuffix, stripTrailing, toKebabCase } from "./chunk-6QIIT3JC.js";
import { __commonJS, __esm, __export, __glob, __toCommonJS, __toESM } from "./chunk-UG6XUGBP.js";
// node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
    "node_modules/strict-uri-encode/index.js" (exports2, module2) {
        "use strict";
        module2.exports = (str)=>encodeURIComponent(str).replace(/[!'()*]/g, (x)=>`%${x.charCodeAt(0).toString(16).toUpperCase()}`);
    }
});
// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
    "node_modules/decode-uri-component/index.js" (exports2, module2) {
        "use strict";
        var token = "%[a-f0-9]{2}";
        var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
        var multiMatcher = new RegExp("(" + token + ")+", "gi");
        function decodeComponents(components3, split2) {
            try {
                return [
                    decodeURIComponent(components3.join(""))
                ];
            } catch (err) {}
            if (components3.length === 1) {
                return components3;
            }
            split2 = split2 || 1;
            var left = components3.slice(0, split2);
            var right = components3.slice(split2);
            return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
        }
        function decode2(input) {
            try {
                return decodeURIComponent(input);
            } catch (err) {
                var tokens = input.match(singleMatcher) || [];
                for(var i2 = 1; i2 < tokens.length; i2++){
                    input = decodeComponents(tokens, i2).join("");
                    tokens = input.match(singleMatcher) || [];
                }
                return input;
            }
        }
        function customDecodeURIComponent(input) {
            var replaceMap = {
                "%FE%FF": "\uFFFD\uFFFD",
                "%FF%FE": "\uFFFD\uFFFD"
            };
            var match = multiMatcher.exec(input);
            while(match){
                try {
                    replaceMap[match[0]] = decodeURIComponent(match[0]);
                } catch (err) {
                    var result = decode2(match[0]);
                    if (result !== match[0]) {
                        replaceMap[match[0]] = result;
                    }
                }
                match = multiMatcher.exec(input);
            }
            replaceMap["%C2"] = "\uFFFD";
            var entries = Object.keys(replaceMap);
            for(var i2 = 0; i2 < entries.length; i2++){
                var key = entries[i2];
                input = input.replace(new RegExp(key, "g"), replaceMap[key]);
            }
            return input;
        }
        module2.exports = function(encodedURI) {
            if (typeof encodedURI !== "string") {
                throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
            }
            try {
                encodedURI = encodedURI.replace(/\+/g, " ");
                return decodeURIComponent(encodedURI);
            } catch (err) {
                return customDecodeURIComponent(encodedURI);
            }
        };
    }
});
// node_modules/split-on-first/index.js
var require_split_on_first = __commonJS({
    "node_modules/split-on-first/index.js" (exports2, module2) {
        "use strict";
        module2.exports = (string2, separator)=>{
            if (!(typeof string2 === "string" && typeof separator === "string")) {
                throw new TypeError("Expected the arguments to be of type `string`");
            }
            if (separator === "") {
                return [
                    string2
                ];
            }
            const separatorIndex = string2.indexOf(separator);
            if (separatorIndex === -1) {
                return [
                    string2
                ];
            }
            return [
                string2.slice(0, separatorIndex),
                string2.slice(separatorIndex + separator.length)
            ];
        };
    }
});
// node_modules/filter-obj/index.js
var require_filter_obj = __commonJS({
    "node_modules/filter-obj/index.js" (exports2, module2) {
        "use strict";
        module2.exports = function(obj, predicate) {
            var ret = {};
            var keys2 = Object.keys(obj);
            var isArr = Array.isArray(predicate);
            for(var i2 = 0; i2 < keys2.length; i2++){
                var key = keys2[i2];
                var val = obj[key];
                if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
                    ret[key] = val;
                }
            }
            return ret;
        };
    }
});
// node_modules/query-string/index.js
var require_query_string = __commonJS({
    "node_modules/query-string/index.js" (exports2) {
        "use strict";
        var strictUriEncode = require_strict_uri_encode();
        var decodeComponent = require_decode_uri_component();
        var splitOnFirst = require_split_on_first();
        var filterObject = require_filter_obj();
        var isNullOrUndefined = (value)=>value === null || value === void 0;
        var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
        function encoderForArrayFormat(options3) {
            switch(options3.arrayFormat){
                case "index":
                    return (key)=>(result, value)=>{
                            const index2 = result.length;
                            if (value === void 0 || options3.skipNull && value === null || options3.skipEmptyString && value === "") {
                                return result;
                            }
                            if (value === null) {
                                return [
                                    ...result,
                                    [
                                        encode(key, options3),
                                        "[",
                                        index2,
                                        "]"
                                    ].join("")
                                ];
                            }
                            return [
                                ...result,
                                [
                                    encode(key, options3),
                                    "[",
                                    encode(index2, options3),
                                    "]=",
                                    encode(value, options3)
                                ].join("")
                            ];
                        };
                case "bracket":
                    return (key)=>(result, value)=>{
                            if (value === void 0 || options3.skipNull && value === null || options3.skipEmptyString && value === "") {
                                return result;
                            }
                            if (value === null) {
                                return [
                                    ...result,
                                    [
                                        encode(key, options3),
                                        "[]"
                                    ].join("")
                                ];
                            }
                            return [
                                ...result,
                                [
                                    encode(key, options3),
                                    "[]=",
                                    encode(value, options3)
                                ].join("")
                            ];
                        };
                case "colon-list-separator":
                    return (key)=>(result, value)=>{
                            if (value === void 0 || options3.skipNull && value === null || options3.skipEmptyString && value === "") {
                                return result;
                            }
                            if (value === null) {
                                return [
                                    ...result,
                                    [
                                        encode(key, options3),
                                        ":list="
                                    ].join("")
                                ];
                            }
                            return [
                                ...result,
                                [
                                    encode(key, options3),
                                    ":list=",
                                    encode(value, options3)
                                ].join("")
                            ];
                        };
                case "comma":
                case "separator":
                case "bracket-separator":
                    {
                        const keyValueSep = options3.arrayFormat === "bracket-separator" ? "[]=" : "=";
                        return (key)=>(result, value)=>{
                                if (value === void 0 || options3.skipNull && value === null || options3.skipEmptyString && value === "") {
                                    return result;
                                }
                                value = value === null ? "" : value;
                                if (result.length === 0) {
                                    return [
                                        [
                                            encode(key, options3),
                                            keyValueSep,
                                            encode(value, options3)
                                        ].join("")
                                    ];
                                }
                                return [
                                    [
                                        result,
                                        encode(value, options3)
                                    ].join(options3.arrayFormatSeparator)
                                ];
                            };
                    }
                default:
                    return (key)=>(result, value)=>{
                            if (value === void 0 || options3.skipNull && value === null || options3.skipEmptyString && value === "") {
                                return result;
                            }
                            if (value === null) {
                                return [
                                    ...result,
                                    encode(key, options3)
                                ];
                            }
                            return [
                                ...result,
                                [
                                    encode(key, options3),
                                    "=",
                                    encode(value, options3)
                                ].join("")
                            ];
                        };
            }
        }
        function parserForArrayFormat(options3) {
            let result;
            switch(options3.arrayFormat){
                case "index":
                    return (key, value, accumulator)=>{
                        result = /\[(\d*)\]$/.exec(key);
                        key = key.replace(/\[\d*\]$/, "");
                        if (!result) {
                            accumulator[key] = value;
                            return;
                        }
                        if (accumulator[key] === void 0) {
                            accumulator[key] = {};
                        }
                        accumulator[key][result[1]] = value;
                    };
                case "bracket":
                    return (key, value, accumulator)=>{
                        result = /(\[\])$/.exec(key);
                        key = key.replace(/\[\]$/, "");
                        if (!result) {
                            accumulator[key] = value;
                            return;
                        }
                        if (accumulator[key] === void 0) {
                            accumulator[key] = [
                                value
                            ];
                            return;
                        }
                        accumulator[key] = [].concat(accumulator[key], value);
                    };
                case "colon-list-separator":
                    return (key, value, accumulator)=>{
                        result = /(:list)$/.exec(key);
                        key = key.replace(/:list$/, "");
                        if (!result) {
                            accumulator[key] = value;
                            return;
                        }
                        if (accumulator[key] === void 0) {
                            accumulator[key] = [
                                value
                            ];
                            return;
                        }
                        accumulator[key] = [].concat(accumulator[key], value);
                    };
                case "comma":
                case "separator":
                    return (key, value, accumulator)=>{
                        const isArray2 = typeof value === "string" && value.includes(options3.arrayFormatSeparator);
                        const isEncodedArray = typeof value === "string" && !isArray2 && decode2(value, options3).includes(options3.arrayFormatSeparator);
                        value = isEncodedArray ? decode2(value, options3) : value;
                        const newValue = isArray2 || isEncodedArray ? value.split(options3.arrayFormatSeparator).map((item)=>decode2(item, options3)) : value === null ? value : decode2(value, options3);
                        accumulator[key] = newValue;
                    };
                case "bracket-separator":
                    return (key, value, accumulator)=>{
                        const isArray2 = /(\[\])$/.test(key);
                        key = key.replace(/\[\]$/, "");
                        if (!isArray2) {
                            accumulator[key] = value ? decode2(value, options3) : value;
                            return;
                        }
                        const arrayValue = value === null ? [] : value.split(options3.arrayFormatSeparator).map((item)=>decode2(item, options3));
                        if (accumulator[key] === void 0) {
                            accumulator[key] = arrayValue;
                            return;
                        }
                        accumulator[key] = [].concat(accumulator[key], arrayValue);
                    };
                default:
                    return (key, value, accumulator)=>{
                        if (accumulator[key] === void 0) {
                            accumulator[key] = value;
                            return;
                        }
                        accumulator[key] = [].concat(accumulator[key], value);
                    };
            }
        }
        function validateArrayFormatSeparator(value) {
            if (typeof value !== "string" || value.length !== 1) {
                throw new TypeError("arrayFormatSeparator must be single character string");
            }
        }
        function encode(value, options3) {
            if (options3.encode) {
                return options3.strict ? strictUriEncode(value) : encodeURIComponent(value);
            }
            return value;
        }
        function decode2(value, options3) {
            if (options3.decode) {
                return decodeComponent(value);
            }
            return value;
        }
        function keysSorter(input) {
            if (Array.isArray(input)) {
                return input.sort();
            }
            if (typeof input === "object") {
                return keysSorter(Object.keys(input)).sort((a, b)=>Number(a) - Number(b)).map((key)=>input[key]);
            }
            return input;
        }
        function removeHash(input) {
            const hashStart = input.indexOf("#");
            if (hashStart !== -1) {
                input = input.slice(0, hashStart);
            }
            return input;
        }
        function getHash(url) {
            let hash = "";
            const hashStart = url.indexOf("#");
            if (hashStart !== -1) {
                hash = url.slice(hashStart);
            }
            return hash;
        }
        function extract(input) {
            input = removeHash(input);
            const queryStart = input.indexOf("?");
            if (queryStart === -1) {
                return "";
            }
            return input.slice(queryStart + 1);
        }
        function parseValue(value, options3) {
            if (options3.parseNumbers && !Number.isNaN(Number(value)) && typeof value === "string" && value.trim() !== "") {
                value = Number(value);
            } else if (options3.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
                value = value.toLowerCase() === "true";
            }
            return value;
        }
        function parse2(query, options3) {
            options3 = Object.assign({
                decode: true,
                sort: true,
                arrayFormat: "none",
                arrayFormatSeparator: ",",
                parseNumbers: false,
                parseBooleans: false
            }, options3);
            validateArrayFormatSeparator(options3.arrayFormatSeparator);
            const formatter = parserForArrayFormat(options3);
            const ret = /* @__PURE__ */ Object.create(null);
            if (typeof query !== "string") {
                return ret;
            }
            query = query.trim().replace(/^[?#&]/, "");
            if (!query) {
                return ret;
            }
            for (const param of query.split("&")){
                if (param === "") {
                    continue;
                }
                let [key, value] = splitOnFirst(options3.decode ? param.replace(/\+/g, " ") : param, "=");
                value = value === void 0 ? null : [
                    "comma",
                    "separator",
                    "bracket-separator"
                ].includes(options3.arrayFormat) ? value : decode2(value, options3);
                formatter(decode2(key, options3), value, ret);
            }
            for (const key of Object.keys(ret)){
                const value = ret[key];
                if (typeof value === "object" && value !== null) {
                    for (const k of Object.keys(value)){
                        value[k] = parseValue(value[k], options3);
                    }
                } else {
                    ret[key] = parseValue(value, options3);
                }
            }
            if (options3.sort === false) {
                return ret;
            }
            return (options3.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options3.sort)).reduce((result, key)=>{
                const value = ret[key];
                if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
                    result[key] = keysSorter(value);
                } else {
                    result[key] = value;
                }
                return result;
            }, /* @__PURE__ */ Object.create(null));
        }
        exports2.extract = extract;
        exports2.parse = parse2;
        exports2.stringify = (object2, options3)=>{
            if (!object2) {
                return "";
            }
            options3 = Object.assign({
                encode: true,
                strict: true,
                arrayFormat: "none",
                arrayFormatSeparator: ","
            }, options3);
            validateArrayFormatSeparator(options3.arrayFormatSeparator);
            const shouldFilter = (key)=>options3.skipNull && isNullOrUndefined(object2[key]) || options3.skipEmptyString && object2[key] === "";
            const formatter = encoderForArrayFormat(options3);
            const objectCopy = {};
            for (const key of Object.keys(object2)){
                if (!shouldFilter(key)) {
                    objectCopy[key] = object2[key];
                }
            }
            const keys2 = Object.keys(objectCopy);
            if (options3.sort !== false) {
                keys2.sort(options3.sort);
            }
            return keys2.map((key)=>{
                const value = object2[key];
                if (value === void 0) {
                    return "";
                }
                if (value === null) {
                    return encode(key, options3);
                }
                if (Array.isArray(value)) {
                    if (value.length === 0 && options3.arrayFormat === "bracket-separator") {
                        return encode(key, options3) + "[]";
                    }
                    return value.reduce(formatter(key), []).join("&");
                }
                return encode(key, options3) + "=" + encode(value, options3);
            }).filter((x)=>x.length > 0).join("&");
        };
        exports2.parseUrl = (url, options3)=>{
            options3 = Object.assign({
                decode: true
            }, options3);
            const [url_, hash] = splitOnFirst(url, "#");
            return Object.assign({
                url: url_.split("?")[0] || "",
                query: parse2(extract(url), options3)
            }, options3 && options3.parseFragmentIdentifier && hash ? {
                fragmentIdentifier: decode2(hash, options3)
            } : {});
        };
        exports2.stringifyUrl = (object2, options3)=>{
            options3 = Object.assign({
                encode: true,
                strict: true,
                [encodeFragmentIdentifier]: true
            }, options3);
            const url = removeHash(object2.url).split("?")[0] || "";
            const queryFromUrl = exports2.extract(object2.url);
            const parsedQueryFromUrl = exports2.parse(queryFromUrl, {
                sort: false
            });
            const query = Object.assign(parsedQueryFromUrl, object2.query);
            let queryString3 = exports2.stringify(query, options3);
            if (queryString3) {
                queryString3 = `?${queryString3}`;
            }
            let hash = getHash(object2.url);
            if (object2.fragmentIdentifier) {
                hash = `#${options3[encodeFragmentIdentifier] ? encode(object2.fragmentIdentifier, options3) : object2.fragmentIdentifier}`;
            }
            return `${url}${queryString3}${hash}`;
        };
        exports2.pick = (input, filter3, options3)=>{
            options3 = Object.assign({
                parseFragmentIdentifier: true,
                [encodeFragmentIdentifier]: false
            }, options3);
            const { url, query, fragmentIdentifier } = exports2.parseUrl(input, options3);
            return exports2.stringifyUrl({
                url,
                query: filterObject(query, filter3),
                fragmentIdentifier
            }, options3);
        };
        exports2.exclude = (input, filter3, options3)=>{
            const exclusionFilter = Array.isArray(filter3) ? (key)=>!filter3.includes(key) : (key, value)=>!filter3(key, value);
            return exports2.pick(input, exclusionFilter, options3);
        };
    }
});
// node_modules/path-to-regexp/index.js
var require_path_to_regexp = __commonJS({
    "node_modules/path-to-regexp/index.js" (exports2, module2) {
        module2.exports = pathToRegexp2;
        module2.exports.match = match;
        module2.exports.regexpToFunction = regexpToFunction;
        module2.exports.parse = parse2;
        module2.exports.compile = compile;
        module2.exports.tokensToFunction = tokensToFunction;
        module2.exports.tokensToRegExp = tokensToRegExp;
        var DEFAULT_DELIMITER = "/";
        var PATH_REGEXP = new RegExp([
            // Match escaped characters that would otherwise appear in future matches.
            // This allows the user to escape special characters that won't transform.
            "(\\\\.)",
            // Match Express-style parameters and un-named parameters with a prefix
            // and optional suffixes. Matches appear as:
            //
            // ":test(\\d+)?" => ["test", "\d+", undefined, "?"]
            // "(\\d+)"  => [undefined, undefined, "\d+", undefined]
            "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"
        ].join("|"), "g");
        function parse2(str, options3) {
            var tokens = [];
            var key = 0;
            var index2 = 0;
            var path = "";
            var defaultDelimiter = options3 && options3.delimiter || DEFAULT_DELIMITER;
            var whitelist = options3 && options3.whitelist || void 0;
            var pathEscaped = false;
            var res;
            while((res = PATH_REGEXP.exec(str)) !== null){
                var m = res[0];
                var escaped = res[1];
                var offset2 = res.index;
                path += str.slice(index2, offset2);
                index2 = offset2 + m.length;
                if (escaped) {
                    path += escaped[1];
                    pathEscaped = true;
                    continue;
                }
                var prev2 = "";
                var name = res[2];
                var capture = res[3];
                var group = res[4];
                var modifier = res[5];
                if (!pathEscaped && path.length) {
                    var k = path.length - 1;
                    var c = path[k];
                    var matches = whitelist ? whitelist.indexOf(c) > -1 : true;
                    if (matches) {
                        prev2 = c;
                        path = path.slice(0, k);
                    }
                }
                if (path) {
                    tokens.push(path);
                    path = "";
                    pathEscaped = false;
                }
                var repeat = modifier === "+" || modifier === "*";
                var optional = modifier === "?" || modifier === "*";
                var pattern = capture || group;
                var delimiter = prev2 || defaultDelimiter;
                var prevText = prev2 || (typeof tokens[tokens.length - 1] === "string" ? tokens[tokens.length - 1] : "");
                tokens.push({
                    name: name || key++,
                    prefix: prev2,
                    delimiter,
                    optional,
                    repeat,
                    pattern: pattern ? escapeGroup(pattern) : restrictBacktrack(delimiter, defaultDelimiter, prevText)
                });
            }
            if (path || index2 < str.length) {
                tokens.push(path + str.substr(index2));
            }
            return tokens;
        }
        function restrictBacktrack(delimiter, defaultDelimiter, prevText) {
            var charGroup = "[^" + escapeString(delimiter === defaultDelimiter ? delimiter : delimiter + defaultDelimiter) + "]";
            if (!prevText || prevText.indexOf(delimiter) > -1 || prevText.indexOf(defaultDelimiter) > -1) {
                return charGroup + "+?";
            }
            return escapeString(prevText) + "|(?:(?!" + escapeString(prevText) + ")" + charGroup + ")+?";
        }
        function compile(str, options3) {
            return tokensToFunction(parse2(str, options3), options3);
        }
        function match(str, options3) {
            var keys2 = [];
            var re = pathToRegexp2(str, keys2, options3);
            return regexpToFunction(re, keys2);
        }
        function regexpToFunction(re, keys2) {
            return function(pathname, options3) {
                var m = re.exec(pathname);
                if (!m) return false;
                var path = m[0];
                var index2 = m.index;
                var params = {};
                var decode2 = options3 && options3.decode || decodeURIComponent;
                for(var i2 = 1; i2 < m.length; i2++){
                    if (m[i2] === void 0) continue;
                    var key = keys2[i2 - 1];
                    if (key.repeat) {
                        params[key.name] = m[i2].split(key.delimiter).map(function(value) {
                            return decode2(value, key);
                        });
                    } else {
                        params[key.name] = decode2(m[i2], key);
                    }
                }
                return {
                    path,
                    index: index2,
                    params
                };
            };
        }
        function tokensToFunction(tokens, options3) {
            var matches = new Array(tokens.length);
            for(var i2 = 0; i2 < tokens.length; i2++){
                if (typeof tokens[i2] === "object") {
                    matches[i2] = new RegExp("^(?:" + tokens[i2].pattern + ")$", flags(options3));
                }
            }
            return function(data, options4) {
                var path = "";
                var encode = options4 && options4.encode || encodeURIComponent;
                var validate = options4 ? options4.validate !== false : true;
                for(var i3 = 0; i3 < tokens.length; i3++){
                    var token = tokens[i3];
                    if (typeof token === "string") {
                        path += token;
                        continue;
                    }
                    var value = data ? data[token.name] : void 0;
                    var segment;
                    if (Array.isArray(value)) {
                        if (!token.repeat) {
                            throw new TypeError('Expected "' + token.name + '" to not repeat, but got array');
                        }
                        if (value.length === 0) {
                            if (token.optional) continue;
                            throw new TypeError('Expected "' + token.name + '" to not be empty');
                        }
                        for(var j = 0; j < value.length; j++){
                            segment = encode(value[j], token);
                            if (validate && !matches[i3].test(segment)) {
                                throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '"');
                            }
                            path += (j === 0 ? token.prefix : token.delimiter) + segment;
                        }
                        continue;
                    }
                    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
                        segment = encode(String(value), token);
                        if (validate && !matches[i3].test(segment)) {
                            throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"');
                        }
                        path += token.prefix + segment;
                        continue;
                    }
                    if (token.optional) continue;
                    throw new TypeError('Expected "' + token.name + '" to be ' + (token.repeat ? "an array" : "a string"));
                }
                return path;
            };
        }
        function escapeString(str) {
            return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
        }
        function escapeGroup(group) {
            return group.replace(/([=!:$/()])/g, "\\$1");
        }
        function flags(options3) {
            return options3 && options3.sensitive ? "" : "i";
        }
        function regexpToRegexp(path, keys2) {
            if (!keys2) return path;
            var groups = path.source.match(/\((?!\?)/g);
            if (groups) {
                for(var i2 = 0; i2 < groups.length; i2++){
                    keys2.push({
                        name: i2,
                        prefix: null,
                        delimiter: null,
                        optional: false,
                        repeat: false,
                        pattern: null
                    });
                }
            }
            return path;
        }
        function arrayToRegexp(path, keys2, options3) {
            var parts = [];
            for(var i2 = 0; i2 < path.length; i2++){
                parts.push(pathToRegexp2(path[i2], keys2, options3).source);
            }
            return new RegExp("(?:" + parts.join("|") + ")", flags(options3));
        }
        function stringToRegexp(path, keys2, options3) {
            return tokensToRegExp(parse2(path, options3), keys2, options3);
        }
        function tokensToRegExp(tokens, keys2, options3) {
            options3 = options3 || {};
            var strict = options3.strict;
            var start2 = options3.start !== false;
            var end = options3.end !== false;
            var delimiter = options3.delimiter || DEFAULT_DELIMITER;
            var endsWith = [].concat(options3.endsWith || []).map(escapeString).concat("$").join("|");
            var route = start2 ? "^" : "";
            for(var i2 = 0; i2 < tokens.length; i2++){
                var token = tokens[i2];
                if (typeof token === "string") {
                    route += escapeString(token);
                } else {
                    var capture = token.repeat ? "(?:" + token.pattern + ")(?:" + escapeString(token.delimiter) + "(?:" + token.pattern + "))*" : token.pattern;
                    if (keys2) keys2.push(token);
                    if (token.optional) {
                        if (!token.prefix) {
                            route += "(" + capture + ")?";
                        } else {
                            route += "(?:" + escapeString(token.prefix) + "(" + capture + "))?";
                        }
                    } else {
                        route += escapeString(token.prefix) + "(" + capture + ")";
                    }
                }
            }
            if (end) {
                if (!strict) route += "(?:" + escapeString(delimiter) + ")?";
                route += endsWith === "$" ? "$" : "(?=" + endsWith + ")";
            } else {
                var endToken = tokens[tokens.length - 1];
                var isEndDelimited = typeof endToken === "string" ? endToken[endToken.length - 1] === delimiter : endToken === void 0;
                if (!strict) route += "(?:" + escapeString(delimiter) + "(?=" + endsWith + "))?";
                if (!isEndDelimited) route += "(?=" + escapeString(delimiter) + "|" + endsWith + ")";
            }
            return new RegExp(route, flags(options3));
        }
        function pathToRegexp2(path, keys2, options3) {
            if (path instanceof RegExp) {
                return regexpToRegexp(path, keys2);
            }
            if (Array.isArray(path)) {
                return arrayToRegexp(/** @type {!Array} */ path, keys2, options3);
            }
            return stringToRegexp(/** @type {string} */ path, keys2, options3);
        }
    }
});
// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js" (exports2) {
        "use strict";
        exports2.byteLength = byteLength;
        exports2.toByteArray = toByteArray2;
        exports2.fromByteArray = fromByteArray2;
        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for(i2 = 0, len = code.length; i2 < len; ++i2){
            lookup[i2] = code[i2];
            revLookup[code.charCodeAt(i2)] = i2;
        }
        var i2;
        var len;
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
        function getLens(b64) {
            var len2 = b64.length;
            if (len2 % 4 > 0) {
                throw new Error("Invalid string. Length must be a multiple of 4");
            }
            var validLen = b64.indexOf("=");
            if (validLen === -1) validLen = len2;
            var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
            return [
                validLen,
                placeHoldersLen
            ];
        }
        function byteLength(b64) {
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function _byteLength(b64, validLen, placeHoldersLen) {
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function toByteArray2(b64) {
            var tmp;
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
            var curByte = 0;
            var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
            var i3;
            for(i3 = 0; i3 < len2; i3 += 4){
                tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
                arr[curByte++] = tmp >> 16 & 255;
                arr[curByte++] = tmp >> 8 & 255;
                arr[curByte++] = tmp & 255;
            }
            if (placeHoldersLen === 2) {
                tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
                arr[curByte++] = tmp & 255;
            }
            if (placeHoldersLen === 1) {
                tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
                arr[curByte++] = tmp >> 8 & 255;
                arr[curByte++] = tmp & 255;
            }
            return arr;
        }
        function tripletToBase64(num) {
            return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
        }
        function encodeChunk(uint8, start2, end) {
            var tmp;
            var output = [];
            for(var i3 = start2; i3 < end; i3 += 3){
                tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
                output.push(tripletToBase64(tmp));
            }
            return output.join("");
        }
        function fromByteArray2(uint8) {
            var tmp;
            var len2 = uint8.length;
            var extraBytes = len2 % 3;
            var parts = [];
            var maxChunkLength = 16383;
            for(var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength){
                parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
            }
            if (extraBytes === 1) {
                tmp = uint8[len2 - 1];
                parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
            } else if (extraBytes === 2) {
                tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
                parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
            }
            return parts.join("");
        }
    }
});
// node_modules/platform/platform.js
var require_platform = __commonJS({
    "node_modules/platform/platform.js" (exports2, module2) {
        (function() {
            "use strict";
            var objectTypes = {
                "function": true,
                "object": true
            };
            var root2 = objectTypes[typeof window] && window || this;
            var oldRoot = root2;
            var freeExports3 = objectTypes[typeof exports2] && exports2;
            var freeModule3 = objectTypes[typeof module2] && module2 && !module2.nodeType && module2;
            var freeGlobal2 = freeExports3 && freeModule3 && typeof global == "object" && global;
            if (freeGlobal2 && (freeGlobal2.global === freeGlobal2 || freeGlobal2.window === freeGlobal2 || freeGlobal2.self === freeGlobal2)) {
                root2 = freeGlobal2;
            }
            var maxSafeInteger = Math.pow(2, 53) - 1;
            var reOpera = /\bOpera/;
            var thisBinding = this;
            var objectProto14 = Object.prototype;
            var hasOwnProperty13 = objectProto14.hasOwnProperty;
            var toString3 = objectProto14.toString;
            function capitalize(string2) {
                string2 = String(string2);
                return string2.charAt(0).toUpperCase() + string2.slice(1);
            }
            function cleanupOS(os, pattern, label) {
                var data = {
                    "10.0": "10",
                    "6.4": "10 Technical Preview",
                    "6.3": "8.1",
                    "6.2": "8",
                    "6.1": "Server 2008 R2 / 7",
                    "6.0": "Server 2008 / Vista",
                    "5.2": "Server 2003 / XP 64-bit",
                    "5.1": "XP",
                    "5.01": "2000 SP1",
                    "5.0": "2000",
                    "4.0": "NT",
                    "4.90": "ME"
                };
                if (pattern && label && /^Win/i.test(os) && !/^Windows Phone /i.test(os) && (data = data[/[\d.]+$/.exec(os)])) {
                    os = "Windows " + data;
                }
                os = String(os);
                if (pattern && label) {
                    os = os.replace(RegExp(pattern, "i"), label);
                }
                os = format(os.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0]);
                return os;
            }
            function each2(object2, callback) {
                var index2 = -1, length = object2 ? object2.length : 0;
                if (typeof length == "number" && length > -1 && length <= maxSafeInteger) {
                    while(++index2 < length){
                        callback(object2[index2], index2, object2);
                    }
                } else {
                    forOwn(object2, callback);
                }
            }
            function format(string2) {
                string2 = trim(string2);
                return /^(?:webOS|i(?:OS|P))/.test(string2) ? string2 : capitalize(string2);
            }
            function forOwn(object2, callback) {
                for(var key in object2){
                    if (hasOwnProperty13.call(object2, key)) {
                        callback(object2[key], key, object2);
                    }
                }
            }
            function getClassOf(value) {
                return value == null ? capitalize(value) : toString3.call(value).slice(8, -1);
            }
            function isHostType(object2, property) {
                var type = object2 != null ? typeof object2[property] : "number";
                return !/^(?:boolean|number|string|undefined)$/.test(type) && (type == "object" ? !!object2[property] : true);
            }
            function qualify(string2) {
                return String(string2).replace(/([ -])(?!$)/g, "$1?");
            }
            function reduce(array2, callback) {
                var accumulator = null;
                each2(array2, function(value, index2) {
                    accumulator = callback(accumulator, value, index2, array2);
                });
                return accumulator;
            }
            function trim(string2) {
                return String(string2).replace(/^ +| +$/g, "");
            }
            function parse2(ua) {
                var context = root2;
                var isCustomContext = ua && typeof ua == "object" && getClassOf(ua) != "String";
                if (isCustomContext) {
                    context = ua;
                    ua = null;
                }
                var nav = context.navigator || {};
                var userAgent = nav.userAgent || "";
                ua || (ua = userAgent);
                var isModuleScope = isCustomContext || thisBinding == oldRoot;
                var likeChrome = isCustomContext ? !!nav.likeChrome : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString3.toString());
                var objectClass = "Object", airRuntimeClass = isCustomContext ? objectClass : "ScriptBridgingProxyObject", enviroClass = isCustomContext ? objectClass : "Environment", javaClass = isCustomContext && context.java ? "JavaPackage" : getClassOf(context.java), phantomClass = isCustomContext ? objectClass : "RuntimeObject";
                var java = /\bJava/.test(javaClass) && context.java;
                var rhino = java && getClassOf(context.environment) == enviroClass;
                var alpha = java ? "a" : "\u03B1";
                var beta = java ? "b" : "\u03B2";
                var doc3 = context.document || {};
                var opera = context.operamini || context.opera;
                var operaClass = reOpera.test(operaClass = isCustomContext && opera ? opera["[[Class]]"] : getClassOf(opera)) ? operaClass : opera = null;
                var data;
                var arch = ua;
                var description = [];
                var prerelease = null;
                var useFeatures = ua == userAgent;
                var version = useFeatures && opera && typeof opera.version == "function" && opera.version();
                var isSpecialCasedOS;
                var layout = getLayout([
                    {
                        "label": "EdgeHTML",
                        "pattern": "Edge"
                    },
                    "Trident",
                    {
                        "label": "WebKit",
                        "pattern": "AppleWebKit"
                    },
                    "iCab",
                    "Presto",
                    "NetFront",
                    "Tasman",
                    "KHTML",
                    "Gecko"
                ]);
                var name = getName([
                    "Adobe AIR",
                    "Arora",
                    "Avant Browser",
                    "Breach",
                    "Camino",
                    "Electron",
                    "Epiphany",
                    "Fennec",
                    "Flock",
                    "Galeon",
                    "GreenBrowser",
                    "iCab",
                    "Iceweasel",
                    "K-Meleon",
                    "Konqueror",
                    "Lunascape",
                    "Maxthon",
                    {
                        "label": "Microsoft Edge",
                        "pattern": "(?:Edge|Edg|EdgA|EdgiOS)"
                    },
                    "Midori",
                    "Nook Browser",
                    "PaleMoon",
                    "PhantomJS",
                    "Raven",
                    "Rekonq",
                    "RockMelt",
                    {
                        "label": "Samsung Internet",
                        "pattern": "SamsungBrowser"
                    },
                    "SeaMonkey",
                    {
                        "label": "Silk",
                        "pattern": "(?:Cloud9|Silk-Accelerated)"
                    },
                    "Sleipnir",
                    "SlimBrowser",
                    {
                        "label": "SRWare Iron",
                        "pattern": "Iron"
                    },
                    "Sunrise",
                    "Swiftfox",
                    "Vivaldi",
                    "Waterfox",
                    "WebPositive",
                    {
                        "label": "Yandex Browser",
                        "pattern": "YaBrowser"
                    },
                    {
                        "label": "UC Browser",
                        "pattern": "UCBrowser"
                    },
                    "Opera Mini",
                    {
                        "label": "Opera Mini",
                        "pattern": "OPiOS"
                    },
                    "Opera",
                    {
                        "label": "Opera",
                        "pattern": "OPR"
                    },
                    "Chromium",
                    "Chrome",
                    {
                        "label": "Chrome",
                        "pattern": "(?:HeadlessChrome)"
                    },
                    {
                        "label": "Chrome Mobile",
                        "pattern": "(?:CriOS|CrMo)"
                    },
                    {
                        "label": "Firefox",
                        "pattern": "(?:Firefox|Minefield)"
                    },
                    {
                        "label": "Firefox for iOS",
                        "pattern": "FxiOS"
                    },
                    {
                        "label": "IE",
                        "pattern": "IEMobile"
                    },
                    {
                        "label": "IE",
                        "pattern": "MSIE"
                    },
                    "Safari"
                ]);
                var product = getProduct([
                    {
                        "label": "BlackBerry",
                        "pattern": "BB10"
                    },
                    "BlackBerry",
                    {
                        "label": "Galaxy S",
                        "pattern": "GT-I9000"
                    },
                    {
                        "label": "Galaxy S2",
                        "pattern": "GT-I9100"
                    },
                    {
                        "label": "Galaxy S3",
                        "pattern": "GT-I9300"
                    },
                    {
                        "label": "Galaxy S4",
                        "pattern": "GT-I9500"
                    },
                    {
                        "label": "Galaxy S5",
                        "pattern": "SM-G900"
                    },
                    {
                        "label": "Galaxy S6",
                        "pattern": "SM-G920"
                    },
                    {
                        "label": "Galaxy S6 Edge",
                        "pattern": "SM-G925"
                    },
                    {
                        "label": "Galaxy S7",
                        "pattern": "SM-G930"
                    },
                    {
                        "label": "Galaxy S7 Edge",
                        "pattern": "SM-G935"
                    },
                    "Google TV",
                    "Lumia",
                    "iPad",
                    "iPod",
                    "iPhone",
                    "Kindle",
                    {
                        "label": "Kindle Fire",
                        "pattern": "(?:Cloud9|Silk-Accelerated)"
                    },
                    "Nexus",
                    "Nook",
                    "PlayBook",
                    "PlayStation Vita",
                    "PlayStation",
                    "TouchPad",
                    "Transformer",
                    {
                        "label": "Wii U",
                        "pattern": "WiiU"
                    },
                    "Wii",
                    "Xbox One",
                    {
                        "label": "Xbox 360",
                        "pattern": "Xbox"
                    },
                    "Xoom"
                ]);
                var manufacturer = getManufacturer({
                    "Apple": {
                        "iPad": 1,
                        "iPhone": 1,
                        "iPod": 1
                    },
                    "Alcatel": {},
                    "Archos": {},
                    "Amazon": {
                        "Kindle": 1,
                        "Kindle Fire": 1
                    },
                    "Asus": {
                        "Transformer": 1
                    },
                    "Barnes & Noble": {
                        "Nook": 1
                    },
                    "BlackBerry": {
                        "PlayBook": 1
                    },
                    "Google": {
                        "Google TV": 1,
                        "Nexus": 1
                    },
                    "HP": {
                        "TouchPad": 1
                    },
                    "HTC": {},
                    "Huawei": {},
                    "Lenovo": {},
                    "LG": {},
                    "Microsoft": {
                        "Xbox": 1,
                        "Xbox One": 1
                    },
                    "Motorola": {
                        "Xoom": 1
                    },
                    "Nintendo": {
                        "Wii U": 1,
                        "Wii": 1
                    },
                    "Nokia": {
                        "Lumia": 1
                    },
                    "Oppo": {},
                    "Samsung": {
                        "Galaxy S": 1,
                        "Galaxy S2": 1,
                        "Galaxy S3": 1,
                        "Galaxy S4": 1
                    },
                    "Sony": {
                        "PlayStation": 1,
                        "PlayStation Vita": 1
                    },
                    "Xiaomi": {
                        "Mi": 1,
                        "Redmi": 1
                    }
                });
                var os = getOS([
                    "Windows Phone",
                    "KaiOS",
                    "Android",
                    "CentOS",
                    {
                        "label": "Chrome OS",
                        "pattern": "CrOS"
                    },
                    "Debian",
                    {
                        "label": "DragonFly BSD",
                        "pattern": "DragonFly"
                    },
                    "Fedora",
                    "FreeBSD",
                    "Gentoo",
                    "Haiku",
                    "Kubuntu",
                    "Linux Mint",
                    "OpenBSD",
                    "Red Hat",
                    "SuSE",
                    "Ubuntu",
                    "Xubuntu",
                    "Cygwin",
                    "Symbian OS",
                    "hpwOS",
                    "webOS ",
                    "webOS",
                    "Tablet OS",
                    "Tizen",
                    "Linux",
                    "Mac OS X",
                    "Macintosh",
                    "Mac",
                    "Windows 98;",
                    "Windows "
                ]);
                function getLayout(guesses) {
                    return reduce(guesses, function(result, guess) {
                        return result || RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua) && (guess.label || guess);
                    });
                }
                function getManufacturer(guesses) {
                    return reduce(guesses, function(result, value, key) {
                        return result || (value[product] || value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] || RegExp("\\b" + qualify(key) + "(?:\\b|\\w*\\d)", "i").exec(ua)) && key;
                    });
                }
                function getName(guesses) {
                    return reduce(guesses, function(result, guess) {
                        return result || RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua) && (guess.label || guess);
                    });
                }
                function getOS(guesses) {
                    return reduce(guesses, function(result, guess) {
                        var pattern = guess.pattern || qualify(guess);
                        if (!result && (result = RegExp("\\b" + pattern + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(ua))) {
                            result = cleanupOS(result, pattern, guess.label || guess);
                        }
                        return result;
                    });
                }
                function getProduct(guesses) {
                    return reduce(guesses, function(result, guess) {
                        var pattern = guess.pattern || qualify(guess);
                        if (!result && (result = RegExp("\\b" + pattern + " *\\d+[.\\w_]*", "i").exec(ua) || RegExp("\\b" + pattern + " *\\w+-[\\w]*", "i").exec(ua) || RegExp("\\b" + pattern + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(ua))) {
                            if ((result = String(guess.label && !RegExp(pattern, "i").test(guess.label) ? guess.label : result).split("/"))[1] && !/[\d.]+/.test(result[0])) {
                                result[0] += " " + result[1];
                            }
                            guess = guess.label || guess;
                            result = format(result[0].replace(RegExp(pattern, "i"), guess).replace(RegExp("; *(?:" + guess + "[_-])?", "i"), " ").replace(RegExp("(" + guess + ")[-_.]?(\\w)", "i"), "$1 $2"));
                        }
                        return result;
                    });
                }
                function getVersion(patterns) {
                    return reduce(patterns, function(result, pattern) {
                        return result || (RegExp(pattern + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(ua) || 0)[1] || null;
                    });
                }
                function toStringPlatform() {
                    return this.description || "";
                }
                layout && (layout = [
                    layout
                ]);
                if (/\bAndroid\b/.test(os) && !product && (data = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(ua))) {
                    product = trim(data[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i, "") || null;
                }
                if (manufacturer && !product) {
                    product = getProduct([
                        manufacturer
                    ]);
                } else if (manufacturer && product) {
                    product = product.replace(RegExp("^(" + qualify(manufacturer) + ")[-_.\\s]", "i"), manufacturer + " ").replace(RegExp("^(" + qualify(manufacturer) + ")[-_.]?(\\w)", "i"), manufacturer + " $2");
                }
                if (data = /\bGoogle TV\b/.exec(product)) {
                    product = data[0];
                }
                if (/\bSimulator\b/i.test(ua)) {
                    product = (product ? product + " " : "") + "Simulator";
                }
                if (name == "Opera Mini" && /\bOPiOS\b/.test(ua)) {
                    description.push("running in Turbo/Uncompressed mode");
                }
                if (name == "IE" && /\blike iPhone OS\b/.test(ua)) {
                    data = parse2(ua.replace(/like iPhone OS/, ""));
                    manufacturer = data.manufacturer;
                    product = data.product;
                } else if (/^iP/.test(product)) {
                    name || (name = "Safari");
                    os = "iOS" + ((data = / OS ([\d_]+)/i.exec(ua)) ? " " + data[1].replace(/_/g, ".") : "");
                } else if (name == "Konqueror" && /^Linux\b/i.test(os)) {
                    os = "Kubuntu";
                } else if (manufacturer && manufacturer != "Google" && (/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua) || /\bVita\b/.test(product)) || /\bAndroid\b/.test(os) && /^Chrome/.test(name) && /\bVersion\//i.test(ua)) {
                    name = "Android Browser";
                    os = /\bAndroid\b/.test(os) ? os : "Android";
                } else if (name == "Silk") {
                    if (!/\bMobi/i.test(ua)) {
                        os = "Android";
                        description.unshift("desktop mode");
                    }
                    if (/Accelerated *= *true/i.test(ua)) {
                        description.unshift("accelerated");
                    }
                } else if (name == "UC Browser" && /\bUCWEB\b/.test(ua)) {
                    description.push("speed mode");
                } else if (name == "PaleMoon" && (data = /\bFirefox\/([\d.]+)\b/.exec(ua))) {
                    description.push("identifying as Firefox " + data[1]);
                } else if (name == "Firefox" && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua))) {
                    os || (os = "Firefox OS");
                    product || (product = data[1]);
                } else if (!name || (data = !/\bMinefield\b/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
                    if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + "/") + 8))) {
                        name = null;
                    }
                    if ((data = product || manufacturer || os) && (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
                        name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + " Browser";
                    }
                } else if (name == "Electron" && (data = (/\bChrome\/([\d.]+)\b/.exec(ua) || 0)[1])) {
                    description.push("Chromium " + data);
                }
                if (!version) {
                    version = getVersion([
                        "(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)",
                        "Version",
                        qualify(name),
                        "(?:Firefox|Minefield|NetFront)"
                    ]);
                }
                if (data = layout == "iCab" && parseFloat(version) > 3 && "WebKit" || /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? "Blink" : "Presto") || /\b(?:Midori|Nook|Safari)\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && "WebKit" || !layout && /\bMSIE\b/i.test(ua) && (os == "Mac OS" ? "Tasman" : "Trident") || layout == "WebKit" && /\bPlayStation\b(?! Vita\b)/i.test(name) && "NetFront") {
                    layout = [
                        data
                    ];
                }
                if (name == "IE" && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
                    name += " Mobile";
                    os = "Windows Phone " + (/\+$/.test(data) ? data : data + ".x");
                    description.unshift("desktop mode");
                } else if (/\bWPDesktop\b/i.test(ua)) {
                    name = "IE Mobile";
                    os = "Windows Phone 8.x";
                    description.unshift("desktop mode");
                    version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
                } else if (name != "IE" && layout == "Trident" && (data = /\brv:([\d.]+)/.exec(ua))) {
                    if (name) {
                        description.push("identifying as " + name + (version ? " " + version : ""));
                    }
                    name = "IE";
                    version = data[1];
                }
                if (useFeatures) {
                    if (isHostType(context, "global")) {
                        if (java) {
                            data = java.lang.System;
                            arch = data.getProperty("os.arch");
                            os = os || data.getProperty("os.name") + " " + data.getProperty("os.version");
                        }
                        if (rhino) {
                            try {
                                version = context.require("ringo/engine").version.join(".");
                                name = "RingoJS";
                            } catch (e) {
                                if ((data = context.system) && data.global.system == context.system) {
                                    name = "Narwhal";
                                    os || (os = data[0].os || null);
                                }
                            }
                            if (!name) {
                                name = "Rhino";
                            }
                        } else if (typeof context.process == "object" && !context.process.browser && (data = context.process)) {
                            if (typeof data.versions == "object") {
                                if (typeof data.versions.electron == "string") {
                                    description.push("Node " + data.versions.node);
                                    name = "Electron";
                                    version = data.versions.electron;
                                } else if (typeof data.versions.nw == "string") {
                                    description.push("Chromium " + version, "Node " + data.versions.node);
                                    name = "NW.js";
                                    version = data.versions.nw;
                                }
                            }
                            if (!name) {
                                name = "Node.js";
                                arch = data.arch;
                                os = data.platform;
                                version = /[\d.]+/.exec(data.version);
                                version = version ? version[0] : null;
                            }
                        }
                    } else if (getClassOf(data = context.runtime) == airRuntimeClass) {
                        name = "Adobe AIR";
                        os = data.flash.system.Capabilities.os;
                    } else if (getClassOf(data = context.phantom) == phantomClass) {
                        name = "PhantomJS";
                        version = (data = data.version || null) && data.major + "." + data.minor + "." + data.patch;
                    } else if (typeof doc3.documentMode == "number" && (data = /\bTrident\/(\d+)/i.exec(ua))) {
                        version = [
                            version,
                            doc3.documentMode
                        ];
                        if ((data = +data[1] + 4) != version[1]) {
                            description.push("IE " + version[1] + " mode");
                            layout && (layout[1] = "");
                            version[1] = data;
                        }
                        version = name == "IE" ? String(version[1].toFixed(1)) : version[0];
                    } else if (typeof doc3.documentMode == "number" && /^(?:Chrome|Firefox)\b/.test(name)) {
                        description.push("masking as " + name + " " + version);
                        name = "IE";
                        version = "11.0";
                        layout = [
                            "Trident"
                        ];
                        os = "Windows";
                    }
                    os = os && format(os);
                }
                if (version && (data = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) || /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ";" + (useFeatures && nav.appMinorVersion)) || /\bMinefield\b/i.test(ua) && "a")) {
                    prerelease = /b/i.test(data) ? "beta" : "alpha";
                    version = version.replace(RegExp(data + "\\+?$"), "") + (prerelease == "beta" ? beta : alpha) + (/\d+\+?/.exec(data) || "");
                }
                if (name == "Fennec" || name == "Firefox" && /\b(?:Android|Firefox OS|KaiOS)\b/.test(os)) {
                    name = "Firefox Mobile";
                } else if (name == "Maxthon" && version) {
                    version = version.replace(/\.[\d.]+/, ".x");
                } else if (/\bXbox\b/i.test(product)) {
                    if (product == "Xbox 360") {
                        os = null;
                    }
                    if (product == "Xbox 360" && /\bIEMobile\b/.test(ua)) {
                        description.unshift("mobile mode");
                    }
                } else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) && (os == "Windows CE" || /Mobi/i.test(ua))) {
                    name += " Mobile";
                } else if (name == "IE" && useFeatures) {
                    try {
                        if (context.external === null) {
                            description.unshift("platform preview");
                        }
                    } catch (e) {
                        description.unshift("embedded");
                    }
                } else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data = (RegExp(product.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(ua) || 0)[1] || version)) {
                    data = [
                        data,
                        /BB10/.test(ua)
                    ];
                    os = (data[1] ? (product = null, manufacturer = "BlackBerry") : "Device Software") + " " + data[0];
                    version = null;
                } else if (this != forOwn && product != "Wii" && (useFeatures && opera || /Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua) || name == "Firefox" && /\bOS X (?:\d+\.){2,}/.test(os) || name == "IE" && (os && !/^Win/.test(os) && version > 5.5 || /\bWindows XP\b/.test(os) && version > 8 || version == 8 && !/\bTrident\b/.test(ua))) && !reOpera.test(data = parse2.call(forOwn, ua.replace(reOpera, "") + ";")) && data.name) {
                    data = "ing as " + data.name + ((data = data.version) ? " " + data : "");
                    if (reOpera.test(name)) {
                        if (/\bIE\b/.test(data) && os == "Mac OS") {
                            os = null;
                        }
                        data = "identify" + data;
                    } else {
                        data = "mask" + data;
                        if (operaClass) {
                            name = format(operaClass.replace(/([a-z])([A-Z])/g, "$1 $2"));
                        } else {
                            name = "Opera";
                        }
                        if (/\bIE\b/.test(data)) {
                            os = null;
                        }
                        if (!useFeatures) {
                            version = null;
                        }
                    }
                    layout = [
                        "Presto"
                    ];
                    description.push(data);
                }
                if (data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1]) {
                    data = [
                        parseFloat(data.replace(/\.(\d)$/, ".0$1")),
                        data
                    ];
                    if (name == "Safari" && data[1].slice(-1) == "+") {
                        name = "WebKit Nightly";
                        prerelease = "alpha";
                        version = data[1].slice(0, -1);
                    } else if (version == data[1] || version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
                        version = null;
                    }
                    data[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(ua) || 0)[1];
                    if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == "WebKit") {
                        layout = [
                            "Blink"
                        ];
                    }
                    if (!useFeatures || !likeChrome && !data[1]) {
                        layout && (layout[1] = "like Safari");
                        data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? "4+" : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : data < 602 ? 9 : data < 604 ? 10 : data < 606 ? 11 : data < 608 ? 12 : "12");
                    } else {
                        layout && (layout[1] = "like Chrome");
                        data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.1 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.3 ? 11 : data < 535.01 ? 12 : data < 535.02 ? "13+" : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.1 ? 19 : data < 537.01 ? 20 : data < 537.11 ? "21+" : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != "Blink" ? "27" : "28");
                    }
                    layout && (layout[1] += " " + (data += typeof data == "number" ? ".x" : /[.+]/.test(data) ? "" : "+"));
                    if (name == "Safari" && (!version || parseInt(version) > 45)) {
                        version = data;
                    } else if (name == "Chrome" && /\bHeadlessChrome/i.test(ua)) {
                        description.unshift("headless");
                    }
                }
                if (name == "Opera" && (data = /\bzbov|zvav$/.exec(os))) {
                    name += " ";
                    description.unshift("desktop mode");
                    if (data == "zvav") {
                        name += "Mini";
                        version = null;
                    } else {
                        name += "Mobile";
                    }
                    os = os.replace(RegExp(" *" + data + "$"), "");
                } else if (name == "Safari" && /\bChrome\b/.exec(layout && layout[1])) {
                    description.unshift("desktop mode");
                    name = "Chrome Mobile";
                    version = null;
                    if (/\bOS X\b/.test(os)) {
                        manufacturer = "Apple";
                        os = "iOS 4.3+";
                    } else {
                        os = null;
                    }
                } else if (/\bSRWare Iron\b/.test(name) && !version) {
                    version = getVersion("Chrome");
                }
                if (version && version.indexOf(data = /[\d.]+$/.exec(os)) == 0 && ua.indexOf("/" + data + "-") > -1) {
                    os = trim(os.replace(data, ""));
                }
                if (os && os.indexOf(name) != -1 && !RegExp(name + " OS").test(os)) {
                    os = os.replace(RegExp(" *" + qualify(name) + " *"), "");
                }
                if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (/Browser|Lunascape|Maxthon/.test(name) || name != "Safari" && /^iOS/.test(os) && /\bSafari\b/.test(layout[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(name) && layout[1])) {
                    (data = layout[layout.length - 1]) && description.push(data);
                }
                if (description.length) {
                    description = [
                        "(" + description.join("; ") + ")"
                    ];
                }
                if (manufacturer && product && product.indexOf(manufacturer) < 0) {
                    description.push("on " + manufacturer);
                }
                if (product) {
                    description.push((/^on /.test(description[description.length - 1]) ? "" : "on ") + product);
                }
                if (os) {
                    data = / ([\d.+]+)$/.exec(os);
                    isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == "/";
                    os = {
                        "architecture": 32,
                        "family": data && !isSpecialCasedOS ? os.replace(data[0], "") : os,
                        "version": data ? data[1] : null,
                        "toString": function() {
                            var version2 = this.version;
                            return this.family + (version2 && !isSpecialCasedOS ? " " + version2 : "") + (this.architecture == 64 ? " 64-bit" : "");
                        }
                    };
                }
                if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
                    if (os) {
                        os.architecture = 64;
                        os.family = os.family.replace(RegExp(" *" + data), "");
                    }
                    if (name && (/\bWOW64\b/i.test(ua) || useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua))) {
                        description.unshift("32-bit");
                    }
                } else if (os && /^OS X/.test(os.family) && name == "Chrome" && parseFloat(version) >= 39) {
                    os.architecture = 64;
                }
                ua || (ua = null);
                var platform3 = {};
                platform3.description = ua;
                platform3.layout = layout && layout[0];
                platform3.manufacturer = manufacturer;
                platform3.name = name;
                platform3.prerelease = prerelease;
                platform3.product = product;
                platform3.ua = ua;
                platform3.version = name && version;
                platform3.os = os || {
                    /**
           * The CPU architecture the OS is built for.
           *
           * @memberOf platform.os
           * @type number|null
           */ "architecture": null,
                    /**
           * The family of the OS.
           *
           * Common values include:
           * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
           * "Windows XP", "OS X", "Linux", "Ubuntu", "Debian", "Fedora", "Red Hat",
           * "SuSE", "Android", "iOS" and "Windows Phone"
           *
           * @memberOf platform.os
           * @type string|null
           */ "family": null,
                    /**
           * The version of the OS.
           *
           * @memberOf platform.os
           * @type string|null
           */ "version": null,
                    /**
           * Returns the OS string.
           *
           * @memberOf platform.os
           * @returns {string} The OS string.
           */ "toString": function() {
                        return "null";
                    }
                };
                platform3.parse = parse2;
                platform3.toString = toStringPlatform;
                if (platform3.version) {
                    description.unshift(version);
                }
                if (platform3.name) {
                    description.unshift(name);
                }
                if (os && name && !(os == String(os).split(" ")[0] && (os == name.split(" ")[0] || product))) {
                    description.push(product ? "(" + os + ")" : "on " + os);
                }
                if (description.length) {
                    platform3.description = description.join(" ");
                }
                return platform3;
            }
            var platform2 = parse2();
            if (false) {
                root2.platform = platform2;
                (false)(function() {
                    return platform2;
                });
            } else if (freeExports3 && freeModule3) {
                forOwn(platform2, function(value, key) {
                    freeExports3[key] = value;
                });
            } else {
                root2.platform = platform2;
            }
        }).call(exports2);
    }
});
// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet;
var init_url_alphabet = __esm({
    "node_modules/nanoid/url-alphabet/index.js" () {
        urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    }
});
// node_modules/nanoid/index.browser.js
var index_browser_exports = {};
__export(index_browser_exports, {
    customAlphabet: ()=>customAlphabet,
    customRandom: ()=>customRandom,
    nanoid: ()=>nanoid,
    random: ()=>random,
    urlAlphabet: ()=>urlAlphabet
});
var random, customRandom, customAlphabet, nanoid;
var init_index_browser = __esm({
    "node_modules/nanoid/index.browser.js" () {
        init_url_alphabet();
        random = (bytes)=>crypto.getRandomValues(new Uint8Array(bytes));
        customRandom = (alphabet, defaultSize, getRandom)=>{
            let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
            let step = -~(1.6 * mask * defaultSize / alphabet.length);
            return (size = defaultSize)=>{
                let id = "";
                while(true){
                    let bytes = getRandom(step);
                    let j = step | 0;
                    while(j--){
                        id += alphabet[bytes[j] & mask] || "";
                        if (id.length === size) return id;
                    }
                }
            };
        };
        customAlphabet = (alphabet, size = 21)=>customRandom(alphabet, size, random);
        nanoid = (size = 21)=>crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte)=>{
                byte &= 63;
                if (byte < 36) {
                    id += byte.toString(36);
                } else if (byte < 62) {
                    id += (byte - 26).toString(36).toUpperCase();
                } else if (byte > 62) {
                    id += "-";
                } else {
                    id += "_";
                }
                return id;
            }, "");
    }
});
// node_modules/ics/dist/defaults.js
var require_defaults = __commonJS({
    "node_modules/ics/dist/defaults.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2.headerDefaults = exports2.eventDefaults = void 0;
        var _nanoid = (init_index_browser(), __toCommonJS(index_browser_exports));
        var headerDefaults = exports2.headerDefaults = function headerDefaults2() {
            return {
                productId: "adamgibbons/ics",
                method: "PUBLISH"
            };
        };
        var eventDefaults = exports2.eventDefaults = function eventDefaults2() {
            return {
                title: "Untitled event",
                uid: (0, _nanoid.nanoid)(),
                timestamp: Date.now()
            };
        };
    }
});
// node_modules/ics/dist/pipeline/build.js
var require_build = __commonJS({
    "node_modules/ics/dist/pipeline/build.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2.buildEvent = buildEvent;
        exports2.buildHeader = buildHeader;
        var _defaults = require_defaults();
        function _typeof2(obj) {
            "@babel/helpers - typeof";
            return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
                return typeof obj2;
            } : function(obj2) {
                return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            }, _typeof2(obj);
        }
        function _defineProperty(obj, key, value) {
            key = _toPropertyKey(key);
            if (key in obj) {
                Object.defineProperty(obj, key, {
                    value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                });
            } else {
                obj[key] = value;
            }
            return obj;
        }
        function _toPropertyKey(arg) {
            var key = _toPrimitive(arg, "string");
            return _typeof2(key) === "symbol" ? key : String(key);
        }
        function _toPrimitive(input, hint) {
            if (_typeof2(input) !== "object" || input === null) return input;
            var prim = input[Symbol.toPrimitive];
            if (prim !== void 0) {
                var res = prim.call(input, hint || "default");
                if (_typeof2(res) !== "object") return res;
                throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (hint === "string" ? String : Number)(input);
        }
        function removeUndefined(input) {
            return Object.entries(input).reduce(function(clean, entry) {
                return typeof entry[1] !== "undefined" ? Object.assign(clean, _defineProperty({}, entry[0], entry[1])) : clean;
            }, {});
        }
        function buildHeader() {
            var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var output = Object.assign({}, (0, _defaults.headerDefaults)(), attributes);
            return removeUndefined(output);
        }
        function buildEvent() {
            var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var output = Object.assign({}, (0, _defaults.eventDefaults)(), attributes);
            return removeUndefined(output);
        }
    }
});
// node_modules/ics/dist/utils/format-date.js
var require_format_date = __commonJS({
    "node_modules/ics/dist/utils/format-date.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = formatDate;
        function _slicedToArray(arr, i2) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
        }
        function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for(var i2 = 0, arr2 = new Array(len); i2 < len; i2++)arr2[i2] = arr[i2];
            return arr2;
        }
        function _iterableToArrayLimit(arr, i2) {
            var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
            if (null != _i) {
                var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
                try {
                    if (_x = (_i = _i.call(arr)).next, 0 === i2) {
                        if (Object(_i) !== _i) return;
                        _n = false;
                    } else for(; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i2); _n = true);
                } catch (err) {
                    _d = true, _e = err;
                } finally{
                    try {
                        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return;
                    } finally{
                        if (_d) throw _e;
                    }
                }
                return _arr;
            }
        }
        function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) return arr;
        }
        var pad = function pad2(n) {
            return n < 10 ? "0".concat(n) : "".concat(n);
        };
        function formatDate() {
            var args = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            var outputType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "utc";
            var inputType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "local";
            if (typeof args === "string") {
                return args;
            }
            if (Array.isArray(args) && args.length === 3) {
                var _args = _slicedToArray(args, 3), year = _args[0], month = _args[1], date2 = _args[2];
                return "".concat(year).concat(pad(month)).concat(pad(date2));
            }
            var outDate = /* @__PURE__ */ new Date();
            if (Array.isArray(args) && args.length > 0 && args[0]) {
                var _args2 = _slicedToArray(args, 6), _year = _args2[0], _month = _args2[1], _date = _args2[2], _args2$ = _args2[3], hours = _args2$ === void 0 ? 0 : _args2$, _args2$2 = _args2[4], minutes = _args2$2 === void 0 ? 0 : _args2$2, _args2$3 = _args2[5], seconds = _args2$3 === void 0 ? 0 : _args2$3;
                if (inputType === "local") {
                    outDate = new Date(_year, _month - 1, _date, hours, minutes, seconds);
                } else {
                    outDate = new Date(Date.UTC(_year, _month - 1, _date, hours, minutes, seconds));
                }
            } else if (!Array.isArray(args)) {
                outDate = new Date(args);
            }
            if (outputType === "local") {
                return [
                    outDate.getFullYear(),
                    pad(outDate.getMonth() + 1),
                    pad(outDate.getDate()),
                    "T",
                    pad(outDate.getHours()),
                    pad(outDate.getMinutes()),
                    pad(outDate.getSeconds())
                ].join("");
            }
            return [
                outDate.getUTCFullYear(),
                pad(outDate.getUTCMonth() + 1),
                pad(outDate.getUTCDate()),
                "T",
                pad(outDate.getUTCHours()),
                pad(outDate.getUTCMinutes()),
                pad(outDate.getUTCSeconds()),
                "Z"
            ].join("");
        }
    }
});
// node_modules/ics/dist/utils/set-geolocation.js
var require_set_geolocation = __commonJS({
    "node_modules/ics/dist/utils/set-geolocation.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = setGeolocation;
        function setGeolocation(_ref) {
            var lat = _ref.lat, lon = _ref.lon;
            return "".concat(lat, ";").concat(lon);
        }
    }
});
// node_modules/ics/dist/utils/encode-param-value.js
var require_encode_param_value = __commonJS({
    "node_modules/ics/dist/utils/encode-param-value.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = encodeParamValue;
        function encodeParamValue(value) {
            return '"'.concat(value.replaceAll('"', '\\"'), '"');
        }
    }
});
// node_modules/ics/dist/utils/set-contact.js
var require_set_contact = __commonJS({
    "node_modules/ics/dist/utils/set-contact.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = setContact;
        var _encodeParamValue = _interopRequireDefault(require_encode_param_value());
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function setContact(_ref) {
            var name = _ref.name, email = _ref.email, rsvp = _ref.rsvp, dir = _ref.dir, partstat = _ref.partstat, role = _ref.role, cutype = _ref.cutype, xNumGuests = _ref.xNumGuests;
            var formattedParts = [];
            if (rsvp !== void 0) {
                formattedParts.push(rsvp ? "RSVP=TRUE" : "RSVP=FALSE");
            }
            if (cutype) {
                formattedParts.push("CUTYPE=".concat((0, _encodeParamValue["default"])(cutype)));
            }
            if (xNumGuests !== void 0) {
                formattedParts.push("X-NUM-GUESTS=".concat(xNumGuests));
            }
            if (role) {
                formattedParts.push("ROLE=".concat((0, _encodeParamValue["default"])(role)));
            }
            if (partstat) {
                formattedParts.push("PARTSTAT=".concat((0, _encodeParamValue["default"])(partstat)));
            }
            if (dir) {
                formattedParts.push("DIR=".concat((0, _encodeParamValue["default"])(dir)));
            }
            formattedParts.push("CN=".concat((0, _encodeParamValue["default"])(name || "Unnamed attendee")));
            var formattedAttendee = formattedParts.join(";").concat(email ? ":mailto:".concat(email) : "");
            return formattedAttendee;
        }
    }
});
// node_modules/ics/dist/utils/set-organizer.js
var require_set_organizer = __commonJS({
    "node_modules/ics/dist/utils/set-organizer.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = setOrganizer;
        var _encodeParamValue = _interopRequireDefault(require_encode_param_value());
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function setOrganizer(_ref) {
            var name = _ref.name, email = _ref.email, dir = _ref.dir, sentBy = _ref.sentBy;
            var formattedOrganizer = "";
            formattedOrganizer += dir ? "DIR=".concat((0, _encodeParamValue["default"])(dir), ";") : "";
            formattedOrganizer += sentBy ? "SENT-BY=".concat((0, _encodeParamValue["default"])("MAILTO:".concat(sentBy)), ";") : "";
            formattedOrganizer += "CN=";
            formattedOrganizer += (0, _encodeParamValue["default"])(name || "Organizer");
            formattedOrganizer += email ? ":MAILTO:".concat(email) : "";
            return formattedOrganizer;
        }
    }
});
// node_modules/runes2/dist/index.cjs.development.cjs
var require_index_cjs_development = __commonJS({
    "node_modules/runes2/dist/index.cjs.development.cjs" (exports2, module2) {
        "use strict";
        var EnumRunesCode;
        (function(EnumRunesCode2) {
            EnumRunesCode2[EnumRunesCode2["HIGH_SURROGATE_START"] = 55296] = "HIGH_SURROGATE_START";
            EnumRunesCode2[EnumRunesCode2["HIGH_SURROGATE_END"] = 56319] = "HIGH_SURROGATE_END";
            EnumRunesCode2[EnumRunesCode2["LOW_SURROGATE_START"] = 56320] = "LOW_SURROGATE_START";
            EnumRunesCode2[EnumRunesCode2["REGIONAL_INDICATOR_START"] = 127462] = "REGIONAL_INDICATOR_START";
            EnumRunesCode2[EnumRunesCode2["REGIONAL_INDICATOR_END"] = 127487] = "REGIONAL_INDICATOR_END";
            EnumRunesCode2[EnumRunesCode2["FITZPATRICK_MODIFIER_START"] = 127995] = "FITZPATRICK_MODIFIER_START";
            EnumRunesCode2[EnumRunesCode2["FITZPATRICK_MODIFIER_END"] = 127999] = "FITZPATRICK_MODIFIER_END";
            EnumRunesCode2[EnumRunesCode2["VARIATION_MODIFIER_START"] = 65024] = "VARIATION_MODIFIER_START";
            EnumRunesCode2[EnumRunesCode2["VARIATION_MODIFIER_END"] = 65039] = "VARIATION_MODIFIER_END";
            EnumRunesCode2[EnumRunesCode2["DIACRITICAL_MARKS_START"] = 8400] = "DIACRITICAL_MARKS_START";
            EnumRunesCode2[EnumRunesCode2["DIACRITICAL_MARKS_END"] = 8447] = "DIACRITICAL_MARKS_END";
            EnumRunesCode2[EnumRunesCode2["SUBDIVISION_INDICATOR_START"] = 127988] = "SUBDIVISION_INDICATOR_START";
            EnumRunesCode2[EnumRunesCode2["TAGS_START"] = 917504] = "TAGS_START";
            EnumRunesCode2[EnumRunesCode2["TAGS_END"] = 917631] = "TAGS_END";
            EnumRunesCode2[EnumRunesCode2["ZWJ"] = 8205] = "ZWJ";
        })(EnumRunesCode || (EnumRunesCode = {}));
        var GRAPHEMES = Object.freeze([
            776,
            2359,
            2367,
            2984,
            3007,
            3021,
            3633,
            3635,
            3648,
            3657,
            4352,
            4449,
            4520
        ]);
        var EnumCodeUnits;
        (function(EnumCodeUnits2) {
            EnumCodeUnits2[EnumCodeUnits2["unit_1"] = 1] = "unit_1";
            EnumCodeUnits2[EnumCodeUnits2["unit_2"] = 2] = "unit_2";
            EnumCodeUnits2[EnumCodeUnits2["unit_4"] = 4] = "unit_4";
        })(EnumCodeUnits || (EnumCodeUnits = {}));
        function runes(string2) {
            if (typeof string2 !== "string") {
                throw new TypeError("string cannot be undefined or null");
            }
            const result = [];
            let i2 = 0;
            let increment = 0;
            while(i2 < string2.length){
                increment += nextUnits(i2 + increment, string2);
                if (isGrapheme(string2[i2 + increment])) {
                    increment++;
                }
                if (isVariationSelector(string2[i2 + increment])) {
                    increment++;
                }
                if (isDiacriticalMark(string2[i2 + increment])) {
                    increment++;
                }
                if (isZeroWidthJoiner(string2[i2 + increment])) {
                    increment++;
                    continue;
                }
                result.push(string2.substring(i2, i2 + increment));
                i2 += increment;
                increment = 0;
            }
            return result;
        }
        function nextUnits(i2, string2) {
            const current = string2[i2];
            if (!isFirstOfSurrogatePair(current) || i2 === string2.length - 1) {
                return 1;
            }
            const currentPair = current + string2[i2 + 1];
            let nextPair = string2.substring(i2 + 2, i2 + 5);
            if (isRegionalIndicator(currentPair) && isRegionalIndicator(nextPair)) {
                return 4;
            }
            if (isSubdivisionFlag(currentPair) && isSupplementarySpecialpurposePlane(nextPair)) {
                return string2.slice(i2).indexOf(String.fromCodePoint(917631)) + 2;
            }
            if (isFitzpatrickModifier(nextPair)) {
                return 4;
            }
            return 2;
        }
        function isFirstOfSurrogatePair(string2) {
            return string2 && betweenInclusive(string2[0].charCodeAt(0), 55296, 56319);
        }
        function isRegionalIndicator(string2) {
            return betweenInclusive(codePointFromSurrogatePair(string2), 127462, 127487);
        }
        function isSubdivisionFlag(string2) {
            return betweenInclusive(codePointFromSurrogatePair(string2), 127988, 127988);
        }
        function isFitzpatrickModifier(string2) {
            return betweenInclusive(codePointFromSurrogatePair(string2), 127995, 127999);
        }
        function isVariationSelector(string2) {
            return typeof string2 === "string" && betweenInclusive(string2.charCodeAt(0), 65024, 65039);
        }
        function isDiacriticalMark(string2) {
            return typeof string2 === "string" && betweenInclusive(string2.charCodeAt(0), 8400, 8447);
        }
        function isSupplementarySpecialpurposePlane(string2) {
            const codePoint = string2.codePointAt(0);
            return typeof string2 === "string" && typeof codePoint === "number" && betweenInclusive(codePoint, 917504, 917631);
        }
        function isGrapheme(string2) {
            return typeof string2 === "string" && GRAPHEMES.includes(string2.charCodeAt(0));
        }
        function isZeroWidthJoiner(string2) {
            return typeof string2 === "string" && string2.charCodeAt(0) === 8205;
        }
        function codePointFromSurrogatePair(pair) {
            const highOffset = pair.charCodeAt(0) - 55296;
            const lowOffset = pair.charCodeAt(1) - 56320;
            return (highOffset << 10) + lowOffset + 65536;
        }
        function betweenInclusive(value, lower, upper) {
            return value >= lower && value <= upper;
        }
        function substring(string2, start2, width) {
            const chars = runes(string2);
            if (start2 === void 0) {
                return string2;
            }
            if (start2 >= chars.length) {
                return "";
            }
            const rest = chars.length - start2;
            const stringWidth = width === void 0 ? rest : width;
            let endIndex = start2 + stringWidth;
            if (endIndex > start2 + rest) {
                endIndex = void 0;
            }
            return chars.slice(start2, endIndex).join("");
        }
        {
            Object.defineProperty(runes, "runes", {
                value: runes
            });
            Object.defineProperty(runes, "default", {
                value: runes
            });
            Object.defineProperty(runes, "__esModule", {
                value: true
            });
            Object.defineProperty(runes, "substr", {
                value: substring
            });
            Object.defineProperty(runes, "substring", {
                value: substring
            });
            Object.defineProperty(runes, "EnumRunesCode", {
                value: EnumRunesCode
            });
            Object.defineProperty(runes, "EnumCodeUnits", {
                value: EnumCodeUnits
            });
            Object.defineProperty(runes, "GRAPHEMES", {
                value: GRAPHEMES
            });
        }
        module2.exports = runes;
    }
});
// node_modules/runes2/dist/index.cjs.production.min.cjs
var require_index_cjs_production_min = __commonJS({
    "node_modules/runes2/dist/index.cjs.production.min.cjs" (exports2, module2) {
        "use strict";
        var e;
        !function(e2) {
            e2[e2.HIGH_SURROGATE_START = 55296] = "HIGH_SURROGATE_START", e2[e2.HIGH_SURROGATE_END = 56319] = "HIGH_SURROGATE_END", e2[e2.LOW_SURROGATE_START = 56320] = "LOW_SURROGATE_START", e2[e2.REGIONAL_INDICATOR_START = 127462] = "REGIONAL_INDICATOR_START", e2[e2.REGIONAL_INDICATOR_END = 127487] = "REGIONAL_INDICATOR_END", e2[e2.FITZPATRICK_MODIFIER_START = 127995] = "FITZPATRICK_MODIFIER_START", e2[e2.FITZPATRICK_MODIFIER_END = 127999] = "FITZPATRICK_MODIFIER_END", e2[e2.VARIATION_MODIFIER_START = 65024] = "VARIATION_MODIFIER_START", e2[e2.VARIATION_MODIFIER_END = 65039] = "VARIATION_MODIFIER_END", e2[e2.DIACRITICAL_MARKS_START = 8400] = "DIACRITICAL_MARKS_START", e2[e2.DIACRITICAL_MARKS_END = 8447] = "DIACRITICAL_MARKS_END", e2[e2.SUBDIVISION_INDICATOR_START = 127988] = "SUBDIVISION_INDICATOR_START", e2[e2.TAGS_START = 917504] = "TAGS_START", e2[e2.TAGS_END = 917631] = "TAGS_END", e2[e2.ZWJ = 8205] = "ZWJ";
        }(e || (e = {}));
        var n = Object.freeze([
            776,
            2359,
            2367,
            2984,
            3007,
            3021,
            3633,
            3635,
            3648,
            3657,
            4352,
            4449,
            4520
        ]);
        var t;
        function runes(e2) {
            if ("string" != typeof e2) throw new TypeError("string cannot be undefined or null");
            const n2 = [];
            let t2 = 0, r = 0;
            for(; t2 < e2.length;)r += nextUnits(t2 + r, e2), isGrapheme(e2[t2 + r]) && r++, isVariationSelector(e2[t2 + r]) && r++, isDiacriticalMark(e2[t2 + r]) && r++, isZeroWidthJoiner(e2[t2 + r]) ? r++ : (n2.push(e2.substring(t2, t2 + r)), t2 += r, r = 0);
            return n2;
        }
        function nextUnits(e2, n2) {
            const t2 = n2[e2];
            if (!function isFirstOfSurrogatePair(e3) {
                return e3 && betweenInclusive(e3[0].charCodeAt(0), 55296, 56319);
            }(t2) || e2 === n2.length - 1) return 1;
            const r = t2 + n2[e2 + 1];
            let i2 = n2.substring(e2 + 2, e2 + 5);
            return isRegionalIndicator(r) && isRegionalIndicator(i2) ? 4 : function isSubdivisionFlag(e3) {
                return betweenInclusive(codePointFromSurrogatePair(e3), 127988, 127988);
            }(r) && function isSupplementarySpecialpurposePlane(e3) {
                const n3 = e3.codePointAt(0);
                return "string" == typeof e3 && "number" == typeof n3 && betweenInclusive(n3, 917504, 917631);
            }(i2) ? n2.slice(e2).indexOf(String.fromCodePoint(917631)) + 2 : function isFitzpatrickModifier(e3) {
                return betweenInclusive(codePointFromSurrogatePair(e3), 127995, 127999);
            }(i2) ? 4 : 2;
        }
        function isRegionalIndicator(e2) {
            return betweenInclusive(codePointFromSurrogatePair(e2), 127462, 127487);
        }
        function isVariationSelector(e2) {
            return "string" == typeof e2 && betweenInclusive(e2.charCodeAt(0), 65024, 65039);
        }
        function isDiacriticalMark(e2) {
            return "string" == typeof e2 && betweenInclusive(e2.charCodeAt(0), 8400, 8447);
        }
        function isGrapheme(e2) {
            return "string" == typeof e2 && n.includes(e2.charCodeAt(0));
        }
        function isZeroWidthJoiner(e2) {
            return "string" == typeof e2 && 8205 === e2.charCodeAt(0);
        }
        function codePointFromSurrogatePair(e2) {
            return (e2.charCodeAt(0) - 55296 << 10) + (e2.charCodeAt(1) - 56320) + 65536;
        }
        function betweenInclusive(e2, n2, t2) {
            return e2 >= n2 && e2 <= t2;
        }
        function substring(e2, n2, t2) {
            const r = runes(e2);
            if (void 0 === n2) return e2;
            if (n2 >= r.length) return "";
            const i2 = r.length - n2;
            let o = n2 + (void 0 === t2 ? i2 : t2);
            return o > n2 + i2 && (o = void 0), r.slice(n2, o).join("");
        }
        !function(e2) {
            e2[e2.unit_1 = 1] = "unit_1", e2[e2.unit_2 = 2] = "unit_2", e2[e2.unit_4 = 4] = "unit_4";
        }(t || (t = {})), Object.defineProperty(runes, "runes", {
            value: runes
        }), Object.defineProperty(runes, "default", {
            value: runes
        }), Object.defineProperty(runes, "__esModule", {
            value: true
        }), Object.defineProperty(runes, "substr", {
            value: substring
        }), Object.defineProperty(runes, "substring", {
            value: substring
        }), Object.defineProperty(runes, "EnumRunesCode", {
            value: e
        }), Object.defineProperty(runes, "EnumCodeUnits", {
            value: t
        }), Object.defineProperty(runes, "GRAPHEMES", {
            value: n
        }), module2.exports = runes;
    }
});
// node_modules/runes2/dist/index.cjs
var require_dist = __commonJS({
    "node_modules/runes2/dist/index.cjs" (exports2, module2) {
        "use strict";
        if (typeof process !== "undefined" && true) {
            module2.exports = require_index_cjs_development();
        } else {
            module2.exports = require_index_cjs_production_min();
        }
    }
});
// node_modules/ics/dist/utils/fold-line.js
var require_fold_line = __commonJS({
    "node_modules/ics/dist/utils/fold-line.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = foldLine;
        var _runes = require_dist();
        function foldLine(line) {
            var parts = [];
            var length = 75;
            while((0, _runes.runes)(line).length > length){
                parts.push((0, _runes.substring)(line, 0, length));
                line = (0, _runes.substring)(line, length);
                length = 74;
            }
            parts.push(line);
            return parts.join("\r\n	");
        }
    }
});
// node_modules/ics/dist/utils/encode-new-lines.js
var require_encode_new_lines = __commonJS({
    "node_modules/ics/dist/utils/encode-new-lines.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = encodeNewLines;
        function encodeNewLines(text2) {
            return text2.replace(/\r?\n/gm, "\\n");
        }
    }
});
// node_modules/ics/dist/utils/set-alarm.js
var require_set_alarm = __commonJS({
    "node_modules/ics/dist/utils/set-alarm.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = setAlarm;
        var _formatDate = _interopRequireDefault(require_format_date());
        var _foldLine = _interopRequireDefault(require_fold_line());
        var _encodeNewLines = _interopRequireDefault(require_encode_new_lines());
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function setDuration(_ref) {
            var weeks = _ref.weeks, days = _ref.days, hours = _ref.hours, minutes = _ref.minutes, seconds = _ref.seconds;
            var formattedString = "P";
            formattedString += weeks ? "".concat(weeks, "W") : "";
            formattedString += days ? "".concat(days, "D") : "";
            formattedString += "T";
            formattedString += hours ? "".concat(hours, "H") : "";
            formattedString += minutes ? "".concat(minutes, "M") : "";
            formattedString += seconds ? "".concat(seconds, "S") : "";
            return formattedString;
        }
        function setTrigger(trigger2) {
            var formattedString = "";
            if (Array.isArray(trigger2) || typeof trigger2 === "number" || typeof trigger2 === "string") {
                formattedString = "TRIGGER;VALUE=DATE-TIME:".concat((0, _encodeNewLines["default"])((0, _formatDate["default"])(trigger2)), "\r\n");
            } else {
                var alert = trigger2.before ? "-" : "";
                formattedString = "TRIGGER:".concat((0, _encodeNewLines["default"])(alert + setDuration(trigger2)), "\r\n");
            }
            return formattedString;
        }
        function setAction(action) {
            return action.toUpperCase();
        }
        function setAlarm() {
            var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var action = attributes.action, repeat = attributes.repeat, description = attributes.description, duration = attributes.duration, attach2 = attributes.attach, attachType = attributes.attachType, trigger2 = attributes.trigger, summary = attributes.summary;
            var formattedString = "BEGIN:VALARM\r\n";
            formattedString += (0, _foldLine["default"])("ACTION:".concat((0, _encodeNewLines["default"])(setAction(action)))) + "\r\n";
            formattedString += repeat ? (0, _foldLine["default"])("REPEAT:".concat(repeat)) + "\r\n" : "";
            formattedString += description ? (0, _foldLine["default"])("DESCRIPTION:".concat((0, _encodeNewLines["default"])(description))) + "\r\n" : "";
            formattedString += duration ? (0, _foldLine["default"])("DURATION:".concat(setDuration(duration))) + "\r\n" : "";
            var attachInfo = attachType ? attachType : "FMTTYPE=audio/basic";
            formattedString += attach2 ? (0, _foldLine["default"])((0, _encodeNewLines["default"])("ATTACH;".concat(attachInfo, ":").concat(attach2))) + "\r\n" : "";
            formattedString += trigger2 ? setTrigger(trigger2) : "";
            formattedString += summary ? (0, _foldLine["default"])("SUMMARY:".concat((0, _encodeNewLines["default"])(summary))) + "\r\n" : "";
            formattedString += "END:VALARM\r\n";
            return formattedString;
        }
    }
});
// node_modules/ics/dist/utils/format-text.js
var require_format_text = __commonJS({
    "node_modules/ics/dist/utils/format-text.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = formatText;
        function formatText(text2) {
            return text2.replace(/\\/gm, "\\\\").replace(/\r?\n/gm, "\\n").replace(/;/gm, "\\;").replace(/,/gm, "\\,");
        }
    }
});
// node_modules/ics/dist/utils/set-description.js
var require_set_description = __commonJS({
    "node_modules/ics/dist/utils/set-description.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = setDescription;
        var _formatText = _interopRequireDefault(require_format_text());
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function setDescription(description) {
            return (0, _formatText["default"])(description);
        }
    }
});
// node_modules/ics/dist/utils/set-summary.js
var require_set_summary = __commonJS({
    "node_modules/ics/dist/utils/set-summary.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = setSummary;
        var _formatText = _interopRequireDefault(require_format_text());
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function setSummary(summary) {
            return (0, _formatText["default"])(summary);
        }
    }
});
// node_modules/ics/dist/utils/format-duration.js
var require_format_duration = __commonJS({
    "node_modules/ics/dist/utils/format-duration.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = formatDuration;
        function formatDuration() {
            var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var weeks = attributes.weeks, days = attributes.days, hours = attributes.hours, minutes = attributes.minutes, seconds = attributes.seconds;
            var formattedDuration = "P";
            formattedDuration += weeks ? "".concat(weeks, "W") : "";
            formattedDuration += days ? "".concat(days, "D") : "";
            formattedDuration += "T";
            formattedDuration += hours ? "".concat(hours, "H") : "";
            formattedDuration += minutes ? "".concat(minutes, "M") : "";
            formattedDuration += seconds ? "".concat(seconds, "S") : "";
            return formattedDuration;
        }
    }
});
// node_modules/ics/dist/utils/set-location.js
var require_set_location = __commonJS({
    "node_modules/ics/dist/utils/set-location.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = setLocation;
        var _formatText = _interopRequireDefault(require_format_text());
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function setLocation(location2) {
            return (0, _formatText["default"])(location2);
        }
    }
});
// node_modules/ics/dist/utils/index.js
var require_utils = __commonJS({
    "node_modules/ics/dist/utils/index.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        Object.defineProperty(exports2, "encodeParamValue", {
            enumerable: true,
            get: function get2() {
                return _encodeParamValue["default"];
            }
        });
        Object.defineProperty(exports2, "foldLine", {
            enumerable: true,
            get: function get2() {
                return _foldLine["default"];
            }
        });
        Object.defineProperty(exports2, "formatDate", {
            enumerable: true,
            get: function get2() {
                return _formatDate["default"];
            }
        });
        Object.defineProperty(exports2, "formatDuration", {
            enumerable: true,
            get: function get2() {
                return _formatDuration["default"];
            }
        });
        Object.defineProperty(exports2, "setAlarm", {
            enumerable: true,
            get: function get2() {
                return _setAlarm["default"];
            }
        });
        Object.defineProperty(exports2, "setContact", {
            enumerable: true,
            get: function get2() {
                return _setContact["default"];
            }
        });
        Object.defineProperty(exports2, "setDescription", {
            enumerable: true,
            get: function get2() {
                return _setDescription["default"];
            }
        });
        Object.defineProperty(exports2, "setGeolocation", {
            enumerable: true,
            get: function get2() {
                return _setGeolocation["default"];
            }
        });
        Object.defineProperty(exports2, "setLocation", {
            enumerable: true,
            get: function get2() {
                return _setLocation["default"];
            }
        });
        Object.defineProperty(exports2, "setOrganizer", {
            enumerable: true,
            get: function get2() {
                return _setOrganizer["default"];
            }
        });
        Object.defineProperty(exports2, "setSummary", {
            enumerable: true,
            get: function get2() {
                return _setSummary["default"];
            }
        });
        var _formatDate = _interopRequireDefault(require_format_date());
        var _setGeolocation = _interopRequireDefault(require_set_geolocation());
        var _setContact = _interopRequireDefault(require_set_contact());
        var _setOrganizer = _interopRequireDefault(require_set_organizer());
        var _setAlarm = _interopRequireDefault(require_set_alarm());
        var _setDescription = _interopRequireDefault(require_set_description());
        var _setSummary = _interopRequireDefault(require_set_summary());
        var _formatDuration = _interopRequireDefault(require_format_duration());
        var _foldLine = _interopRequireDefault(require_fold_line());
        var _setLocation = _interopRequireDefault(require_set_location());
        var _encodeParamValue = _interopRequireDefault(require_encode_param_value());
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
    }
});
// node_modules/ics/dist/pipeline/format.js
var require_format = __commonJS({
    "node_modules/ics/dist/pipeline/format.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2.formatEvent = formatEvent;
        exports2.formatFooter = formatFooter;
        exports2.formatHeader = formatHeader;
        var _utils = require_utils();
        var _encodeNewLines = _interopRequireDefault(require_encode_new_lines());
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function formatHeader() {
            var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var productId = attributes.productId, method = attributes.method, calName = attributes.calName;
            var icsFormat = "";
            icsFormat += "BEGIN:VCALENDAR\r\n";
            icsFormat += "VERSION:2.0\r\n";
            icsFormat += "CALSCALE:GREGORIAN\r\n";
            icsFormat += (0, _utils.foldLine)("PRODID:".concat((0, _encodeNewLines["default"])(productId))) + "\r\n";
            icsFormat += (0, _utils.foldLine)("METHOD:".concat((0, _encodeNewLines["default"])(method))) + "\r\n";
            icsFormat += calName ? (0, _utils.foldLine)("X-WR-CALNAME:".concat((0, _encodeNewLines["default"])(calName))) + "\r\n" : "";
            icsFormat += "X-PUBLISHED-TTL:PT1H\r\n";
            return icsFormat;
        }
        function formatFooter() {
            return "END:VCALENDAR\r\n";
        }
        function formatEvent() {
            var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var title = attributes.title, uid = attributes.uid, sequence = attributes.sequence, timestamp2 = attributes.timestamp, start2 = attributes.start, startType = attributes.startType, startInputType = attributes.startInputType, startOutputType = attributes.startOutputType, duration = attributes.duration, end = attributes.end, endInputType = attributes.endInputType, endOutputType = attributes.endOutputType, description = attributes.description, url = attributes.url, geo = attributes.geo, location2 = attributes.location, status2 = attributes.status, categories = attributes.categories, organizer = attributes.organizer, attendees = attributes.attendees, alarms = attributes.alarms, recurrenceRule = attributes.recurrenceRule, exclusionDates = attributes.exclusionDates, busyStatus = attributes.busyStatus, transp = attributes.transp, classification = attributes.classification, created = attributes.created, lastModified = attributes.lastModified, htmlContent = attributes.htmlContent;
            var icsFormat = "";
            icsFormat += "BEGIN:VEVENT\r\n";
            icsFormat += (0, _utils.foldLine)("UID:".concat((0, _encodeNewLines["default"])(uid))) + "\r\n";
            icsFormat += title ? (0, _utils.foldLine)("SUMMARY:".concat((0, _encodeNewLines["default"])((0, _utils.setSummary)(title)))) + "\r\n" : "";
            icsFormat += (0, _utils.foldLine)("DTSTAMP:".concat((0, _encodeNewLines["default"])((0, _utils.formatDate)(timestamp2)))) + "\r\n";
            icsFormat += (0, _utils.foldLine)("DTSTART".concat(start2 && start2.length == 3 ? ";VALUE=DATE" : "", ":").concat((0, _encodeNewLines["default"])((0, _utils.formatDate)(start2, startOutputType || startType, startInputType)))) + "\r\n";
            if (!end || end.length !== 3 || start2.length !== end.length || start2.some(function(val, i2) {
                return val !== end[i2];
            })) {
                if (end) {
                    icsFormat += (0, _utils.foldLine)("DTEND".concat(end.length === 3 ? ";VALUE=DATE" : "", ":").concat((0, _encodeNewLines["default"])((0, _utils.formatDate)(end, endOutputType || startOutputType || startType, endInputType || startInputType)))) + "\r\n";
                }
            }
            icsFormat += typeof sequence !== "undefined" ? "SEQUENCE:".concat(sequence, "\r\n") : "";
            icsFormat += description ? (0, _utils.foldLine)("DESCRIPTION:".concat((0, _encodeNewLines["default"])((0, _utils.setDescription)(description)))) + "\r\n" : "";
            icsFormat += url ? (0, _utils.foldLine)("URL:".concat((0, _encodeNewLines["default"])(url))) + "\r\n" : "";
            icsFormat += geo ? (0, _utils.foldLine)("GEO:".concat((0, _utils.setGeolocation)(geo))) + "\r\n" : "";
            icsFormat += location2 ? (0, _utils.foldLine)("LOCATION:".concat((0, _encodeNewLines["default"])((0, _utils.setLocation)(location2)))) + "\r\n" : "";
            icsFormat += status2 ? (0, _utils.foldLine)("STATUS:".concat((0, _encodeNewLines["default"])(status2))) + "\r\n" : "";
            icsFormat += categories ? (0, _utils.foldLine)("CATEGORIES:".concat((0, _encodeNewLines["default"])(categories.join(",")))) + "\r\n" : "";
            icsFormat += organizer ? (0, _utils.foldLine)("ORGANIZER;".concat((0, _utils.setOrganizer)(organizer))) + "\r\n" : "";
            icsFormat += busyStatus ? (0, _utils.foldLine)("X-MICROSOFT-CDO-BUSYSTATUS:".concat((0, _encodeNewLines["default"])(busyStatus))) + "\r\n" : "";
            icsFormat += transp ? (0, _utils.foldLine)("TRANSP:".concat((0, _encodeNewLines["default"])(transp))) + "\r\n" : "";
            icsFormat += classification ? (0, _utils.foldLine)("CLASS:".concat((0, _encodeNewLines["default"])(classification))) + "\r\n" : "";
            icsFormat += created ? "CREATED:" + (0, _encodeNewLines["default"])((0, _utils.formatDate)(created)) + "\r\n" : "";
            icsFormat += lastModified ? "LAST-MODIFIED:" + (0, _encodeNewLines["default"])((0, _utils.formatDate)(lastModified)) + "\r\n" : "";
            icsFormat += htmlContent ? (0, _utils.foldLine)("X-ALT-DESC;FMTTYPE=text/html:".concat((0, _encodeNewLines["default"])(htmlContent))) + "\r\n" : "";
            if (attendees) {
                attendees.forEach(function(attendee) {
                    icsFormat += (0, _utils.foldLine)("ATTENDEE;".concat((0, _encodeNewLines["default"])((0, _utils.setContact)(attendee)))) + "\r\n";
                });
            }
            icsFormat += recurrenceRule ? (0, _utils.foldLine)("RRULE:".concat((0, _encodeNewLines["default"])(recurrenceRule))) + "\r\n" : "";
            icsFormat += exclusionDates ? (0, _utils.foldLine)("EXDATE:".concat((0, _encodeNewLines["default"])(exclusionDates.map(function(a) {
                return (0, _utils.formatDate)(a);
            }).join(",")))) + "\r\n" : "";
            icsFormat += duration ? (0, _utils.foldLine)("DURATION:".concat((0, _utils.formatDuration)(duration))) + "\r\n" : "";
            if (alarms) {
                alarms.forEach(function(alarm) {
                    icsFormat += (0, _utils.setAlarm)(alarm);
                });
            }
            icsFormat += "END:VEVENT\r\n";
            return icsFormat;
        }
    }
});
// node_modules/property-expr/index.js
var require_property_expr = __commonJS({
    "node_modules/property-expr/index.js" (exports2, module2) {
        "use strict";
        function Cache(maxSize) {
            this._maxSize = maxSize;
            this.clear();
        }
        Cache.prototype.clear = function() {
            this._size = 0;
            this._values = /* @__PURE__ */ Object.create(null);
        };
        Cache.prototype.get = function(key) {
            return this._values[key];
        };
        Cache.prototype.set = function(key, value) {
            this._size >= this._maxSize && this.clear();
            if (!(key in this._values)) this._size++;
            return this._values[key] = value;
        };
        var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g;
        var DIGIT_REGEX = /^\d+$/;
        var LEAD_DIGIT_REGEX = /^\d/;
        var SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g;
        var CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/;
        var MAX_CACHE_SIZE = 512;
        var pathCache = new Cache(MAX_CACHE_SIZE);
        var setCache = new Cache(MAX_CACHE_SIZE);
        var getCache = new Cache(MAX_CACHE_SIZE);
        module2.exports = {
            Cache,
            split: split2,
            normalizePath: normalizePath2,
            setter: function(path) {
                var parts = normalizePath2(path);
                return setCache.get(path) || setCache.set(path, function setter(obj, value) {
                    var index2 = 0;
                    var len = parts.length;
                    var data = obj;
                    while(index2 < len - 1){
                        var part = parts[index2];
                        if (part === "__proto__" || part === "constructor" || part === "prototype") {
                            return obj;
                        }
                        data = data[parts[index2++]];
                    }
                    data[parts[index2]] = value;
                });
            },
            getter: function(path, safe) {
                var parts = normalizePath2(path);
                return getCache.get(path) || getCache.set(path, function getter2(data) {
                    var index2 = 0, len = parts.length;
                    while(index2 < len){
                        if (data != null || !safe) data = data[parts[index2++]];
                        else return;
                    }
                    return data;
                });
            },
            join: function(segments) {
                return segments.reduce(function(path, part) {
                    return path + (isQuoted(part) || DIGIT_REGEX.test(part) ? "[" + part + "]" : (path ? "." : "") + part);
                }, "");
            },
            forEach: function(path, cb, thisArg) {
                forEach3(Array.isArray(path) ? path : split2(path), cb, thisArg);
            }
        };
        function normalizePath2(path) {
            return pathCache.get(path) || pathCache.set(path, split2(path).map(function(part) {
                return part.replace(CLEAN_QUOTES_REGEX, "$2");
            }));
        }
        function split2(path) {
            return path.match(SPLIT_REGEX) || [
                ""
            ];
        }
        function forEach3(parts, iter, thisArg) {
            var len = parts.length, part, idx, isArray2, isBracket;
            for(idx = 0; idx < len; idx++){
                part = parts[idx];
                if (part) {
                    if (shouldBeQuoted(part)) {
                        part = '"' + part + '"';
                    }
                    isBracket = isQuoted(part);
                    isArray2 = !isBracket && /^\d+$/.test(part);
                    iter.call(thisArg, part, isBracket, isArray2, idx, parts);
                }
            }
        }
        function isQuoted(str) {
            return typeof str === "string" && str && [
                "'",
                '"'
            ].indexOf(str.charAt(0)) !== -1;
        }
        function hasLeadingNumber(part) {
            return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
        }
        function hasSpecialChars(part) {
            return SPEC_CHAR_REGEX.test(part);
        }
        function shouldBeQuoted(part) {
            return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
        }
    }
});
// node_modules/tiny-case/index.js
var require_tiny_case = __commonJS({
    "node_modules/tiny-case/index.js" (exports2, module2) {
        var reWords = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['’](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['’](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g;
        var words = (str)=>str.match(reWords) || [];
        var upperFirst = (str)=>str[0].toUpperCase() + str.slice(1);
        var join2 = (str, d)=>words(str).join(d).toLowerCase();
        var camelCase2 = (str)=>words(str).reduce((acc, next2)=>`${acc}${!acc ? next2.toLowerCase() : next2[0].toUpperCase() + next2.slice(1).toLowerCase()}`, "");
        var pascalCase = (str)=>upperFirst(camelCase2(str));
        var snakeCase2 = (str)=>join2(str, "_");
        var kebabCase = (str)=>join2(str, "-");
        var sentenceCase = (str)=>upperFirst(join2(str, " "));
        var titleCase = (str)=>words(str).map(upperFirst).join(" ");
        module2.exports = {
            words,
            upperFirst,
            camelCase: camelCase2,
            pascalCase,
            snakeCase: snakeCase2,
            kebabCase,
            sentenceCase,
            titleCase
        };
    }
});
// node_modules/toposort/index.js
var require_toposort = __commonJS({
    "node_modules/toposort/index.js" (exports2, module2) {
        module2.exports = function(edges) {
            return toposort2(uniqueNodes(edges), edges);
        };
        module2.exports.array = toposort2;
        function toposort2(nodes, edges) {
            var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i2 = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
            edges.forEach(function(edge) {
                if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
                    throw new Error("Unknown node. There is an unknown node in the supplied edges.");
                }
            });
            while(i2--){
                if (!visited[i2]) visit(nodes[i2], i2, /* @__PURE__ */ new Set());
            }
            return sorted;
            function visit(node, i3, predecessors) {
                if (predecessors.has(node)) {
                    var nodeRep;
                    try {
                        nodeRep = ", node was:" + JSON.stringify(node);
                    } catch (e) {
                        nodeRep = "";
                    }
                    throw new Error("Cyclic dependency" + nodeRep);
                }
                if (!nodesHash.has(node)) {
                    throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node));
                }
                if (visited[i3]) return;
                visited[i3] = true;
                var outgoing = outgoingEdges.get(node) || /* @__PURE__ */ new Set();
                outgoing = Array.from(outgoing);
                if (i3 = outgoing.length) {
                    predecessors.add(node);
                    do {
                        var child = outgoing[--i3];
                        visit(child, nodesHash.get(child), predecessors);
                    }while (i3)
                    predecessors.delete(node);
                }
                sorted[--cursor] = node;
            }
        }
        function uniqueNodes(arr) {
            var res = /* @__PURE__ */ new Set();
            for(var i2 = 0, len = arr.length; i2 < len; i2++){
                var edge = arr[i2];
                res.add(edge[0]);
                res.add(edge[1]);
            }
            return Array.from(res);
        }
        function makeOutgoingEdges(arr) {
            var edges = /* @__PURE__ */ new Map();
            for(var i2 = 0, len = arr.length; i2 < len; i2++){
                var edge = arr[i2];
                if (!edges.has(edge[0])) edges.set(edge[0], /* @__PURE__ */ new Set());
                if (!edges.has(edge[1])) edges.set(edge[1], /* @__PURE__ */ new Set());
                edges.get(edge[0]).add(edge[1]);
            }
            return edges;
        }
        function makeNodesHash(arr) {
            var res = /* @__PURE__ */ new Map();
            for(var i2 = 0, len = arr.length; i2 < len; i2++){
                res.set(arr[i2], i2);
            }
            return res;
        }
    }
});
// node_modules/yup/index.esm.js
var index_esm_exports = {};
__export(index_esm_exports, {
    ArraySchema: ()=>ArraySchema,
    BooleanSchema: ()=>BooleanSchema,
    DateSchema: ()=>DateSchema,
    LazySchema: ()=>Lazy,
    MixedSchema: ()=>MixedSchema,
    NumberSchema: ()=>NumberSchema,
    ObjectSchema: ()=>ObjectSchema,
    Schema: ()=>Schema,
    StringSchema: ()=>StringSchema,
    TupleSchema: ()=>TupleSchema,
    ValidationError: ()=>ValidationError,
    addMethod: ()=>addMethod,
    array: ()=>create$2,
    bool: ()=>create$7,
    boolean: ()=>create$7,
    date: ()=>create$4,
    defaultLocale: ()=>locale,
    getIn: ()=>getIn,
    isSchema: ()=>isSchema,
    lazy: ()=>create,
    mixed: ()=>create$8,
    number: ()=>create$5,
    object: ()=>create$3,
    printValue: ()=>printValue,
    reach: ()=>reach,
    ref: ()=>create$9,
    setLocale: ()=>setLocale,
    string: ()=>create$6,
    tuple: ()=>create$1
});
function printNumber(val) {
    if (val != +val) return "NaN";
    const isNegativeZero = val === 0 && 1 / val < 0;
    return isNegativeZero ? "-0" : "" + val;
}
function printSimpleValue(val, quoteStrings = false) {
    if (val == null || val === true || val === false) return "" + val;
    const typeOf = typeof val;
    if (typeOf === "number") return printNumber(val);
    if (typeOf === "string") return quoteStrings ? `"${val}"` : val;
    if (typeOf === "function") return "[Function " + (val.name || "anonymous") + "]";
    if (typeOf === "symbol") return symbolToString2.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
    const tag = toString2.call(val).slice(8, -1);
    if (tag === "Date") return isNaN(val.getTime()) ? "" + val : val.toISOString(val);
    if (tag === "Error" || val instanceof Error) return "[" + errorToString.call(val) + "]";
    if (tag === "RegExp") return regExpToString.call(val);
    return null;
}
function printValue(value, quoteStrings) {
    let result = printSimpleValue(value, quoteStrings);
    if (result !== null) return result;
    return JSON.stringify(value, function(key, value2) {
        let result2 = printSimpleValue(this[key], quoteStrings);
        if (result2 !== null) return result2;
        return value2;
    }, 2);
}
function toArray(value) {
    return value == null ? [] : [].concat(value);
}
function create$9(key, options3) {
    return new Reference(key, options3);
}
function createValidation(config) {
    function validate({ value, path = "", options: options3, originalValue, schema }, panic, next2) {
        const { name, test, params, message, skipAbsent } = config;
        let { parent: parent2, context, abortEarly = schema.spec.abortEarly, disableStackTrace = schema.spec.disableStackTrace } = options3;
        const resolveOptions = {
            value,
            parent: parent2,
            context
        };
        function createError(overrides = {}) {
            const nextParams = resolveParams(Object.assign({
                value,
                originalValue,
                label: schema.spec.label,
                path: overrides.path || path,
                spec: schema.spec,
                disableStackTrace: overrides.disableStackTrace || disableStackTrace
            }, params, overrides.params), resolveOptions);
            const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name, nextParams.disableStackTrace);
            error.params = nextParams;
            return error;
        }
        const invalid = abortEarly ? panic : next2;
        let ctx = {
            path,
            parent: parent2,
            type: name,
            from: options3.from,
            createError,
            resolve (item) {
                return resolveMaybeRef(item, resolveOptions);
            },
            options: options3,
            originalValue,
            schema
        };
        const handleResult = (validOrError)=>{
            if (ValidationError.isError(validOrError)) invalid(validOrError);
            else if (!validOrError) invalid(createError());
            else next2(null);
        };
        const handleError = (err)=>{
            if (ValidationError.isError(err)) invalid(err);
            else panic(err);
        };
        const shouldSkip = skipAbsent && isAbsent(value);
        if (shouldSkip) {
            return handleResult(true);
        }
        let result;
        try {
            var _result;
            result = test.call(ctx, value, ctx);
            if (typeof ((_result = result) == null ? void 0 : _result.then) === "function") {
                if (options3.sync) {
                    throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
                }
                return Promise.resolve(result).then(handleResult, handleError);
            }
        } catch (err) {
            handleError(err);
            return;
        }
        handleResult(result);
    }
    validate.OPTIONS = config;
    return validate;
}
function resolveParams(params, options3) {
    if (!params) return params;
    for (const key of Object.keys(params)){
        params[key] = resolveMaybeRef(params[key], options3);
    }
    return params;
}
function resolveMaybeRef(item, options3) {
    return Reference.isRef(item) ? item.getValue(options3.value, options3.parent, options3.context) : item;
}
function getIn(schema, path, value, context = value) {
    let parent2, lastPart, lastPartDebug;
    if (!path) return {
        parent: parent2,
        parentPath: path,
        schema
    };
    (0, import_property_expr.forEach)(path, (_part, isBracket, isArray2)=>{
        let part = isBracket ? _part.slice(1, _part.length - 1) : _part;
        schema = schema.resolve({
            context,
            parent: parent2,
            value
        });
        let isTuple = schema.type === "tuple";
        let idx = isArray2 ? parseInt(part, 10) : 0;
        if (schema.innerType || isTuple) {
            if (isTuple && !isArray2) throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${lastPartDebug}" must contain an index to the tuple element, e.g. "${lastPartDebug}[0]"`);
            if (value && idx >= value.length) {
                throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. because there is no value at that index. `);
            }
            parent2 = value;
            value = value && value[idx];
            schema = isTuple ? schema.spec.types[idx] : schema.innerType;
        }
        if (!isArray2) {
            if (!schema.fields || !schema.fields[part]) throw new Error(`The schema does not contain the path: ${path}. (failed at: ${lastPartDebug} which is a type: "${schema.type}")`);
            parent2 = value;
            value = value && value[part];
            schema = schema.fields[part];
        }
        lastPart = part;
        lastPartDebug = isBracket ? "[" + _part + "]" : "." + _part;
    });
    return {
        schema,
        parent: parent2,
        parentPath: lastPart
    };
}
function reach(obj, path, value, context) {
    return getIn(obj, path, value, context).schema;
}
function clone(src, seen = /* @__PURE__ */ new Map()) {
    if (isSchema(src) || !src || typeof src !== "object") return src;
    if (seen.has(src)) return seen.get(src);
    let copy;
    if (src instanceof Date) {
        copy = new Date(src.getTime());
        seen.set(src, copy);
    } else if (src instanceof RegExp) {
        copy = new RegExp(src);
        seen.set(src, copy);
    } else if (Array.isArray(src)) {
        copy = new Array(src.length);
        seen.set(src, copy);
        for(let i2 = 0; i2 < src.length; i2++)copy[i2] = clone(src[i2], seen);
    } else if (src instanceof Map) {
        copy = /* @__PURE__ */ new Map();
        seen.set(src, copy);
        for (const [k, v] of src.entries())copy.set(k, clone(v, seen));
    } else if (src instanceof Set) {
        copy = /* @__PURE__ */ new Set();
        seen.set(src, copy);
        for (const v of src)copy.add(clone(v, seen));
    } else if (src instanceof Object) {
        copy = {};
        seen.set(src, copy);
        for (const [k, v] of Object.entries(src))copy[k] = clone(v, seen);
    } else {
        throw Error(`Unable to clone ${src}`);
    }
    return copy;
}
function createStandardPath(path) {
    if (!(path != null && path.length)) {
        return void 0;
    }
    const segments = [];
    let currentSegment = "";
    let inBrackets = false;
    let inQuotes = false;
    for(let i2 = 0; i2 < path.length; i2++){
        const char = path[i2];
        if (char === "[" && !inQuotes) {
            if (currentSegment) {
                segments.push(...currentSegment.split(".").filter(Boolean));
                currentSegment = "";
            }
            inBrackets = true;
            continue;
        }
        if (char === "]" && !inQuotes) {
            if (currentSegment) {
                if (/^\d+$/.test(currentSegment)) {
                    segments.push(currentSegment);
                } else {
                    segments.push(currentSegment.replace(/^"|"$/g, ""));
                }
                currentSegment = "";
            }
            inBrackets = false;
            continue;
        }
        if (char === '"') {
            inQuotes = !inQuotes;
            continue;
        }
        if (char === "." && !inBrackets && !inQuotes) {
            if (currentSegment) {
                segments.push(currentSegment);
                currentSegment = "";
            }
            continue;
        }
        currentSegment += char;
    }
    if (currentSegment) {
        segments.push(...currentSegment.split(".").filter(Boolean));
    }
    return segments;
}
function createStandardIssues(error, parentPath) {
    const path = parentPath ? `${parentPath}.${error.path}` : error.path;
    return error.errors.map((err)=>({
            message: err,
            path: createStandardPath(path)
        }));
}
function issuesFromValidationError(error, parentPath) {
    var _error$inner;
    if (!((_error$inner = error.inner) != null && _error$inner.length) && error.errors.length) {
        return createStandardIssues(error, parentPath);
    }
    const path = parentPath ? `${parentPath}.${error.path}` : error.path;
    return error.inner.flatMap((err)=>issuesFromValidationError(err, path));
}
function create$8(spec) {
    return new MixedSchema(spec);
}
function create$7() {
    return new BooleanSchema();
}
function parseIsoDate(date2) {
    const struct = parseDateStruct(date2);
    if (!struct) return Date.parse ? Date.parse(date2) : Number.NaN;
    if (struct.z === void 0 && struct.plusMinus === void 0) {
        return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();
    }
    let totalMinutesOffset = 0;
    if (struct.z !== "Z" && struct.plusMinus !== void 0) {
        totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;
        if (struct.plusMinus === "+") totalMinutesOffset = 0 - totalMinutesOffset;
    }
    return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);
}
function parseDateStruct(date2) {
    var _regexResult$7$length, _regexResult$;
    const regexResult = isoReg.exec(date2);
    if (!regexResult) return null;
    return {
        year: toNumber2(regexResult[1]),
        month: toNumber2(regexResult[2], 1) - 1,
        day: toNumber2(regexResult[3], 1),
        hour: toNumber2(regexResult[4]),
        minute: toNumber2(regexResult[5]),
        second: toNumber2(regexResult[6]),
        millisecond: regexResult[7] ? // allow arbitrary sub-second precision beyond milliseconds
        toNumber2(regexResult[7].substring(0, 3)) : 0,
        precision: (_regexResult$7$length = (_regexResult$ = regexResult[7]) == null ? void 0 : _regexResult$.length) != null ? _regexResult$7$length : void 0,
        z: regexResult[8] || void 0,
        plusMinus: regexResult[9] || void 0,
        hourOffset: toNumber2(regexResult[10]),
        minuteOffset: toNumber2(regexResult[11])
    };
}
function toNumber2(str, defaultValue = 0) {
    return Number(str) || defaultValue;
}
function create$6() {
    return new StringSchema();
}
function create$5() {
    return new NumberSchema();
}
function create$4() {
    return new DateSchema();
}
function sortFields(fields, excludedEdges = []) {
    let edges = [];
    let nodes = /* @__PURE__ */ new Set();
    let excludes = new Set(excludedEdges.map(([a, b])=>`${a}-${b}`));
    function addNode(depPath, key) {
        let node = (0, import_property_expr.split)(depPath)[0];
        nodes.add(node);
        if (!excludes.has(`${key}-${node}`)) edges.push([
            key,
            node
        ]);
    }
    for (const key of Object.keys(fields)){
        let value = fields[key];
        nodes.add(key);
        if (Reference.isRef(value) && value.isSibling) addNode(value.path, key);
        else if (isSchema(value) && "deps" in value) value.deps.forEach((path)=>addNode(path, key));
    }
    return import_toposort.default.array(Array.from(nodes), edges).reverse();
}
function findIndex(arr, err) {
    let idx = Infinity;
    arr.some((key, ii)=>{
        var _err$path;
        if ((_err$path = err.path) != null && _err$path.includes(key)) {
            idx = ii;
            return true;
        }
    });
    return idx;
}
function sortByKeyOrder(keys2) {
    return (a, b)=>{
        return findIndex(keys2, a) - findIndex(keys2, b);
    };
}
function deepPartial(schema) {
    if ("fields" in schema) {
        const partial = {};
        for (const [key, fieldSchema] of Object.entries(schema.fields)){
            partial[key] = deepPartial(fieldSchema);
        }
        return schema.setFields(partial);
    }
    if (schema.type === "array") {
        const nextArray = schema.optional();
        if (nextArray.innerType) nextArray.innerType = deepPartial(nextArray.innerType);
        return nextArray;
    }
    if (schema.type === "tuple") {
        return schema.optional().clone({
            types: schema.spec.types.map(deepPartial)
        });
    }
    if ("optional" in schema) {
        return schema.optional();
    }
    return schema;
}
function unknown(ctx, value) {
    let known = Object.keys(ctx.fields);
    return Object.keys(value).filter((key)=>known.indexOf(key) === -1);
}
function create$3(spec) {
    return new ObjectSchema(spec);
}
function create$2(type) {
    return new ArraySchema(type);
}
function create$1(schemas) {
    return new TupleSchema(schemas);
}
function create(builder) {
    return new Lazy(builder);
}
function catchValidationError(fn) {
    try {
        return fn();
    } catch (err) {
        if (ValidationError.isError(err)) return Promise.reject(err);
        throw err;
    }
}
function setLocale(custom) {
    Object.keys(custom).forEach((type)=>{
        Object.keys(custom[type]).forEach((method)=>{
            locale[type][method] = custom[type][method];
        });
    });
}
function addMethod(schemaType, name, fn) {
    if (!schemaType || !isSchema(schemaType.prototype)) throw new TypeError("You must provide a yup schema constructor function");
    if (typeof name !== "string") throw new TypeError("A Method name must be provided");
    if (typeof fn !== "function") throw new TypeError("Method function must be provided");
    schemaType.prototype[name] = fn;
}
var import_property_expr, import_tiny_case, import_toposort, toString2, errorToString, regExpToString, symbolToString2, SYMBOL_REGEXP, _Symbol$toStringTag, _Symbol$hasInstance, _Symbol$toStringTag2, strReg, ValidationErrorNoStack, ValidationError, mixed, string, number, date, boolean, object, array, tuple, locale, isSchema, Condition, prefixes, Reference, isAbsent, ReferenceSet, Schema, returnsTrue, MixedSchema, BooleanSchema, isoReg, rEmail, rUrl, rUUID, yearMonthDay, hourMinuteSecond, zOrOffset, rIsoDateTime, isTrimmed, objStringTag, StringSchema, isNaN$1, NumberSchema, invalidDate, isDate, DateSchema, parseJson, deepHas, isObject3, defaultSort, ObjectSchema, ArraySchema, TupleSchema, Lazy;
var init_index_esm = __esm({
    "node_modules/yup/index.esm.js" () {
        import_property_expr = __toESM(require_property_expr());
        import_tiny_case = __toESM(require_tiny_case());
        import_toposort = __toESM(require_toposort());
        toString2 = Object.prototype.toString;
        errorToString = Error.prototype.toString;
        regExpToString = RegExp.prototype.toString;
        symbolToString2 = typeof Symbol !== "undefined" ? Symbol.prototype.toString : ()=>"";
        SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
        strReg = /\$\{\s*(\w+)\s*\}/g;
        _Symbol$toStringTag = Symbol.toStringTag;
        ValidationErrorNoStack = class {
            constructor(errorOrErrors, value, field, type){
                this.name = void 0;
                this.message = void 0;
                this.value = void 0;
                this.path = void 0;
                this.type = void 0;
                this.params = void 0;
                this.errors = void 0;
                this.inner = void 0;
                this[_Symbol$toStringTag] = "Error";
                this.name = "ValidationError";
                this.value = value;
                this.path = field;
                this.type = type;
                this.errors = [];
                this.inner = [];
                toArray(errorOrErrors).forEach((err)=>{
                    if (ValidationError.isError(err)) {
                        this.errors.push(...err.errors);
                        const innerErrors = err.inner.length ? err.inner : [
                            err
                        ];
                        this.inner.push(...innerErrors);
                    } else {
                        this.errors.push(err);
                    }
                });
                this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
            }
        };
        _Symbol$hasInstance = Symbol.hasInstance;
        _Symbol$toStringTag2 = Symbol.toStringTag;
        ValidationError = class _ValidationError extends Error {
            static formatError(message, params) {
                const path = params.label || params.path || "this";
                params = Object.assign({}, params, {
                    path,
                    originalPath: params.path
                });
                if (typeof message === "string") return message.replace(strReg, (_, key)=>printValue(params[key]));
                if (typeof message === "function") return message(params);
                return message;
            }
            static isError(err) {
                return err && err.name === "ValidationError";
            }
            static [_Symbol$hasInstance](inst) {
                return ValidationErrorNoStack[Symbol.hasInstance](inst) || super[Symbol.hasInstance](inst);
            }
            constructor(errorOrErrors, value, field, type, disableStack){
                const errorNoStack = new ValidationErrorNoStack(errorOrErrors, value, field, type);
                if (disableStack) {
                    return errorNoStack;
                }
                super();
                this.value = void 0;
                this.path = void 0;
                this.type = void 0;
                this.params = void 0;
                this.errors = [];
                this.inner = [];
                this[_Symbol$toStringTag2] = "Error";
                this.name = errorNoStack.name;
                this.message = errorNoStack.message;
                this.type = errorNoStack.type;
                this.value = errorNoStack.value;
                this.path = errorNoStack.path;
                this.errors = errorNoStack.errors;
                this.inner = errorNoStack.inner;
                if (Error.captureStackTrace) {
                    Error.captureStackTrace(this, _ValidationError);
                }
            }
        };
        mixed = {
            default: "${path} is invalid",
            required: "${path} is a required field",
            defined: "${path} must be defined",
            notNull: "${path} cannot be null",
            oneOf: "${path} must be one of the following values: ${values}",
            notOneOf: "${path} must not be one of the following values: ${values}",
            notType: ({ path, type, value, originalValue })=>{
                const castMsg = originalValue != null && originalValue !== value ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : ".";
                return type !== "mixed" ? `${path} must be a \`${type}\` type, but the final value was: \`${printValue(value, true)}\`` + castMsg : `${path} must match the configured type. The validated value was: \`${printValue(value, true)}\`` + castMsg;
            }
        };
        string = {
            length: "${path} must be exactly ${length} characters",
            min: "${path} must be at least ${min} characters",
            max: "${path} must be at most ${max} characters",
            matches: '${path} must match the following: "${regex}"',
            email: "${path} must be a valid email",
            url: "${path} must be a valid URL",
            uuid: "${path} must be a valid UUID",
            datetime: "${path} must be a valid ISO date-time",
            datetime_precision: "${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits",
            datetime_offset: '${path} must be a valid ISO date-time with UTC "Z" timezone',
            trim: "${path} must be a trimmed string",
            lowercase: "${path} must be a lowercase string",
            uppercase: "${path} must be a upper case string"
        };
        number = {
            min: "${path} must be greater than or equal to ${min}",
            max: "${path} must be less than or equal to ${max}",
            lessThan: "${path} must be less than ${less}",
            moreThan: "${path} must be greater than ${more}",
            positive: "${path} must be a positive number",
            negative: "${path} must be a negative number",
            integer: "${path} must be an integer"
        };
        date = {
            min: "${path} field must be later than ${min}",
            max: "${path} field must be at earlier than ${max}"
        };
        boolean = {
            isValue: "${path} field must be ${value}"
        };
        object = {
            noUnknown: "${path} field has unspecified keys: ${unknown}",
            exact: "${path} object contains unknown properties: ${properties}"
        };
        array = {
            min: "${path} field must have at least ${min} items",
            max: "${path} field must have less than or equal to ${max} items",
            length: "${path} must have ${length} items"
        };
        tuple = {
            notType: (params)=>{
                const { path, value, spec } = params;
                const typeLen = spec.types.length;
                if (Array.isArray(value)) {
                    if (value.length < typeLen) return `${path} tuple value has too few items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
                    if (value.length > typeLen) return `${path} tuple value has too many items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
                }
                return ValidationError.formatError(mixed.notType, params);
            }
        };
        locale = Object.assign(/* @__PURE__ */ Object.create(null), {
            mixed,
            string,
            number,
            date,
            object,
            array,
            boolean,
            tuple
        });
        isSchema = (obj)=>obj && obj.__isYupSchema__;
        Condition = class _Condition {
            static fromOptions(refs, config) {
                if (!config.then && !config.otherwise) throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
                let { is: is2, then: then2, otherwise } = config;
                let check = typeof is2 === "function" ? is2 : (...values)=>values.every((value)=>value === is2);
                return new _Condition(refs, (values, schema)=>{
                    var _branch;
                    let branch = check(...values) ? then2 : otherwise;
                    return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;
                });
            }
            resolve(base, options3) {
                let values = this.refs.map((ref)=>// TODO: ? operator here?
                    ref.getValue(options3 == null ? void 0 : options3.value, options3 == null ? void 0 : options3.parent, options3 == null ? void 0 : options3.context));
                let schema = this.fn(values, base, options3);
                if (schema === void 0 || // @ts-ignore this can be base
                schema === base) {
                    return base;
                }
                if (!isSchema(schema)) throw new TypeError("conditions must return a schema object");
                return schema.resolve(options3);
            }
            constructor(refs, builder){
                this.fn = void 0;
                this.refs = refs;
                this.refs = refs;
                this.fn = builder;
            }
        };
        prefixes = {
            context: "$",
            value: "."
        };
        Reference = class {
            getValue(value, parent2, context) {
                let result = this.isContext ? context : this.isValue ? value : parent2;
                if (this.getter) result = this.getter(result || {});
                if (this.map) result = this.map(result);
                return result;
            }
            /**
       *
       * @param {*} value
       * @param {Object} options
       * @param {Object=} options.context
       * @param {Object=} options.parent
       */ cast(value, options3) {
                return this.getValue(value, options3 == null ? void 0 : options3.parent, options3 == null ? void 0 : options3.context);
            }
            resolve() {
                return this;
            }
            describe() {
                return {
                    type: "ref",
                    key: this.key
                };
            }
            toString() {
                return `Ref(${this.key})`;
            }
            static isRef(value) {
                return value && value.__isYupRef;
            }
            constructor(key, options3 = {}){
                this.key = void 0;
                this.isContext = void 0;
                this.isValue = void 0;
                this.isSibling = void 0;
                this.path = void 0;
                this.getter = void 0;
                this.map = void 0;
                if (typeof key !== "string") throw new TypeError("ref must be a string, got: " + key);
                this.key = key.trim();
                if (key === "") throw new TypeError("ref must be a non-empty string");
                this.isContext = this.key[0] === prefixes.context;
                this.isValue = this.key[0] === prefixes.value;
                this.isSibling = !this.isContext && !this.isValue;
                let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
                this.path = this.key.slice(prefix.length);
                this.getter = this.path && (0, import_property_expr.getter)(this.path, true);
                this.map = options3.map;
            }
        };
        Reference.prototype.__isYupRef = true;
        isAbsent = (value)=>value == null;
        ReferenceSet = class _ReferenceSet extends Set {
            describe() {
                const description = [];
                for (const item of this.values()){
                    description.push(Reference.isRef(item) ? item.describe() : item);
                }
                return description;
            }
            resolveAll(resolve) {
                let result = [];
                for (const item of this.values()){
                    result.push(resolve(item));
                }
                return result;
            }
            clone() {
                return new _ReferenceSet(this.values());
            }
            merge(newItems, removeItems) {
                const next2 = this.clone();
                newItems.forEach((value)=>next2.add(value));
                removeItems.forEach((value)=>next2.delete(value));
                return next2;
            }
        };
        Schema = class {
            // TODO: remove
            get _type() {
                return this.type;
            }
            clone(spec) {
                if (this._mutate) {
                    if (spec) Object.assign(this.spec, spec);
                    return this;
                }
                const next2 = Object.create(Object.getPrototypeOf(this));
                next2.type = this.type;
                next2._typeCheck = this._typeCheck;
                next2._whitelist = this._whitelist.clone();
                next2._blacklist = this._blacklist.clone();
                next2.internalTests = Object.assign({}, this.internalTests);
                next2.exclusiveTests = Object.assign({}, this.exclusiveTests);
                next2.deps = [
                    ...this.deps
                ];
                next2.conditions = [
                    ...this.conditions
                ];
                next2.tests = [
                    ...this.tests
                ];
                next2.transforms = [
                    ...this.transforms
                ];
                next2.spec = clone(Object.assign({}, this.spec, spec));
                return next2;
            }
            label(label) {
                let next2 = this.clone();
                next2.spec.label = label;
                return next2;
            }
            meta(...args) {
                if (args.length === 0) return this.spec.meta;
                let next2 = this.clone();
                next2.spec.meta = Object.assign(next2.spec.meta || {}, args[0]);
                return next2;
            }
            withMutation(fn) {
                let before = this._mutate;
                this._mutate = true;
                let result = fn(this);
                this._mutate = before;
                return result;
            }
            concat(schema) {
                if (!schema || schema === this) return this;
                if (schema.type !== this.type && this.type !== "mixed") throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema.type}`);
                let base = this;
                let combined = schema.clone();
                const mergedSpec = Object.assign({}, base.spec, combined.spec);
                combined.spec = mergedSpec;
                combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);
                combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);
                combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);
                combined.tests = base.tests;
                combined.exclusiveTests = base.exclusiveTests;
                combined.withMutation((next2)=>{
                    schema.tests.forEach((fn)=>{
                        next2.test(fn.OPTIONS);
                    });
                });
                combined.transforms = [
                    ...base.transforms,
                    ...combined.transforms
                ];
                return combined;
            }
            isType(v) {
                if (v == null) {
                    if (this.spec.nullable && v === null) return true;
                    if (this.spec.optional && v === void 0) return true;
                    return false;
                }
                return this._typeCheck(v);
            }
            resolve(options3) {
                let schema = this;
                if (schema.conditions.length) {
                    let conditions = schema.conditions;
                    schema = schema.clone();
                    schema.conditions = [];
                    schema = conditions.reduce((prevSchema, condition)=>condition.resolve(prevSchema, options3), schema);
                    schema = schema.resolve(options3);
                }
                return schema;
            }
            resolveOptions(options3) {
                var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;
                return Object.assign({}, options3, {
                    from: options3.from || [],
                    strict: (_options$strict = options3.strict) != null ? _options$strict : this.spec.strict,
                    abortEarly: (_options$abortEarly = options3.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,
                    recursive: (_options$recursive = options3.recursive) != null ? _options$recursive : this.spec.recursive,
                    disableStackTrace: (_options$disableStack = options3.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace
                });
            }
            /**
       * Run the configured transform pipeline over an input value.
       */ cast(value, options3 = {}) {
                let resolvedSchema = this.resolve(Object.assign({
                    value
                }, options3));
                let allowOptionality = options3.assert === "ignore-optionality";
                let result = resolvedSchema._cast(value, options3);
                if (options3.assert !== false && !resolvedSchema.isType(result)) {
                    if (allowOptionality && isAbsent(result)) {
                        return result;
                    }
                    let formattedValue = printValue(value);
                    let formattedResult = printValue(result);
                    throw new TypeError(`The value of ${options3.path || "field"} could not be cast to a value that satisfies the schema type: "${resolvedSchema.type}". 

attempted value: ${formattedValue} 
` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ""));
                }
                return result;
            }
            _cast(rawValue, options3) {
                let value = rawValue === void 0 ? rawValue : this.transforms.reduce((prevValue, fn)=>fn.call(this, prevValue, rawValue, this), rawValue);
                if (value === void 0) {
                    value = this.getDefault(options3);
                }
                return value;
            }
            _validate(_value, options3 = {}, panic, next2) {
                let { path, originalValue = _value, strict = this.spec.strict } = options3;
                let value = _value;
                if (!strict) {
                    value = this._cast(value, Object.assign({
                        assert: false
                    }, options3));
                }
                let initialTests = [];
                for (let test of Object.values(this.internalTests)){
                    if (test) initialTests.push(test);
                }
                this.runTests({
                    path,
                    value,
                    originalValue,
                    options: options3,
                    tests: initialTests
                }, panic, (initialErrors)=>{
                    if (initialErrors.length) {
                        return next2(initialErrors, value);
                    }
                    this.runTests({
                        path,
                        value,
                        originalValue,
                        options: options3,
                        tests: this.tests
                    }, panic, next2);
                });
            }
            /**
       * Executes a set of validations, either schema, produced Tests or a nested
       * schema validate result.
       */ runTests(runOptions, panic, next2) {
                let fired = false;
                let { tests, value, originalValue, path, options: options3 } = runOptions;
                let panicOnce = (arg)=>{
                    if (fired) return;
                    fired = true;
                    panic(arg, value);
                };
                let nextOnce = (arg)=>{
                    if (fired) return;
                    fired = true;
                    next2(arg, value);
                };
                let count = tests.length;
                let nestedErrors = [];
                if (!count) return nextOnce([]);
                let args = {
                    value,
                    originalValue,
                    path,
                    options: options3,
                    schema: this
                };
                for(let i2 = 0; i2 < tests.length; i2++){
                    const test = tests[i2];
                    test(args, panicOnce, function finishTestRun(err) {
                        if (err) {
                            Array.isArray(err) ? nestedErrors.push(...err) : nestedErrors.push(err);
                        }
                        if (--count <= 0) {
                            nextOnce(nestedErrors);
                        }
                    });
                }
            }
            asNestedTest({ key, index: index2, parent: parent2, parentPath, originalParent, options: options3 }) {
                const k = key != null ? key : index2;
                if (k == null) {
                    throw TypeError("Must include `key` or `index` for nested validations");
                }
                const isIndex2 = typeof k === "number";
                let value = parent2[k];
                const testOptions = Object.assign({}, options3, {
                    // Nested validations fields are always strict:
                    //    1. parent isn't strict so the casting will also have cast inner values
                    //    2. parent is strict in which case the nested values weren't cast either
                    strict: true,
                    parent: parent2,
                    value,
                    originalValue: originalParent[k],
                    // FIXME: tests depend on `index` being passed around deeply,
                    //   we should not let the options.key/index bleed through
                    key: void 0,
                    // index: undefined,
                    [isIndex2 ? "index" : "key"]: k,
                    path: isIndex2 || k.includes(".") ? `${parentPath || ""}[${isIndex2 ? k : `"${k}"`}]` : (parentPath ? `${parentPath}.` : "") + key
                });
                return (_, panic, next2)=>this.resolve(testOptions)._validate(value, testOptions, panic, next2);
            }
            validate(value, options3) {
                var _options$disableStack2;
                let schema = this.resolve(Object.assign({}, options3, {
                    value
                }));
                let disableStackTrace = (_options$disableStack2 = options3 == null ? void 0 : options3.disableStackTrace) != null ? _options$disableStack2 : schema.spec.disableStackTrace;
                return new Promise((resolve, reject)=>schema._validate(value, options3, (error, parsed)=>{
                        if (ValidationError.isError(error)) error.value = parsed;
                        reject(error);
                    }, (errors, validated)=>{
                        if (errors.length) reject(new ValidationError(errors, validated, void 0, void 0, disableStackTrace));
                        else resolve(validated);
                    }));
            }
            validateSync(value, options3) {
                var _options$disableStack3;
                let schema = this.resolve(Object.assign({}, options3, {
                    value
                }));
                let result;
                let disableStackTrace = (_options$disableStack3 = options3 == null ? void 0 : options3.disableStackTrace) != null ? _options$disableStack3 : schema.spec.disableStackTrace;
                schema._validate(value, Object.assign({}, options3, {
                    sync: true
                }), (error, parsed)=>{
                    if (ValidationError.isError(error)) error.value = parsed;
                    throw error;
                }, (errors, validated)=>{
                    if (errors.length) throw new ValidationError(errors, value, void 0, void 0, disableStackTrace);
                    result = validated;
                });
                return result;
            }
            isValid(value, options3) {
                return this.validate(value, options3).then(()=>true, (err)=>{
                    if (ValidationError.isError(err)) return false;
                    throw err;
                });
            }
            isValidSync(value, options3) {
                try {
                    this.validateSync(value, options3);
                    return true;
                } catch (err) {
                    if (ValidationError.isError(err)) return false;
                    throw err;
                }
            }
            _getDefault(options3) {
                let defaultValue = this.spec.default;
                if (defaultValue == null) {
                    return defaultValue;
                }
                return typeof defaultValue === "function" ? defaultValue.call(this, options3) : clone(defaultValue);
            }
            getDefault(options3) {
                let schema = this.resolve(options3 || {});
                return schema._getDefault(options3);
            }
            default(def) {
                if (arguments.length === 0) {
                    return this._getDefault();
                }
                let next2 = this.clone({
                    default: def
                });
                return next2;
            }
            strict(isStrict = true) {
                return this.clone({
                    strict: isStrict
                });
            }
            nullability(nullable, message) {
                const next2 = this.clone({
                    nullable
                });
                next2.internalTests.nullable = createValidation({
                    message,
                    name: "nullable",
                    test (value) {
                        return value === null ? this.schema.spec.nullable : true;
                    }
                });
                return next2;
            }
            optionality(optional, message) {
                const next2 = this.clone({
                    optional
                });
                next2.internalTests.optionality = createValidation({
                    message,
                    name: "optionality",
                    test (value) {
                        return value === void 0 ? this.schema.spec.optional : true;
                    }
                });
                return next2;
            }
            optional() {
                return this.optionality(true);
            }
            defined(message = mixed.defined) {
                return this.optionality(false, message);
            }
            nullable() {
                return this.nullability(true);
            }
            nonNullable(message = mixed.notNull) {
                return this.nullability(false, message);
            }
            required(message = mixed.required) {
                return this.clone().withMutation((next2)=>next2.nonNullable(message).defined(message));
            }
            notRequired() {
                return this.clone().withMutation((next2)=>next2.nullable().optional());
            }
            transform(fn) {
                let next2 = this.clone();
                next2.transforms.push(fn);
                return next2;
            }
            /**
       * Adds a test function to the schema's queue of tests.
       * tests can be exclusive or non-exclusive.
       *
       * - exclusive tests, will replace any existing tests of the same name.
       * - non-exclusive: can be stacked
       *
       * If a non-exclusive test is added to a schema with an exclusive test of the same name
       * the exclusive test is removed and further tests of the same name will be stacked.
       *
       * If an exclusive test is added to a schema with non-exclusive tests of the same name
       * the previous tests are removed and further tests of the same name will replace each other.
       */ test(...args) {
                let opts;
                if (args.length === 1) {
                    if (typeof args[0] === "function") {
                        opts = {
                            test: args[0]
                        };
                    } else {
                        opts = args[0];
                    }
                } else if (args.length === 2) {
                    opts = {
                        name: args[0],
                        test: args[1]
                    };
                } else {
                    opts = {
                        name: args[0],
                        message: args[1],
                        test: args[2]
                    };
                }
                if (opts.message === void 0) opts.message = mixed.default;
                if (typeof opts.test !== "function") throw new TypeError("`test` is a required parameters");
                let next2 = this.clone();
                let validate = createValidation(opts);
                let isExclusive = opts.exclusive || opts.name && next2.exclusiveTests[opts.name] === true;
                if (opts.exclusive) {
                    if (!opts.name) throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
                }
                if (opts.name) next2.exclusiveTests[opts.name] = !!opts.exclusive;
                next2.tests = next2.tests.filter((fn)=>{
                    if (fn.OPTIONS.name === opts.name) {
                        if (isExclusive) return false;
                        if (fn.OPTIONS.test === validate.OPTIONS.test) return false;
                    }
                    return true;
                });
                next2.tests.push(validate);
                return next2;
            }
            when(keys2, options3) {
                if (!Array.isArray(keys2) && typeof keys2 !== "string") {
                    options3 = keys2;
                    keys2 = ".";
                }
                let next2 = this.clone();
                let deps = toArray(keys2).map((key)=>new Reference(key));
                deps.forEach((dep)=>{
                    if (dep.isSibling) next2.deps.push(dep.key);
                });
                next2.conditions.push(typeof options3 === "function" ? new Condition(deps, options3) : Condition.fromOptions(deps, options3));
                return next2;
            }
            typeError(message) {
                let next2 = this.clone();
                next2.internalTests.typeError = createValidation({
                    message,
                    name: "typeError",
                    skipAbsent: true,
                    test (value) {
                        if (!this.schema._typeCheck(value)) return this.createError({
                            params: {
                                type: this.schema.type
                            }
                        });
                        return true;
                    }
                });
                return next2;
            }
            oneOf(enums, message = mixed.oneOf) {
                let next2 = this.clone();
                enums.forEach((val)=>{
                    next2._whitelist.add(val);
                    next2._blacklist.delete(val);
                });
                next2.internalTests.whiteList = createValidation({
                    message,
                    name: "oneOf",
                    skipAbsent: true,
                    test (value) {
                        let valids = this.schema._whitelist;
                        let resolved = valids.resolveAll(this.resolve);
                        return resolved.includes(value) ? true : this.createError({
                            params: {
                                values: Array.from(valids).join(", "),
                                resolved
                            }
                        });
                    }
                });
                return next2;
            }
            notOneOf(enums, message = mixed.notOneOf) {
                let next2 = this.clone();
                enums.forEach((val)=>{
                    next2._blacklist.add(val);
                    next2._whitelist.delete(val);
                });
                next2.internalTests.blacklist = createValidation({
                    message,
                    name: "notOneOf",
                    test (value) {
                        let invalids = this.schema._blacklist;
                        let resolved = invalids.resolveAll(this.resolve);
                        if (resolved.includes(value)) return this.createError({
                            params: {
                                values: Array.from(invalids).join(", "),
                                resolved
                            }
                        });
                        return true;
                    }
                });
                return next2;
            }
            strip(strip = true) {
                let next2 = this.clone();
                next2.spec.strip = strip;
                return next2;
            }
            /**
       * Return a serialized description of the schema including validations, flags, types etc.
       *
       * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).
       */ describe(options3) {
                const next2 = (options3 ? this.resolve(options3) : this).clone();
                const { label, meta, optional, nullable } = next2.spec;
                const description = {
                    meta,
                    label,
                    optional,
                    nullable,
                    default: next2.getDefault(options3),
                    type: next2.type,
                    oneOf: next2._whitelist.describe(),
                    notOneOf: next2._blacklist.describe(),
                    tests: next2.tests.filter((n, idx, list2)=>list2.findIndex((c)=>c.OPTIONS.name === n.OPTIONS.name) === idx).map((fn)=>{
                        const params = fn.OPTIONS.params && options3 ? resolveParams(Object.assign({}, fn.OPTIONS.params), options3) : fn.OPTIONS.params;
                        return {
                            name: fn.OPTIONS.name,
                            params
                        };
                    })
                };
                return description;
            }
            get ["~standard"]() {
                const schema = this;
                const standard = {
                    version: 1,
                    vendor: "yup",
                    validate (value) {
                        return _async_to_generator(function*() {
                            try {
                                const result = yield schema.validate(value, {
                                    abortEarly: false
                                });
                                return {
                                    value: result
                                };
                            } catch (err) {
                                if (err instanceof ValidationError) {
                                    return {
                                        issues: issuesFromValidationError(err)
                                    };
                                }
                                throw err;
                            }
                        })();
                    }
                };
                return standard;
            }
            constructor(options3){
                this.type = void 0;
                this.deps = [];
                this.tests = void 0;
                this.transforms = void 0;
                this.conditions = [];
                this._mutate = void 0;
                this.internalTests = {};
                this._whitelist = new ReferenceSet();
                this._blacklist = new ReferenceSet();
                this.exclusiveTests = /* @__PURE__ */ Object.create(null);
                this._typeCheck = void 0;
                this.spec = void 0;
                this.tests = [];
                this.transforms = [];
                this.withMutation(()=>{
                    this.typeError(mixed.notType);
                });
                this.type = options3.type;
                this._typeCheck = options3.check;
                this.spec = Object.assign({
                    strip: false,
                    strict: false,
                    abortEarly: true,
                    recursive: true,
                    disableStackTrace: false,
                    nullable: false,
                    optional: true,
                    coerce: true
                }, options3 == null ? void 0 : options3.spec);
                this.withMutation((s)=>{
                    s.nonNullable();
                });
            }
        };
        Schema.prototype.__isYupSchema__ = true;
        for (const method of [
            "validate",
            "validateSync"
        ])Schema.prototype[`${method}At`] = function(path, value, options3 = {}) {
            const { parent: parent2, parentPath, schema } = getIn(this, path, value, options3.context);
            return schema[method](parent2 && parent2[parentPath], Object.assign({}, options3, {
                parent: parent2,
                path
            }));
        };
        for (const alias of [
            "equals",
            "is"
        ])Schema.prototype[alias] = Schema.prototype.oneOf;
        for (const alias of [
            "not",
            "nope"
        ])Schema.prototype[alias] = Schema.prototype.notOneOf;
        returnsTrue = ()=>true;
        MixedSchema = class extends Schema {
            constructor(spec){
                super(typeof spec === "function" ? {
                    type: "mixed",
                    check: spec
                } : Object.assign({
                    type: "mixed",
                    check: returnsTrue
                }, spec));
            }
        };
        create$8.prototype = MixedSchema.prototype;
        BooleanSchema = class extends Schema {
            isTrue(message = boolean.isValue) {
                return this.test({
                    message,
                    name: "is-value",
                    exclusive: true,
                    params: {
                        value: "true"
                    },
                    test (value) {
                        return isAbsent(value) || value === true;
                    }
                });
            }
            isFalse(message = boolean.isValue) {
                return this.test({
                    message,
                    name: "is-value",
                    exclusive: true,
                    params: {
                        value: "false"
                    },
                    test (value) {
                        return isAbsent(value) || value === false;
                    }
                });
            }
            default(def) {
                return super.default(def);
            }
            defined(msg) {
                return super.defined(msg);
            }
            optional() {
                return super.optional();
            }
            required(msg) {
                return super.required(msg);
            }
            notRequired() {
                return super.notRequired();
            }
            nullable() {
                return super.nullable();
            }
            nonNullable(msg) {
                return super.nonNullable(msg);
            }
            strip(v) {
                return super.strip(v);
            }
            constructor(){
                super({
                    type: "boolean",
                    check (v) {
                        if (v instanceof Boolean) v = v.valueOf();
                        return typeof v === "boolean";
                    }
                });
                this.withMutation(()=>{
                    this.transform((value, _raw, ctx)=>{
                        if (ctx.spec.coerce && !ctx.isType(value)) {
                            if (/^(true|1)$/i.test(String(value))) return true;
                            if (/^(false|0)$/i.test(String(value))) return false;
                        }
                        return value;
                    });
                });
            }
        };
        create$7.prototype = BooleanSchema.prototype;
        isoReg = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
        rEmail = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
        rUrl = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
        rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
        yearMonthDay = "^\\d{4}-\\d{2}-\\d{2}";
        hourMinuteSecond = "\\d{2}:\\d{2}:\\d{2}";
        zOrOffset = "(([+-]\\d{2}(:?\\d{2})?)|Z)";
        rIsoDateTime = new RegExp(`${yearMonthDay}T${hourMinuteSecond}(\\.\\d+)?${zOrOffset}$`);
        isTrimmed = (value)=>isAbsent(value) || value === value.trim();
        objStringTag = ({}).toString();
        StringSchema = class extends Schema {
            required(message) {
                return super.required(message).withMutation((schema)=>schema.test({
                        message: message || mixed.required,
                        name: "required",
                        skipAbsent: true,
                        test: (value)=>!!value.length
                    }));
            }
            notRequired() {
                return super.notRequired().withMutation((schema)=>{
                    schema.tests = schema.tests.filter((t)=>t.OPTIONS.name !== "required");
                    return schema;
                });
            }
            length(length, message = string.length) {
                return this.test({
                    message,
                    name: "length",
                    exclusive: true,
                    params: {
                        length
                    },
                    skipAbsent: true,
                    test (value) {
                        return value.length === this.resolve(length);
                    }
                });
            }
            min(min, message = string.min) {
                return this.test({
                    message,
                    name: "min",
                    exclusive: true,
                    params: {
                        min
                    },
                    skipAbsent: true,
                    test (value) {
                        return value.length >= this.resolve(min);
                    }
                });
            }
            max(max, message = string.max) {
                return this.test({
                    name: "max",
                    exclusive: true,
                    message,
                    params: {
                        max
                    },
                    skipAbsent: true,
                    test (value) {
                        return value.length <= this.resolve(max);
                    }
                });
            }
            matches(regex, options3) {
                let excludeEmptyString = false;
                let message;
                let name;
                if (options3) {
                    if (typeof options3 === "object") {
                        ({ excludeEmptyString = false, message, name } = options3);
                    } else {
                        message = options3;
                    }
                }
                return this.test({
                    name: name || "matches",
                    message: message || string.matches,
                    params: {
                        regex
                    },
                    skipAbsent: true,
                    test: (value)=>value === "" && excludeEmptyString || value.search(regex) !== -1
                });
            }
            email(message = string.email) {
                return this.matches(rEmail, {
                    name: "email",
                    message,
                    excludeEmptyString: true
                });
            }
            url(message = string.url) {
                return this.matches(rUrl, {
                    name: "url",
                    message,
                    excludeEmptyString: true
                });
            }
            uuid(message = string.uuid) {
                return this.matches(rUUID, {
                    name: "uuid",
                    message,
                    excludeEmptyString: false
                });
            }
            datetime(options3) {
                let message = "";
                let allowOffset;
                let precision;
                if (options3) {
                    if (typeof options3 === "object") {
                        ({ message = "", allowOffset = false, precision = void 0 } = options3);
                    } else {
                        message = options3;
                    }
                }
                return this.matches(rIsoDateTime, {
                    name: "datetime",
                    message: message || string.datetime,
                    excludeEmptyString: true
                }).test({
                    name: "datetime_offset",
                    message: message || string.datetime_offset,
                    params: {
                        allowOffset
                    },
                    skipAbsent: true,
                    test: (value)=>{
                        if (!value || allowOffset) return true;
                        const struct = parseDateStruct(value);
                        if (!struct) return false;
                        return !!struct.z;
                    }
                }).test({
                    name: "datetime_precision",
                    message: message || string.datetime_precision,
                    params: {
                        precision
                    },
                    skipAbsent: true,
                    test: (value)=>{
                        if (!value || precision == void 0) return true;
                        const struct = parseDateStruct(value);
                        if (!struct) return false;
                        return struct.precision === precision;
                    }
                });
            }
            //-- transforms --
            ensure() {
                return this.default("").transform((val)=>val === null ? "" : val);
            }
            trim(message = string.trim) {
                return this.transform((val)=>val != null ? val.trim() : val).test({
                    message,
                    name: "trim",
                    test: isTrimmed
                });
            }
            lowercase(message = string.lowercase) {
                return this.transform((value)=>!isAbsent(value) ? value.toLowerCase() : value).test({
                    message,
                    name: "string_case",
                    exclusive: true,
                    skipAbsent: true,
                    test: (value)=>isAbsent(value) || value === value.toLowerCase()
                });
            }
            uppercase(message = string.uppercase) {
                return this.transform((value)=>!isAbsent(value) ? value.toUpperCase() : value).test({
                    message,
                    name: "string_case",
                    exclusive: true,
                    skipAbsent: true,
                    test: (value)=>isAbsent(value) || value === value.toUpperCase()
                });
            }
            constructor(){
                super({
                    type: "string",
                    check (value) {
                        if (value instanceof String) value = value.valueOf();
                        return typeof value === "string";
                    }
                });
                this.withMutation(()=>{
                    this.transform((value, _raw, ctx)=>{
                        if (!ctx.spec.coerce || ctx.isType(value)) return value;
                        if (Array.isArray(value)) return value;
                        const strValue = value != null && value.toString ? value.toString() : value;
                        if (strValue === objStringTag) return value;
                        return strValue;
                    });
                });
            }
        };
        create$6.prototype = StringSchema.prototype;
        isNaN$1 = (value)=>value != +value;
        NumberSchema = class extends Schema {
            min(min, message = number.min) {
                return this.test({
                    message,
                    name: "min",
                    exclusive: true,
                    params: {
                        min
                    },
                    skipAbsent: true,
                    test (value) {
                        return value >= this.resolve(min);
                    }
                });
            }
            max(max, message = number.max) {
                return this.test({
                    message,
                    name: "max",
                    exclusive: true,
                    params: {
                        max
                    },
                    skipAbsent: true,
                    test (value) {
                        return value <= this.resolve(max);
                    }
                });
            }
            lessThan(less, message = number.lessThan) {
                return this.test({
                    message,
                    name: "max",
                    exclusive: true,
                    params: {
                        less
                    },
                    skipAbsent: true,
                    test (value) {
                        return value < this.resolve(less);
                    }
                });
            }
            moreThan(more, message = number.moreThan) {
                return this.test({
                    message,
                    name: "min",
                    exclusive: true,
                    params: {
                        more
                    },
                    skipAbsent: true,
                    test (value) {
                        return value > this.resolve(more);
                    }
                });
            }
            positive(msg = number.positive) {
                return this.moreThan(0, msg);
            }
            negative(msg = number.negative) {
                return this.lessThan(0, msg);
            }
            integer(message = number.integer) {
                return this.test({
                    name: "integer",
                    message,
                    skipAbsent: true,
                    test: (val)=>Number.isInteger(val)
                });
            }
            truncate() {
                return this.transform((value)=>!isAbsent(value) ? value | 0 : value);
            }
            round(method) {
                var _method;
                let avail = [
                    "ceil",
                    "floor",
                    "round",
                    "trunc"
                ];
                method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || "round";
                if (method === "trunc") return this.truncate();
                if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError("Only valid options for round() are: " + avail.join(", "));
                return this.transform((value)=>!isAbsent(value) ? Math[method](value) : value);
            }
            constructor(){
                super({
                    type: "number",
                    check (value) {
                        if (value instanceof Number) value = value.valueOf();
                        return typeof value === "number" && !isNaN$1(value);
                    }
                });
                this.withMutation(()=>{
                    this.transform((value, _raw, ctx)=>{
                        if (!ctx.spec.coerce) return value;
                        let parsed = value;
                        if (typeof parsed === "string") {
                            parsed = parsed.replace(/\s/g, "");
                            if (parsed === "") return NaN;
                            parsed = +parsed;
                        }
                        if (ctx.isType(parsed) || parsed === null) return parsed;
                        return parseFloat(parsed);
                    });
                });
            }
        };
        create$5.prototype = NumberSchema.prototype;
        invalidDate = /* @__PURE__ */ new Date("");
        isDate = (obj)=>Object.prototype.toString.call(obj) === "[object Date]";
        DateSchema = class _DateSchema extends Schema {
            prepareParam(ref, name) {
                let param;
                if (!Reference.isRef(ref)) {
                    let cast = this.cast(ref);
                    if (!this._typeCheck(cast)) throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
                    param = cast;
                } else {
                    param = ref;
                }
                return param;
            }
            min(min, message = date.min) {
                let limit = this.prepareParam(min, "min");
                return this.test({
                    message,
                    name: "min",
                    exclusive: true,
                    params: {
                        min
                    },
                    skipAbsent: true,
                    test (value) {
                        return value >= this.resolve(limit);
                    }
                });
            }
            max(max, message = date.max) {
                let limit = this.prepareParam(max, "max");
                return this.test({
                    message,
                    name: "max",
                    exclusive: true,
                    params: {
                        max
                    },
                    skipAbsent: true,
                    test (value) {
                        return value <= this.resolve(limit);
                    }
                });
            }
            constructor(){
                super({
                    type: "date",
                    check (v) {
                        return isDate(v) && !isNaN(v.getTime());
                    }
                });
                this.withMutation(()=>{
                    this.transform((value, _raw, ctx)=>{
                        if (!ctx.spec.coerce || ctx.isType(value) || value === null) return value;
                        value = parseIsoDate(value);
                        return !isNaN(value) ? new Date(value) : _DateSchema.INVALID_DATE;
                    });
                });
            }
        };
        DateSchema.INVALID_DATE = invalidDate;
        create$4.prototype = DateSchema.prototype;
        create$4.INVALID_DATE = invalidDate;
        parseJson = (value, _, ctx)=>{
            if (typeof value !== "string") {
                return value;
            }
            let parsed = value;
            try {
                parsed = JSON.parse(value);
            } catch (err) {}
            return ctx.isType(parsed) ? parsed : value;
        };
        deepHas = (obj, p)=>{
            const path = [
                ...(0, import_property_expr.normalizePath)(p)
            ];
            if (path.length === 1) return path[0] in obj;
            let last = path.pop();
            let parent2 = (0, import_property_expr.getter)((0, import_property_expr.join)(path), true)(obj);
            return !!(parent2 && last in parent2);
        };
        isObject3 = (obj)=>Object.prototype.toString.call(obj) === "[object Object]";
        defaultSort = sortByKeyOrder([]);
        ObjectSchema = class extends Schema {
            _cast(_value, options3 = {}) {
                var _options$stripUnknown;
                let value = super._cast(_value, options3);
                if (value === void 0) return this.getDefault(options3);
                if (!this._typeCheck(value)) return value;
                let fields = this.fields;
                let strip = (_options$stripUnknown = options3.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
                let props = [].concat(this._nodes, Object.keys(value).filter((v)=>!this._nodes.includes(v)));
                let intermediateValue = {};
                let innerOptions = Object.assign({}, options3, {
                    parent: intermediateValue,
                    __validating: options3.__validating || false
                });
                let isChanged = false;
                for (const prop of props){
                    let field = fields[prop];
                    let exists = prop in value;
                    if (field) {
                        let fieldValue;
                        let inputValue = value[prop];
                        innerOptions.path = (options3.path ? `${options3.path}.` : "") + prop;
                        field = field.resolve({
                            value: inputValue,
                            context: options3.context,
                            parent: intermediateValue
                        });
                        let fieldSpec = field instanceof Schema ? field.spec : void 0;
                        let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
                        if (fieldSpec != null && fieldSpec.strip) {
                            isChanged = isChanged || prop in value;
                            continue;
                        }
                        fieldValue = !options3.__validating || !strict ? // TODO: use _cast, this is double resolving
                        field.cast(value[prop], innerOptions) : value[prop];
                        if (fieldValue !== void 0) {
                            intermediateValue[prop] = fieldValue;
                        }
                    } else if (exists && !strip) {
                        intermediateValue[prop] = value[prop];
                    }
                    if (exists !== prop in intermediateValue || intermediateValue[prop] !== value[prop]) {
                        isChanged = true;
                    }
                }
                return isChanged ? intermediateValue : value;
            }
            _validate(_value, options3 = {}, panic, next2) {
                let { from = [], originalValue = _value, recursive = this.spec.recursive } = options3;
                options3.from = [
                    {
                        schema: this,
                        value: originalValue
                    },
                    ...from
                ];
                options3.__validating = true;
                options3.originalValue = originalValue;
                super._validate(_value, options3, panic, (objectErrors, value)=>{
                    if (!recursive || !isObject3(value)) {
                        next2(objectErrors, value);
                        return;
                    }
                    originalValue = originalValue || value;
                    let tests = [];
                    for (let key of this._nodes){
                        let field = this.fields[key];
                        if (!field || Reference.isRef(field)) {
                            continue;
                        }
                        tests.push(field.asNestedTest({
                            options: options3,
                            key,
                            parent: value,
                            parentPath: options3.path,
                            originalParent: originalValue
                        }));
                    }
                    this.runTests({
                        tests,
                        value,
                        originalValue,
                        options: options3
                    }, panic, (fieldErrors)=>{
                        next2(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);
                    });
                });
            }
            clone(spec) {
                const next2 = super.clone(spec);
                next2.fields = Object.assign({}, this.fields);
                next2._nodes = this._nodes;
                next2._excludedEdges = this._excludedEdges;
                next2._sortErrors = this._sortErrors;
                return next2;
            }
            concat(schema) {
                let next2 = super.concat(schema);
                let nextFields = next2.fields;
                for (let [field, schemaOrRef] of Object.entries(this.fields)){
                    const target = nextFields[field];
                    nextFields[field] = target === void 0 ? schemaOrRef : target;
                }
                return next2.withMutation((s)=>// XXX: excludes here is wrong
                    s.setFields(nextFields, [
                        ...this._excludedEdges,
                        ...schema._excludedEdges
                    ]));
            }
            _getDefault(options3) {
                if ("default" in this.spec) {
                    return super._getDefault(options3);
                }
                if (!this._nodes.length) {
                    return void 0;
                }
                let dft = {};
                this._nodes.forEach((key)=>{
                    var _innerOptions;
                    const field = this.fields[key];
                    let innerOptions = options3;
                    if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
                        innerOptions = Object.assign({}, innerOptions, {
                            parent: innerOptions.value,
                            value: innerOptions.value[key]
                        });
                    }
                    dft[key] = field && "getDefault" in field ? field.getDefault(innerOptions) : void 0;
                });
                return dft;
            }
            setFields(shape, excludedEdges) {
                let next2 = this.clone();
                next2.fields = shape;
                next2._nodes = sortFields(shape, excludedEdges);
                next2._sortErrors = sortByKeyOrder(Object.keys(shape));
                if (excludedEdges) next2._excludedEdges = excludedEdges;
                return next2;
            }
            shape(additions, excludes = []) {
                return this.clone().withMutation((next2)=>{
                    let edges = next2._excludedEdges;
                    if (excludes.length) {
                        if (!Array.isArray(excludes[0])) excludes = [
                            excludes
                        ];
                        edges = [
                            ...next2._excludedEdges,
                            ...excludes
                        ];
                    }
                    return next2.setFields(Object.assign(next2.fields, additions), edges);
                });
            }
            partial() {
                const partial = {};
                for (const [key, schema] of Object.entries(this.fields)){
                    partial[key] = "optional" in schema && schema.optional instanceof Function ? schema.optional() : schema;
                }
                return this.setFields(partial);
            }
            deepPartial() {
                const next2 = deepPartial(this);
                return next2;
            }
            pick(keys2) {
                const picked = {};
                for (const key of keys2){
                    if (this.fields[key]) picked[key] = this.fields[key];
                }
                return this.setFields(picked, this._excludedEdges.filter(([a, b])=>keys2.includes(a) && keys2.includes(b)));
            }
            omit(keys2) {
                const remaining = [];
                for (const key of Object.keys(this.fields)){
                    if (keys2.includes(key)) continue;
                    remaining.push(key);
                }
                return this.pick(remaining);
            }
            from(from, to, alias) {
                let fromGetter = (0, import_property_expr.getter)(from, true);
                return this.transform((obj)=>{
                    if (!obj) return obj;
                    let newObj = obj;
                    if (deepHas(obj, from)) {
                        newObj = Object.assign({}, obj);
                        if (!alias) delete newObj[from];
                        newObj[to] = fromGetter(obj);
                    }
                    return newObj;
                });
            }
            /** Parse an input JSON string to an object */ json() {
                return this.transform(parseJson);
            }
            /**
       * Similar to `noUnknown` but only validates that an object is the right shape without stripping the unknown keys
       */ exact(message) {
                return this.test({
                    name: "exact",
                    exclusive: true,
                    message: message || object.exact,
                    test (value) {
                        if (value == null) return true;
                        const unknownKeys = unknown(this.schema, value);
                        return unknownKeys.length === 0 || this.createError({
                            params: {
                                properties: unknownKeys.join(", ")
                            }
                        });
                    }
                });
            }
            stripUnknown() {
                return this.clone({
                    noUnknown: true
                });
            }
            noUnknown(noAllow = true, message = object.noUnknown) {
                if (typeof noAllow !== "boolean") {
                    message = noAllow;
                    noAllow = true;
                }
                let next2 = this.test({
                    name: "noUnknown",
                    exclusive: true,
                    message,
                    test (value) {
                        if (value == null) return true;
                        const unknownKeys = unknown(this.schema, value);
                        return !noAllow || unknownKeys.length === 0 || this.createError({
                            params: {
                                unknown: unknownKeys.join(", ")
                            }
                        });
                    }
                });
                next2.spec.noUnknown = noAllow;
                return next2;
            }
            unknown(allow = true, message = object.noUnknown) {
                return this.noUnknown(!allow, message);
            }
            transformKeys(fn) {
                return this.transform((obj)=>{
                    if (!obj) return obj;
                    const result = {};
                    for (const key of Object.keys(obj))result[fn(key)] = obj[key];
                    return result;
                });
            }
            camelCase() {
                return this.transformKeys(import_tiny_case.camelCase);
            }
            snakeCase() {
                return this.transformKeys(import_tiny_case.snakeCase);
            }
            constantCase() {
                return this.transformKeys((key)=>(0, import_tiny_case.snakeCase)(key).toUpperCase());
            }
            describe(options3) {
                const next2 = (options3 ? this.resolve(options3) : this).clone();
                const base = super.describe(options3);
                base.fields = {};
                for (const [key, value] of Object.entries(next2.fields)){
                    var _innerOptions2;
                    let innerOptions = options3;
                    if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {
                        innerOptions = Object.assign({}, innerOptions, {
                            parent: innerOptions.value,
                            value: innerOptions.value[key]
                        });
                    }
                    base.fields[key] = value.describe(innerOptions);
                }
                return base;
            }
            constructor(spec){
                super({
                    type: "object",
                    check (value) {
                        return isObject3(value) || typeof value === "function";
                    }
                });
                this.fields = /* @__PURE__ */ Object.create(null);
                this._sortErrors = defaultSort;
                this._nodes = [];
                this._excludedEdges = [];
                this.withMutation(()=>{
                    if (spec) {
                        this.shape(spec);
                    }
                });
            }
        };
        create$3.prototype = ObjectSchema.prototype;
        ArraySchema = class extends Schema {
            _cast(_value, _opts) {
                const value = super._cast(_value, _opts);
                if (!this._typeCheck(value) || !this.innerType) {
                    return value;
                }
                let isChanged = false;
                const castArray = value.map((v, idx)=>{
                    const castElement = this.innerType.cast(v, Object.assign({}, _opts, {
                        path: `${_opts.path || ""}[${idx}]`
                    }));
                    if (castElement !== v) {
                        isChanged = true;
                    }
                    return castElement;
                });
                return isChanged ? castArray : value;
            }
            _validate(_value, options3 = {}, panic, next2) {
                var _options$recursive;
                let innerType = this.innerType;
                let recursive = (_options$recursive = options3.recursive) != null ? _options$recursive : this.spec.recursive;
                options3.originalValue != null ? options3.originalValue : _value;
                super._validate(_value, options3, panic, (arrayErrors, value)=>{
                    var _options$originalValu2;
                    if (!recursive || !innerType || !this._typeCheck(value)) {
                        next2(arrayErrors, value);
                        return;
                    }
                    let tests = new Array(value.length);
                    for(let index2 = 0; index2 < value.length; index2++){
                        var _options$originalValu;
                        tests[index2] = innerType.asNestedTest({
                            options: options3,
                            index: index2,
                            parent: value,
                            parentPath: options3.path,
                            originalParent: (_options$originalValu = options3.originalValue) != null ? _options$originalValu : _value
                        });
                    }
                    this.runTests({
                        value,
                        tests,
                        originalValue: (_options$originalValu2 = options3.originalValue) != null ? _options$originalValu2 : _value,
                        options: options3
                    }, panic, (innerTypeErrors)=>next2(innerTypeErrors.concat(arrayErrors), value));
                });
            }
            clone(spec) {
                const next2 = super.clone(spec);
                next2.innerType = this.innerType;
                return next2;
            }
            /** Parse an input JSON string to an object */ json() {
                return this.transform(parseJson);
            }
            concat(schema) {
                let next2 = super.concat(schema);
                next2.innerType = this.innerType;
                if (schema.innerType) next2.innerType = next2.innerType ? // @ts-expect-error Lazy doesn't have concat and will break
                next2.innerType.concat(schema.innerType) : schema.innerType;
                return next2;
            }
            of(schema) {
                let next2 = this.clone();
                if (!isSchema(schema)) throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(schema));
                next2.innerType = schema;
                next2.spec = Object.assign({}, next2.spec, {
                    types: schema
                });
                return next2;
            }
            length(length, message = array.length) {
                return this.test({
                    message,
                    name: "length",
                    exclusive: true,
                    params: {
                        length
                    },
                    skipAbsent: true,
                    test (value) {
                        return value.length === this.resolve(length);
                    }
                });
            }
            min(min, message) {
                message = message || array.min;
                return this.test({
                    message,
                    name: "min",
                    exclusive: true,
                    params: {
                        min
                    },
                    skipAbsent: true,
                    // FIXME(ts): Array<typeof T>
                    test (value) {
                        return value.length >= this.resolve(min);
                    }
                });
            }
            max(max, message) {
                message = message || array.max;
                return this.test({
                    message,
                    name: "max",
                    exclusive: true,
                    params: {
                        max
                    },
                    skipAbsent: true,
                    test (value) {
                        return value.length <= this.resolve(max);
                    }
                });
            }
            ensure() {
                return this.default(()=>[]).transform((val, original)=>{
                    if (this._typeCheck(val)) return val;
                    return original == null ? [] : [].concat(original);
                });
            }
            compact(rejector) {
                let reject = !rejector ? (v)=>!!v : (v, i2, a)=>!rejector(v, i2, a);
                return this.transform((values)=>values != null ? values.filter(reject) : values);
            }
            describe(options3) {
                const next2 = (options3 ? this.resolve(options3) : this).clone();
                const base = super.describe(options3);
                if (next2.innerType) {
                    var _innerOptions;
                    let innerOptions = options3;
                    if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
                        innerOptions = Object.assign({}, innerOptions, {
                            parent: innerOptions.value,
                            value: innerOptions.value[0]
                        });
                    }
                    base.innerType = next2.innerType.describe(innerOptions);
                }
                return base;
            }
            constructor(type){
                super({
                    type: "array",
                    spec: {
                        types: type
                    },
                    check (v) {
                        return Array.isArray(v);
                    }
                });
                this.innerType = void 0;
                this.innerType = type;
            }
        };
        create$2.prototype = ArraySchema.prototype;
        TupleSchema = class extends Schema {
            _cast(inputValue, options3) {
                const { types } = this.spec;
                const value = super._cast(inputValue, options3);
                if (!this._typeCheck(value)) {
                    return value;
                }
                let isChanged = false;
                const castArray = types.map((type, idx)=>{
                    const castElement = type.cast(value[idx], Object.assign({}, options3, {
                        path: `${options3.path || ""}[${idx}]`
                    }));
                    if (castElement !== value[idx]) isChanged = true;
                    return castElement;
                });
                return isChanged ? castArray : value;
            }
            _validate(_value, options3 = {}, panic, next2) {
                let itemTypes = this.spec.types;
                super._validate(_value, options3, panic, (tupleErrors, value)=>{
                    var _options$originalValu2;
                    if (!this._typeCheck(value)) {
                        next2(tupleErrors, value);
                        return;
                    }
                    let tests = [];
                    for (let [index2, itemSchema] of itemTypes.entries()){
                        var _options$originalValu;
                        tests[index2] = itemSchema.asNestedTest({
                            options: options3,
                            index: index2,
                            parent: value,
                            parentPath: options3.path,
                            originalParent: (_options$originalValu = options3.originalValue) != null ? _options$originalValu : _value
                        });
                    }
                    this.runTests({
                        value,
                        tests,
                        originalValue: (_options$originalValu2 = options3.originalValue) != null ? _options$originalValu2 : _value,
                        options: options3
                    }, panic, (innerTypeErrors)=>next2(innerTypeErrors.concat(tupleErrors), value));
                });
            }
            describe(options3) {
                const next2 = (options3 ? this.resolve(options3) : this).clone();
                const base = super.describe(options3);
                base.innerType = next2.spec.types.map((schema, index2)=>{
                    var _innerOptions;
                    let innerOptions = options3;
                    if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
                        innerOptions = Object.assign({}, innerOptions, {
                            parent: innerOptions.value,
                            value: innerOptions.value[index2]
                        });
                    }
                    return schema.describe(innerOptions);
                });
                return base;
            }
            constructor(schemas){
                super({
                    type: "tuple",
                    spec: {
                        types: schemas
                    },
                    check (v) {
                        const types = this.spec.types;
                        return Array.isArray(v) && v.length === types.length;
                    }
                });
                this.withMutation(()=>{
                    this.typeError(tuple.notType);
                });
            }
        };
        create$1.prototype = TupleSchema.prototype;
        Lazy = class _Lazy {
            clone(spec) {
                const next2 = new _Lazy(this.builder);
                next2.spec = Object.assign({}, this.spec, spec);
                return next2;
            }
            optionality(optional) {
                const next2 = this.clone({
                    optional
                });
                return next2;
            }
            optional() {
                return this.optionality(true);
            }
            resolve(options3) {
                return this._resolve(options3.value, options3);
            }
            cast(value, options3) {
                return this._resolve(value, options3).cast(value, options3);
            }
            asNestedTest(config) {
                let { key, index: index2, parent: parent2, options: options3 } = config;
                let value = parent2[index2 != null ? index2 : key];
                return this._resolve(value, Object.assign({}, options3, {
                    value,
                    parent: parent2
                })).asNestedTest(config);
            }
            validate(value, options3) {
                return catchValidationError(()=>this._resolve(value, options3).validate(value, options3));
            }
            validateSync(value, options3) {
                return this._resolve(value, options3).validateSync(value, options3);
            }
            validateAt(path, value, options3) {
                return catchValidationError(()=>this._resolve(value, options3).validateAt(path, value, options3));
            }
            validateSyncAt(path, value, options3) {
                return this._resolve(value, options3).validateSyncAt(path, value, options3);
            }
            isValid(value, options3) {
                try {
                    return this._resolve(value, options3).isValid(value, options3);
                } catch (err) {
                    if (ValidationError.isError(err)) {
                        return Promise.resolve(false);
                    }
                    throw err;
                }
            }
            isValidSync(value, options3) {
                return this._resolve(value, options3).isValidSync(value, options3);
            }
            describe(options3) {
                return options3 ? this.resolve(options3).describe(options3) : {
                    type: "lazy",
                    meta: this.spec.meta,
                    label: void 0
                };
            }
            meta(...args) {
                if (args.length === 0) return this.spec.meta;
                let next2 = this.clone();
                next2.spec.meta = Object.assign(next2.spec.meta || {}, args[0]);
                return next2;
            }
            get ["~standard"]() {
                const schema = this;
                const standard = {
                    version: 1,
                    vendor: "yup",
                    validate (value) {
                        return _async_to_generator(function*() {
                            try {
                                const result = yield schema.validate(value, {
                                    abortEarly: false
                                });
                                return {
                                    value: result
                                };
                            } catch (err) {
                                if (ValidationError.isError(err)) {
                                    return {
                                        issues: issuesFromValidationError(err)
                                    };
                                }
                                throw err;
                            }
                        })();
                    }
                };
                return standard;
            }
            constructor(builder){
                this.type = "lazy";
                this.__isYupSchema__ = true;
                this.spec = void 0;
                this._resolve = (value, options3 = {})=>{
                    let schema = this.builder(value, options3);
                    if (!isSchema(schema)) throw new TypeError("lazy() functions must return a valid schema");
                    if (this.spec.optional) schema = schema.optional();
                    return schema.resolve(options3);
                };
                this.builder = builder;
                this.spec = {
                    meta: void 0,
                    optional: false
                };
            }
        };
    }
});
// node_modules/ics/dist/schema/index.js
var require_schema = __commonJS({
    "node_modules/ics/dist/schema/index.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2.urlRegex = void 0;
        exports2.validateHeader = validateHeader;
        exports2.validateHeaderAndEvent = validateHeaderAndEvent;
        var yup = _interopRequireWildcard((init_index_esm(), __toCommonJS(index_esm_exports)));
        function _getRequireWildcardCache(nodeInterop) {
            if (typeof WeakMap !== "function") return null;
            var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
            var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
            return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
                return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
            })(nodeInterop);
        }
        function _interopRequireWildcard(obj, nodeInterop) {
            if (!nodeInterop && obj && obj.__esModule) {
                return obj;
            }
            if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
                return {
                    "default": obj
                };
            }
            var cache2 = _getRequireWildcardCache(nodeInterop);
            if (cache2 && cache2.has(obj)) {
                return cache2.get(obj);
            }
            var newObj = {};
            var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for(var key in obj){
                if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
                    if (desc && (desc.get || desc.set)) {
                        Object.defineProperty(newObj, key, desc);
                    } else {
                        newObj[key] = obj[key];
                    }
                }
            }
            newObj["default"] = obj;
            if (cache2) {
                cache2.set(obj, newObj);
            }
            return newObj;
        }
        function _typeof2(obj) {
            "@babel/helpers - typeof";
            return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
                return typeof obj2;
            } : function(obj2) {
                return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            }, _typeof2(obj);
        }
        function ownKeys(object2, enumerableOnly) {
            var keys2 = Object.keys(object2);
            if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object2);
                enumerableOnly && (symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
                })), keys2.push.apply(keys2, symbols);
            }
            return keys2;
        }
        function _objectSpread(target) {
            for(var i2 = 1; i2 < arguments.length; i2++){
                var source = null != arguments[i2] ? arguments[i2] : {};
                i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
                    _defineProperty(target, key, source[key]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
            }
            return target;
        }
        function _defineProperty(obj, key, value) {
            key = _toPropertyKey(key);
            if (key in obj) {
                Object.defineProperty(obj, key, {
                    value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                });
            } else {
                obj[key] = value;
            }
            return obj;
        }
        function _toPropertyKey(arg) {
            var key = _toPrimitive(arg, "string");
            return _typeof2(key) === "symbol" ? key : String(key);
        }
        function _toPrimitive(input, hint) {
            if (_typeof2(input) !== "object" || input === null) return input;
            var prim = input[Symbol.toPrimitive];
            if (prim !== void 0) {
                var res = prim.call(input, hint || "default");
                if (_typeof2(res) !== "object") return res;
                throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (hint === "string" ? String : Number)(input);
        }
        var urlRegex = exports2.urlRegex = /^(?:([a-z0-9+.-]+):\/\/)(?:\S+(?::\S*)?@)?(?:(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*\.?)(?::\d{2,5})?(?:[/?#]\S*)?$/;
        var dateTimeSchema = function dateTimeSchema2(_ref) {
            var required = _ref.required;
            return yup.lazy(function(value) {
                if (typeof value === "number") {
                    return yup.number().integer().min(0);
                }
                if (typeof value === "string") {
                    return yup.string().required();
                }
                if (!required && typeof value === "undefined") {
                    return yup.mixed().oneOf([
                        void 0
                    ]);
                }
                return yup.array().required().min(3).max(7).of(yup.lazy(function(item, options3) {
                    var itemIndex = options3.parent.indexOf(options3.value);
                    return [
                        yup.number().integer(),
                        yup.number().integer().min(1).max(12),
                        yup.number().integer().min(1).max(31),
                        yup.number().integer().min(0).max(23),
                        yup.number().integer().min(0).max(60),
                        yup.number().integer().min(0).max(60)
                    ][itemIndex];
                }));
            });
        };
        var durationSchema = yup.object().shape({
            before: yup["boolean"](),
            //option to set before alaram
            weeks: yup.number(),
            days: yup.number(),
            hours: yup.number(),
            minutes: yup.number(),
            seconds: yup.number()
        }).noUnknown();
        var contactSchema = yup.object().shape({
            name: yup.string(),
            email: yup.string().email(),
            rsvp: yup["boolean"](),
            dir: yup.string().matches(urlRegex),
            partstat: yup.string(),
            role: yup.string(),
            cutype: yup.string(),
            xNumGuests: yup.number()
        }).noUnknown();
        var organizerSchema = yup.object().shape({
            name: yup.string(),
            email: yup.string().email(),
            dir: yup.string(),
            sentBy: yup.string()
        }).noUnknown();
        var alarmSchema = yup.object().shape({
            action: yup.string().matches(/^(audio|display|email)$/).required(),
            trigger: yup.mixed().required(),
            description: yup.string(),
            duration: durationSchema,
            repeat: yup.number(),
            attach: yup.string(),
            attachType: yup.string(),
            summary: yup.string(),
            attendee: contactSchema,
            "x-prop": yup.mixed(),
            "iana-prop": yup.mixed()
        }).noUnknown();
        var headerShape = {
            productId: yup.string(),
            method: yup.string(),
            calName: yup.string()
        };
        var headerSchema = yup.object().shape(headerShape).noUnknown();
        var eventShape = {
            summary: yup.string(),
            timestamp: dateTimeSchema({
                required: false
            }),
            title: yup.string(),
            uid: yup.string(),
            sequence: yup.number().integer().max(2147483647),
            start: dateTimeSchema({
                required: true
            }),
            duration: durationSchema,
            startType: yup.string().matches(/^(utc|local)$/),
            startInputType: yup.string().matches(/^(utc|local)$/),
            startOutputType: yup.string().matches(/^(utc|local)$/),
            end: dateTimeSchema({
                required: false
            }),
            endInputType: yup.string().matches(/^(utc|local)$/),
            endOutputType: yup.string().matches(/^(utc|local)$/),
            description: yup.string(),
            url: yup.string().matches(urlRegex),
            geo: yup.object().shape({
                lat: yup.number(),
                lon: yup.number()
            }),
            location: yup.string(),
            status: yup.string().matches(/^(TENTATIVE|CANCELLED|CONFIRMED)$/i),
            categories: yup.array().of(yup.string()),
            organizer: organizerSchema,
            attendees: yup.array().of(contactSchema),
            alarms: yup.array().of(alarmSchema),
            recurrenceRule: yup.string(),
            busyStatus: yup.string().matches(/^(TENTATIVE|FREE|BUSY|OOF)$/i),
            transp: yup.string().matches(/^(TRANSPARENT|OPAQUE)$/i),
            classification: yup.string(),
            created: dateTimeSchema({
                required: false
            }),
            lastModified: dateTimeSchema({
                required: false
            }),
            exclusionDates: yup.array().of(dateTimeSchema({
                required: true
            })),
            htmlContent: yup.string()
        };
        var headerAndEventSchema = yup.object().shape(_objectSpread(_objectSpread({}, headerShape), eventShape)).test("xor", "object should have end or duration (but not both)", function(val) {
            var hasEnd = !!val.end;
            var hasDuration = !!val.duration;
            return hasEnd && !hasDuration || !hasEnd && hasDuration || !hasEnd && !hasDuration;
        }).noUnknown();
        function validateHeader(candidate) {
            try {
                var value = headerSchema.validateSync(candidate, {
                    abortEarly: false,
                    strict: true
                });
                return {
                    error: null,
                    value
                };
            } catch (error) {
                return {
                    error: Object.assign({}, error),
                    value: void 0
                };
            }
        }
        function validateHeaderAndEvent(candidate) {
            try {
                var value = headerAndEventSchema.validateSync(candidate, {
                    abortEarly: false,
                    strict: true
                });
                return {
                    error: null,
                    value
                };
            } catch (error) {
                return {
                    error: Object.assign({}, error),
                    value: void 0
                };
            }
        }
    }
});
// node_modules/ics/dist/pipeline/validate.js
var require_validate = __commonJS({
    "node_modules/ics/dist/pipeline/validate.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        var _schema = require_schema();
        Object.keys(_schema).forEach(function(key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports2 && exports2[key] === _schema[key]) return;
            Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function get2() {
                    return _schema[key];
                }
            });
        });
    }
});
// node_modules/ics/dist/pipeline/index.js
var require_pipeline = __commonJS({
    "node_modules/ics/dist/pipeline/index.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        Object.defineProperty(exports2, "buildEvent", {
            enumerable: true,
            get: function get2() {
                return _build.buildEvent;
            }
        });
        Object.defineProperty(exports2, "buildHeader", {
            enumerable: true,
            get: function get2() {
                return _build.buildHeader;
            }
        });
        Object.defineProperty(exports2, "formatEvent", {
            enumerable: true,
            get: function get2() {
                return _format.formatEvent;
            }
        });
        Object.defineProperty(exports2, "formatFooter", {
            enumerable: true,
            get: function get2() {
                return _format.formatFooter;
            }
        });
        Object.defineProperty(exports2, "formatHeader", {
            enumerable: true,
            get: function get2() {
                return _format.formatHeader;
            }
        });
        Object.defineProperty(exports2, "urlRegex", {
            enumerable: true,
            get: function get2() {
                return _validate.urlRegex;
            }
        });
        Object.defineProperty(exports2, "validateHeader", {
            enumerable: true,
            get: function get2() {
                return _validate.validateHeader;
            }
        });
        Object.defineProperty(exports2, "validateHeaderAndEvent", {
            enumerable: true,
            get: function get2() {
                return _validate.validateHeaderAndEvent;
            }
        });
        var _build = require_build();
        var _format = require_format();
        var _validate = require_validate();
    }
});
// node_modules/ics/dist/index.js
var require_dist2 = __commonJS({
    "node_modules/ics/dist/index.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2.convertTimestampToArray = convertTimestampToArray;
        exports2.createEvent = createEvent3;
        exports2.createEvents = createEvents2;
        exports2.isValidURL = isValidURL;
        var _pipeline = require_pipeline();
        function _typeof2(obj) {
            "@babel/helpers - typeof";
            return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
                return typeof obj2;
            } : function(obj2) {
                return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            }, _typeof2(obj);
        }
        function ownKeys(object2, enumerableOnly) {
            var keys2 = Object.keys(object2);
            if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object2);
                enumerableOnly && (symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
                })), keys2.push.apply(keys2, symbols);
            }
            return keys2;
        }
        function _objectSpread(target) {
            for(var i2 = 1; i2 < arguments.length; i2++){
                var source = null != arguments[i2] ? arguments[i2] : {};
                i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
                    _defineProperty(target, key, source[key]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
            }
            return target;
        }
        function _defineProperty(obj, key, value) {
            key = _toPropertyKey(key);
            if (key in obj) {
                Object.defineProperty(obj, key, {
                    value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                });
            } else {
                obj[key] = value;
            }
            return obj;
        }
        function _toPropertyKey(arg) {
            var key = _toPrimitive(arg, "string");
            return _typeof2(key) === "symbol" ? key : String(key);
        }
        function _toPrimitive(input, hint) {
            if (_typeof2(input) !== "object" || input === null) return input;
            var prim = input[Symbol.toPrimitive];
            if (prim !== void 0) {
                var res = prim.call(input, hint || "default");
                if (_typeof2(res) !== "object") return res;
                throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (hint === "string" ? String : Number)(input);
        }
        function buildHeaderAndValidate(header) {
            return (0, _pipeline.validateHeader)((0, _pipeline.buildHeader)(header));
        }
        function buildHeaderAndEventAndValidate(event2) {
            return (0, _pipeline.validateHeaderAndEvent)(_objectSpread(_objectSpread({}, (0, _pipeline.buildHeader)(event2)), (0, _pipeline.buildEvent)(event2)));
        }
        function convertTimestampToArray(timestamp2) {
            var inputType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "local";
            var dateArray = [];
            var d = new Date(timestamp2);
            dateArray.push(inputType === "local" ? d.getFullYear() : d.getUTCFullYear());
            dateArray.push((inputType === "local" ? d.getMonth() : d.getUTCMonth()) + 1);
            dateArray.push(inputType === "local" ? d.getDate() : d.getUTCDate());
            dateArray.push(inputType === "local" ? d.getHours() : d.getUTCHours());
            dateArray.push(inputType === "local" ? d.getMinutes() : d.getUTCMinutes());
            return dateArray;
        }
        function createEvent3(attributes, cb) {
            return createEvents2([
                attributes
            ], cb);
        }
        function createEvents2(events, headerAttributesOrCb, cb) {
            var resolvedHeaderAttributes = _typeof2(headerAttributesOrCb) === "object" ? headerAttributesOrCb : {};
            var resolvedCb = arguments.length === 3 ? cb : typeof headerAttributesOrCb === "function" ? headerAttributesOrCb : null;
            var run2 = function run3() {
                if (!events) {
                    return {
                        error: new Error("one argument is required"),
                        value: null
                    };
                }
                var _ref = events.length === 0 ? buildHeaderAndValidate(resolvedHeaderAttributes) : buildHeaderAndEventAndValidate(_objectSpread(_objectSpread({}, events[0]), resolvedHeaderAttributes)), headerError = _ref.error, headerValue = _ref.value;
                if (headerError) {
                    return {
                        error: headerError,
                        value: null
                    };
                }
                var value = "";
                value += (0, _pipeline.formatHeader)(headerValue);
                for(var i2 = 0; i2 < events.length; i2++){
                    var _buildHeaderAndEventA = buildHeaderAndEventAndValidate(events[i2]), eventError = _buildHeaderAndEventA.error, eventValue = _buildHeaderAndEventA.value;
                    if (eventError) return {
                        error: eventError,
                        value: null
                    };
                    value += (0, _pipeline.formatEvent)(eventValue);
                }
                value += (0, _pipeline.formatFooter)();
                return {
                    error: null,
                    value
                };
            };
            var returnValue;
            try {
                returnValue = run2();
            } catch (e) {
                returnValue = {
                    error: e,
                    value: null
                };
            }
            if (!resolvedCb) {
                return returnValue;
            }
            return resolvedCb(returnValue.error, returnValue.value);
        }
        function isValidURL(url) {
            return _pipeline.urlRegex.test(url);
        }
    }
});
// node_modules/is-mobile/index.js
var require_is_mobile = __commonJS({
    "node_modules/is-mobile/index.js" (exports2, module2) {
        "use strict";
        module2.exports = isMobile2;
        module2.exports.isMobile = isMobile2;
        module2.exports.default = isMobile2;
        var mobileRE = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|samsungbrowser.*mobile|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;
        var notMobileRE = /CrOS/;
        var tabletRE = /android|ipad|playbook|silk/i;
        function isMobile2(opts) {
            if (!opts) opts = {};
            let ua = opts.ua;
            if (!ua && typeof navigator !== "undefined") ua = navigator.userAgent;
            if (ua && ua.headers && typeof ua.headers["user-agent"] === "string") {
                ua = ua.headers["user-agent"];
            }
            if (typeof ua !== "string") return false;
            let result = mobileRE.test(ua) && !notMobileRE.test(ua) || !!opts.tablet && tabletRE.test(ua);
            if (!result && opts.tablet && opts.featureDetect && navigator && navigator.maxTouchPoints > 1 && ua.indexOf("Macintosh") !== -1 && ua.indexOf("Safari") !== -1) {
                result = true;
            }
            return result;
        }
    }
});
// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n) {
        for(var e = 1; e < arguments.length; e++){
            var t = arguments[e];
            for(var r in t)({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
        }
        return n;
    }, _extends.apply(null, arguments);
}
// node_modules/history/index.js
var Action;
(function(Action2) {
    Action2["Pop"] = "POP";
    Action2["Push"] = "PUSH";
    Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
var readOnly = true ? function(obj) {
    return Object.freeze(obj);
} : function(obj) {
    return obj;
};
function warning(cond, message) {
    if (!cond) {
        if (typeof console !== "undefined") console.warn(message);
        try {
            throw new Error(message);
        } catch (e) {}
    }
}
var BeforeUnloadEventType = "beforeunload";
var HashChangeEventType = "hashchange";
var PopStateEventType = "popstate";
function createBrowserHistory(options3) {
    if (options3 === void 0) {
        options3 = {};
    }
    var _options = options3, _options$window = _options.window, window2 = _options$window === void 0 ? document.defaultView : _options$window;
    var globalHistory = window2.history;
    function getIndexAndLocation() {
        var _window$location = window2.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash;
        var state = globalHistory.state || {};
        return [
            state.idx,
            readOnly({
                pathname,
                search,
                hash,
                state: state.usr || null,
                key: state.key || "default"
            })
        ];
    }
    var blockedPopTx = null;
    function handlePop() {
        if (blockedPopTx) {
            blockers.call(blockedPopTx);
            blockedPopTx = null;
        } else {
            var nextAction = Action.Pop;
            var _getIndexAndLocation = getIndexAndLocation(), nextIndex = _getIndexAndLocation[0], nextLocation = _getIndexAndLocation[1];
            if (blockers.length) {
                if (nextIndex != null) {
                    var delta = index2 - nextIndex;
                    if (delta) {
                        blockedPopTx = {
                            action: nextAction,
                            location: nextLocation,
                            retry: function retry() {
                                go(delta * -1);
                            }
                        };
                        go(delta);
                    }
                } else {
                    true ? warning(false, // TODO: Write up a doc that explains our blocking strategy in
                    // detail and link to it here so people can understand better what
                    // is going on and how to avoid it.
                    "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.") : void 0;
                }
            } else {
                applyTx(nextAction);
            }
        }
    }
    window2.addEventListener(PopStateEventType, handlePop);
    var action = Action.Pop;
    var _getIndexAndLocation2 = getIndexAndLocation(), index2 = _getIndexAndLocation2[0], location2 = _getIndexAndLocation2[1];
    var listeners = createEvents();
    var blockers = createEvents();
    if (index2 == null) {
        index2 = 0;
        globalHistory.replaceState(_extends({}, globalHistory.state, {
            idx: index2
        }), "");
    }
    function createHref(to) {
        return typeof to === "string" ? to : createPath(to);
    }
    function getNextLocation(to, state) {
        if (state === void 0) {
            state = null;
        }
        return readOnly(_extends({
            pathname: location2.pathname,
            hash: "",
            search: ""
        }, typeof to === "string" ? parsePath(to) : to, {
            state,
            key: createKey()
        }));
    }
    function getHistoryStateAndUrl(nextLocation, index3) {
        return [
            {
                usr: nextLocation.state,
                key: nextLocation.key,
                idx: index3
            },
            createHref(nextLocation)
        ];
    }
    function allowTx(action2, location3, retry) {
        return !blockers.length || (blockers.call({
            action: action2,
            location: location3,
            retry
        }), false);
    }
    function applyTx(nextAction) {
        action = nextAction;
        var _getIndexAndLocation3 = getIndexAndLocation();
        index2 = _getIndexAndLocation3[0];
        location2 = _getIndexAndLocation3[1];
        listeners.call({
            action,
            location: location2
        });
    }
    function push(to, state) {
        var nextAction = Action.Push;
        var nextLocation = getNextLocation(to, state);
        function retry() {
            push(to, state);
        }
        if (allowTx(nextAction, nextLocation, retry)) {
            var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index2 + 1), historyState = _getHistoryStateAndUr[0], url = _getHistoryStateAndUr[1];
            try {
                globalHistory.pushState(historyState, "", url);
            } catch (error) {
                window2.location.assign(url);
            }
            applyTx(nextAction);
        }
    }
    function replace(to, state) {
        var nextAction = Action.Replace;
        var nextLocation = getNextLocation(to, state);
        function retry() {
            replace(to, state);
        }
        if (allowTx(nextAction, nextLocation, retry)) {
            var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index2), historyState = _getHistoryStateAndUr2[0], url = _getHistoryStateAndUr2[1];
            globalHistory.replaceState(historyState, "", url);
            applyTx(nextAction);
        }
    }
    function go(delta) {
        globalHistory.go(delta);
    }
    var history2 = {
        get action () {
            return action;
        },
        get location () {
            return location2;
        },
        createHref,
        push,
        replace,
        go,
        back: function back() {
            go(-1);
        },
        forward: function forward() {
            go(1);
        },
        listen: function listen(listener) {
            return listeners.push(listener);
        },
        block: function block(blocker) {
            var unblock = blockers.push(blocker);
            if (blockers.length === 1) {
                window2.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
            }
            return function() {
                unblock();
                if (!blockers.length) {
                    window2.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
                }
            };
        }
    };
    return history2;
}
function createHashHistory(options3) {
    if (options3 === void 0) {
        options3 = {};
    }
    var _options2 = options3, _options2$window = _options2.window, window2 = _options2$window === void 0 ? document.defaultView : _options2$window;
    var globalHistory = window2.history;
    function getIndexAndLocation() {
        var _parsePath = parsePath(window2.location.hash.substr(1)), _parsePath$pathname = _parsePath.pathname, pathname = _parsePath$pathname === void 0 ? "/" : _parsePath$pathname, _parsePath$search = _parsePath.search, search = _parsePath$search === void 0 ? "" : _parsePath$search, _parsePath$hash = _parsePath.hash, hash = _parsePath$hash === void 0 ? "" : _parsePath$hash;
        var state = globalHistory.state || {};
        return [
            state.idx,
            readOnly({
                pathname,
                search,
                hash,
                state: state.usr || null,
                key: state.key || "default"
            })
        ];
    }
    var blockedPopTx = null;
    function handlePop() {
        if (blockedPopTx) {
            blockers.call(blockedPopTx);
            blockedPopTx = null;
        } else {
            var nextAction = Action.Pop;
            var _getIndexAndLocation4 = getIndexAndLocation(), nextIndex = _getIndexAndLocation4[0], nextLocation = _getIndexAndLocation4[1];
            if (blockers.length) {
                if (nextIndex != null) {
                    var delta = index2 - nextIndex;
                    if (delta) {
                        blockedPopTx = {
                            action: nextAction,
                            location: nextLocation,
                            retry: function retry() {
                                go(delta * -1);
                            }
                        };
                        go(delta);
                    }
                } else {
                    true ? warning(false, // TODO: Write up a doc that explains our blocking strategy in
                    // detail and link to it here so people can understand better
                    // what is going on and how to avoid it.
                    "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.") : void 0;
                }
            } else {
                applyTx(nextAction);
            }
        }
    }
    window2.addEventListener(PopStateEventType, handlePop);
    window2.addEventListener(HashChangeEventType, function() {
        var _getIndexAndLocation5 = getIndexAndLocation(), nextLocation = _getIndexAndLocation5[1];
        if (createPath(nextLocation) !== createPath(location2)) {
            handlePop();
        }
    });
    var action = Action.Pop;
    var _getIndexAndLocation6 = getIndexAndLocation(), index2 = _getIndexAndLocation6[0], location2 = _getIndexAndLocation6[1];
    var listeners = createEvents();
    var blockers = createEvents();
    if (index2 == null) {
        index2 = 0;
        globalHistory.replaceState(_extends({}, globalHistory.state, {
            idx: index2
        }), "");
    }
    function getBaseHref() {
        var base = document.querySelector("base");
        var href = "";
        if (base && base.getAttribute("href")) {
            var url = window2.location.href;
            var hashIndex = url.indexOf("#");
            href = hashIndex === -1 ? url : url.slice(0, hashIndex);
        }
        return href;
    }
    function createHref(to) {
        return getBaseHref() + "#" + (typeof to === "string" ? to : createPath(to));
    }
    function getNextLocation(to, state) {
        if (state === void 0) {
            state = null;
        }
        return readOnly(_extends({
            pathname: location2.pathname,
            hash: "",
            search: ""
        }, typeof to === "string" ? parsePath(to) : to, {
            state,
            key: createKey()
        }));
    }
    function getHistoryStateAndUrl(nextLocation, index3) {
        return [
            {
                usr: nextLocation.state,
                key: nextLocation.key,
                idx: index3
            },
            createHref(nextLocation)
        ];
    }
    function allowTx(action2, location3, retry) {
        return !blockers.length || (blockers.call({
            action: action2,
            location: location3,
            retry
        }), false);
    }
    function applyTx(nextAction) {
        action = nextAction;
        var _getIndexAndLocation7 = getIndexAndLocation();
        index2 = _getIndexAndLocation7[0];
        location2 = _getIndexAndLocation7[1];
        listeners.call({
            action,
            location: location2
        });
    }
    function push(to, state) {
        var nextAction = Action.Push;
        var nextLocation = getNextLocation(to, state);
        function retry() {
            push(to, state);
        }
        true ? warning(nextLocation.pathname.charAt(0) === "/", "Relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")") : void 0;
        if (allowTx(nextAction, nextLocation, retry)) {
            var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index2 + 1), historyState = _getHistoryStateAndUr3[0], url = _getHistoryStateAndUr3[1];
            try {
                globalHistory.pushState(historyState, "", url);
            } catch (error) {
                window2.location.assign(url);
            }
            applyTx(nextAction);
        }
    }
    function replace(to, state) {
        var nextAction = Action.Replace;
        var nextLocation = getNextLocation(to, state);
        function retry() {
            replace(to, state);
        }
        true ? warning(nextLocation.pathname.charAt(0) === "/", "Relative pathnames are not supported in hash history.replace(" + JSON.stringify(to) + ")") : void 0;
        if (allowTx(nextAction, nextLocation, retry)) {
            var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index2), historyState = _getHistoryStateAndUr4[0], url = _getHistoryStateAndUr4[1];
            globalHistory.replaceState(historyState, "", url);
            applyTx(nextAction);
        }
    }
    function go(delta) {
        globalHistory.go(delta);
    }
    var history2 = {
        get action () {
            return action;
        },
        get location () {
            return location2;
        },
        createHref,
        push,
        replace,
        go,
        back: function back() {
            go(-1);
        },
        forward: function forward() {
            go(1);
        },
        listen: function listen(listener) {
            return listeners.push(listener);
        },
        block: function block(blocker) {
            var unblock = blockers.push(blocker);
            if (blockers.length === 1) {
                window2.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
            }
            return function() {
                unblock();
                if (!blockers.length) {
                    window2.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
                }
            };
        }
    };
    return history2;
}
function promptBeforeUnload(event2) {
    event2.preventDefault();
    event2.returnValue = "";
}
function createEvents() {
    var handlers = [];
    return {
        get length () {
            return handlers.length;
        },
        push: function push(fn) {
            handlers.push(fn);
            return function() {
                handlers = handlers.filter(function(handler) {
                    return handler !== fn;
                });
            };
        },
        call: function call(arg) {
            handlers.forEach(function(fn) {
                return fn && fn(arg);
            });
        }
    };
}
function createKey() {
    return Math.random().toString(36).substr(2, 8);
}
function createPath(_ref) {
    var _ref$pathname = _ref.pathname, pathname = _ref$pathname === void 0 ? "/" : _ref$pathname, _ref$search = _ref.search, search = _ref$search === void 0 ? "" : _ref$search, _ref$hash = _ref.hash, hash = _ref$hash === void 0 ? "" : _ref$hash;
    if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
    if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
    return pathname;
}
function parsePath(path) {
    var parsedPath = {};
    if (path) {
        var hashIndex = path.indexOf("#");
        if (hashIndex >= 0) {
            parsedPath.hash = path.substr(hashIndex);
            path = path.substr(0, hashIndex);
        }
        var searchIndex = path.indexOf("?");
        if (searchIndex >= 0) {
            parsedPath.search = path.substr(searchIndex);
            path = path.substr(0, searchIndex);
        }
        if (path) {
            parsedPath.pathname = path;
        }
    }
    return parsedPath;
}
// node_modules/@tarojs/router/dist/router/index.js
var RouterConfig = class {
    static set config(e) {
        this.__config = e;
    }
    static get config() {
        return this.__config;
    }
    static get pages() {
        return this.config.pages || [];
    }
    static get router() {
        return this.config.router || {};
    }
    static get mode() {
        return this.router.mode || "hash";
    }
    static get customRoutes() {
        return this.router.customRoutes || {};
    }
    static isPage(url = "") {
        return this.pages.findIndex((e)=>addLeadingSlash(e) === url) !== -1;
    }
};
// node_modules/@tarojs/router/dist/history.js
var history;
var basename = "/";
var MpaHistory = class {
    get location() {
        return {
            pathname: window.location.pathname,
            search: window.location.search,
            hash: window.location.hash,
            key: `${window.history.length}`,
            state: window.history.state
        };
    }
    createHref(_to) {
        throw new Error("Method not implemented.");
    }
    parseUrl(to) {
        let url = to.pathname || "";
        if (RouterConfig.isPage(url)) {
            url += ".html";
        }
        if (to.search) {
            url += `?${to.search}`;
        }
        if (to.hash) {
            url += `#${to.hash}`;
        }
        return url;
    }
    push(to, _state = {}) {
        window.location.assign(this.parseUrl(to));
    }
    replace(to, _state = {}) {
        window.location.replace(this.parseUrl(to));
    }
    go(delta) {
        window.history.go(delta);
    }
    listen(listener) {
        function callback(e) {
            if (e.action === "pushState") {
                listener({
                    action: Action.Push,
                    location: this.location
                });
            } else if (e.action === "replaceState") {
                listener({
                    action: Action.Replace,
                    location: this.location
                });
            } else {
                listener({
                    action: Action.Pop,
                    location: this.location
                });
            }
        }
        window.addEventListener("popstate", callback);
        return ()=>{
            window.removeEventListener("popstate", callback);
        };
    }
    block(_blocker) {
        throw new Error("Method not implemented.");
    }
    eventState(action) {
        return (data, unused, url)=>{
            const wrapper = window.history[action](data, unused, url);
            const evt = new Event(action);
            evt.action = action;
            evt.state = data;
            evt.unused = unused;
            evt.url = url;
            window.dispatchEvent(evt);
            return wrapper;
        };
    }
    constructor(){
        this.back = window.history.back;
        this.forward = window.history.forward;
        this.pushState = this.eventState("pushState");
        this.replaceState = this.eventState("replaceState");
    }
};
function setHistory(h2, base = "/") {
    history = h2;
    basename = base;
}
function createMpaHistory(_) {
    return new MpaHistory();
}
function setHistoryMode(mode, base = "/") {
    const options3 = {
        window
    };
    basename = base;
    if (mode === "browser") {
        history = createBrowserHistory(options3);
    } else if (mode === "multi") {
        history = createMpaHistory();
    } else {
        history = createHashHistory(options3);
    }
}
function prependBasename(url = "") {
    return basename.replace(/\/$/, "") + "/" + url.replace(/^\//, "");
}
// node_modules/@tarojs/router/dist/utils/index.js
var RoutesAlias = class {
    set(customRoutes = {}) {
        for(let key in customRoutes){
            const path = customRoutes[key];
            key = addLeadingSlash(key);
            if (typeof path === "string") {
                this.conf.push([
                    key,
                    addLeadingSlash(path)
                ]);
            } else if ((path === null || path === void 0 ? void 0 : path.length) > 0) {
                this.conf.push(...path.map((p)=>[
                        key,
                        addLeadingSlash(p)
                    ]));
            }
        }
    }
    constructor(){
        this.conf = [];
        this.getConfig = (url = "")=>{
            const customRoute = this.conf.filter((arr)=>{
                return arr.includes(url);
            });
            return customRoute[0];
        };
        this.getOrigin = (url = "")=>{
            var _a;
            return ((_a = this.getConfig(url)) === null || _a === void 0 ? void 0 : _a[0]) || url;
        };
        this.getAlias = (url = "")=>{
            var _a;
            return ((_a = this.getConfig(url)) === null || _a === void 0 ? void 0 : _a[1]) || url;
        };
        this.getAll = (url = "")=>{
            return this.conf.filter((arr)=>arr.includes(url)).reduceRight((p, a)=>{
                p.unshift(a[1]);
                return p;
            }, []);
        };
    }
};
var routesAlias = new RoutesAlias();
// node_modules/@tarojs/router/dist/router/stack.js
var Stacks = class {
    set delta(delta) {
        if (delta > 0) {
            this.backDelta = delta;
        } else if (this.backDelta > 0) {
            --this.backDelta;
        } else {
            this.backDelta = 0;
        }
    }
    get delta() {
        return this.backDelta;
    }
    set method(methodName) {
        this.methodName = methodName;
    }
    get method() {
        return this.methodName;
    }
    get length() {
        return this.stacks.length;
    }
    get last() {
        return this.stacks[this.length - 1];
    }
    get() {
        return this.stacks;
    }
    getItem(index2) {
        return this.stacks[index2];
    }
    getLastIndex(pathname, stateWith = 1) {
        const list2 = [
            ...this.stacks
        ].reverse();
        return list2.findIndex((page, i2)=>{
            var _a;
            return i2 >= stateWith && ((_a = page.path) === null || _a === void 0 ? void 0 : _a.replace(/\?.*/g, "")) === pathname;
        });
    }
    getDelta(pathname) {
        if (this.backDelta >= 1) {
            return this.backDelta;
        }
        const index2 = this.getLastIndex(pathname);
        return index2 > 0 ? index2 : 1;
    }
    getPrevIndex(pathname, stateWith = 1) {
        const lastIndex = this.getLastIndex(pathname, stateWith);
        if (lastIndex < 0) {
            return -1;
        }
        return this.length - 1 - lastIndex;
    }
    pop() {
        return this.stacks.pop();
    }
    push(page) {
        return this.stacks.push(page);
    }
    getTabs() {
        return this.tabs;
    }
    pushTab(path) {
        this.tabs[path] = this.last;
        this.pop();
    }
    popTab(path) {
        this.push(this.tabs[path]);
        delete this.tabs[path];
    }
    removeTab(path) {
        delete this.tabs[path];
    }
    constructor(){
        this.stacks = [];
        this.backDelta = 0;
        this.tabs = {};
        this.methodName = "";
    }
};
var stacks = new Stacks();
// node_modules/@tarojs/router/dist/api.js
function processNavigateUrl(option) {
    var _a;
    const pathPieces = parsePath(option.url);
    if ((_a = pathPieces.pathname) === null || _a === void 0 ? void 0 : _a.includes("./")) {
        const parts = routesAlias.getOrigin(history.location.pathname).split("/");
        parts.pop();
        pathPieces.pathname.split("/").forEach((item)=>{
            if (item === ".") {
                return;
            }
            item === ".." ? parts.pop() : parts.push(item);
        });
        pathPieces.pathname = parts.join("/");
    }
    pathPieces.pathname = routesAlias.getAlias(addLeadingSlash(pathPieces.pathname));
    pathPieces.pathname = prependBasename(pathPieces.pathname);
    if (!pathPieces.search) pathPieces.search = "";
    return pathPieces;
}
function navigate(option, method) {
    return __awaiter(this, void 0, void 0, function*() {
        return new Promise((resolve, reject)=>{
            stacks.method = method;
            const { success, complete, fail } = option;
            const unListen = history.listen(()=>{
                const res = {
                    errMsg: `${method}:ok`
                };
                success === null || success === void 0 ? void 0 : success(res);
                complete === null || complete === void 0 ? void 0 : complete(res);
                resolve(res);
                unListen();
            });
            try {
                if ("url" in option) {
                    const pathPieces = processNavigateUrl(option);
                    const state = {
                        timestamp: Date.now()
                    };
                    if (method === "navigateTo") {
                        history.push(pathPieces, state);
                    } else if (method === "redirectTo" || method === "switchTab") {
                        history.replace(pathPieces, state);
                    } else if (method === "reLaunch") {
                        stacks.delta = stacks.length;
                        history.replace(pathPieces, state);
                    }
                } else if (method === "navigateBack") {
                    stacks.delta = option.delta;
                    if (stacks.length > option.delta) {
                        history.go(-option.delta);
                    } else {
                        history.go(1 - stacks.length);
                    }
                }
            } catch (error) {
                const res = {
                    errMsg: `${method}:fail ${error.message || error}`
                };
                fail === null || fail === void 0 ? void 0 : fail(res);
                complete === null || complete === void 0 ? void 0 : complete(res);
                reject(res);
            }
        });
    });
}
function navigateTo(option) {
    return navigate(option, "navigateTo");
}
function redirectTo(option) {
    return navigate(option, "redirectTo");
}
function navigateBack(option = {
    delta: 1
}) {
    if (!option.delta || option.delta < 1) {
        option.delta = 1;
    }
    return navigate(option, "navigateBack");
}
function switchTab(option) {
    return navigate(option, "switchTab");
}
function reLaunch(option) {
    return navigate(option, "reLaunch");
}
function getCurrentPages() {
    if (RouterConfig.mode === "multi") {
        console.warn("\u591A\u9875\u9762\u8DEF\u7531\u6A21\u5F0F\u4E0D\u652F\u6301\u4F7F\u7528 getCurrentPages \u65B9\u6CD5\uFF01");
    }
    const pages = stacks.get();
    return pages.map((e)=>{
        var _a;
        return Object.assign(Object.assign({}, e), {
            route: ((_a = e.path) === null || _a === void 0 ? void 0 : _a.replace(/\?.*/g, "")) || ""
        });
    });
}
// node_modules/@tarojs/router/dist/utils/navigate.js
var preTitle = document.title;
var isWeixin = ()=>!!navigator.userAgent.match(/\bMicroMessenger\b/ig);
var isDingTalk = ()=>!!navigator.userAgent.match(/\bDingTalk\b/ig);
function setTitle(title) {
    return __awaiter(this, void 0, void 0, function*() {
        if (preTitle === title) return title;
        document.title = title;
        preTitle = title;
        if (false) {
            if (!isLoadDdEntry) {
                isLoadDdEntry = true;
            }
            const setDingTitle = null.default;
            setDingTitle({
                title
            });
        }
        return title;
    });
}
// node_modules/@tarojs/router/dist/router/multi-page.js
var import_query_string = __toESM(require_query_string());
// node_modules/@tarojs/router/dist/events/resize.js
var pageResizeFn;
function bindPageResize(page) {
    pageResizeFn && window.removeEventListener("resize", pageResizeFn);
    pageResizeFn = function() {
        page.onResize && page.onResize({
            size: {
                windowHeight: window.innerHeight,
                windowWidth: window.innerWidth
            }
        });
    };
    window.addEventListener("resize", pageResizeFn, false);
}
// node_modules/@tarojs/router/dist/events/scroll.js
var pageScrollFn = {};
var pageDOM = window;
function bindPageScroll(page, scrollEl, distance = 50) {
    var _a;
    const pagePath = page ? page === null || page === void 0 ? void 0 : page.path : (_a = Current.router) === null || _a === void 0 ? void 0 : _a.path;
    pageScrollFn[pagePath] && scrollEl.removeEventListener("scroll", pageScrollFn[pagePath]);
    pageDOM = scrollEl;
    let isReachBottom = false;
    pageScrollFn[pagePath] = function() {
        var _a2;
        (_a2 = page.onPageScroll) === null || _a2 === void 0 ? void 0 : _a2.call(page, {
            scrollTop: pageDOM instanceof Window ? window.scrollY : pageDOM.scrollTop
        });
        if (isReachBottom && getOffset() > distance) {
            isReachBottom = false;
        }
        if (page.onReachBottom && !isReachBottom && getOffset() < distance) {
            isReachBottom = true;
            page.onReachBottom();
        }
    };
    pageDOM.addEventListener("scroll", pageScrollFn[pagePath], false);
}
function getOffset() {
    if (pageDOM instanceof Window) {
        return document.documentElement.scrollHeight - window.scrollY - window.innerHeight;
    } else {
        return pageDOM.scrollHeight - pageDOM.scrollTop - pageDOM.clientHeight;
    }
}
// node_modules/@tarojs/router/dist/style.js
function loadAnimateStyle(ms = 300) {
    const css2 = `
body {
  overflow: hidden; // \u9632\u6B62 iOS \u9875\u9762\u6EDA\u52A8
}
.taro_router > .taro_page {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: #fff;
  transform: translate(100%, 0);
  transition: transform ${ms}ms;
  z-index: 0;
}

.taro_router > .taro_page.taro_tabbar_page,
.taro_router > .taro_page.taro_page_show.taro_page_stationed {
  transform: none;
}

.taro_router > .taro_page.taro_page_show {
  transform: translate(0, 0);
}
`;
    addStyle(css2);
}
function loadRouterStyle(enableTabBar, enableWindowScroll) {
    const css2 = `
  .taro_router {
    position: relative;
    width: 100%;
    height: 100%;
  }

  .taro_page {
    width: 100%;
    height: 100%;
${enableWindowScroll ? "" : `
    overflow-x: hidden;
    overflow-y: scroll;
    max-height: 100vh;
`}
  }
${enableTabBar ? `
  .taro-tabbar__container > .taro-tabbar__panel {
    overflow: hidden;
  }

  .taro-tabbar__container > .taro-tabbar__panel > .taro_page.taro_tabbar_page {
    max-height: calc(100vh - var(--taro-tabbar-height) - constant(safe-area-inset-bottom));
    max-height: calc(100vh - var(--taro-tabbar-height) - env(safe-area-inset-bottom));
  }

` : ""}
  .taro_page_shade,
  .taro_router > .taro_page.taro_page_show.taro_page_stationed:not(.taro_page_shade):not(.taro_tabbar_page):not(:last-child) {
    display: none;
  }
`;
    addStyle(css2);
}
function addStyle(css2) {
    if (!css2) return;
    const style = document.createElement("style");
    style.innerHTML = css2;
    document.getElementsByTagName("head")[0].appendChild(style);
}
// node_modules/@tarojs/router/dist/router/multi-page.js
var MultiPageHandler = class {
    get appId() {
        return this.config.appId || "app";
    }
    get router() {
        return this.config.router || {};
    }
    get routerMode() {
        return this.router.mode || "hash";
    }
    get customRoutes() {
        return this.router.customRoutes || {};
    }
    get tabBarList() {
        var _a;
        return ((_a = this.config.tabBar) === null || _a === void 0 ? void 0 : _a.list) || [];
    }
    get PullDownRefresh() {
        return this.config.PullDownRefresh;
    }
    set pathname(p) {
        this.router.pathname = p;
    }
    get pathname() {
        return this.router.pathname;
    }
    get basename() {
        return this.router.basename || "";
    }
    get pageConfig() {
        return this.config.route;
    }
    get isTabBar() {
        var _a;
        const routePath = addLeadingSlash(stripBasename(this.pathname, this.basename));
        const pagePath = ((_a = Object.entries(this.customRoutes).find(([, target])=>{
            if (typeof target === "string") {
                return target === routePath;
            } else if ((target === null || target === void 0 ? void 0 : target.length) > 0) {
                return target.includes(routePath);
            }
            return false;
        })) === null || _a === void 0 ? void 0 : _a[0]) || routePath;
        return !!pagePath && this.tabBarList.some((t)=>t.pagePath === pagePath);
    }
    get search() {
        return location.search.substr(1);
    }
    get usingWindowScroll() {
        var _a;
        let usingWindowScroll = true;
        if (typeof ((_a = this.pageConfig) === null || _a === void 0 ? void 0 : _a.usingWindowScroll) === "boolean") {
            usingWindowScroll = this.pageConfig.usingWindowScroll;
        }
        const win3 = window;
        win3.__taroAppConfig || (win3.__taroAppConfig = {});
        win3.__taroAppConfig.usingWindowScroll = usingWindowScroll;
        return usingWindowScroll;
    }
    getQuery(search = "", options3 = {}) {
        search = search ? `${search}&${this.search}` : this.search;
        const query = search ? import_query_string.default.parse(search) : {};
        return Object.assign(Object.assign({}, query), options3);
    }
    isDefaultNavigationStyle() {
        var _a, _b;
        let style = (_a = this.config.window) === null || _a === void 0 ? void 0 : _a.navigationStyle;
        if (typeof ((_b = this.pageConfig) === null || _b === void 0 ? void 0 : _b.navigationStyle) === "string") {
            style = this.pageConfig.navigationStyle;
        }
        return style !== "custom";
    }
    mount() {
        setHistory(this.history, this.basename);
        loadRouterStyle(this.tabBarList.length > 1, this.usingWindowScroll);
    }
    onReady(page, onLoad = true) {
        var _a;
        const pageEl = this.getPageContainer(page);
        if (pageEl && !(pageEl === null || pageEl === void 0 ? void 0 : pageEl["__isReady"])) {
            const el = pageEl.firstElementChild;
            const componentOnReady = el === null || el === void 0 ? void 0 : el["componentOnReady"];
            if (componentOnReady) {
                componentOnReady === null || componentOnReady === void 0 ? void 0 : componentOnReady().then(()=>{
                    requestAnimationFrame(()=>{
                        var _a2;
                        (_a2 = page.onReady) === null || _a2 === void 0 ? void 0 : _a2.call(page);
                        pageEl["__isReady"] = true;
                    });
                });
            } else {
                (_a = page.onReady) === null || _a === void 0 ? void 0 : _a.call(page);
                pageEl["__isReady"] = true;
            }
            onLoad && (pageEl["__page"] = page);
        }
    }
    load(page, pageConfig = {}) {
        var _a;
        if (!page) return;
        (_a = page.onLoad) === null || _a === void 0 ? void 0 : _a.call(page, this.getQuery("", page.options), ()=>{
            var _a2;
            const pageEl = this.getPageContainer(page);
            if (this.isTabBar) {
                pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.add("taro_tabbar_page");
            }
            if (this.isDefaultNavigationStyle()) {
                pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.add("taro_navigation_page");
            }
            this.onReady(page, true);
            (_a2 = page.onShow) === null || _a2 === void 0 ? void 0 : _a2.call(page);
            this.bindPageEvents(page, pageConfig);
        });
    }
    getPageContainer(page) {
        var _a;
        const path = page ? page === null || page === void 0 ? void 0 : page.path : (_a = Current.page) === null || _a === void 0 ? void 0 : _a.path;
        const id = path === null || path === void 0 ? void 0 : path.replace(/([^a-z0-9\u00a0-\uffff_-])/ig, "\\$1");
        if (page) {
            return document.querySelector(`.taro_page#${id}`);
        }
        const el = id ? document.querySelector(`.taro_page#${id}`) : document.querySelector(".taro_page") || document.querySelector(".taro_router");
        return el;
    }
    getScrollingElement(page) {
        if (this.usingWindowScroll) return window;
        return this.getPageContainer(page) || window;
    }
    bindPageEvents(page, config = {}) {
        var _a;
        const scrollEl = this.getScrollingElement(page);
        const distance = config.onReachBottomDistance || ((_a = this.config.window) === null || _a === void 0 ? void 0 : _a.onReachBottomDistance) || 50;
        bindPageScroll(page, scrollEl, distance);
        bindPageResize(page);
    }
    constructor(config, history2){
        this.history = history2;
        this.config = config;
        this.mount();
    }
};
// node_modules/@tarojs/router/dist/router/mpa.js
var createStampId = incrementId();
var launchStampId = createStampId();
function createMultiRouter(history2, app, config, framework) {
    var _a, _b, _c, _d, _e, _f;
    return __awaiter(this, void 0, void 0, function*() {
        if (typeof app.onUnhandledRejection === "function") {
            window.addEventListener("unhandledrejection", app.onUnhandledRejection);
        }
        RouterConfig.config = config;
        const handler = new MultiPageHandler(config, history2);
        const launchParam = {
            path: config.pageName,
            query: handler.getQuery(launchStampId),
            scene: 0,
            shareTicket: "",
            referrerInfo: {}
        };
        eventCenter.trigger("__taroRouterLaunch", launchParam);
        (_a = app.onLaunch) === null || _a === void 0 ? void 0 : _a.call(app, launchParam);
        app.onError && window.addEventListener("error", (e)=>{
            var _a2;
            return (_a2 = app.onError) === null || _a2 === void 0 ? void 0 : _a2.call(app, e.message);
        });
        const pathName = config.pageName;
        const pageConfig = handler.pageConfig;
        eventCenter.trigger("__taroRouterChange", {
            toLocation: {
                path: pathName
            }
        });
        let element;
        try {
            element = yield (_b = pageConfig.load) === null || _b === void 0 ? void 0 : _b.call(pageConfig);
            if (element instanceof Array) {
                element = element[0];
            }
        } catch (error) {
            throw new Error(error);
        }
        if (!element) return;
        let enablePullDownRefresh = ((_c = config === null || config === void 0 ? void 0 : config.window) === null || _c === void 0 ? void 0 : _c.enablePullDownRefresh) || false;
        if (pageConfig) {
            setTitle((_d = pageConfig.navigationBarTitleText) !== null && _d !== void 0 ? _d : document.title);
            if (typeof pageConfig.enablePullDownRefresh === "boolean") {
                enablePullDownRefresh = pageConfig.enablePullDownRefresh;
            }
        }
        const el = (_e = element.default) !== null && _e !== void 0 ? _e : element;
        const loadConfig = Object.assign({}, pageConfig);
        delete loadConfig["path"];
        delete loadConfig["load"];
        const page = createPageConfig(enablePullDownRefresh ? hooks.call("createPullDownComponent", el, pathName, framework, handler.PullDownRefresh) : el, pathName + stringify(launchParam), {}, loadConfig);
        handler.load(page, pageConfig);
        (_f = app.onShow) === null || _f === void 0 ? void 0 : _f.call(app, launchParam);
    });
}
// node_modules/universal-router/module.js
var import_path_to_regexp = __toESM(require_path_to_regexp());
var hasOwnProperty = Object.prototype.hasOwnProperty;
var cache = /* @__PURE__ */ new Map();
function decodeParam(val) {
    try {
        return decodeURIComponent(val);
    } catch (err) {
        return val;
    }
}
function matchPath(route, pathname, parentKeys, parentParams) {
    var end = !route.children;
    var cacheKey = (route.path || "") + "|" + end;
    var regexp = cache.get(cacheKey);
    if (!regexp) {
        var keys2 = [];
        regexp = {
            keys: keys2,
            pattern: (0, import_path_to_regexp.default)(route.path || "", keys2, {
                end
            })
        };
        cache.set(cacheKey, regexp);
    }
    var m = regexp.pattern.exec(pathname);
    if (!m) {
        return null;
    }
    var path = m[0];
    var params = Object.assign({}, parentParams);
    for(var i2 = 1; i2 < m.length; i2++){
        var key = regexp.keys[i2 - 1];
        var prop = key.name;
        var value = m[i2];
        if (value !== void 0 || !hasOwnProperty.call(params, prop)) {
            if (key.repeat) {
                params[prop] = value ? value.split(key.delimiter).map(decodeParam) : [];
            } else {
                params[prop] = value ? decodeParam(value) : value;
            }
        }
    }
    return {
        path: !end && path.charAt(path.length - 1) === "/" ? path.substr(1) : path,
        keys: parentKeys.concat(regexp.keys),
        params
    };
}
function matchRoute(route, baseUrl, pathname, parentKeys, parentParams) {
    var match;
    var childMatches;
    var childIndex = 0;
    return {
        next: function next2(routeToSkip) {
            if (route === routeToSkip) {
                return {
                    done: true
                };
            }
            if (!match) {
                match = matchPath(route, pathname, parentKeys, parentParams);
                if (match) {
                    return {
                        done: false,
                        value: {
                            route,
                            baseUrl,
                            path: match.path,
                            keys: match.keys,
                            params: match.params
                        }
                    };
                }
            }
            if (match && route.children) {
                while(childIndex < route.children.length){
                    if (!childMatches) {
                        var childRoute = route.children[childIndex];
                        childRoute.parent = route;
                        childMatches = matchRoute(childRoute, baseUrl + match.path, pathname.substr(match.path.length), match.keys, match.params);
                    }
                    var childMatch = childMatches.next(routeToSkip);
                    if (!childMatch.done) {
                        return {
                            done: false,
                            value: childMatch.value
                        };
                    }
                    childMatches = null;
                    childIndex++;
                }
            }
            return {
                done: true
            };
        }
    };
}
function resolveRoute(context, params) {
    if (typeof context.route.action === "function") {
        return context.route.action(context, params);
    }
    return void 0;
}
function isChildRoute(parentRoute, childRoute) {
    var route = childRoute;
    while(route){
        route = route.parent;
        if (route === parentRoute) {
            return true;
        }
    }
    return false;
}
var UniversalRouter = function() {
    function UniversalRouter2(routes, options3) {
        if (options3 === void 0) {
            options3 = {};
        }
        if (!routes || typeof routes !== "object") {
            throw new TypeError("Invalid routes");
        }
        this.baseUrl = options3.baseUrl || "";
        this.errorHandler = options3.errorHandler;
        this.resolveRoute = options3.resolveRoute || resolveRoute;
        this.context = Object.assign({
            router: this
        }, options3.context);
        this.root = Array.isArray(routes) ? {
            path: "",
            children: routes,
            parent: null
        } : routes;
        this.root.parent = null;
    }
    var _proto = UniversalRouter2.prototype;
    _proto.resolve = function resolve(pathnameOrContext) {
        var _this = this;
        var context = Object.assign({}, this.context, {}, typeof pathnameOrContext === "string" ? {
            pathname: pathnameOrContext
        } : pathnameOrContext);
        var match = matchRoute(this.root, this.baseUrl, context.pathname.substr(this.baseUrl.length), [], null);
        var resolve2 = this.resolveRoute;
        var matches = null;
        var nextMatches = null;
        var currentContext = context;
        function next2(resume, parent2, prevResult) {
            if (parent2 === void 0) {
                parent2 = matches.value.route;
            }
            var routeToSkip = prevResult === null && !matches.done && matches.value.route;
            matches = nextMatches || match.next(routeToSkip);
            nextMatches = null;
            if (!resume) {
                if (matches.done || !isChildRoute(parent2, matches.value.route)) {
                    nextMatches = matches;
                    return Promise.resolve(null);
                }
            }
            if (matches.done) {
                var error = new Error("Route not found");
                error.status = 404;
                return Promise.reject(error);
            }
            currentContext = Object.assign({}, context, {}, matches.value);
            return Promise.resolve(resolve2(currentContext, matches.value.params)).then(function(result) {
                if (result !== null && result !== void 0) {
                    return result;
                }
                return next2(resume, parent2, result);
            });
        }
        context.next = next2;
        return Promise.resolve().then(function() {
            return next2(true, _this.root);
        })["catch"](function(error) {
            if (_this.errorHandler) {
                return _this.errorHandler(error, currentContext);
            }
            throw error;
        });
    };
    return UniversalRouter2;
}();
UniversalRouter.pathToRegexp = import_path_to_regexp.default;
var module_default = UniversalRouter;
// node_modules/@tarojs/router/dist/router/page.js
var import_query_string2 = __toESM(require_query_string());
var PageHandler = class {
    get currentPage() {
        const routePath = getCurrentPage(this.routerMode, this.basename);
        return routePath === "/" ? this.homePage : routePath;
    }
    get appId() {
        return this.config.appId || "app";
    }
    get router() {
        return this.config.router || {};
    }
    get routerMode() {
        return this.router.mode || "hash";
    }
    get customRoutes() {
        return this.router.customRoutes || {};
    }
    get routes() {
        return this.config.routes || [];
    }
    get tabBarList() {
        var _a;
        return ((_a = this.config.tabBar) === null || _a === void 0 ? void 0 : _a.list) || [];
    }
    get PullDownRefresh() {
        return this.config.PullDownRefresh;
    }
    get animation() {
        var _a, _b;
        return (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.animation) !== null && _b !== void 0 ? _b : this.defaultAnimation;
    }
    get animationDelay() {
        var _a;
        return (typeof this.animation === "object" ? this.animation.delay : this.animation ? (_a = this.defaultAnimation) === null || _a === void 0 ? void 0 : _a.delay : 0) || 0;
    }
    get animationDuration() {
        var _a;
        return (typeof this.animation === "object" ? this.animation.duration : this.animation ? (_a = this.defaultAnimation) === null || _a === void 0 ? void 0 : _a.duration : 0) || 0;
    }
    set pathname(p) {
        this.router.pathname = p;
    }
    get pathname() {
        return this.router.pathname;
    }
    get basename() {
        return this.router.basename || "";
    }
    get pageConfig() {
        const routePath = addLeadingSlash(stripBasename(this.pathname, this.basename));
        const homePage = addLeadingSlash(this.homePage);
        return this.routes.find((r)=>{
            var _a;
            const pagePath = addLeadingSlash(r.path);
            return [
                pagePath,
                homePage
            ].includes(routePath) || ((_a = routesAlias.getConfig(pagePath)) === null || _a === void 0 ? void 0 : _a.includes(routePath));
        });
    }
    isTabBar(pathname) {
        var _a;
        const routePath = addLeadingSlash(stripBasename(pathname, this.basename)).split("?")[0];
        const pagePath = ((_a = Object.entries(this.customRoutes).find(([, target])=>{
            if (typeof target === "string") {
                return target === routePath;
            } else if ((target === null || target === void 0 ? void 0 : target.length) > 0) {
                return target.includes(routePath);
            }
            return false;
        })) === null || _a === void 0 ? void 0 : _a[0]) || routePath;
        return !!pagePath && this.tabBarList.some((t)=>stripTrailing(t.pagePath) === pagePath);
    }
    isDefaultNavigationStyle() {
        var _a, _b;
        let style = (_a = this.config.window) === null || _a === void 0 ? void 0 : _a.navigationStyle;
        if (typeof ((_b = this.pageConfig) === null || _b === void 0 ? void 0 : _b.navigationStyle) === "string") {
            style = this.pageConfig.navigationStyle;
        }
        return style !== "custom";
    }
    isSamePage(page) {
        const routePath = stripBasename(this.pathname, this.basename);
        const pagePath = stripBasename(page === null || page === void 0 ? void 0 : page.path, this.basename);
        return pagePath.startsWith(routePath + "?");
    }
    get search() {
        let search = "?";
        if (this.routerMode === "hash") {
            const idx = location.hash.indexOf("?");
            if (idx > -1) {
                search = location.hash.slice(idx);
            }
        } else {
            search = location.search;
        }
        return search.substring(1);
    }
    get usingWindowScroll() {
        var _a;
        let usingWindowScroll = false;
        if (typeof ((_a = this.pageConfig) === null || _a === void 0 ? void 0 : _a.usingWindowScroll) === "boolean") {
            usingWindowScroll = this.pageConfig.usingWindowScroll;
        }
        const win3 = window;
        win3.__taroAppConfig || (win3.__taroAppConfig = {});
        win3.__taroAppConfig.usingWindowScroll = usingWindowScroll;
        return usingWindowScroll;
    }
    getQuery(stamp = "", search = "", options3 = {}) {
        search = search ? `${search}&${this.search}` : this.search;
        const query = search ? import_query_string2.default.parse(search, {
            decode: false
        }) : {};
        query.stamp = stamp;
        return Object.assign(Object.assign({}, query), options3);
    }
    mount() {
        setHistory(this.history, this.basename);
        this.pathname = history.location.pathname;
        this.animation && loadAnimateStyle(this.animationDuration);
        loadRouterStyle(this.tabBarList.length > 1, this.usingWindowScroll);
    }
    onReady(page, onLoad = true) {
        var _a;
        const pageEl = this.getPageContainer(page);
        if (pageEl && !(pageEl === null || pageEl === void 0 ? void 0 : pageEl["__isReady"])) {
            const el = pageEl.firstElementChild;
            const componentOnReady = el === null || el === void 0 ? void 0 : el["componentOnReady"];
            if (componentOnReady) {
                componentOnReady === null || componentOnReady === void 0 ? void 0 : componentOnReady().then(()=>{
                    _raf(()=>{
                        var _a2;
                        (_a2 = page.onReady) === null || _a2 === void 0 ? void 0 : _a2.call(page);
                        pageEl["__isReady"] = true;
                    });
                });
            } else {
                (_a = page.onReady) === null || _a === void 0 ? void 0 : _a.call(page);
                pageEl["__isReady"] = true;
            }
            onLoad && (pageEl["__page"] = page);
        }
    }
    load(page, pageConfig = {}, stampId, pageNo = 0) {
        var _a, _b;
        if (!page) return;
        stacks.push(page);
        const param = this.getQuery(stampId, "", page.options);
        let pageEl = this.getPageContainer(page);
        if (pageEl) {
            pageEl.classList.remove("taro_page_shade");
            this.isTabBar(this.pathname) && pageEl.classList.add("taro_tabbar_page");
            this.isDefaultNavigationStyle() && pageEl.classList.add("taro_navigation_page");
            this.addAnimation(pageEl, pageNo === 0);
            (_a = page.onShow) === null || _a === void 0 ? void 0 : _a.call(page);
            this.bindPageEvents(page, pageConfig);
            this.triggerRouterChange();
        } else {
            (_b = page.onLoad) === null || _b === void 0 ? void 0 : _b.call(page, param, ()=>{
                var _a2;
                pageEl = this.getPageContainer(page);
                this.isTabBar(this.pathname) && (pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.add("taro_tabbar_page"));
                this.isDefaultNavigationStyle() && (pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.add("taro_navigation_page"));
                this.addAnimation(pageEl, pageNo === 0);
                (_a2 = page.onShow) === null || _a2 === void 0 ? void 0 : _a2.call(page);
                this.onReady(page, true);
                this.bindPageEvents(page, pageConfig);
                this.triggerRouterChange();
            });
        }
    }
    unload(page, delta = 1, top = false) {
        var _a, _b, _c;
        if (!page) return;
        stacks.delta = --delta;
        stacks.pop();
        if (this.animation && top) {
            if (this.unloadTimer) {
                clearTimeout(this.unloadTimer);
                (_b = (_a = this.lastUnloadPage) === null || _a === void 0 ? void 0 : _a.onUnload) === null || _b === void 0 ? void 0 : _b.call(_a);
                this.unloadTimer = null;
            }
            this.lastUnloadPage = page;
            const pageEl = this.getPageContainer(page);
            pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.remove("taro_page_stationed");
            pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.remove("taro_page_show");
            if (pageEl) {
                pageEl.style.zIndex = "1";
            }
            this.unloadTimer = setTimeout(()=>{
                var _a2, _b2;
                this.unloadTimer = null;
                (_b2 = (_a2 = this.lastUnloadPage) === null || _a2 === void 0 ? void 0 : _a2.onUnload) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
                eventCenter.trigger("__taroPageOnShowAfterDestroyed");
            }, this.animationDuration);
        } else {
            const pageEl = this.getPageContainer(page);
            pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.remove("taro_page_stationed");
            pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.remove("taro_page_show");
            (_c = page === null || page === void 0 ? void 0 : page.onUnload) === null || _c === void 0 ? void 0 : _c.call(page);
            setTimeout(()=>{
                eventCenter.trigger("__taroPageOnShowAfterDestroyed");
            }, 0);
        }
        if (delta >= 1) this.unload(stacks.last, delta);
    }
    show(page, pageConfig = {}, pageNo = 0) {
        var _a, _b;
        if (!page) return;
        const param = this.getQuery(page["$taroParams"]["stamp"], "", page.options);
        let pageEl = this.getPageContainer(page);
        if (pageEl) {
            pageEl.classList.remove("taro_page_shade");
            this.addAnimation(pageEl, pageNo === 0);
            (_a = page.onShow) === null || _a === void 0 ? void 0 : _a.call(page);
            this.bindPageEvents(page, pageConfig);
            this.triggerRouterChange();
        } else {
            (_b = page.onLoad) === null || _b === void 0 ? void 0 : _b.call(page, param, ()=>{
                var _a2;
                pageEl = this.getPageContainer(page);
                this.addAnimation(pageEl, pageNo === 0);
                (_a2 = page.onShow) === null || _a2 === void 0 ? void 0 : _a2.call(page);
                this.onReady(page, false);
                this.bindPageEvents(page, pageConfig);
                this.triggerRouterChange();
            });
        }
    }
    hide(page) {
        var _a;
        if (!page) return;
        const pageEl = this.getPageContainer(page);
        if (pageEl) {
            if (this.hideTimer) {
                clearTimeout(this.hideTimer);
                this.hideTimer = null;
                pageEl.classList.add("taro_page_shade");
            }
            this.lastHidePage = pageEl;
            this.hideTimer = setTimeout(()=>{
                this.hideTimer = null;
                pageEl.classList.add("taro_page_shade");
            }, this.animationDuration + this.animationDelay);
            (_a = page.onHide) === null || _a === void 0 ? void 0 : _a.call(page);
        } else {
            setTimeout(()=>this.hide(page), 0);
        }
    }
    addAnimation(pageEl, first = false) {
        if (!pageEl) return;
        if (this.animation && !first) {
            setTimeout(()=>{
                pageEl.classList.add("taro_page_show");
                setTimeout(()=>{
                    pageEl.classList.add("taro_page_stationed");
                }, this.animationDuration);
            }, this.animationDelay);
        } else {
            pageEl.classList.add("taro_page_show");
            pageEl.classList.add("taro_page_stationed");
        }
    }
    getPageContainer(page) {
        var _a;
        const path = page ? page === null || page === void 0 ? void 0 : page.path : (_a = Current.page) === null || _a === void 0 ? void 0 : _a.path;
        const id = path === null || path === void 0 ? void 0 : path.replace(/([^a-z0-9\u00a0-\uffff_-])/ig, "\\$1");
        if (page) {
            return document.querySelector(`.taro_page#${id}`);
        }
        const el = id ? document.querySelector(`.taro_page#${id}`) : document.querySelector(".taro_page") || document.querySelector(".taro_router");
        return el;
    }
    getScrollingElement(page) {
        if (this.usingWindowScroll) return window;
        return this.getPageContainer(page) || window;
    }
    bindPageEvents(page, config = {}) {
        var _a;
        const scrollEl = this.getScrollingElement(page);
        const distance = config.onReachBottomDistance || ((_a = this.config.window) === null || _a === void 0 ? void 0 : _a.onReachBottomDistance) || 50;
        bindPageScroll(page, scrollEl, distance);
        bindPageResize(page);
    }
    triggerRouterChange() {
        setTimeout(()=>{
            eventCenter.trigger("__afterTaroRouterChange", {
                toLocation: {
                    path: this.pathname
                }
            });
        }, 0);
    }
    constructor(config, history2){
        this.history = history2;
        this.defaultAnimation = {
            duration: 300,
            delay: 50
        };
        this.config = config;
        this.homePage = getHomePage(this.routes[0].path, this.basename, this.customRoutes, this.config.entryPagePath);
        this.mount();
    }
};
// node_modules/@tarojs/router/dist/router/spa.js
var createStampId2 = incrementId();
var launchStampId2 = createStampId2();
function createRouter(history2, app, config, framework) {
    var _a, _b;
    if (typeof app.onUnhandledRejection === "function") {
        window.addEventListener("unhandledrejection", app.onUnhandledRejection);
    }
    RouterConfig.config = config;
    const handler = new PageHandler(config, history2);
    routesAlias.set(handler.router.customRoutes);
    const basename2 = handler.router.basename;
    const routes = handler.routes.map((route)=>{
        const routePath2 = addLeadingSlash(route.path);
        const paths = routesAlias.getAll(routePath2);
        return {
            path: paths.length < 1 ? routePath2 : paths,
            action: route.load
        };
    });
    const router = new module_default(routes, {
        baseUrl: basename2 || ""
    });
    const launchParam = {
        path: handler.currentPage,
        query: handler.getQuery(launchStampId2),
        scene: 0,
        shareTicket: "",
        referrerInfo: {}
    };
    eventCenter.trigger("__taroRouterLaunch", launchParam);
    (_a = app.onLaunch) === null || _a === void 0 ? void 0 : _a.call(app, launchParam);
    app.onError && window.addEventListener("error", (e)=>{
        var _a2;
        return (_a2 = app.onError) === null || _a2 === void 0 ? void 0 : _a2.call(app, e.message);
    });
    const render2 = ({ location: location2, action })=>__awaiter(this, void 0, void 0, function*() {
            var _c, _d, _e, _f, _g, _h, _j, _k, _l;
            handler.pathname = decodeURI(location2.pathname);
            if ((_c = window.__taroAppConfig) === null || _c === void 0 ? void 0 : _c.usingWindowScroll) window.scrollTo(0, 0);
            eventCenter.trigger("__taroRouterChange", {
                toLocation: {
                    path: handler.pathname
                }
            });
            let element, params;
            try {
                const result = yield router.resolve(handler.router.forcePath || handler.pathname);
                [element, , params] = yield Promise.all(result);
            } catch (error) {
                if (error.status === 404) {
                    const notFoundEvent = {
                        isEntryPage: stacks.length === 0,
                        path: handler.pathname,
                        query: handler.getQuery(createStampId2())
                    };
                    (_d = app.onPageNotFound) === null || _d === void 0 ? void 0 : _d.call(app, notFoundEvent);
                    eventCenter.trigger("__taroRouterNotFound", notFoundEvent);
                } else if (/Loading hot update .* failed./.test(error.message)) {
                    window.location.reload();
                } else {
                    throw error;
                }
            }
            if (!element) return;
            const pageConfig = handler.pageConfig;
            let enablePullDownRefresh = ((_e = config === null || config === void 0 ? void 0 : config.window) === null || _e === void 0 ? void 0 : _e.enablePullDownRefresh) || false;
            let navigationStyle = ((_f = config === null || config === void 0 ? void 0 : config.window) === null || _f === void 0 ? void 0 : _f.navigationStyle) || "default";
            let navigationBarTextStyle = ((_g = config === null || config === void 0 ? void 0 : config.window) === null || _g === void 0 ? void 0 : _g.navigationBarTextStyle) || "white";
            let navigationBarBackgroundColor = ((_h = config === null || config === void 0 ? void 0 : config.window) === null || _h === void 0 ? void 0 : _h.navigationBarBackgroundColor) || "#000000";
            if (pageConfig) {
                setTitle((_j = pageConfig.navigationBarTitleText) !== null && _j !== void 0 ? _j : document.title);
                if (typeof pageConfig.enablePullDownRefresh === "boolean") {
                    enablePullDownRefresh = pageConfig.enablePullDownRefresh;
                }
                if (typeof pageConfig.navigationStyle === "string") {
                    navigationStyle = pageConfig.navigationStyle;
                }
                if (typeof pageConfig.navigationBarTextStyle === "string") {
                    navigationBarTextStyle = pageConfig.navigationBarTextStyle;
                }
                if (typeof pageConfig.navigationBarBackgroundColor === "string") {
                    navigationBarBackgroundColor = pageConfig.navigationBarBackgroundColor;
                }
            }
            eventCenter.trigger("__taroSetNavigationStyle", navigationStyle, navigationBarTextStyle, navigationBarBackgroundColor);
            const currentPage = Current.page;
            const pathname = handler.pathname;
            const methodName = (_k = stacks.method) !== null && _k !== void 0 ? _k : "";
            const cacheTabs = stacks.getTabs();
            let shouldLoad = false;
            stacks.method = "";
            if (methodName === "reLaunch") {
                handler.unload(currentPage, stacks.length);
                for(const key in cacheTabs){
                    if (cacheTabs[key]) {
                        handler.unload(cacheTabs[key]);
                        stacks.removeTab(key);
                    }
                }
                shouldLoad = true;
            } else if (currentPage && handler.isTabBar(handler.pathname)) {
                if (handler.isSamePage(currentPage)) return;
                if (handler.isTabBar(currentPage.path)) {
                    handler.hide(currentPage);
                    stacks.pushTab(currentPage.path.split("?")[0]);
                } else if (stacks.length > 0) {
                    const firstIns = stacks.getItem(0);
                    if (handler.isTabBar(firstIns.path)) {
                        handler.unload(currentPage, stacks.length - 1, true);
                        stacks.pushTab(firstIns.path.split("?")[0]);
                    } else {
                        handler.unload(currentPage, stacks.length, true);
                    }
                }
                if (cacheTabs[handler.pathname]) {
                    stacks.popTab(handler.pathname);
                    return handler.show(stacks.getItem(0), pageConfig, 0);
                }
                shouldLoad = true;
            } else if (action === "POP") {
                const prevIndex = stacks.getPrevIndex(pathname);
                const delta = stacks.getDelta(pathname);
                if (currentPage !== stacks.getItem(prevIndex)) {
                    handler.unload(currentPage, delta, prevIndex > -1);
                    if (prevIndex > -1) {
                        eventCenter.once("__taroPageOnShowAfterDestroyed", ()=>{
                            handler.show(stacks.getItem(prevIndex), pageConfig, prevIndex);
                        });
                    } else {
                        shouldLoad = true;
                    }
                }
            } else if (action === "REPLACE") {
                const delta = stacks.getDelta(pathname);
                handler.unload(currentPage, delta);
                shouldLoad = true;
            } else if (action === "PUSH") {
                handler.hide(currentPage);
                shouldLoad = true;
            }
            if (shouldLoad || stacks.length < 1) {
                const el = (_l = element.default) !== null && _l !== void 0 ? _l : element;
                const loadConfig = Object.assign({}, pageConfig);
                const stacksIndex = stacks.length;
                delete loadConfig["path"];
                delete loadConfig["load"];
                let pageStampId = "";
                if (launchStampId2) {
                    pageStampId = launchStampId2;
                    launchStampId2 = "";
                } else {
                    pageStampId = createStampId2();
                }
                const page = createPageConfig(enablePullDownRefresh ? hooks.call("createPullDownComponent", el, pathname, framework, handler.PullDownRefresh, pageStampId) : el, pathname + stringify(handler.getQuery(pageStampId)), {}, loadConfig);
                if (params) page.options = params;
                handler.load(page, pageConfig, pageStampId, stacksIndex);
            }
        });
    const routePath = addLeadingSlash(stripBasename(history2.location.pathname, handler.basename));
    if (routePath === "/") {
        history2.replace(prependBasename(handler.homePage + history2.location.search));
    }
    render2({
        location: history2.location,
        action: Action.Push
    });
    (_b = app.onShow) === null || _b === void 0 ? void 0 : _b.call(app, launchParam);
    return history2.listen(render2);
}
// node_modules/@stencil/core/internal/app-data/index.js
var BUILD = {
    allRenderFn: false,
    cmpDidLoad: true,
    cmpDidUnload: false,
    cmpDidUpdate: true,
    cmpDidRender: true,
    cmpWillLoad: true,
    cmpWillUpdate: true,
    cmpWillRender: true,
    connectedCallback: true,
    disconnectedCallback: true,
    element: true,
    event: true,
    hasRenderFn: true,
    lifecycle: true,
    hostListener: true,
    hostListenerTargetWindow: true,
    hostListenerTargetDocument: true,
    hostListenerTargetBody: true,
    hostListenerTargetParent: false,
    hostListenerTarget: true,
    member: true,
    method: true,
    mode: true,
    observeAttribute: true,
    prop: true,
    propMutable: true,
    reflect: true,
    scoped: true,
    shadowDom: true,
    slot: true,
    cssAnnotations: true,
    state: true,
    style: true,
    svg: true,
    updatable: true,
    vdomAttribute: true,
    vdomXlink: true,
    vdomClass: true,
    vdomFunctional: true,
    vdomKey: true,
    vdomListener: true,
    vdomRef: true,
    vdomPropOrAttr: true,
    vdomRender: true,
    vdomStyle: true,
    vdomText: true,
    watchCallback: true,
    taskQueue: true,
    hotModuleReplacement: false,
    isDebug: false,
    isDev: false,
    isTesting: false,
    hydrateServerSide: false,
    hydrateClientSide: false,
    lifecycleDOMEvents: false,
    lazyLoad: false,
    profile: false,
    slotRelocation: true,
    appendChildSlotFix: false,
    cloneNodeFix: false,
    hydratedAttribute: false,
    hydratedClass: true,
    safari10: false,
    scriptDataOpts: false,
    scopedSlotTextContentFix: false,
    shadowDomShim: false,
    slotChildNodesFix: false,
    invisiblePrehydration: true,
    propBoolean: true,
    propNumber: true,
    propString: true,
    cssVarShim: false,
    constructableCSS: true,
    cmpShouldUpdate: true,
    devTools: false,
    dynamicImportShim: false,
    shadowDelegatesFocus: true,
    initializeNextTick: false,
    asyncLoading: false,
    asyncQueue: false,
    transformTagName: false,
    attachStyles: true
};
var NAMESPACE = /* default */ "app";
// import("./**/*.entry.js*") in node_modules/@stencil/core/internal/client/index.js
var globImport_entry_js = __glob({});
// node_modules/@stencil/core/internal/client/index.js
var scopeId;
var contentRef;
var hostTagName;
var customError;
var i = 0;
var useNativeShadowDom = false;
var checkSlotFallbackVisibility = false;
var checkSlotRelocate = false;
var isSvgMode = false;
var renderingRef = null;
var queueCongestion = 0;
var queuePending = false;
var Build = {
    isDev: BUILD.isDev ? true : false,
    isBrowser: true,
    isServer: false,
    isTesting: BUILD.isTesting ? true : false
};
var createTime = (fnName, tagName = "")=>{
    if (BUILD.profile && performance.mark) {
        const key = `st:${fnName}:${tagName}:${i++}`;
        performance.mark(key);
        return ()=>performance.measure(`[Stencil] ${fnName}() <${tagName}>`, key);
    } else {
        return ()=>{
            return;
        };
    }
};
var uniqueTime = (key, measureText)=>{
    if (BUILD.profile && performance.mark) {
        if (performance.getEntriesByName(key, "mark").length === 0) {
            performance.mark(key);
        }
        return ()=>{
            if (performance.getEntriesByName(measureText, "measure").length === 0) {
                performance.measure(measureText, key);
            }
        };
    } else {
        return ()=>{
            return;
        };
    }
};
var CONTENT_REF_ID = "r";
var ORG_LOCATION_ID = "o";
var SLOT_NODE_ID = "s";
var TEXT_NODE_ID = "t";
var HYDRATE_ID = "s-id";
var HYDRATED_STYLE_ID = "sty-id";
var HYDRATE_CHILD_ID = "c-id";
var XLINK_NS = "http://www.w3.org/1999/xlink";
var EMPTY_OBJ = {};
var SVG_NS = "http://www.w3.org/2000/svg";
var HTML_NS = "http://www.w3.org/1999/xhtml";
var isDef = (v)=>v != null;
var isComplexType = (o)=>{
    o = typeof o;
    return o === "object" || o === "function";
};
function queryNonceMetaTagContent(doc3) {
    var _a, _b, _c;
    return (_c = (_b = (_a = doc3.head) === null || _a === void 0 ? void 0 : _a.querySelector('meta[name="csp-nonce"]')) === null || _b === void 0 ? void 0 : _b.getAttribute("content")) !== null && _c !== void 0 ? _c : void 0;
}
var h = (nodeName, vnodeData, ...children2)=>{
    let child = null;
    let key = null;
    let slotName = null;
    let simple = false;
    let lastSimple = false;
    const vNodeChildren = [];
    const walk = (c)=>{
        for(let i2 = 0; i2 < c.length; i2++){
            child = c[i2];
            if (Array.isArray(child)) {
                walk(child);
            } else if (child != null && typeof child !== "boolean") {
                if (simple = typeof nodeName !== "function" && !isComplexType(child)) {
                    child = String(child);
                } else if (BUILD.isDev && typeof nodeName !== "function" && child.$flags$ === void 0) {
                    consoleDevError(`vNode passed as children has unexpected type.
Make sure it's using the correct h() function.
Empty objects can also be the cause, look for JSX comments that became objects.`);
                }
                if (simple && lastSimple) {
                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;
                } else {
                    vNodeChildren.push(simple ? newVNode(null, child) : child);
                }
                lastSimple = simple;
            }
        }
    };
    walk(children2);
    if (vnodeData) {
        if (BUILD.isDev && nodeName === "input") {
            validateInputProperties(vnodeData);
        }
        if (BUILD.vdomKey && vnodeData.key) {
            key = vnodeData.key;
        }
        if (BUILD.slotRelocation && vnodeData.name) {
            slotName = vnodeData.name;
        }
        if (BUILD.vdomClass) {
            const classData = vnodeData.className || vnodeData.class;
            if (classData) {
                vnodeData.class = typeof classData !== "object" ? classData : Object.keys(classData).filter((k)=>classData[k]).join(" ");
            }
        }
    }
    if (BUILD.isDev && vNodeChildren.some(isHost)) {
        consoleDevError(`The <Host> must be the single root component. Make sure:
- You are NOT using hostData() and <Host> in the same component.
- <Host> is used once, and it's the single root component of the render() function.`);
    }
    if (BUILD.vdomFunctional && typeof nodeName === "function") {
        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);
    }
    const vnode = newVNode(nodeName, null);
    vnode.$attrs$ = vnodeData;
    if (vNodeChildren.length > 0) {
        vnode.$children$ = vNodeChildren;
    }
    if (BUILD.vdomKey) {
        vnode.$key$ = key;
    }
    if (BUILD.slotRelocation) {
        vnode.$name$ = slotName;
    }
    return vnode;
};
var newVNode = (tag, text2)=>{
    const vnode = {
        $flags$: 0,
        $tag$: tag,
        $text$: text2,
        $elm$: null,
        $children$: null
    };
    if (BUILD.vdomAttribute) {
        vnode.$attrs$ = null;
    }
    if (BUILD.vdomKey) {
        vnode.$key$ = null;
    }
    if (BUILD.slotRelocation) {
        vnode.$name$ = null;
    }
    return vnode;
};
var Host = {};
var isHost = (node)=>node && node.$tag$ === Host;
var vdomFnUtils = {
    forEach: (children2, cb)=>children2.map(convertToPublic).forEach(cb),
    map: (children2, cb)=>children2.map(convertToPublic).map(cb).map(convertToPrivate)
};
var convertToPublic = (node)=>({
        vattrs: node.$attrs$,
        vchildren: node.$children$,
        vkey: node.$key$,
        vname: node.$name$,
        vtag: node.$tag$,
        vtext: node.$text$
    });
var convertToPrivate = (node)=>{
    if (typeof node.vtag === "function") {
        const vnodeData = Object.assign({}, node.vattrs);
        if (node.vkey) {
            vnodeData.key = node.vkey;
        }
        if (node.vname) {
            vnodeData.name = node.vname;
        }
        return h(node.vtag, vnodeData, ...node.vchildren || []);
    }
    const vnode = newVNode(node.vtag, node.vtext);
    vnode.$attrs$ = node.vattrs;
    vnode.$children$ = node.vchildren;
    vnode.$key$ = node.vkey;
    vnode.$name$ = node.vname;
    return vnode;
};
var validateInputProperties = (inputElm)=>{
    const props = Object.keys(inputElm);
    const value = props.indexOf("value");
    if (value === -1) {
        return;
    }
    const typeIndex = props.indexOf("type");
    const minIndex = props.indexOf("min");
    const maxIndex = props.indexOf("max");
    const stepIndex = props.indexOf("step");
    if (value < typeIndex || value < minIndex || value < maxIndex || value < stepIndex) {
        consoleDevWarn(`The "value" prop of <input> should be set after "min", "max", "type" and "step"`);
    }
};
var initializeClientHydrate = (hostElm, tagName, hostId, hostRef)=>{
    const endHydrate = createTime("hydrateClient", tagName);
    const shadowRoot = hostElm.shadowRoot;
    const childRenderNodes = [];
    const slotNodes = [];
    const shadowRootNodes = BUILD.shadowDom && shadowRoot ? [] : null;
    const vnode = hostRef.$vnode$ = newVNode(tagName, null);
    if (!plt.$orgLocNodes$) {
        initializeDocumentHydrate(doc.body, plt.$orgLocNodes$ = /* @__PURE__ */ new Map());
    }
    hostElm[HYDRATE_ID] = hostId;
    hostElm.removeAttribute(HYDRATE_ID);
    clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);
    childRenderNodes.map((c)=>{
        const orgLocationId = c.$hostId$ + "." + c.$nodeId$;
        const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);
        const node = c.$elm$;
        if (orgLocationNode && supportsShadow && orgLocationNode["s-en"] === "") {
            orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);
        }
        if (!shadowRoot) {
            node["s-hn"] = tagName;
            if (orgLocationNode) {
                node["s-ol"] = orgLocationNode;
                node["s-ol"]["s-nr"] = node;
            }
        }
        plt.$orgLocNodes$.delete(orgLocationId);
    });
    if (BUILD.shadowDom && shadowRoot) {
        shadowRootNodes.map((shadowRootNode)=>{
            if (shadowRootNode) {
                shadowRoot.appendChild(shadowRootNode);
            }
        });
    }
    endHydrate();
};
var clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId)=>{
    let childNodeType;
    let childIdSplt;
    let childVNode;
    let i2;
    if (node.nodeType === 1) {
        childNodeType = node.getAttribute(HYDRATE_CHILD_ID);
        if (childNodeType) {
            childIdSplt = childNodeType.split(".");
            if (childIdSplt[0] === hostId || childIdSplt[0] === "0") {
                childVNode = {
                    $flags$: 0,
                    $hostId$: childIdSplt[0],
                    $nodeId$: childIdSplt[1],
                    $depth$: childIdSplt[2],
                    $index$: childIdSplt[3],
                    $tag$: node.tagName.toLowerCase(),
                    $elm$: node,
                    $attrs$: null,
                    $children$: null,
                    $key$: null,
                    $name$: null,
                    $text$: null
                };
                childRenderNodes.push(childVNode);
                node.removeAttribute(HYDRATE_CHILD_ID);
                if (!parentVNode.$children$) {
                    parentVNode.$children$ = [];
                }
                parentVNode.$children$[childVNode.$index$] = childVNode;
                parentVNode = childVNode;
                if (shadowRootNodes && childVNode.$depth$ === "0") {
                    shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
                }
            }
        }
        for(i2 = node.childNodes.length - 1; i2 >= 0; i2--){
            clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i2], hostId);
        }
        if (node.shadowRoot) {
            for(i2 = node.shadowRoot.childNodes.length - 1; i2 >= 0; i2--){
                clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i2], hostId);
            }
        }
    } else if (node.nodeType === 8) {
        childIdSplt = node.nodeValue.split(".");
        if (childIdSplt[1] === hostId || childIdSplt[1] === "0") {
            childNodeType = childIdSplt[0];
            childVNode = {
                $flags$: 0,
                $hostId$: childIdSplt[1],
                $nodeId$: childIdSplt[2],
                $depth$: childIdSplt[3],
                $index$: childIdSplt[4],
                $elm$: node,
                $attrs$: null,
                $children$: null,
                $key$: null,
                $name$: null,
                $tag$: null,
                $text$: null
            };
            if (childNodeType === TEXT_NODE_ID) {
                childVNode.$elm$ = node.nextSibling;
                if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3) {
                    childVNode.$text$ = childVNode.$elm$.textContent;
                    childRenderNodes.push(childVNode);
                    node.remove();
                    if (!parentVNode.$children$) {
                        parentVNode.$children$ = [];
                    }
                    parentVNode.$children$[childVNode.$index$] = childVNode;
                    if (shadowRootNodes && childVNode.$depth$ === "0") {
                        shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
                    }
                }
            } else if (childVNode.$hostId$ === hostId) {
                if (childNodeType === SLOT_NODE_ID) {
                    childVNode.$tag$ = "slot";
                    if (childIdSplt[5]) {
                        node["s-sn"] = childVNode.$name$ = childIdSplt[5];
                    } else {
                        node["s-sn"] = "";
                    }
                    node["s-sr"] = true;
                    if (BUILD.shadowDom && shadowRootNodes) {
                        childVNode.$elm$ = doc.createElement(childVNode.$tag$);
                        if (childVNode.$name$) {
                            childVNode.$elm$.setAttribute("name", childVNode.$name$);
                        }
                        node.parentNode.insertBefore(childVNode.$elm$, node);
                        node.remove();
                        if (childVNode.$depth$ === "0") {
                            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
                        }
                    }
                    slotNodes.push(childVNode);
                    if (!parentVNode.$children$) {
                        parentVNode.$children$ = [];
                    }
                    parentVNode.$children$[childVNode.$index$] = childVNode;
                } else if (childNodeType === CONTENT_REF_ID) {
                    if (BUILD.shadowDom && shadowRootNodes) {
                        node.remove();
                    } else if (BUILD.slotRelocation) {
                        hostElm["s-cr"] = node;
                        node["s-cn"] = true;
                    }
                }
            }
        }
    } else if (parentVNode && parentVNode.$tag$ === "style") {
        const vnode = newVNode(null, node.textContent);
        vnode.$elm$ = node;
        vnode.$index$ = "0";
        parentVNode.$children$ = [
            vnode
        ];
    }
};
var initializeDocumentHydrate = (node, orgLocNodes)=>{
    if (node.nodeType === 1) {
        let i2 = 0;
        for(; i2 < node.childNodes.length; i2++){
            initializeDocumentHydrate(node.childNodes[i2], orgLocNodes);
        }
        if (node.shadowRoot) {
            for(i2 = 0; i2 < node.shadowRoot.childNodes.length; i2++){
                initializeDocumentHydrate(node.shadowRoot.childNodes[i2], orgLocNodes);
            }
        }
    } else if (node.nodeType === 8) {
        const childIdSplt = node.nodeValue.split(".");
        if (childIdSplt[0] === ORG_LOCATION_ID) {
            orgLocNodes.set(childIdSplt[1] + "." + childIdSplt[2], node);
            node.nodeValue = "";
            node["s-en"] = childIdSplt[3];
        }
    }
};
var computeMode = (elm)=>modeResolutionChain.map((h2)=>h2(elm)).find((m)=>!!m);
var parsePropertyValue = (propValue, propType)=>{
    if (propValue != null && !isComplexType(propValue)) {
        if (BUILD.propBoolean && propType & 4) {
            return propValue === "false" ? false : propValue === "" || !!propValue;
        }
        if (BUILD.propNumber && propType & 2) {
            return parseFloat(propValue);
        }
        if (BUILD.propString && propType & 1) {
            return String(propValue);
        }
        return propValue;
    }
    return propValue;
};
var getElement = (ref)=>BUILD.lazyLoad ? getHostRef(ref).$hostElement$ : ref;
var createEvent = (ref, name, flags)=>{
    const elm = getElement(ref);
    return {
        emit: (detail)=>{
            if (BUILD.isDev && !elm.isConnected) {
                consoleDevWarn(`The "${name}" event was emitted, but the dispatcher node is no longer connected to the dom.`);
            }
            return emitEvent(elm, name, {
                bubbles: !!(flags & 4),
                composed: !!(flags & 2),
                cancelable: !!(flags & 1),
                detail
            });
        }
    };
};
var emitEvent = (elm, name, opts)=>{
    const ev = plt.ce(name, opts);
    elm.dispatchEvent(ev);
    return ev;
};
var rootAppliedStyles = /* @__PURE__ */ new WeakMap();
var registerStyle = (scopeId2, cssText, allowCS)=>{
    let style = styles.get(scopeId2);
    if (supportsConstructableStylesheets && allowCS) {
        style = style || new CSSStyleSheet();
        if (typeof style === "string") {
            style = cssText;
        } else {
            style.replaceSync(cssText);
        }
    } else {
        style = cssText;
    }
    styles.set(scopeId2, style);
};
var addStyle2 = (styleContainerNode, cmpMeta, mode, hostElm)=>{
    var _a;
    let scopeId2 = getScopeId(cmpMeta, mode);
    const style = styles.get(scopeId2);
    if (!BUILD.attachStyles) {
        return scopeId2;
    }
    styleContainerNode = styleContainerNode.nodeType === 11 ? styleContainerNode : doc;
    if (style) {
        if (typeof style === "string") {
            styleContainerNode = styleContainerNode.head || styleContainerNode;
            let appliedStyles = rootAppliedStyles.get(styleContainerNode);
            let styleElm;
            if (!appliedStyles) {
                rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */ new Set());
            }
            if (!appliedStyles.has(scopeId2)) {
                if (BUILD.hydrateClientSide && styleContainerNode.host && (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}="${scopeId2}"]`))) {
                    styleElm.innerHTML = style;
                } else {
                    if (BUILD.cssVarShim && plt.$cssShim$) {
                        styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId2, style, !!(cmpMeta.$flags$ & 10));
                        const newScopeId = styleElm["s-sc"];
                        if (newScopeId) {
                            scopeId2 = newScopeId;
                            appliedStyles = null;
                        }
                    } else {
                        styleElm = doc.createElement("style");
                        styleElm.innerHTML = style;
                    }
                    const nonce = (_a = plt.$nonce$) !== null && _a !== void 0 ? _a : queryNonceMetaTagContent(doc);
                    if (nonce != null) {
                        styleElm.setAttribute("nonce", nonce);
                    }
                    if (BUILD.hydrateServerSide || BUILD.hotModuleReplacement) {
                        styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId2);
                    }
                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector("link"));
                }
                if (appliedStyles) {
                    appliedStyles.add(scopeId2);
                }
            }
        } else if (BUILD.constructableCSS && !styleContainerNode.adoptedStyleSheets.includes(style)) {
            styleContainerNode.adoptedStyleSheets = [
                ...styleContainerNode.adoptedStyleSheets,
                style
            ];
        }
    }
    return scopeId2;
};
var attachStyles = (hostRef)=>{
    const cmpMeta = hostRef.$cmpMeta$;
    const elm = hostRef.$hostElement$;
    const flags = cmpMeta.$flags$;
    const endAttachStyles = createTime("attachStyles", cmpMeta.$tagName$);
    const scopeId2 = addStyle2(BUILD.shadowDom && supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$, elm);
    if ((BUILD.shadowDom || BUILD.scoped) && BUILD.cssAnnotations && flags & 10) {
        elm["s-sc"] = scopeId2;
        elm.classList.add(scopeId2 + "-h");
        if (BUILD.scoped && flags & 2) {
            elm.classList.add(scopeId2 + "-s");
        }
    }
    endAttachStyles();
};
var getScopeId = (cmp, mode)=>"sc-" + (BUILD.mode && mode && cmp.$flags$ & 32 ? cmp.$tagName$ + "-" + mode : cmp.$tagName$);
var setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags)=>{
    if (oldValue !== newValue) {
        let isProp = isMemberInElement(elm, memberName);
        let ln = memberName.toLowerCase();
        if (BUILD.vdomClass && memberName === "class") {
            const classList = elm.classList;
            const oldClasses = parseClassList(oldValue);
            const newClasses = parseClassList(newValue);
            classList.remove(...oldClasses.filter((c)=>c && !newClasses.includes(c)));
            classList.add(...newClasses.filter((c)=>c && !oldClasses.includes(c)));
        } else if (BUILD.vdomStyle && memberName === "style") {
            if (BUILD.updatable) {
                for(const prop in oldValue){
                    if (!newValue || newValue[prop] == null) {
                        if (!BUILD.hydrateServerSide && prop.includes("-")) {
                            elm.style.removeProperty(prop);
                        } else {
                            elm.style[prop] = "";
                        }
                    }
                }
            }
            for(const prop in newValue){
                if (!oldValue || newValue[prop] !== oldValue[prop]) {
                    if (!BUILD.hydrateServerSide && prop.includes("-")) {
                        elm.style.setProperty(prop, newValue[prop]);
                    } else {
                        elm.style[prop] = newValue[prop];
                    }
                }
            }
        } else if (BUILD.vdomKey && memberName === "key") ;
        else if (BUILD.vdomRef && memberName === "ref") {
            if (newValue) {
                newValue(elm);
            }
        } else if (BUILD.vdomListener && (BUILD.lazyLoad ? !isProp : !elm.__lookupSetter__(memberName)) && memberName[0] === "o" && memberName[1] === "n") {
            if (memberName[2] === "-") {
                memberName = memberName.slice(3);
            } else if (isMemberInElement(win, ln)) {
                memberName = ln.slice(2);
            } else {
                memberName = ln[2] + memberName.slice(3);
            }
            if (oldValue) {
                plt.rel(elm, memberName, oldValue, false);
            }
            if (newValue) {
                plt.ael(elm, memberName, newValue, false);
            }
        } else if (BUILD.vdomPropOrAttr) {
            const isComplex = isComplexType(newValue);
            if ((isProp || isComplex && newValue !== null) && !isSvg) {
                try {
                    if (!elm.tagName.includes("-")) {
                        const n = newValue == null ? "" : newValue;
                        if (memberName === "list") {
                            isProp = false;
                        } else if (oldValue == null || elm[memberName] != n) {
                            elm[memberName] = n;
                        }
                    } else {
                        elm[memberName] = newValue;
                    }
                } catch (e) {}
            }
            let xlink = false;
            if (BUILD.vdomXlink) {
                if (ln !== (ln = ln.replace(/^xlink\:?/, ""))) {
                    memberName = ln;
                    xlink = true;
                }
            }
            if (newValue == null || newValue === false) {
                if (newValue !== false || elm.getAttribute(memberName) === "") {
                    if (BUILD.vdomXlink && xlink) {
                        elm.removeAttributeNS(XLINK_NS, memberName);
                    } else {
                        elm.removeAttribute(memberName);
                    }
                }
            } else if ((!isProp || flags & 4 || isSvg) && !isComplex) {
                newValue = newValue === true ? "" : newValue;
                if (BUILD.vdomXlink && xlink) {
                    elm.setAttributeNS(XLINK_NS, memberName, newValue);
                } else {
                    elm.setAttribute(memberName, newValue);
                }
            }
        }
    }
};
var parseClassListRegex = /\s/;
var parseClassList = (value)=>!value ? [] : value.split(parseClassListRegex);
var updateElement = (oldVnode, newVnode, isSvgMode2, memberName)=>{
    const elm = newVnode.$elm$.nodeType === 11 && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
    const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;
    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
    if (BUILD.updatable) {
        for(memberName in oldVnodeAttrs){
            if (!(memberName in newVnodeAttrs)) {
                setAccessor(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);
            }
        }
    }
    for(memberName in newVnodeAttrs){
        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode2, newVnode.$flags$);
    }
};
var createElm = (oldParentVNode, newParentVNode, childIndex, parentElm)=>{
    const newVNode2 = newParentVNode.$children$[childIndex];
    let i2 = 0;
    let elm;
    let childNode;
    let oldVNode;
    if (BUILD.slotRelocation && !useNativeShadowDom) {
        checkSlotRelocate = true;
        if (newVNode2.$tag$ === "slot") {
            if (scopeId) {
                parentElm.classList.add(scopeId + "-s");
            }
            newVNode2.$flags$ |= newVNode2.$children$ ? // slot element has fallback content
            2 : // slot element does not have fallback content
            1;
        }
    }
    if (BUILD.isDev && newVNode2.$elm$) {
        consoleDevError(`The JSX ${newVNode2.$text$ !== null ? `"${newVNode2.$text$}" text` : `"${newVNode2.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`);
    }
    if (BUILD.vdomText && newVNode2.$text$ !== null) {
        elm = newVNode2.$elm$ = doc.createTextNode(newVNode2.$text$);
    } else if (BUILD.slotRelocation && newVNode2.$flags$ & 1) {
        elm = newVNode2.$elm$ = BUILD.isDebug || BUILD.hydrateServerSide ? slotReferenceDebugNode(newVNode2) : doc.createTextNode("");
    } else {
        if (BUILD.svg && !isSvgMode) {
            isSvgMode = newVNode2.$tag$ === "svg";
        }
        elm = newVNode2.$elm$ = BUILD.svg ? doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, BUILD.slotRelocation && newVNode2.$flags$ & 2 ? "slot-fb" : newVNode2.$tag$) : doc.createElement(BUILD.slotRelocation && newVNode2.$flags$ & 2 ? "slot-fb" : newVNode2.$tag$);
        if (BUILD.svg && isSvgMode && newVNode2.$tag$ === "foreignObject") {
            isSvgMode = false;
        }
        if (BUILD.vdomAttribute) {
            updateElement(null, newVNode2, isSvgMode);
        }
        if ((BUILD.shadowDom || BUILD.scoped) && isDef(scopeId) && elm["s-si"] !== scopeId) {
            elm.classList.add(elm["s-si"] = scopeId);
        }
        if (newVNode2.$children$) {
            for(i2 = 0; i2 < newVNode2.$children$.length; ++i2){
                childNode = createElm(oldParentVNode, newVNode2, i2, elm);
                if (childNode) {
                    elm.appendChild(childNode);
                }
            }
        }
        if (BUILD.svg) {
            if (newVNode2.$tag$ === "svg") {
                isSvgMode = false;
            } else if (elm.tagName === "foreignObject") {
                isSvgMode = true;
            }
        }
    }
    if (BUILD.slotRelocation) {
        elm["s-hn"] = hostTagName;
        if (newVNode2.$flags$ & (2 | 1)) {
            elm["s-sr"] = true;
            elm["s-cr"] = contentRef;
            elm["s-sn"] = newVNode2.$name$ || "";
            oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
            if (oldVNode && oldVNode.$tag$ === newVNode2.$tag$ && oldParentVNode.$elm$) {
                putBackInOriginalLocation(oldParentVNode.$elm$, false);
            }
        }
    }
    return elm;
};
var putBackInOriginalLocation = (parentElm, recursive)=>{
    plt.$flags$ |= 1;
    const oldSlotChildNodes = parentElm.childNodes;
    for(let i2 = oldSlotChildNodes.length - 1; i2 >= 0; i2--){
        const childNode = oldSlotChildNodes[i2];
        if (childNode["s-hn"] !== hostTagName && childNode["s-ol"]) {
            parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));
            childNode["s-ol"].remove();
            childNode["s-ol"] = void 0;
            checkSlotRelocate = true;
        }
        if (recursive) {
            putBackInOriginalLocation(childNode, recursive);
        }
    }
    plt.$flags$ &= ~1;
};
var addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx)=>{
    let containerElm = BUILD.slotRelocation && parentElm["s-cr"] && parentElm["s-cr"].parentNode || parentElm;
    let childNode;
    if (BUILD.shadowDom && containerElm.shadowRoot && containerElm.tagName === hostTagName) {
        containerElm = containerElm.shadowRoot;
    }
    for(; startIdx <= endIdx; ++startIdx){
        if (vnodes[startIdx]) {
            childNode = createElm(null, parentVNode, startIdx, parentElm);
            if (childNode) {
                vnodes[startIdx].$elm$ = childNode;
                containerElm.insertBefore(childNode, BUILD.slotRelocation ? referenceNode(before) : before);
            }
        }
    }
};
var removeVnodes = (vnodes, startIdx, endIdx, vnode, elm)=>{
    for(; startIdx <= endIdx; ++startIdx){
        if (vnode = vnodes[startIdx]) {
            elm = vnode.$elm$;
            callNodeRefs(vnode);
            if (BUILD.slotRelocation) {
                checkSlotFallbackVisibility = true;
                if (elm["s-ol"]) {
                    elm["s-ol"].remove();
                } else {
                    putBackInOriginalLocation(elm, true);
                }
            }
            elm.remove();
        }
    }
};
var updateChildren = (parentElm, oldCh, newVNode2, newCh)=>{
    let oldStartIdx = 0;
    let newStartIdx = 0;
    let idxInOld = 0;
    let i2 = 0;
    let oldEndIdx = oldCh.length - 1;
    let oldStartVnode = oldCh[0];
    let oldEndVnode = oldCh[oldEndIdx];
    let newEndIdx = newCh.length - 1;
    let newStartVnode = newCh[0];
    let newEndVnode = newCh[newEndIdx];
    let node;
    let elmToMove;
    while(oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx){
        if (oldStartVnode == null) {
            oldStartVnode = oldCh[++oldStartIdx];
        } else if (oldEndVnode == null) {
            oldEndVnode = oldCh[--oldEndIdx];
        } else if (newStartVnode == null) {
            newStartVnode = newCh[++newStartIdx];
        } else if (newEndVnode == null) {
            newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldStartVnode, newStartVnode)) {
            patch(oldStartVnode, newStartVnode);
            oldStartVnode = oldCh[++oldStartIdx];
            newStartVnode = newCh[++newStartIdx];
        } else if (isSameVnode(oldEndVnode, newEndVnode)) {
            patch(oldEndVnode, newEndVnode);
            oldEndVnode = oldCh[--oldEndIdx];
            newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldStartVnode, newEndVnode)) {
            if (BUILD.slotRelocation && (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot")) {
                putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
            }
            patch(oldStartVnode, newEndVnode);
            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
            oldStartVnode = oldCh[++oldStartIdx];
            newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldEndVnode, newStartVnode)) {
            if (BUILD.slotRelocation && (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot")) {
                putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
            }
            patch(oldEndVnode, newStartVnode);
            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
            oldEndVnode = oldCh[--oldEndIdx];
            newStartVnode = newCh[++newStartIdx];
        } else {
            idxInOld = -1;
            if (BUILD.vdomKey) {
                for(i2 = oldStartIdx; i2 <= oldEndIdx; ++i2){
                    if (oldCh[i2] && oldCh[i2].$key$ !== null && oldCh[i2].$key$ === newStartVnode.$key$) {
                        idxInOld = i2;
                        break;
                    }
                }
            }
            if (BUILD.vdomKey && idxInOld >= 0) {
                elmToMove = oldCh[idxInOld];
                if (elmToMove.$tag$ !== newStartVnode.$tag$) {
                    node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld, parentElm);
                } else {
                    patch(elmToMove, newStartVnode);
                    oldCh[idxInOld] = void 0;
                    node = elmToMove.$elm$;
                }
                newStartVnode = newCh[++newStartIdx];
            } else {
                node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx, parentElm);
                newStartVnode = newCh[++newStartIdx];
            }
            if (node) {
                if (BUILD.slotRelocation) {
                    parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));
                } else {
                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);
                }
            }
        }
    }
    if (oldStartIdx > oldEndIdx) {
        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode2, newCh, newStartIdx, newEndIdx);
    } else if (BUILD.updatable && newStartIdx > newEndIdx) {
        removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
};
var isSameVnode = (leftVNode, rightVNode)=>{
    if (leftVNode.$tag$ === rightVNode.$tag$) {
        if (BUILD.slotRelocation && leftVNode.$tag$ === "slot") {
            return leftVNode.$name$ === rightVNode.$name$;
        }
        if (BUILD.vdomKey) {
            return leftVNode.$key$ === rightVNode.$key$;
        }
        return true;
    }
    return false;
};
var referenceNode = (node)=>{
    return node && node["s-ol"] || node;
};
var parentReferenceNode = (node)=>(node["s-ol"] ? node["s-ol"] : node).parentNode;
var patch = (oldVNode, newVNode2)=>{
    const elm = newVNode2.$elm$ = oldVNode.$elm$;
    const oldChildren = oldVNode.$children$;
    const newChildren = newVNode2.$children$;
    const tag = newVNode2.$tag$;
    const text2 = newVNode2.$text$;
    let defaultHolder;
    if (!BUILD.vdomText || text2 === null) {
        if (BUILD.svg) {
            isSvgMode = tag === "svg" ? true : tag === "foreignObject" ? false : isSvgMode;
        }
        if (BUILD.vdomAttribute || BUILD.reflect) {
            if (BUILD.slot && tag === "slot") ;
            else {
                updateElement(oldVNode, newVNode2, isSvgMode);
            }
        }
        if (BUILD.updatable && oldChildren !== null && newChildren !== null) {
            updateChildren(elm, oldChildren, newVNode2, newChildren);
        } else if (newChildren !== null) {
            if (BUILD.updatable && BUILD.vdomText && oldVNode.$text$ !== null) {
                elm.textContent = "";
            }
            addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);
        } else if (BUILD.updatable && oldChildren !== null) {
            removeVnodes(oldChildren, 0, oldChildren.length - 1);
        }
        if (BUILD.svg && isSvgMode && tag === "svg") {
            isSvgMode = false;
        }
    } else if (BUILD.vdomText && BUILD.slotRelocation && (defaultHolder = elm["s-cr"])) {
        defaultHolder.parentNode.textContent = text2;
    } else if (BUILD.vdomText && oldVNode.$text$ !== text2) {
        elm.data = text2;
    }
};
var updateFallbackSlotVisibility = (elm)=>{
    const childNodes = elm.childNodes;
    let childNode;
    let i2;
    let ilen;
    let j;
    let slotNameAttr;
    let nodeType;
    for(i2 = 0, ilen = childNodes.length; i2 < ilen; i2++){
        childNode = childNodes[i2];
        if (childNode.nodeType === 1) {
            if (childNode["s-sr"]) {
                slotNameAttr = childNode["s-sn"];
                childNode.hidden = false;
                for(j = 0; j < ilen; j++){
                    nodeType = childNodes[j].nodeType;
                    if (childNodes[j]["s-hn"] !== childNode["s-hn"] || slotNameAttr !== "") {
                        if (nodeType === 1 && slotNameAttr === childNodes[j].getAttribute("slot")) {
                            childNode.hidden = true;
                            break;
                        }
                    } else {
                        if (nodeType === 1 || nodeType === 3 && childNodes[j].textContent.trim() !== "") {
                            childNode.hidden = true;
                            break;
                        }
                    }
                }
            }
            updateFallbackSlotVisibility(childNode);
        }
    }
};
var relocateNodes = [];
var relocateSlotContent = (elm)=>{
    let childNode;
    let node;
    let hostContentNodes;
    let slotNameAttr;
    let relocateNodeData;
    let j;
    let i2 = 0;
    const childNodes = elm.childNodes;
    const ilen = childNodes.length;
    for(; i2 < ilen; i2++){
        childNode = childNodes[i2];
        if (childNode["s-sr"] && (node = childNode["s-cr"]) && node.parentNode) {
            hostContentNodes = node.parentNode.childNodes;
            slotNameAttr = childNode["s-sn"];
            for(j = hostContentNodes.length - 1; j >= 0; j--){
                node = hostContentNodes[j];
                if (!node["s-cn"] && !node["s-nr"] && node["s-hn"] !== childNode["s-hn"]) {
                    if (isNodeLocatedInSlot(node, slotNameAttr)) {
                        relocateNodeData = relocateNodes.find((r)=>r.$nodeToRelocate$ === node);
                        checkSlotFallbackVisibility = true;
                        node["s-sn"] = node["s-sn"] || slotNameAttr;
                        if (relocateNodeData) {
                            relocateNodeData.$slotRefNode$ = childNode;
                        } else {
                            relocateNodes.push({
                                $slotRefNode$: childNode,
                                $nodeToRelocate$: node
                            });
                        }
                        if (node["s-sr"]) {
                            relocateNodes.map((relocateNode)=>{
                                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node["s-sn"])) {
                                    relocateNodeData = relocateNodes.find((r)=>r.$nodeToRelocate$ === node);
                                    if (relocateNodeData && !relocateNode.$slotRefNode$) {
                                        relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                                    }
                                }
                            });
                        }
                    } else if (!relocateNodes.some((r)=>r.$nodeToRelocate$ === node)) {
                        relocateNodes.push({
                            $nodeToRelocate$: node
                        });
                    }
                }
            }
        }
        if (childNode.nodeType === 1) {
            relocateSlotContent(childNode);
        }
    }
};
var isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr)=>{
    if (nodeToRelocate.nodeType === 1) {
        if (nodeToRelocate.getAttribute("slot") === null && slotNameAttr === "") {
            return true;
        }
        if (nodeToRelocate.getAttribute("slot") === slotNameAttr) {
            return true;
        }
        return false;
    }
    if (nodeToRelocate["s-sn"] === slotNameAttr) {
        return true;
    }
    return slotNameAttr === "";
};
var callNodeRefs = (vNode)=>{
    if (BUILD.vdomRef) {
        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
        vNode.$children$ && vNode.$children$.map(callNodeRefs);
    }
};
var renderVdom = (hostRef, renderFnResults)=>{
    const hostElm = hostRef.$hostElement$;
    const cmpMeta = hostRef.$cmpMeta$;
    const oldVNode = hostRef.$vnode$ || newVNode(null, null);
    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
    hostTagName = hostElm.tagName;
    if (BUILD.isDev && Array.isArray(renderFnResults) && renderFnResults.some(isHost)) {
        throw new Error(`The <Host> must be the single root component.
Looks like the render() function of "${hostTagName.toLowerCase()}" is returning an array that contains the <Host>.

The render() function should look like this instead:

render() {
  // Do not return an array
  return (
    <Host>{content}</Host>
  );
}
  `);
    }
    if (BUILD.reflect && cmpMeta.$attrsToReflect$) {
        rootVnode.$attrs$ = rootVnode.$attrs$ || {};
        cmpMeta.$attrsToReflect$.map(([propName, attribute])=>rootVnode.$attrs$[attribute] = hostElm[propName]);
    }
    rootVnode.$tag$ = null;
    rootVnode.$flags$ |= 4;
    hostRef.$vnode$ = rootVnode;
    rootVnode.$elm$ = oldVNode.$elm$ = BUILD.shadowDom ? hostElm.shadowRoot || hostElm : hostElm;
    if (BUILD.scoped || BUILD.shadowDom) {
        scopeId = hostElm["s-sc"];
    }
    if (BUILD.slotRelocation) {
        contentRef = hostElm["s-cr"];
        useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1) !== 0;
        checkSlotFallbackVisibility = false;
    }
    patch(oldVNode, rootVnode);
    if (BUILD.slotRelocation) {
        plt.$flags$ |= 1;
        if (checkSlotRelocate) {
            relocateSlotContent(rootVnode.$elm$);
            let relocateData;
            let nodeToRelocate;
            let orgLocationNode;
            let parentNodeRef;
            let insertBeforeNode;
            let refNode;
            let i2 = 0;
            for(; i2 < relocateNodes.length; i2++){
                relocateData = relocateNodes[i2];
                nodeToRelocate = relocateData.$nodeToRelocate$;
                if (!nodeToRelocate["s-ol"]) {
                    orgLocationNode = BUILD.isDebug || BUILD.hydrateServerSide ? originalLocationDebugNode(nodeToRelocate) : doc.createTextNode("");
                    orgLocationNode["s-nr"] = nodeToRelocate;
                    nodeToRelocate.parentNode.insertBefore(nodeToRelocate["s-ol"] = orgLocationNode, nodeToRelocate);
                }
            }
            for(i2 = 0; i2 < relocateNodes.length; i2++){
                relocateData = relocateNodes[i2];
                nodeToRelocate = relocateData.$nodeToRelocate$;
                if (relocateData.$slotRefNode$) {
                    parentNodeRef = relocateData.$slotRefNode$.parentNode;
                    insertBeforeNode = relocateData.$slotRefNode$.nextSibling;
                    orgLocationNode = nodeToRelocate["s-ol"];
                    while(orgLocationNode = orgLocationNode.previousSibling){
                        refNode = orgLocationNode["s-nr"];
                        if (refNode && refNode["s-sn"] === nodeToRelocate["s-sn"] && parentNodeRef === refNode.parentNode) {
                            refNode = refNode.nextSibling;
                            if (!refNode || !refNode["s-nr"]) {
                                insertBeforeNode = refNode;
                                break;
                            }
                        }
                    }
                    if (!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode || nodeToRelocate.nextSibling !== insertBeforeNode) {
                        if (nodeToRelocate !== insertBeforeNode) {
                            if (!nodeToRelocate["s-hn"] && nodeToRelocate["s-ol"]) {
                                nodeToRelocate["s-hn"] = nodeToRelocate["s-ol"].parentNode.nodeName;
                            }
                            parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);
                        }
                    }
                } else {
                    if (nodeToRelocate.nodeType === 1) {
                        nodeToRelocate.hidden = true;
                    }
                }
            }
        }
        if (checkSlotFallbackVisibility) {
            updateFallbackSlotVisibility(rootVnode.$elm$);
        }
        plt.$flags$ &= ~1;
        relocateNodes.length = 0;
    }
};
var slotReferenceDebugNode = (slotVNode)=>doc.createComment(`<slot${slotVNode.$name$ ? ' name="' + slotVNode.$name$ + '"' : ""}> (host=${hostTagName.toLowerCase()})`);
var originalLocationDebugNode = (nodeToRelocate)=>doc.createComment(`org-location for ` + (nodeToRelocate.localName ? `<${nodeToRelocate.localName}> (host=${nodeToRelocate["s-hn"]})` : `[${nodeToRelocate.textContent}]`));
var attachToAncestor = (hostRef, ancestorComponent)=>{
    if (BUILD.asyncLoading && ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent["s-p"]) {
        ancestorComponent["s-p"].push(new Promise((r)=>hostRef.$onRenderResolve$ = r));
    }
};
var scheduleUpdate = (hostRef, isInitialLoad)=>{
    if (BUILD.taskQueue && BUILD.updatable) {
        hostRef.$flags$ |= 16;
    }
    if (BUILD.asyncLoading && hostRef.$flags$ & 4) {
        hostRef.$flags$ |= 512;
        return;
    }
    attachToAncestor(hostRef, hostRef.$ancestorComponent$);
    const dispatch = ()=>dispatchHooks(hostRef, isInitialLoad);
    return BUILD.taskQueue ? writeTask(dispatch) : dispatch();
};
var dispatchHooks = (hostRef, isInitialLoad)=>{
    const elm = hostRef.$hostElement$;
    const endSchedule = createTime("scheduleUpdate", hostRef.$cmpMeta$.$tagName$);
    const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
    let promise;
    if (isInitialLoad) {
        if (BUILD.lazyLoad && BUILD.hostListener) {
            hostRef.$flags$ |= 256;
            if (hostRef.$queuedListeners$) {
                hostRef.$queuedListeners$.map(([methodName, event2])=>safeCall(instance, methodName, event2));
                hostRef.$queuedListeners$ = null;
            }
        }
        emitLifecycleEvent(elm, "componentWillLoad");
        if (BUILD.cmpWillLoad) {
            promise = safeCall(instance, "componentWillLoad");
        }
    } else {
        emitLifecycleEvent(elm, "componentWillUpdate");
        if (BUILD.cmpWillUpdate) {
            promise = safeCall(instance, "componentWillUpdate");
        }
    }
    emitLifecycleEvent(elm, "componentWillRender");
    if (BUILD.cmpWillRender) {
        promise = then(promise, ()=>safeCall(instance, "componentWillRender"));
    }
    endSchedule();
    return then(promise, ()=>updateComponent(hostRef, instance, isInitialLoad));
};
var updateComponent = function() {
    var _ref = _async_to_generator(function*(hostRef, instance, isInitialLoad) {
        const elm = hostRef.$hostElement$;
        const endUpdate = createTime("update", hostRef.$cmpMeta$.$tagName$);
        const rc = elm["s-rc"];
        if (BUILD.style && isInitialLoad) {
            attachStyles(hostRef);
        }
        const endRender = createTime("render", hostRef.$cmpMeta$.$tagName$);
        if (BUILD.isDev) {
            hostRef.$flags$ |= 1024;
        }
        if (BUILD.hydrateServerSide) {
            yield callRender(hostRef, instance, elm);
        } else {
            callRender(hostRef, instance, elm);
        }
        if (BUILD.cssVarShim && plt.$cssShim$) {
            plt.$cssShim$.updateHost(elm);
        }
        if (BUILD.isDev) {
            hostRef.$renderCount$++;
            hostRef.$flags$ &= ~1024;
        }
        if (BUILD.hydrateServerSide) {
            try {
                serverSideConnected(elm);
                if (isInitialLoad) {
                    if (hostRef.$cmpMeta$.$flags$ & 1) {
                        elm["s-en"] = "";
                    } else if (hostRef.$cmpMeta$.$flags$ & 2) {
                        elm["s-en"] = "c";
                    }
                }
            } catch (e) {
                consoleError(e, elm);
            }
        }
        if (BUILD.asyncLoading && rc) {
            rc.map((cb)=>cb());
            elm["s-rc"] = void 0;
        }
        endRender();
        endUpdate();
        if (BUILD.asyncLoading) {
            const childrenPromises = elm["s-p"];
            const postUpdate = ()=>postUpdateComponent(hostRef);
            if (childrenPromises.length === 0) {
                postUpdate();
            } else {
                Promise.all(childrenPromises).then(postUpdate);
                hostRef.$flags$ |= 4;
                childrenPromises.length = 0;
            }
        } else {
            postUpdateComponent(hostRef);
        }
    });
    return function updateComponent(hostRef, instance, isInitialLoad) {
        return _ref.apply(this, arguments);
    };
}();
var callRender = (hostRef, instance, elm)=>{
    const allRenderFn = BUILD.allRenderFn ? true : false;
    const lazyLoad2 = BUILD.lazyLoad ? true : false;
    const taskQueue = BUILD.taskQueue ? true : false;
    const updatable = BUILD.updatable ? true : false;
    try {
        renderingRef = instance;
        instance = allRenderFn ? instance.render() : instance.render && instance.render();
        if (updatable && taskQueue) {
            hostRef.$flags$ &= ~16;
        }
        if (updatable || lazyLoad2) {
            hostRef.$flags$ |= 2;
        }
        if (BUILD.hasRenderFn || BUILD.reflect) {
            if (BUILD.vdomRender || BUILD.reflect) {
                if (BUILD.hydrateServerSide) {
                    return Promise.resolve(instance).then((value)=>renderVdom(hostRef, value));
                } else {
                    renderVdom(hostRef, instance);
                }
            } else {
                elm.textContent = instance;
            }
        }
    } catch (e) {
        consoleError(e, hostRef.$hostElement$);
    }
    renderingRef = null;
    return null;
};
var postUpdateComponent = (hostRef)=>{
    const tagName = hostRef.$cmpMeta$.$tagName$;
    const elm = hostRef.$hostElement$;
    const endPostUpdate = createTime("postUpdate", tagName);
    const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
    const ancestorComponent = hostRef.$ancestorComponent$;
    if (BUILD.cmpDidRender) {
        if (BUILD.isDev) {
            hostRef.$flags$ |= 1024;
        }
        safeCall(instance, "componentDidRender");
        if (BUILD.isDev) {
            hostRef.$flags$ &= ~1024;
        }
    }
    emitLifecycleEvent(elm, "componentDidRender");
    if (!(hostRef.$flags$ & 64)) {
        hostRef.$flags$ |= 64;
        if (BUILD.asyncLoading && BUILD.cssAnnotations) {
            addHydratedFlag(elm);
        }
        if (BUILD.cmpDidLoad) {
            if (BUILD.isDev) {
                hostRef.$flags$ |= 2048;
            }
            safeCall(instance, "componentDidLoad");
            if (BUILD.isDev) {
                hostRef.$flags$ &= ~2048;
            }
        }
        emitLifecycleEvent(elm, "componentDidLoad");
        endPostUpdate();
        if (BUILD.asyncLoading) {
            hostRef.$onReadyResolve$(elm);
            if (!ancestorComponent) {
                appDidLoad(tagName);
            }
        }
    } else {
        if (BUILD.cmpDidUpdate) {
            if (BUILD.isDev) {
                hostRef.$flags$ |= 1024;
            }
            safeCall(instance, "componentDidUpdate");
            if (BUILD.isDev) {
                hostRef.$flags$ &= ~1024;
            }
        }
        emitLifecycleEvent(elm, "componentDidUpdate");
        endPostUpdate();
    }
    if (BUILD.hotModuleReplacement) {
        elm["s-hmr-load"] && elm["s-hmr-load"]();
    }
    if (BUILD.method && BUILD.lazyLoad) {
        hostRef.$onInstanceResolve$(elm);
    }
    if (BUILD.asyncLoading) {
        if (hostRef.$onRenderResolve$) {
            hostRef.$onRenderResolve$();
            hostRef.$onRenderResolve$ = void 0;
        }
        if (hostRef.$flags$ & 512) {
            nextTick2(()=>scheduleUpdate(hostRef, false));
        }
        hostRef.$flags$ &= ~(4 | 512);
    }
};
var appDidLoad = (who)=>{
    if (BUILD.cssAnnotations) {
        addHydratedFlag(doc.documentElement);
    }
    if (BUILD.asyncQueue) {
        plt.$flags$ |= 2;
    }
    nextTick2(()=>emitEvent(win, "appload", {
            detail: {
                namespace: NAMESPACE
            }
        }));
    if (BUILD.profile && performance.measure) {
        performance.measure(`[Stencil] ${NAMESPACE} initial load (by ${who})`, "st:app:start");
    }
};
var safeCall = (instance, method, arg)=>{
    if (instance && instance[method]) {
        try {
            return instance[method](arg);
        } catch (e) {
            consoleError(e);
        }
    }
    return void 0;
};
var then = (promise, thenFn)=>{
    return promise && promise.then ? promise.then(thenFn) : thenFn();
};
var emitLifecycleEvent = (elm, lifecycleName)=>{
    if (BUILD.lifecycleDOMEvents) {
        emitEvent(elm, "stencil_" + lifecycleName, {
            bubbles: true,
            composed: true,
            detail: {
                namespace: NAMESPACE
            }
        });
    }
};
var addHydratedFlag = (elm)=>BUILD.hydratedClass ? elm.classList.add("hydrated") : BUILD.hydratedAttribute ? elm.setAttribute("hydrated", "") : void 0;
var serverSideConnected = (elm)=>{
    const children2 = elm.children;
    if (children2 != null) {
        for(let i2 = 0, ii = children2.length; i2 < ii; i2++){
            const childElm = children2[i2];
            if (typeof childElm.connectedCallback === "function") {
                childElm.connectedCallback();
            }
            serverSideConnected(childElm);
        }
    }
};
var getValue = (ref, propName)=>getHostRef(ref).$instanceValues$.get(propName);
var setValue = (ref, propName, newVal, cmpMeta)=>{
    const hostRef = getHostRef(ref);
    const elm = BUILD.lazyLoad ? hostRef.$hostElement$ : ref;
    const oldVal = hostRef.$instanceValues$.get(propName);
    const flags = hostRef.$flags$;
    const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
    const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
    const didValueChange = newVal !== oldVal && !areBothNaN;
    if ((!BUILD.lazyLoad || !(flags & 8) || oldVal === void 0) && didValueChange) {
        hostRef.$instanceValues$.set(propName, newVal);
        if (BUILD.isDev) {
            if (hostRef.$flags$ & 1024) {
                consoleDevWarn(`The state/prop "${propName}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`, "\nElement", elm, "\nNew value", newVal, "\nOld value", oldVal);
            } else if (hostRef.$flags$ & 2048) {
                consoleDevWarn(`The state/prop "${propName}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`, "\nElement", elm, "\nNew value", newVal, "\nOld value", oldVal);
            }
        }
        if (!BUILD.lazyLoad || instance) {
            if (BUILD.watchCallback && cmpMeta.$watchers$ && flags & 128) {
                const watchMethods = cmpMeta.$watchers$[propName];
                if (watchMethods) {
                    watchMethods.map((watchMethodName)=>{
                        try {
                            instance[watchMethodName](newVal, oldVal, propName);
                        } catch (e) {
                            consoleError(e, elm);
                        }
                    });
                }
            }
            if (BUILD.updatable && (flags & (2 | 16)) === 2) {
                if (BUILD.cmpShouldUpdate && instance.componentShouldUpdate) {
                    if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
                        return;
                    }
                }
                scheduleUpdate(hostRef, false);
            }
        }
    }
};
var proxyComponent = (Cstr, cmpMeta, flags)=>{
    if (BUILD.member && cmpMeta.$members$) {
        if (BUILD.watchCallback && Cstr.watchers) {
            cmpMeta.$watchers$ = Cstr.watchers;
        }
        const members = Object.entries(cmpMeta.$members$);
        const prototype = Cstr.prototype;
        members.map(([memberName, [memberFlags]])=>{
            if ((BUILD.prop || BUILD.state) && (memberFlags & 31 || (!BUILD.lazyLoad || flags & 2) && memberFlags & 32)) {
                Object.defineProperty(prototype, memberName, {
                    get () {
                        return getValue(this, memberName);
                    },
                    set (newValue) {
                        if (BUILD.isDev) {
                            const ref = getHostRef(this);
                            if (// we are proxying the instance (not element)
                            (flags & 1) === 0 && // the element is not constructing
                            (ref.$flags$ & 8) === 0 && // the member is a prop
                            (memberFlags & 31) !== 0 && // the member is not mutable
                            (memberFlags & 1024) === 0) {
                                consoleDevWarn(`@Prop() "${memberName}" on <${cmpMeta.$tagName$}> is immutable but was modified from within the component.
More information: https://stenciljs.com/docs/properties#prop-mutability`);
                            }
                        }
                        setValue(this, memberName, newValue, cmpMeta);
                    },
                    configurable: true,
                    enumerable: true
                });
            } else if (BUILD.lazyLoad && BUILD.method && flags & 1 && memberFlags & 64) {
                Object.defineProperty(prototype, memberName, {
                    value (...args) {
                        const ref = getHostRef(this);
                        return ref.$onInstancePromise$.then(()=>ref.$lazyInstance$[memberName](...args));
                    }
                });
            }
        });
        if (BUILD.observeAttribute && (!BUILD.lazyLoad || flags & 1)) {
            const attrNameToPropName = /* @__PURE__ */ new Map();
            prototype.attributeChangedCallback = function(attrName, _oldValue, newValue) {
                plt.jmp(()=>{
                    const propName = attrNameToPropName.get(attrName);
                    if (this.hasOwnProperty(propName)) {
                        newValue = this[propName];
                        delete this[propName];
                    } else if (prototype.hasOwnProperty(propName) && typeof this[propName] === "number" && this[propName] == newValue) {
                        return;
                    }
                    this[propName] = newValue === null && typeof this[propName] === "boolean" ? false : newValue;
                });
            };
            Cstr.observedAttributes = members.filter(([_, m])=>m[0] & 15).map(([propName, m])=>{
                const attrName = m[1] || propName;
                attrNameToPropName.set(attrName, propName);
                if (BUILD.reflect && m[0] & 512) {
                    cmpMeta.$attrsToReflect$.push([
                        propName,
                        attrName
                    ]);
                }
                return attrName;
            });
        }
    }
    return Cstr;
};
var initializeComponent = function() {
    var _ref = _async_to_generator(function*(elm, hostRef, cmpMeta, hmrVersionId, Cstr) {
        if ((BUILD.lazyLoad || BUILD.hydrateServerSide || BUILD.style) && (hostRef.$flags$ & 32) === 0) {
            if (BUILD.lazyLoad || BUILD.hydrateClientSide) {
                hostRef.$flags$ |= 32;
                Cstr = loadModule(cmpMeta, hostRef, hmrVersionId);
                if (Cstr.then) {
                    const endLoad = uniqueTime(`st:load:${cmpMeta.$tagName$}:${hostRef.$modeName$}`, `[Stencil] Load module for <${cmpMeta.$tagName$}>`);
                    Cstr = yield Cstr;
                    endLoad();
                }
                if ((BUILD.isDev || BUILD.isDebug) && !Cstr) {
                    throw new Error(`Constructor for "${cmpMeta.$tagName$}#${hostRef.$modeName$}" was not found`);
                }
                if (BUILD.member && !Cstr.isProxied) {
                    if (BUILD.watchCallback) {
                        cmpMeta.$watchers$ = Cstr.watchers;
                    }
                    proxyComponent(Cstr, cmpMeta, 2);
                    Cstr.isProxied = true;
                }
                const endNewInstance = createTime("createInstance", cmpMeta.$tagName$);
                if (BUILD.member) {
                    hostRef.$flags$ |= 8;
                }
                try {
                    new Cstr(hostRef);
                } catch (e) {
                    consoleError(e);
                }
                if (BUILD.member) {
                    hostRef.$flags$ &= ~8;
                }
                if (BUILD.watchCallback) {
                    hostRef.$flags$ |= 128;
                }
                endNewInstance();
                fireConnectedCallback(hostRef.$lazyInstance$);
            } else {
                Cstr = elm.constructor;
                hostRef.$flags$ |= 32;
                customElements.whenDefined(cmpMeta.$tagName$).then(()=>hostRef.$flags$ |= 128);
            }
            if (BUILD.style && Cstr.style) {
                let style = Cstr.style;
                if (BUILD.mode && typeof style !== "string") {
                    style = style[hostRef.$modeName$ = computeMode(elm)];
                    if (BUILD.hydrateServerSide && hostRef.$modeName$) {
                        elm.setAttribute("s-mode", hostRef.$modeName$);
                    }
                }
                const scopeId2 = getScopeId(cmpMeta, hostRef.$modeName$);
                if (!styles.has(scopeId2)) {
                    const endRegisterStyles = createTime("registerStyles", cmpMeta.$tagName$);
                    if (!BUILD.hydrateServerSide && BUILD.shadowDom && BUILD.shadowDomShim && cmpMeta.$flags$ & 8) {
                        style = yield import("./shadow-css-QIOVHN4A.js").then((m)=>m.scopeCss(style, scopeId2, false));
                    }
                    registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1));
                    endRegisterStyles();
                }
            }
        }
        const ancestorComponent = hostRef.$ancestorComponent$;
        const schedule = ()=>scheduleUpdate(hostRef, true);
        if (BUILD.asyncLoading && ancestorComponent && ancestorComponent["s-rc"]) {
            ancestorComponent["s-rc"].push(schedule);
        } else {
            schedule();
        }
    });
    return function initializeComponent(elm, hostRef, cmpMeta, hmrVersionId, Cstr) {
        return _ref.apply(this, arguments);
    };
}();
var fireConnectedCallback = (instance)=>{
    if (BUILD.lazyLoad && BUILD.connectedCallback) {
        safeCall(instance, "connectedCallback");
    }
};
var connectedCallback = (elm)=>{
    if ((plt.$flags$ & 1) === 0) {
        const hostRef = getHostRef(elm);
        const cmpMeta = hostRef.$cmpMeta$;
        const endConnected = createTime("connectedCallback", cmpMeta.$tagName$);
        if (BUILD.hostListenerTargetParent) {
            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, true);
        }
        if (!(hostRef.$flags$ & 1)) {
            hostRef.$flags$ |= 1;
            let hostId;
            if (BUILD.hydrateClientSide) {
                hostId = elm.getAttribute(HYDRATE_ID);
                if (hostId) {
                    if (BUILD.shadowDom && supportsShadow && cmpMeta.$flags$ & 1) {
                        const scopeId2 = BUILD.mode ? addStyle2(elm.shadowRoot, cmpMeta, elm.getAttribute("s-mode")) : addStyle2(elm.shadowRoot, cmpMeta);
                        elm.classList.remove(scopeId2 + "-h", scopeId2 + "-s");
                    }
                    initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);
                }
            }
            if (BUILD.slotRelocation && !hostId) {
                if (BUILD.hydrateServerSide || (BUILD.slot || BUILD.shadowDom) && cmpMeta.$flags$ & (4 | 8)) {
                    setContentReference(elm);
                }
            }
            if (BUILD.asyncLoading) {
                let ancestorComponent = elm;
                while(ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host){
                    if (BUILD.hydrateClientSide && ancestorComponent.nodeType === 1 && ancestorComponent.hasAttribute("s-id") && ancestorComponent["s-p"] || ancestorComponent["s-p"]) {
                        attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);
                        break;
                    }
                }
            }
            if (BUILD.prop && !BUILD.hydrateServerSide && cmpMeta.$members$) {
                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]])=>{
                    if (memberFlags & 31 && elm.hasOwnProperty(memberName)) {
                        const value = elm[memberName];
                        delete elm[memberName];
                        elm[memberName] = value;
                    }
                });
            }
            if (BUILD.initializeNextTick) {
                nextTick2(()=>initializeComponent(elm, hostRef, cmpMeta));
            } else {
                initializeComponent(elm, hostRef, cmpMeta);
            }
        } else {
            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);
            fireConnectedCallback(hostRef.$lazyInstance$);
        }
        endConnected();
    }
};
var setContentReference = (elm)=>{
    const contentRefElm = elm["s-cr"] = doc.createComment(BUILD.isDebug ? `content-ref (host=${elm.localName})` : "");
    contentRefElm["s-cn"] = true;
    elm.insertBefore(contentRefElm, elm.firstChild);
};
var disconnectedCallback = (elm)=>{
    if ((plt.$flags$ & 1) === 0) {
        const hostRef = getHostRef(elm);
        const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
        if (BUILD.hostListener) {
            if (hostRef.$rmListeners$) {
                hostRef.$rmListeners$.map((rmListener)=>rmListener());
                hostRef.$rmListeners$ = void 0;
            }
        }
        if (BUILD.cssVarShim && plt.$cssShim$) {
            plt.$cssShim$.removeHost(elm);
        }
        if (BUILD.lazyLoad && BUILD.disconnectedCallback) {
            safeCall(instance, "disconnectedCallback");
        }
        if (BUILD.cmpDidUnload) {
            safeCall(instance, "componentDidUnload");
        }
    }
};
var proxyCustomElement = (Cstr, compactMeta)=>{
    const cmpMeta = {
        $flags$: compactMeta[0],
        $tagName$: compactMeta[1]
    };
    if (BUILD.member) {
        cmpMeta.$members$ = compactMeta[2];
    }
    if (BUILD.hostListener) {
        cmpMeta.$listeners$ = compactMeta[3];
    }
    if (BUILD.watchCallback) {
        cmpMeta.$watchers$ = Cstr.$watchers$;
    }
    if (BUILD.reflect) {
        cmpMeta.$attrsToReflect$ = [];
    }
    if (BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1) {
        cmpMeta.$flags$ |= 8;
    }
    const originalConnectedCallback = Cstr.prototype.connectedCallback;
    const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;
    Object.assign(Cstr.prototype, {
        __registerHost () {
            registerHost(this, cmpMeta);
        },
        connectedCallback () {
            connectedCallback(this);
            if (BUILD.connectedCallback && originalConnectedCallback) {
                originalConnectedCallback.call(this);
            }
        },
        disconnectedCallback () {
            disconnectedCallback(this);
            if (BUILD.disconnectedCallback && originalDisconnectedCallback) {
                originalDisconnectedCallback.call(this);
            }
        },
        __attachShadow () {
            if (supportsShadow) {
                if (BUILD.shadowDelegatesFocus) {
                    this.attachShadow({
                        mode: "open",
                        delegatesFocus: !!(cmpMeta.$flags$ & 16)
                    });
                } else {
                    this.attachShadow({
                        mode: "open"
                    });
                }
            } else {
                this.shadowRoot = this;
            }
        }
    });
    Cstr.is = cmpMeta.$tagName$;
    return proxyComponent(Cstr, cmpMeta, 1 | 2);
};
var addHostEventListeners = (elm, hostRef, listeners, attachParentListeners)=>{
    if (BUILD.hostListener && listeners) {
        if (BUILD.hostListenerTargetParent) {
            if (attachParentListeners) {
                listeners = listeners.filter(([flags])=>flags & 32);
            } else {
                listeners = listeners.filter(([flags])=>!(flags & 32));
            }
        }
        listeners.map(([flags, name, method])=>{
            const target = BUILD.hostListenerTarget ? getHostListenerTarget(elm, flags) : elm;
            const handler = hostListenerProxy(hostRef, method);
            const opts = hostListenerOpts(flags);
            plt.ael(target, name, handler, opts);
            (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(()=>plt.rel(target, name, handler, opts));
        });
    }
};
var hostListenerProxy = (hostRef, methodName)=>(ev)=>{
        try {
            if (BUILD.lazyLoad) {
                if (hostRef.$flags$ & 256) {
                    hostRef.$lazyInstance$[methodName](ev);
                } else {
                    (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([
                        methodName,
                        ev
                    ]);
                }
            } else {
                hostRef.$hostElement$[methodName](ev);
            }
        } catch (e) {
            consoleError(e);
        }
    };
var getHostListenerTarget = (elm, flags)=>{
    if (BUILD.hostListenerTargetDocument && flags & 4) return doc;
    if (BUILD.hostListenerTargetWindow && flags & 8) return win;
    if (BUILD.hostListenerTargetBody && flags & 16) return doc.body;
    if (BUILD.hostListenerTargetParent && flags & 32) return elm.parentElement;
    return elm;
};
var hostListenerOpts = (flags)=>supportsListenerOptions ? {
        passive: (flags & 1) !== 0,
        capture: (flags & 2) !== 0
    } : (flags & 2) !== 0;
var hostRefs = /* @__PURE__ */ new WeakMap();
var getHostRef = (ref)=>hostRefs.get(ref);
var registerHost = (elm, cmpMeta)=>{
    const hostRef = {
        $flags$: 0,
        $hostElement$: elm,
        $cmpMeta$: cmpMeta,
        $instanceValues$: /* @__PURE__ */ new Map()
    };
    if (BUILD.isDev) {
        hostRef.$renderCount$ = 0;
    }
    if (BUILD.method && BUILD.lazyLoad) {
        hostRef.$onInstancePromise$ = new Promise((r)=>hostRef.$onInstanceResolve$ = r);
    }
    if (BUILD.asyncLoading) {
        hostRef.$onReadyPromise$ = new Promise((r)=>hostRef.$onReadyResolve$ = r);
        elm["s-p"] = [];
        elm["s-rc"] = [];
    }
    addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);
    return hostRefs.set(elm, hostRef);
};
var isMemberInElement = (elm, memberName)=>memberName in elm;
var consoleError = (e, el)=>(customError || console.error)(e, el);
var STENCIL_DEV_MODE = BUILD.isTesting ? [
    "STENCIL:"
] : [
    "%cstencil",
    "color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px"
];
var consoleDevError = (...m)=>console.error(...STENCIL_DEV_MODE, ...m);
var consoleDevWarn = (...m)=>console.warn(...STENCIL_DEV_MODE, ...m);
var cmpModules = /* @__PURE__ */ new Map();
var loadModule = (cmpMeta, hostRef, hmrVersionId)=>{
    const exportName = cmpMeta.$tagName$.replace(/-/g, "_");
    const bundleId = cmpMeta.$lazyBundleId$;
    if (BUILD.isDev && typeof bundleId !== "string") {
        consoleDevError(`Trying to lazily load component <${cmpMeta.$tagName$}> with style mode "${hostRef.$modeName$}", but it does not exist.`);
        return void 0;
    }
    const module2 = !BUILD.hotModuleReplacement ? cmpModules.get(bundleId) : false;
    if (module2) {
        return module2[exportName];
    }
    return /* @vite-ignore */ /* webpackInclude: /\.entry\.js$/ */ /* webpackExclude: /\.system\.entry\.js$/ */ /* webpackMode: "lazy" */ globImport_entry_js(`./${bundleId}.entry.js${BUILD.hotModuleReplacement && hmrVersionId ? "?s-hmr=" + hmrVersionId : ""}`).then((importedModule)=>{
        if (!BUILD.hotModuleReplacement) {
            cmpModules.set(bundleId, importedModule);
        }
        return importedModule[exportName];
    }, consoleError);
};
var styles = /* @__PURE__ */ new Map();
var modeResolutionChain = [];
var win = typeof window !== "undefined" ? window : {};
var CSS = BUILD.cssVarShim ? win.CSS : null;
var doc = win.document || {
    head: {}
};
var H = win.HTMLElement || class {
};
var plt = {
    $flags$: 0,
    $resourcesUrl$: "",
    jmp: (h2)=>h2(),
    raf: (h2)=>requestAnimationFrame(h2),
    ael: (el, eventName, listener, opts)=>el.addEventListener(eventName, listener, opts),
    rel: (el, eventName, listener, opts)=>el.removeEventListener(eventName, listener, opts),
    ce: (eventName, opts)=>new CustomEvent(eventName, opts)
};
var supportsShadow = BUILD.shadowDomShim && BUILD.shadowDom ? (()=>(doc.head.attachShadow + "").indexOf("[native") > -1)() : true;
var supportsListenerOptions = (()=>{
    let supportsListenerOptions2 = false;
    try {
        doc.addEventListener("e", null, Object.defineProperty({}, "passive", {
            get () {
                supportsListenerOptions2 = true;
            }
        }));
    } catch (e) {}
    return supportsListenerOptions2;
})();
var promiseResolve = (v)=>Promise.resolve(v);
var supportsConstructableStylesheets = BUILD.constructableCSS ? (()=>{
    try {
        new CSSStyleSheet();
        return typeof new CSSStyleSheet().replaceSync === "function";
    } catch (e) {}
    return false;
})() : false;
var queueDomReads = [];
var queueDomWrites = [];
var queueDomWritesLow = [];
var queueTask = (queue, write)=>(cb)=>{
        queue.push(cb);
        if (!queuePending) {
            queuePending = true;
            if (write && plt.$flags$ & 4) {
                nextTick2(flush);
            } else {
                plt.raf(flush);
            }
        }
    };
var consume = (queue)=>{
    for(let i2 = 0; i2 < queue.length; i2++){
        try {
            queue[i2](performance.now());
        } catch (e) {
            consoleError(e);
        }
    }
    queue.length = 0;
};
var consumeTimeout = (queue, timeout)=>{
    let i2 = 0;
    let ts = 0;
    while(i2 < queue.length && (ts = performance.now()) < timeout){
        try {
            queue[i2++](ts);
        } catch (e) {
            consoleError(e);
        }
    }
    if (i2 === queue.length) {
        queue.length = 0;
    } else if (i2 !== 0) {
        queue.splice(0, i2);
    }
};
var flush = ()=>{
    if (BUILD.asyncQueue) {
        queueCongestion++;
    }
    consume(queueDomReads);
    if (BUILD.asyncQueue) {
        const timeout = (plt.$flags$ & 6) === 2 ? performance.now() + 14 * Math.ceil(queueCongestion * (1 / 10)) : Infinity;
        consumeTimeout(queueDomWrites, timeout);
        consumeTimeout(queueDomWritesLow, timeout);
        if (queueDomWrites.length > 0) {
            queueDomWritesLow.push(...queueDomWrites);
            queueDomWrites.length = 0;
        }
        if (queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0) {
            plt.raf(flush);
        } else {
            queueCongestion = 0;
        }
    } else {
        consume(queueDomWrites);
        if (queuePending = queueDomReads.length > 0) {
            plt.raf(flush);
        }
    }
};
var nextTick2 = (cb)=>promiseResolve().then(cb);
var readTask = queueTask(queueDomReads, false);
var writeTask = queueTask(queueDomWrites, true);
// node_modules/@tarojs/plugin-platform-h5/dist/dist/definition.json.js
var apis = {
    Behavior: "*",
    getEnv: "*",
    ENV_TYPE: "*",
    Link: "*",
    interceptors: "*",
    interceptorify: "*",
    Current: "*",
    options: "*",
    eventCenter: "*",
    Events: "*",
    preload: "*",
    taro: "*",
    requirePlugin: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    initPxTransform: {
        object: "{ designWidth?: number; deviceRatio?: TDeviceRatio; baseFontSize?: number; unitPrecision?: number; targetUnit?: string; }",
        success: "void"
    },
    pxTransform: {
        object: "number",
        success: "void",
        "return": "*"
    },
    canIUseWebp: {
        object: "void",
        success: "void",
        "return": "boolean"
    },
    getAppInfo: {
        object: "void",
        success: "void",
        "return": "{ platform: string; taroVersion: string; designWidth: any; }"
    },
    createRewardedVideoAd: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    createInterstitialAd: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    stopFaceDetect: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    initFaceDetect: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    faceDetect: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getInferenceEnvInfo: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    createInferenceSession: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    isVKSupport: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    createVKSession: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getOpenUserInfo: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    tradePay: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    env: {},
    arrayBufferToBase64: "*",
    base64ToArrayBuffer: "*",
    getUserCryptoManager: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    setEnableDebug: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getRealtimeLogManager: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getLogManager: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    reportPerformance: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getPerformance: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    preloadWebview: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    preloadSkylineView: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    preloadAssets: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    openSystemBluetoothSetting: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    openAppAuthorizeSetting: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getWindowInfo: {
        object: "void",
        success: "void",
        "return": "Result"
    },
    getSystemSetting: {
        object: "void",
        success: "void",
        "return": "Result"
    },
    getDeviceInfo: {
        object: "void",
        success: "void",
        "return": "Result"
    },
    getAppBaseInfo: {
        object: "void",
        success: "void",
        "return": "Result"
    },
    getAppAuthorizeSetting: {
        object: "void",
        success: "void",
        "return": "Result"
    },
    getSystemInfoSync: {
        object: "void",
        success: "void",
        "return": "Result"
    },
    getSystemInfoAsync: {
        object: "Option",
        success: "void",
        "return": "Promise<Result>"
    },
    getSystemInfo: {
        object: "Option",
        success: "void",
        "return": "Promise<Result>"
    },
    getSkylineInfoSync: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getSkylineInfo: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getRendererUserAgent: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    updateWeChatApp: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getUpdateManager: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onUnhandledRejection: {
        callback: "Result<T>"
    },
    onThemeChange: {
        callback: "Result"
    },
    onPageNotFound: {
        callback: "Result"
    },
    onLazyLoadError: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onError: {
        callback: "string | ErrorEvent | Error"
    },
    onAudioInterruptionEnd: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onAudioInterruptionBegin: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onAppShow: {
        callback: "CallbackResult"
    },
    onAppHide: {
        callback: "CallbackResult"
    },
    offUnhandledRejection: {
        callback: "Result<T>"
    },
    offThemeChange: {
        callback: "Result"
    },
    offPageNotFound: {
        callback: "Result"
    },
    offLazyLoadError: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offError: {
        callback: "string | ErrorEvent | Error"
    },
    offAudioInterruptionEnd: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offAudioInterruptionBegin: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offAppShow: {
        callback: "CallbackResult"
    },
    offAppHide: {
        callback: "CallbackResult"
    },
    getLaunchOptionsSync: {
        object: "void",
        success: "void",
        "return": "LaunchOptions"
    },
    getEnterOptionsSync: {
        object: "void",
        success: "void",
        "return": "EnterOptions"
    },
    createOffscreenCanvas: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    createCanvasContext: {
        object: "string",
        success: "void",
        "return": "CanvasContext"
    },
    canvasToTempFilePath: {
        object: "Option",
        success: "void",
        "return": "Promise<SuccessCallbackResult>"
    },
    canvasPutImageData: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    canvasGetImageData: {
        object: "Option",
        success: "void",
        "return": "Promise<SuccessCallbackResult>"
    },
    reportMonitor: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    reportAnalytics: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    reportEvent: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getExptInfoSync: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    stopAccelerometer: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    startAccelerometer: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    onAccelerometerChange: {
        callback: "Result"
    },
    offAccelerometerChange: {
        callback: "Result"
    },
    checkIsOpenAccessibility: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getBatteryInfoSync: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getBatteryInfo: {
        object: "Option",
        success: "void",
        "return": "Promise<SuccessCallbackResult>"
    },
    stopBluetoothDevicesDiscovery: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    startBluetoothDevicesDiscovery: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    openBluetoothAdapter: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onBluetoothDeviceFound: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onBluetoothAdapterStateChange: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offBluetoothDeviceFound: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offBluetoothAdapterStateChange: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    makeBluetoothPair: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    isBluetoothDevicePaired: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getConnectedBluetoothDevices: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getBluetoothDevices: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getBluetoothAdapterState: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    closeBluetoothAdapter: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    writeBLECharacteristicValue: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    setBLEMTU: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    readBLECharacteristicValue: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onBLEMTUChange: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onBLEConnectionStateChange: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onBLECharacteristicValueChange: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offBLEMTUChange: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offBLEConnectionStateChange: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offBLECharacteristicValueChange: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    notifyBLECharacteristicValueChange: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getBLEMTU: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getBLEDeviceServices: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getBLEDeviceRSSI: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getBLEDeviceCharacteristics: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    createBLEConnection: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    closeBLEConnection: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onBLEPeripheralConnectionStateChanged: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offBLEPeripheralConnectionStateChanged: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    createBLEPeripheralServer: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    addPhoneRepeatCalendar: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    addPhoneCalendar: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    setClipboardData: {
        object: "Option",
        success: "void",
        "return": "Promise<Promised>"
    },
    getClipboardData: {
        object: "Option",
        success: "void",
        "return": "Promise<Promised>"
    },
    stopCompass: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    startCompass: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    onCompassChange: {
        callback: "OnCompassChangeCallbackResult"
    },
    offCompassChange: {
        callback: "OnCompassChangeCallbackResult"
    },
    chooseContact: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    addPhoneContact: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getRandomValues: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    stopGyroscope: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    startGyroscope: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onGyroscopeChange: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offGyroscopeChange: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    stopBeaconDiscovery: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    startBeaconDiscovery: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onBeaconUpdate: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onBeaconServiceChange: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offBeaconUpdate: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offBeaconServiceChange: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getBeacons: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onKeyboardHeightChange: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offKeyboardHeightChange: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    hideKeyboard: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getSelectedTextRange: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onMemoryWarning: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offMemoryWarning: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    stopDeviceMotionListening: {
        object: "Option",
        success: "void"
    },
    startDeviceMotionListening: {
        object: "Option",
        success: "void"
    },
    onDeviceMotionChange: {
        callback: "CallbackResult"
    },
    offDeviceMotionChange: {
        callback: "CallbackResult"
    },
    getNetworkType: {
        object: "Option",
        success: "void",
        "return": "Promise<SuccessCallbackResult>"
    },
    onNetworkWeakChange: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onNetworkStatusChange: {
        callback: "CallbackResult"
    },
    offNetworkWeakChange: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offNetworkStatusChange: {
        callback: "CallbackResult"
    },
    getLocalIPAddress: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    stopHCE: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    startHCE: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    sendHCEMessage: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onHCEMessage: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offHCEMessage: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getNFCAdapter: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getHCEState: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    makePhoneCall: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    scanCode: {
        object: "Partial<{ needResult: number; }>",
        success: "void",
        "return": "Promise<any>"
    },
    setVisualEffectOnCapture: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    setScreenBrightness: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    setKeepScreenOn: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onUserCaptureScreen: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offUserCaptureScreen: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getScreenBrightness: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onScreenRecordingStateChanged: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offScreenRecordingStateChanged: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getScreenRecordingState: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    sendSms: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    vibrateShort: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    vibrateLong: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    stopWifi: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    startWifi: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    setWifiList: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onWifiConnectedWithPartialInfo: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onWifiConnected: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onGetWifiList: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offWifiConnectedWithPartialInfo: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offWifiConnected: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offGetWifiList: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getWifiList: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getConnectedWifi: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    connectWifi: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getExtConfigSync: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getExtConfig: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    saveFileToDisk: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    saveFile: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    removeSavedFile: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    openDocument: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getSavedFileList: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getSavedFileInfo: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getFileSystemManager: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getFileInfo: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getApp: {
        object: "*",
        success: "void",
        "return": "Instance<T>"
    },
    getCurrentInstance: {
        object: "void",
        success: "void",
        "return": "Current"
    },
    stopLocationUpdate: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    startLocationUpdateBackground: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    startLocationUpdate: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    openLocation: {
        object: "Partial<{ scale: number; }>",
        success: "void",
        "return": "Promise<any>"
    },
    onLocationChangeError: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onLocationChange: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offLocationChangeError: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offLocationChange: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getLocation: {
        object: "Partial<Option>",
        success: "void",
        "return": "Promise<SuccessCallbackResult>"
    },
    choosePoi: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getFuzzyLocation: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    chooseLocation: {
        object: "Option",
        success: "void",
        "return": "Promise<SuccessCallbackResult>"
    },
    stopVoice: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    setInnerAudioOption: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    playVoice: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    pauseVoice: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getAvailableAudioSources: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    createWebAudioContext: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    createMediaAudioPlayer: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    createInnerAudioContext: {
        object: "void",
        success: "void",
        "return": "InnerAudioContext"
    },
    createAudioContext: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    stopBackgroundAudio: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    seekBackgroundAudio: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    playBackgroundAudio: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    pauseBackgroundAudio: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onBackgroundAudioStop: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onBackgroundAudioPlay: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onBackgroundAudioPause: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getBackgroundAudioPlayerState: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getBackgroundAudioManager: {
        object: "void",
        success: "void",
        "return": "BackgroundAudioManager"
    },
    createCameraContext: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    saveImageToPhotosAlbum: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    previewMedia: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    getImageInfo: {
        object: "Option",
        success: "void",
        "return": "Promise<SuccessCallbackResult>"
    },
    previewImage: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    compressImage: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    chooseMessageFile: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    chooseImage: {
        object: "Option",
        success: "void",
        "return": "Promise<SuccessCallbackResult>"
    },
    editImage: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    cropImage: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    createLivePusherContext: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    createLivePlayerContext: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    createMapContext: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    createMediaRecorder: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    stopRecord: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    startRecord: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getRecorderManager: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    saveVideoToPhotosAlbum: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    openVideoEditor: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getVideoInfo: {
        object: "Option",
        success: "void",
        "return": "Promise<SuccessCallbackResult>"
    },
    createVideoContext: {
        object: "string",
        success: "void",
        "return": "VideoContext"
    },
    compressVideo: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    chooseMedia: {
        object: "Option",
        success: "void",
        "return": "Promise<SuccessCallbackResult>"
    },
    chooseVideo: {
        object: "Option",
        success: "void",
        "return": "Promise<SuccessCallbackResult>"
    },
    createVideoDecoder: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    createMediaContainer: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    updateVoIPChatMuteConfig: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    subscribeVoIPVideoMembers: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    setEnable1v1Chat: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onVoIPVideoMembersChanged: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onVoIPChatStateChanged: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onVoIPChatSpeakersChanged: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onVoIPChatMembersChanged: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onVoIPChatInterrupted: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offVoIPChatSpeakersChanged: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offVoIPVideoMembersChanged: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offVoIPChatStateChanged: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offVoIPChatMembersChanged: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offVoIPChatInterrupted: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    joinVoIPChat: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    join1v1Chat: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    exitVoIPChat: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    openEmbeddedMiniProgram: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    navigateToMiniProgram: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    navigateBackMiniProgram: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    exitMiniProgram: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    openBusinessView: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    downloadFile: {
        object: "Option",
        success: "void",
        "return": "DownloadTaskPromise"
    },
    stopLocalServiceDiscovery: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    startLocalServiceDiscovery: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onLocalServiceResolveFail: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onLocalServiceLost: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onLocalServiceFound: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onLocalServiceDiscoveryStop: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offLocalServiceResolveFail: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offLocalServiceLost: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offLocalServiceFound: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offLocalServiceDiscoveryStop: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    request: {
        object: "*",
        success: "void",
        "return": "RequestTask<T>"
    },
    addInterceptor: "*",
    cleanInterceptors: "*",
    createTCPSocket: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    createUDPSocket: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    uploadFile: {
        object: "Option",
        success: "void",
        "return": "UploadTaskPromise"
    },
    sendSocketMessage: "*",
    onSocketOpen: "*",
    onSocketMessage: "*",
    onSocketError: "*",
    onSocketClose: "*",
    connectSocket: "*",
    closeSocket: "*",
    getAccountInfoSync: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    chooseAddress: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    authorizeForMiniProgram: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    authorize: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    openCard: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    addCard: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    reserveChannelsLive: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    openChannelsUserProfile: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    openChannelsLive: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    openChannelsEvent: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    openChannelsActivity: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getChannelsShareKey: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getChannelsLiveNoticeInfo: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getChannelsLiveInfo: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    openCustomerServiceChat: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    requestDeviceVoIP: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getDeviceVoIPList: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    checkIsSupportFacialRecognition: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    startFacialRecognitionVerify: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    startFacialRecognitionVerifyAndUploadVideo: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    faceVerifyForPay: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    addVideoToFavorites: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    addFileToFavorites: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getGroupEnterInfo: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    chooseInvoiceTitle: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    chooseInvoice: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    chooseLicensePlate: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    pluginLogin: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    login: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    checkSession: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    checkIsAddedToMyMiniProgram: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    requirePrivacyAuthorize: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    openPrivacyContract: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onNeedPrivacyAuthorization: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getPrivacySetting: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    showRedPackage: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    openSetting: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getSetting: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    startSoterAuthentication: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    checkIsSupportSoterAuthentication: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    checkIsSoterEnrolledInDevice: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    requestSubscribeMessage: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    requestSubscribeDeviceMessage: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getUserProfile: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getUserInfo: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    shareToWeRun: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getWeRunData: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    requestPayment: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    requestPluginPayment: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    requestOrderPayment: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    openQzonePublish: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getQQRunData: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    setOfficialDress: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    setCustomDress: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    updateQQApp: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    addRecentColorSign: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getGuildInfo: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    applyAddToMyApps: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    isAddedToMyApps: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    updateShareMenu: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    showShareMenu: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    showShareImageMenu: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    shareVideoMessage: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    shareFileMessage: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onCopyUrl: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    offCopyUrl: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    hideShareMenu: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getShareInfo: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    authPrivateMessage: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    setStorageSync: {
        object: "string",
        success: "void"
    },
    setStorage: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    revokeBufferURL: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    removeStorageSync: {
        object: "string",
        success: "void"
    },
    removeStorage: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    getStorageSync: {
        object: "*",
        success: "void",
        "return": "*"
    },
    getStorageInfoSync: {
        object: "void",
        success: "void",
        "return": "Option"
    },
    getStorageInfo: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    getStorage: {
        object: "*",
        success: "void",
        "return": "Promise<SuccessCallbackResult<T>>"
    },
    createBufferURL: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    clearStorageSync: {
        object: "void",
        success: "void"
    },
    clearStorage: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    batchSetStorageSync: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    batchSetStorage: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    batchGetStorageSync: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    batchGetStorage: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    setBackgroundFetchToken: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onBackgroundFetchData: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getBackgroundFetchToken: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getBackgroundFetchData: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    createCacheManager: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    setPageInfo: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    ocrIdCard: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    ocrBankCard: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    ocrDrivingLicense: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    ocrVehicleLicense: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    textReview: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    textToAudio: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    imageAudit: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    advancedGeneralIdentify: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    objectDetectIdentify: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    carClassify: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    dishClassify: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    logoClassify: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    animalClassify: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    plantClassify: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getSwanId: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    requestPolymerPayment: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    navigateToSmartGameProgram: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    navigateToSmartProgram: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    navigateBackSmartProgram: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    preloadSubPackage: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    createAnimation: {
        object: "Option",
        success: "void",
        "return": "Animation"
    },
    setBackgroundTextStyle: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    setBackgroundColor: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    nextTick: {
        callback: "any[]"
    },
    loadFontFace: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    showToast: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    hideToast: {
        object: "Option",
        success: "void"
    },
    showLoading: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    hideLoading: {
        object: "Option",
        success: "void"
    },
    showModal: {
        object: "Option",
        success: "void",
        "return": "Promise<SuccessCallbackResult>"
    },
    showActionSheet: {
        object: "Option",
        success: "void",
        "return": "Promise<SuccessCallbackResult>"
    },
    enableAlertBeforeUnload: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    disableAlertBeforeUnload: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    getMenuButtonBoundingClientRect: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    showNavigationBarLoading: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    setNavigationBarTitle: "*",
    setNavigationBarColor: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    hideNavigationBarLoading: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    hideHomeButton: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    startPullDownRefresh: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    stopPullDownRefresh: {
        object: "Option",
        success: "void"
    },
    pageScrollTo: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    setTopBarText: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    initTabBarApis: "*",
    showTabBarRedDot: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    showTabBar: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    setTabBarStyle: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    setTabBarItem: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    setTabBarBadge: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    removeTabBarBadge: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    hideTabBarRedDot: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    hideTabBar: {
        object: "Option",
        success: "void",
        "return": "Promise<CallbackResult>"
    },
    setWindowSize: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    onWindowResize: {
        callback: "CallbackResult"
    },
    offWindowResize: {
        callback: "CallbackResult"
    },
    checkIsPictureInPictureActive: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    createWorker: {
        object: "*",
        success: "void",
        "return": "Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"
    },
    createSelectorQuery: {
        object: "void",
        success: "void",
        "return": "SelectorQuery"
    },
    createIntersectionObserver: {
        object: "*",
        success: "void",
        "return": "IntersectionObserver"
    },
    createMediaQueryObserver: {
        object: "void",
        success: "void",
        "return": "MediaQueryObserver"
    }
};
var components = {
    ad: {},
    "ad-custom": {},
    "animation-video": {},
    "animation-view": {},
    "ar-camera": {},
    audio: {
        autoplay: "boolean",
        controls: "boolean",
        loop: "boolean",
        muted: "boolean",
        nativeProps: "*",
        src: "string"
    },
    "aweme-data": {},
    block: {},
    button: {
        disabled: "boolean",
        formType: '"submit" | "reset"',
        hoverClass: "string",
        hoverStartTime: "number",
        hoverStayTime: "number",
        loading: "boolean",
        plain: "boolean",
        size: "string",
        type: "string"
    },
    camera: {},
    canvas: {
        canvasId: "string",
        height: "string",
        nativeProps: "*",
        width: "string"
    },
    "channel-live": {},
    "channel-video": {},
    checkbox: {
        checked: "boolean",
        color: "string",
        disabled: "boolean",
        id: "string",
        name: "string",
        nativeProps: "*",
        value: "string | number"
    },
    "checkbox-group": {
        name: "*"
    },
    "comment-detail": {},
    "comment-list": {},
    "contact-button": {},
    "cover-image": {
        nativeProps: "*",
        src: "string"
    },
    "cover-view": {
        animation: "string",
        hoverClass: "string",
        hoverStartTime: "number",
        hoverStayTime: "number"
    },
    "custom-wrapper": {},
    editor: {},
    "follow-swan": {},
    form: {},
    "functional-page-navigator": {},
    "grid-view": {},
    icon: {
        color: "string",
        size: "string | number",
        type: "Type"
    },
    image: {
        lazyLoad: "boolean",
        mode: "Mode",
        nativeProps: "*",
        src: "string"
    },
    "inline-payment-panel": {},
    input: {
        autoFocus: "boolean",
        confirmType: "string",
        disabled: "boolean",
        focus: "() => Promise<void>",
        maxlength: "number",
        name: "string",
        nativeProps: "*",
        password: "boolean",
        placeholder: "string",
        type: "string",
        value: "string"
    },
    "keyboard-accessory": {},
    label: {
        "for": "string"
    },
    lifestyle: {},
    like: {},
    "list-view": {},
    "live-player": {},
    "live-pusher": {},
    login: {},
    lottie: {},
    map: {},
    "match-media": {},
    "movable-area": {
        scaleArea: "boolean"
    },
    "movable-view": {
        animation: "boolean",
        damping: "number",
        direction: '"all" | "vertical" | "horizontal" | "none"',
        disabled: "boolean",
        endScale: "() => Promise<void>",
        friction: "number",
        inertia: "boolean",
        outOfBounds: "boolean",
        scale: "boolean",
        scaleMax: "number",
        scaleMin: "number",
        scaleValue: "number",
        setParent: "({ element, area }: { element: HTMLElement; area: { width: number; height: number; }; }) => Promise<void>",
        setScale: "(scale: number) => Promise<void>",
        x: "string | number",
        y: "string | number"
    },
    "native-slot": {},
    "navigation-bar": {},
    navigator: {
        delta: "number",
        hoverClass: "string",
        isHover: "boolean",
        openType: "string",
        url: "string"
    },
    "official-account": {},
    "open-data": {},
    "page-container": {},
    "page-meta": {},
    picker: {
        disabled: "boolean",
        end: "string",
        fields: "Fields",
        mode: "Mode",
        name: "string",
        range: "any[]",
        rangeKey: "string",
        start: "string",
        textProps: "PickerText",
        value: "PickerValue"
    },
    "picker-view-column": {
        col: "string",
        initialPosition: "string",
        paddingVertical: "number"
    },
    "picker-view": {
        indicatorClass: "string",
        indicatorStyle: "string",
        maskClass: "string",
        maskStyle: "string",
        value: "number[]"
    },
    progress: {
        active: "boolean",
        activeColor: "string",
        backgroundColor: "string",
        borderRadius: "string | number",
        fontSize: "string | number",
        percent: "number",
        showInfo: "boolean",
        strokeWidth: "string | number"
    },
    "pull-to-refresh": {
        damping: "number",
        distanceToRefresh: "number",
        indicator: "{ activate: string; deactivate: string; release: string; finish: string; }",
        prefixCls: "string"
    },
    radio: {
        checked: "boolean",
        disabled: "boolean",
        id: "string",
        name: "string",
        nativeProps: "*",
        value: "string"
    },
    "radio-group": {
        name: "*"
    },
    "rich-text": {
        nodes: "Nodes",
        selectable: "boolean",
        space: "string | number | symbol",
        userSelect: "boolean"
    },
    "root-portal": {},
    "rtc-room": {},
    "rtc-room-item": {},
    "scroll-view": {
        animated: "boolean",
        lowerThreshold: "string | number",
        mpScrollIntoView: "string",
        mpScrollIntoViewAlignment: '"center" | "start" | "end" | "nearest"',
        mpScrollIntoViewMethod: "(selector: string) => Promise<void>",
        mpScrollLeft: "string | number",
        mpScrollToMethod: "(object: Option) => Promise<void>",
        mpScrollTop: "string | number",
        scrollX: "boolean",
        scrollY: "boolean",
        upperThreshold: "string | number"
    },
    "share-element": {},
    slider: {
        activeColor: "string",
        backgroundColor: "string",
        blockColor: "string",
        blockSize: "number",
        disabled: "boolean",
        max: "number",
        min: "number",
        name: "string",
        showValue: "boolean",
        step: "number",
        value: "number"
    },
    slot: {},
    snapshot: {},
    "sticky-header": {},
    "sticky-section": {},
    swiper: {
        autoplay: "boolean",
        circular: "boolean",
        current: "number",
        displayMultipleItems: "number",
        duration: "number",
        full: "boolean",
        indicatorActiveColor: "string",
        indicatorColor: "string",
        indicatorDots: "boolean",
        interval: "number",
        nextMargin: "string",
        previousMargin: "string",
        vertical: "boolean",
        zoom: "boolean"
    },
    "swiper-item": {
        deep: "boolean",
        itemId: "string"
    },
    "switch": {
        checked: "boolean",
        color: "string",
        disabled: "boolean",
        name: "string",
        nativeProps: "*",
        type: "string"
    },
    "tab-item": {},
    tabs: {},
    text: {
        numberOfLines: "number",
        selectable: "boolean",
        space: "string | number | symbol",
        userSelect: "boolean"
    },
    textarea: {
        autoFocus: "boolean",
        autoHeight: "boolean",
        disabled: "boolean",
        focus: "() => Promise<void>",
        maxlength: "number",
        name: "string",
        nativeProps: "*",
        placeholder: "string",
        value: "string"
    },
    video: {
        autoplay: "boolean",
        controls: "boolean",
        danmuBtn: "boolean",
        danmuList: "[]",
        duration: "number",
        enableDanmu: "boolean",
        enablePlayGesture: "boolean",
        enableProgressGesture: "boolean",
        exitFullScreen: "() => Promise<void>",
        getHlsObject: "() => Promise<HLS>",
        initialTime: "number",
        loop: "boolean",
        muted: "boolean",
        nativeProps: "*",
        objectFit: '"contain" | "fill" | "cover"',
        pause: "() => Promise<void>",
        play: "() => Promise<void>",
        poster: "string",
        requestFullScreen: "() => Promise<void>",
        seek: "(position: number) => Promise<void>",
        showCenterPlayBtn: "boolean",
        showFullscreenBtn: "boolean",
        showMuteBtn: "boolean",
        showPlayBtn: "boolean",
        showProgress: "boolean",
        src: "string",
        stop: "() => Promise<void>",
        vslideGesture: "boolean",
        vslideGestureInFullscreen: "boolean"
    },
    view: {
        animation: "string",
        hoverClass: "string",
        hoverStartTime: "number",
        hoverStayTime: "number"
    },
    "voip-room": {},
    "web-view": {
        src: "string"
    }
};
var definition = {
    apis,
    components
};
// node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
}
var listCacheClear_default = listCacheClear;
// node_modules/lodash-es/eq.js
function eq(value, other) {
    return value === other || value !== value && other !== other;
}
var eq_default = eq;
// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array2, key) {
    var length = array2.length;
    while(length--){
        if (eq_default(array2[length][0], key)) {
            return length;
        }
    }
    return -1;
}
var assocIndexOf_default = assocIndexOf;
// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
    var data = this.__data__, index2 = assocIndexOf_default(data, key);
    if (index2 < 0) {
        return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
        data.pop();
    } else {
        splice.call(data, index2, 1);
    }
    --this.size;
    return true;
}
var listCacheDelete_default = listCacheDelete;
// node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
    var data = this.__data__, index2 = assocIndexOf_default(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
}
var listCacheGet_default = listCacheGet;
// node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
    return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;
// node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
    var data = this.__data__, index2 = assocIndexOf_default(data, key);
    if (index2 < 0) {
        ++this.size;
        data.push([
            key,
            value
        ]);
    } else {
        data[index2][1] = value;
    }
    return this;
}
var listCacheSet_default = listCacheSet;
// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index2 < length){
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
    }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;
// node_modules/lodash-es/_stackClear.js
function stackClear() {
    this.__data__ = new ListCache_default();
    this.size = 0;
}
var stackClear_default = stackClear;
// node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
}
var stackDelete_default = stackDelete;
// node_modules/lodash-es/_stackGet.js
function stackGet(key) {
    return this.__data__.get(key);
}
var stackGet_default = stackGet;
// node_modules/lodash-es/_stackHas.js
function stackHas(key) {
    return this.__data__.has(key);
}
var stackHas_default = stackHas;
// node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;
// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;
// node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;
// node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty2 = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
    try {
        value[symToStringTag] = void 0;
        var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) {
            value[symToStringTag] = tag;
        } else {
            delete value[symToStringTag];
        }
    }
    return result;
}
var getRawTag_default = getRawTag;
// node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
    return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;
// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
    if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;
// node_modules/lodash-es/isObject.js
function isObject2(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject2;
// node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction2(value) {
    if (!isObject_default(value)) {
        return false;
    }
    var tag = baseGetTag_default(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction2;
// node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;
// node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;
// node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + "";
        } catch (e) {}
    }
    return "";
}
var toSource_default = toSource;
// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty3 = objectProto3.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString2.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
    if (!isObject_default(value) || isMasked_default(value)) {
        return false;
    }
    var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;
// node_modules/lodash-es/_getValue.js
function getValue2(object2, key) {
    return object2 == null ? void 0 : object2[key];
}
var getValue_default = getValue2;
// node_modules/lodash-es/_getNative.js
function getNative(object2, key) {
    var value = getValue_default(object2, key);
    return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;
// node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;
// node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;
// node_modules/lodash-es/_hashClear.js
function hashClear() {
    this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
    this.size = 0;
}
var hashClear_default = hashClear;
// node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
}
var hashDelete_default = hashDelete;
// node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto4 = Object.prototype;
var hasOwnProperty4 = objectProto4.hasOwnProperty;
function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate_default) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty4.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;
// node_modules/lodash-es/_hashHas.js
var objectProto5 = Object.prototype;
var hasOwnProperty5 = objectProto5.hasOwnProperty;
function hashHas(key) {
    var data = this.__data__;
    return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty5.call(data, key);
}
var hashHas_default = hashHas;
// node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
}
var hashSet_default = hashSet;
// node_modules/lodash-es/_Hash.js
function Hash(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index2 < length){
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
    }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;
// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
        "hash": new Hash_default(),
        "map": new (Map_default || ListCache_default)(),
        "string": new Hash_default()
    };
}
var mapCacheClear_default = mapCacheClear;
// node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;
// node_modules/lodash-es/_getMapData.js
function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;
// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
    var result = getMapData_default(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
}
var mapCacheDelete_default = mapCacheDelete;
// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
    return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;
// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
    return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;
// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
    var data = getMapData_default(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
}
var mapCacheSet_default = mapCacheSet;
// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index2 < length){
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
    }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;
// node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache_default) {
        var pairs = data.__data__;
        if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            this.size = ++data.size;
            return this;
        }
        data = this.__data__ = new MapCache_default(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
}
var stackSet_default = stackSet;
// node_modules/lodash-es/_Stack.js
function Stack(entries) {
    var data = this.__data__ = new ListCache_default(entries);
    this.size = data.size;
}
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;
// node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED3);
    return this;
}
var setCacheAdd_default = setCacheAdd;
// node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value) {
    return this.__data__.has(value);
}
var setCacheHas_default = setCacheHas;
// node_modules/lodash-es/_SetCache.js
function SetCache(values) {
    var index2 = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache_default();
    while(++index2 < length){
        this.add(values[index2]);
    }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;
// node_modules/lodash-es/_arraySome.js
function arraySome(array2, predicate) {
    var index2 = -1, length = array2 == null ? 0 : array2.length;
    while(++index2 < length){
        if (predicate(array2[index2], index2, array2)) {
            return true;
        }
    }
    return false;
}
var arraySome_default = arraySome;
// node_modules/lodash-es/_cacheHas.js
function cacheHas(cache2, key) {
    return cache2.has(key);
}
var cacheHas_default = cacheHas;
// node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
    }
    var arrStacked = stack.get(array2);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
    }
    var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
    stack.set(array2, other);
    stack.set(other, array2);
    while(++index2 < arrLength){
        var arrValue = array2[index2], othValue = other[index2];
        if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
        }
        if (compared !== void 0) {
            if (compared) {
                continue;
            }
            result = false;
            break;
        }
        if (seen) {
            if (!arraySome_default(other, function(othValue2, othIndex) {
                if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                }
            })) {
                result = false;
                break;
            }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
        }
    }
    stack["delete"](array2);
    stack["delete"](other);
    return result;
}
var equalArrays_default = equalArrays;
// node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;
// node_modules/lodash-es/_mapToArray.js
function mapToArray(map) {
    var index2 = -1, result = Array(map.size);
    map.forEach(function(value, key) {
        result[++index2] = [
            key,
            value
        ];
    });
    return result;
}
var mapToArray_default = mapToArray;
// node_modules/lodash-es/_setToArray.js
function setToArray(set3) {
    var index2 = -1, result = Array(set3.size);
    set3.forEach(function(value) {
        result[++index2] = value;
    });
    return result;
}
var setToArray_default = setToArray;
// node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
    switch(tag){
        case dataViewTag:
            if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
                return false;
            }
            object2 = object2.buffer;
            other = other.buffer;
        case arrayBufferTag:
            if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object2), new Uint8Array_default(other))) {
                return false;
            }
            return true;
        case boolTag:
        case dateTag:
        case numberTag:
            return eq_default(+object2, +other);
        case errorTag:
            return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
            return object2 == other + "";
        case mapTag:
            var convert = mapToArray_default;
        case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
            convert || (convert = setToArray_default);
            if (object2.size != other.size && !isPartial) {
                return false;
            }
            var stacked = stack.get(object2);
            if (stacked) {
                return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG2;
            stack.set(object2, other);
            var result = equalArrays_default(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object2);
            return result;
        case symbolTag:
            if (symbolValueOf) {
                return symbolValueOf.call(object2) == symbolValueOf.call(other);
            }
    }
    return false;
}
var equalByTag_default = equalByTag;
// node_modules/lodash-es/_arrayPush.js
function arrayPush(array2, values) {
    var index2 = -1, length = values.length, offset2 = array2.length;
    while(++index2 < length){
        array2[offset2 + index2] = values[index2];
    }
    return array2;
}
var arrayPush_default = arrayPush;
// node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;
// node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
    var result = keysFunc(object2);
    return isArray_default(object2) ? result : arrayPush_default(result, symbolsFunc(object2));
}
var baseGetAllKeys_default = baseGetAllKeys;
// node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array2, predicate) {
    var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
    while(++index2 < length){
        var value = array2[index2];
        if (predicate(value, index2, array2)) {
            result[resIndex++] = value;
        }
    }
    return result;
}
var arrayFilter_default = arrayFilter;
// node_modules/lodash-es/stubArray.js
function stubArray() {
    return [];
}
var stubArray_default = stubArray;
// node_modules/lodash-es/_getSymbols.js
var objectProto6 = Object.prototype;
var propertyIsEnumerable = objectProto6.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object2) {
    if (object2 == null) {
        return [];
    }
    object2 = Object(object2);
    return arrayFilter_default(nativeGetSymbols(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
    });
};
var getSymbols_default = getSymbols;
// node_modules/lodash-es/_baseTimes.js
function baseTimes(n, iteratee) {
    var index2 = -1, result = Array(n);
    while(++index2 < n){
        result[index2] = iteratee(index2);
    }
    return result;
}
var baseTimes_default = baseTimes;
// node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
    return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;
// node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
    return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;
// node_modules/lodash-es/isArguments.js
var objectProto7 = Object.prototype;
var hasOwnProperty6 = objectProto7.hasOwnProperty;
var propertyIsEnumerable2 = objectProto7.propertyIsEnumerable;
var isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
    return arguments;
}()) ? baseIsArguments_default : function(value) {
    return isObjectLike_default(value) && hasOwnProperty6.call(value, "callee") && !propertyIsEnumerable2.call(value, "callee");
};
var isArguments_default = isArguments;
// node_modules/lodash-es/stubFalse.js
function stubFalse() {
    return false;
}
var stubFalse_default = stubFalse;
// node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;
// node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
var isIndex_default = isIndex;
// node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;
// node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var errorTag2 = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag2 = "[object Map]";
var numberTag2 = "[object Number]";
var objectTag = "[object Object]";
var regexpTag2 = "[object RegExp]";
var setTag2 = "[object Set]";
var stringTag2 = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag2 = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag2] = typedArrayTags[boolTag2] = typedArrayTags[dataViewTag2] = typedArrayTags[dateTag2] = typedArrayTags[errorTag2] = typedArrayTags[funcTag2] = typedArrayTags[mapTag2] = typedArrayTags[numberTag2] = typedArrayTags[objectTag] = typedArrayTags[regexpTag2] = typedArrayTags[setTag2] = typedArrayTags[stringTag2] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
    return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;
// node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
    return function(value) {
        return func(value);
    };
}
var baseUnary_default = baseUnary;
// node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
    try {
        var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
        if (types) {
            return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {}
}();
var nodeUtil_default = nodeUtil;
// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;
// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto8 = Object.prototype;
var hasOwnProperty7 = objectProto8.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
    var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
    for(var key in value){
        if ((inherited || hasOwnProperty7.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex_default(key, length)))) {
            result.push(key);
        }
    }
    return result;
}
var arrayLikeKeys_default = arrayLikeKeys;
// node_modules/lodash-es/_isPrototype.js
var objectProto9 = Object.prototype;
function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto9;
    return value === proto;
}
var isPrototype_default = isPrototype;
// node_modules/lodash-es/_overArg.js
function overArg(func, transform2) {
    return function(arg) {
        return func(transform2(arg));
    };
}
var overArg_default = overArg;
// node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;
// node_modules/lodash-es/_baseKeys.js
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function baseKeys(object2) {
    if (!isPrototype_default(object2)) {
        return nativeKeys_default(object2);
    }
    var result = [];
    for(var key in Object(object2)){
        if (hasOwnProperty8.call(object2, key) && key != "constructor") {
            result.push(key);
        }
    }
    return result;
}
var baseKeys_default = baseKeys;
// node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
    return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;
// node_modules/lodash-es/keys.js
function keys(object2) {
    return isArrayLike_default(object2) ? arrayLikeKeys_default(object2) : baseKeys_default(object2);
}
var keys_default = keys;
// node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object2) {
    return baseGetAllKeys_default(object2, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys;
// node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto11 = Object.prototype;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object2), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
        return false;
    }
    var index2 = objLength;
    while(index2--){
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty9.call(other, key))) {
            return false;
        }
    }
    var objStacked = stack.get(object2);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
        return objStacked == other && othStacked == object2;
    }
    var result = true;
    stack.set(object2, other);
    stack.set(other, object2);
    var skipCtor = isPartial;
    while(++index2 < objLength){
        key = objProps[index2];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
        }
        skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && "constructor" in object2 && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
        }
    }
    stack["delete"](object2);
    stack["delete"](other);
    return result;
}
var equalObjects_default = equalObjects;
// node_modules/lodash-es/_DataView.js
var DataView2 = getNative_default(root_default, "DataView");
var DataView_default = DataView2;
// node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;
// node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;
// node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap2;
// node_modules/lodash-es/_getTag.js
var mapTag3 = "[object Map]";
var objectTag2 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag3 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag3 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag3 || Map_default && getTag(new Map_default()) != mapTag3 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag3 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
    getTag = function(value) {
        var result = baseGetTag_default(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
        if (ctorString) {
            switch(ctorString){
                case dataViewCtorString:
                    return dataViewTag3;
                case mapCtorString:
                    return mapTag3;
                case promiseCtorString:
                    return promiseTag;
                case setCtorString:
                    return setTag3;
                case weakMapCtorString:
                    return weakMapTag2;
            }
        }
        return result;
    };
}
var getTag_default = getTag;
// node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var objectTag3 = "[object Object]";
var objectProto12 = Object.prototype;
var hasOwnProperty10 = objectProto12.hasOwnProperty;
function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray_default(object2), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag2 : getTag_default(object2), othTag = othIsArr ? arrayTag2 : getTag_default(other);
    objTag = objTag == argsTag3 ? objectTag3 : objTag;
    othTag = othTag == argsTag3 ? objectTag3 : othTag;
    var objIsObj = objTag == objectTag3, othIsObj = othTag == objectTag3, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer_default(object2)) {
        if (!isBuffer_default(other)) {
            return false;
        }
        objIsArr = true;
        objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
        stack || (stack = new Stack_default());
        return objIsArr || isTypedArray_default(object2) ? equalArrays_default(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object2, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
        var objIsWrapped = objIsObj && hasOwnProperty10.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty10.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack_default());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
    }
    if (!isSameTag) {
        return false;
    }
    stack || (stack = new Stack_default());
    return equalObjects_default(object2, other, bitmask, customizer, equalFunc, stack);
}
var baseIsEqualDeep_default = baseIsEqualDeep;
// node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
        return true;
    }
    if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
        return value !== value && other !== other;
    }
    return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
}
var baseIsEqual_default = baseIsEqual;
// node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object2, source, matchData, customizer) {
    var index2 = matchData.length, length = index2, noCustomizer = !customizer;
    if (object2 == null) {
        return !length;
    }
    object2 = Object(object2);
    while(index2--){
        var data = matchData[index2];
        if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
            return false;
        }
    }
    while(++index2 < length){
        data = matchData[index2];
        var key = data[0], objValue = object2[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
            if (objValue === void 0 && !(key in object2)) {
                return false;
            }
        } else {
            var stack = new Stack_default();
            if (customizer) {
                var result = customizer(objValue, srcValue, key, object2, source, stack);
            }
            if (!(result === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result)) {
                return false;
            }
        }
    }
    return true;
}
var baseIsMatch_default = baseIsMatch;
// node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value) {
    return value === value && !isObject_default(value);
}
var isStrictComparable_default = isStrictComparable;
// node_modules/lodash-es/_getMatchData.js
function getMatchData(object2) {
    var result = keys_default(object2), length = result.length;
    while(length--){
        var key = result[length], value = object2[key];
        result[length] = [
            key,
            value,
            isStrictComparable_default(value)
        ];
    }
    return result;
}
var getMatchData_default = getMatchData;
// node_modules/lodash-es/isMatchWith.js
function isMatchWith(object2, source, customizer) {
    customizer = typeof customizer == "function" ? customizer : void 0;
    return baseIsMatch_default(object2, source, getMatchData_default(source), customizer);
}
var isMatchWith_default = isMatchWith;
// node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
    try {
        var func = getNative_default(Object, "defineProperty");
        func({}, "", {});
        return func;
    } catch (e) {}
}();
var defineProperty_default = defineProperty;
// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object2, key, value) {
    if (key == "__proto__" && defineProperty_default) {
        defineProperty_default(object2, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
        });
    } else {
        object2[key] = value;
    }
}
var baseAssignValue_default = baseAssignValue;
// node_modules/lodash-es/_assignValue.js
var objectProto13 = Object.prototype;
var hasOwnProperty11 = objectProto13.hasOwnProperty;
function assignValue(object2, key, value) {
    var objValue = object2[key];
    if (!(hasOwnProperty11.call(object2, key) && eq_default(objValue, value)) || value === void 0 && !(key in object2)) {
        baseAssignValue_default(object2, key, value);
    }
}
var assignValue_default = assignValue;
// node_modules/lodash-es/isSymbol.js
var symbolTag2 = "[object Symbol]";
function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag2;
}
var isSymbol_default = isSymbol;
// node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object2) {
    if (isArray_default(value)) {
        return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
        return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
}
var isKey_default = isKey;
// node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key)) {
            return cache2.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache2.set(key, result) || cache2;
        return result;
    };
    memoized.cache = new (memoize.Cache || MapCache_default)();
    return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;
// node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
    var result = memoize_default(func, function(key) {
        if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
        }
        return key;
    });
    var cache2 = result.cache;
    return result;
}
var memoizeCapped_default = memoizeCapped;
// node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string2) {
    var result = [];
    if (string2.charCodeAt(0) === 46) {
        result.push("");
    }
    string2.replace(rePropName, function(match, number2, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
    });
    return result;
});
var stringToPath_default = stringToPath;
// node_modules/lodash-es/_arrayMap.js
function arrayMap(array2, iteratee) {
    var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
    while(++index2 < length){
        result[index2] = iteratee(array2[index2], index2, array2);
    }
    return result;
}
var arrayMap_default = arrayMap;
// node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto2 ? symbolProto2.toString : void 0;
function baseToString(value) {
    if (typeof value == "string") {
        return value;
    }
    if (isArray_default(value)) {
        return arrayMap_default(value, baseToString) + "";
    }
    if (isSymbol_default(value)) {
        return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var baseToString_default = baseToString;
// node_modules/lodash-es/toString.js
function toString(value) {
    return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;
// node_modules/lodash-es/_castPath.js
function castPath(value, object2) {
    if (isArray_default(value)) {
        return value;
    }
    return isKey_default(value, object2) ? [
        value
    ] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;
// node_modules/lodash-es/_toKey.js
var INFINITY2 = 1 / 0;
function toKey(value) {
    if (typeof value == "string" || isSymbol_default(value)) {
        return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
}
var toKey_default = toKey;
// node_modules/lodash-es/_baseSet.js
function baseSet(object2, path, value, customizer) {
    if (!isObject_default(object2)) {
        return object2;
    }
    path = castPath_default(path, object2);
    var index2 = -1, length = path.length, lastIndex = length - 1, nested = object2;
    while(nested != null && ++index2 < length){
        var key = toKey_default(path[index2]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object2;
        }
        if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : void 0;
            if (newValue === void 0) {
                newValue = isObject_default(objValue) ? objValue : isIndex_default(path[index2 + 1]) ? [] : {};
            }
        }
        assignValue_default(nested, key, newValue);
        nested = nested[key];
    }
    return object2;
}
var baseSet_default = baseSet;
// node_modules/lodash-es/set.js
function set(object2, path, value) {
    return object2 == null ? object2 : baseSet_default(object2, path, value);
}
var set_default = set;
// node_modules/@tarojs/api/dist/index.esm.js
var ENV_TYPE = {
    WEAPP: "WEAPP",
    SWAN: "SWAN",
    ALIPAY: "ALIPAY",
    TT: "TT",
    QQ: "QQ",
    JD: "JD",
    WEB: "WEB",
    RN: "RN",
    HARMONY: "HARMONY",
    QUICKAPP: "QUICKAPP",
    HARMONYHYBRID: "HARMONYHYBRID"
};
function getEnv() {
    if (false) {
        return ENV_TYPE.WEAPP;
    } else if (false) {
        return ENV_TYPE.ALIPAY;
    } else if (false) {
        return ENV_TYPE.SWAN;
    } else if (false) {
        return ENV_TYPE.TT;
    } else if (false) {
        return ENV_TYPE.JD;
    } else if (false) {
        return ENV_TYPE.QQ;
    } else if (false) {
        return ENV_TYPE.HARMONYHYBRID;
    } else if (true) {
        return ENV_TYPE.WEB;
    } else if (false) {
        return ENV_TYPE.RN;
    } else if (false) {
        return ENV_TYPE.HARMONY;
    } else if (false) {
        return ENV_TYPE.QUICKAPP;
    } else {
        return "h5";
    }
}
var Chain = class _Chain {
    proceed(requestParams = {}) {
        this.requestParams = requestParams;
        if (this.index >= this.interceptors.length) {
            throw new Error("chain \u53C2\u6570\u9519\u8BEF, \u8BF7\u52FF\u76F4\u63A5\u4FEE\u6539 request.chain");
        }
        const nextInterceptor = this._getNextInterceptor();
        const nextChain = this._getNextChain();
        const p = nextInterceptor(nextChain);
        const res = p.catch((err)=>Promise.reject(err));
        Object.keys(p).forEach((k)=>isFunction(p[k]) && (res[k] = p[k]));
        return res;
    }
    _getNextInterceptor() {
        return this.interceptors[this.index];
    }
    _getNextChain() {
        return new _Chain(this.requestParams, this.interceptors, this.index + 1);
    }
    constructor(requestParams, interceptors3, index2){
        this.index = index2 || 0;
        this.requestParams = requestParams || {};
        this.interceptors = interceptors3 || [];
    }
};
var Link = class {
    request(requestParams) {
        const chain = this.chain;
        const taroInterceptor2 = this.taroInterceptor;
        chain.interceptors = chain.interceptors.filter((interceptor)=>interceptor !== taroInterceptor2).concat(taroInterceptor2);
        return chain.proceed(Object.assign({}, requestParams));
    }
    addInterceptor(interceptor) {
        this.chain.interceptors.push(interceptor);
    }
    cleanInterceptors() {
        this.chain = new Chain();
    }
    constructor(interceptor){
        this.taroInterceptor = interceptor;
        this.chain = new Chain();
    }
};
function interceptorify(promiseifyApi) {
    return new Link(function(chain) {
        return promiseifyApi(chain.requestParams);
    });
}
function timeoutInterceptor(chain) {
    const requestParams = chain.requestParams;
    let p;
    const res = new Promise((resolve, reject)=>{
        const timeout = setTimeout(()=>{
            clearTimeout(timeout);
            reject(new Error("\u7F51\u7EDC\u94FE\u63A5\u8D85\u65F6,\u8BF7\u7A0D\u540E\u518D\u8BD5\uFF01"));
        }, requestParams && requestParams.timeout || 6e4);
        p = chain.proceed(requestParams);
        p.then((res2)=>{
            if (!timeout) return;
            clearTimeout(timeout);
            resolve(res2);
        }).catch((err)=>{
            timeout && clearTimeout(timeout);
            reject(err);
        });
    });
    if (!isUndefined(p) && isFunction(p.abort)) res.abort = p.abort;
    return res;
}
function logInterceptor(chain) {
    const requestParams = chain.requestParams;
    const { method, data, url } = requestParams;
    console.log(`http ${method || "GET"} --> ${url} data: `, data);
    const p = chain.proceed(requestParams);
    const res = p.then((res2)=>{
        console.log(`http <-- ${url} result:`, res2);
        return res2;
    });
    if (isFunction(p.abort)) res.abort = p.abort;
    return res;
}
var interceptors = Object.freeze({
    __proto__: null,
    logInterceptor,
    timeoutInterceptor
});
function Behavior(options3) {
    return options3;
}
function getPreload(current) {
    return function(key, val) {
        current.preloadData = isObject(key) ? key : {
            [key]: val
        };
    };
}
var defaultDesignWidth = 750;
var defaultDesignRatio = {
    640: 2.34 / 2,
    750: 1,
    828: 1.81 / 2
};
var defaultBaseFontSize = 20;
var defaultUnitPrecision = 5;
var defaultTargetUnit = "rpx";
function getInitPxTransform(taro2) {
    return function(config) {
        const { designWidth = defaultDesignWidth, deviceRatio = defaultDesignRatio, baseFontSize = defaultBaseFontSize, targetUnit = defaultTargetUnit, unitPrecision = defaultUnitPrecision } = config;
        taro2.config = taro2.config || {};
        taro2.config.designWidth = designWidth;
        taro2.config.deviceRatio = deviceRatio;
        taro2.config.baseFontSize = baseFontSize;
        taro2.config.targetUnit = targetUnit;
        taro2.config.unitPrecision = unitPrecision;
    };
}
function getPxTransform(taro2) {
    return function(size) {
        const config = taro2.config || {};
        const baseFontSize = config.baseFontSize;
        const deviceRatio = config.deviceRatio || defaultDesignRatio;
        const designWidth = ((input = 0)=>isFunction(config.designWidth) ? config.designWidth(input) : config.designWidth || defaultDesignWidth)(size);
        if (!(designWidth in deviceRatio)) {
            throw new Error(`deviceRatio \u914D\u7F6E\u4E2D\u4E0D\u5B58\u5728 ${designWidth} \u7684\u8BBE\u7F6E\uFF01`);
        }
        const targetUnit = config.targetUnit || defaultTargetUnit;
        const unitPrecision = config.unitPrecision || defaultUnitPrecision;
        const formatSize = ~~size;
        let rootValue = 1 / deviceRatio[designWidth];
        switch(targetUnit){
            case "rem":
                rootValue *= baseFontSize * 2;
                break;
            case "px":
                rootValue *= 2;
                break;
        }
        let val = formatSize / rootValue;
        if (unitPrecision >= 0 && unitPrecision <= 100) {
            val = Number(val.toFixed(unitPrecision));
        }
        return val + targetUnit;
    };
}
var Taro = {
    Behavior,
    getEnv,
    ENV_TYPE,
    Link,
    interceptors,
    Current,
    getCurrentInstance,
    options,
    nextTick,
    eventCenter,
    Events,
    getInitPxTransform,
    interceptorify
};
Taro.initPxTransform = getInitPxTransform(Taro);
Taro.preload = getPreload(Current);
Taro.pxTransform = getPxTransform(Taro);
// node_modules/@tarojs/taro-h5/dist/utils/handler.js
var MethodHandler = class {
    success(res = {}, promise = {}) {
        if (!res.errMsg) {
            res.errMsg = `${this.methodName}:ok`;
        }
        isFunction(this.__success) && this.__success(res);
        isFunction(this.__complete) && this.__complete(res);
        const { resolve = Promise.resolve.bind(Promise) } = promise;
        return resolve(res);
    }
    fail(res = {}, promise = {}) {
        if (!res.errMsg) {
            res.errMsg = `${this.methodName}:fail`;
        } else {
            res.errMsg = `${this.methodName}:fail ${res.errMsg}`;
        }
        isFunction(this.__fail) && this.__fail(res);
        isFunction(this.__complete) && this.__complete(res);
        const { resolve = Promise.resolve.bind(Promise), reject = Promise.reject.bind(Promise) } = promise;
        return this.isHandlerError ? resolve(res) : reject(res);
    }
    constructor({ name, success, fail, complete }){
        this.isHandlerError = false;
        this.methodName = name;
        this.__success = success;
        this.__fail = fail;
        this.__complete = complete;
        this.isHandlerError = isFunction(this.__complete) || isFunction(this.__fail);
    }
};
var CallbackManager = class {
    constructor(){
        this.callbacks = [];
        this.add = (opt)=>{
            if (opt) this.callbacks.push(opt);
        };
        this.remove = (opt)=>{
            if (opt) {
                let pos = -1;
                this.callbacks.forEach((callback, k)=>{
                    if (callback === opt) {
                        pos = k;
                    }
                });
                if (pos > -1) {
                    this.callbacks.splice(pos, 1);
                }
            }
        };
        this.count = ()=>{
            return this.callbacks.length;
        };
        this.trigger = (...args)=>{
            this.callbacks.forEach((opt)=>{
                if (isFunction(opt)) {
                    opt(...args);
                } else {
                    const { callback, ctx } = opt;
                    isFunction(callback) && callback.call(ctx, ...args);
                }
            });
        };
    }
};
// node_modules/@tarojs/taro-h5/dist/utils/animation.js
var easeInOut = (t)=>t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
var getTimingFunc = (easeFunc, frameCnt)=>{
    return (x)=>{
        if (frameCnt <= 1) {
            return easeFunc(1);
        }
        const t = x / (frameCnt - 1);
        return easeFunc(t);
    };
};
// node_modules/@tarojs/taro-h5/dist/utils/helper.js
function createDownload(url = "", download = "") {
    const link2 = document.createElement("a");
    link2.style.display = "none";
    link2.href = url;
    link2.download = download;
    link2.click();
}
// node_modules/@tarojs/taro-h5/dist/utils/valid.js
var VALID_COLOR_REG = /^#[0-9a-fA-F]{6}$/;
var isValidColor = (color)=>{
    return VALID_COLOR_REG.test(color);
};
// node_modules/@tarojs/taro-h5/dist/utils/index.js
function shouldBeObject(target) {
    if (target && typeof target === "object") return {
        flag: true
    };
    return {
        flag: false,
        msg: getParameterError({
            correct: "Object",
            wrong: target
        })
    };
}
function findDOM(inst) {
    if (inst && hooks.isExist("getDOMNode")) {
        return hooks.call("getDOMNode", inst);
    }
    const page = Current.page;
    const path = page === null || page === void 0 ? void 0 : page.path;
    const msg = "\u6CA1\u6709\u627E\u5230\u5DF2\u7ECF\u52A0\u8F7D\u4E86\u7684\u9875\u9762\uFF0C\u8BF7\u5728\u9875\u9762\u52A0\u8F7D\u5B8C\u6210\u540E\u65F6\u5019\u6B64 API\u3002";
    if (path == null) {
        throw new Error(msg);
    }
    const el = document.getElementById(path);
    if (el == null) {
        throw new Error("\u5728\u5DF2\u52A0\u8F7D\u9875\u9762\u4E2D\u6CA1\u6709\u627E\u5230\u5BF9\u5E94\u7684\u5BB9\u5668\u5143\u7D20\u3002");
    }
    return el;
}
function getParameterError({ name = "", para, correct, wrong, level = "error" }) {
    const parameter = para ? `parameter.${para}` : "parameter";
    const errorType = upperCaseFirstLetter(wrong === null ? "Null" : typeof wrong);
    return `${name ? `${name}:fail ` : ""}parameter ${level}: ${parameter} should be ${correct} instead of ${errorType}`;
}
function upperCaseFirstLetter(string2) {
    if (typeof string2 !== "string") return string2;
    string2 = string2.replace(/^./, (match)=>match.toUpperCase());
    return string2;
}
function inlineStyle(style) {
    let res = "";
    for(const attr2 in style)res += `${attr2}: ${style[attr2]};`;
    if (res.indexOf("display: flex;") >= 0) res += "display: -webkit-box;display: -webkit-flex;";
    res = res.replace(/transform:(.+?);/g, (s, $1)=>`${s}-webkit-transform:${$1};`);
    res = res.replace(/flex-direction:(.+?);/g, (s, $1)=>`${s}-webkit-flex-direction:${$1};`);
    return res;
}
function setTransform(el, val) {
    el.style.webkitTransform = val;
    el.style.transform = val;
}
function serializeParams(params) {
    if (!params) {
        return "";
    }
    return Object.keys(params).map((key)=>`${encodeURIComponent(key)}=${typeof params[key] === "object" ? encodeURIComponent(JSON.stringify(params[key])) : encodeURIComponent(params[key])}`).join("&");
}
function temporarilyNotSupport(name = "") {
    return (option = {}, ...args)=>{
        const { success, fail, complete } = option;
        const handle3 = new MethodHandler({
            name,
            success,
            fail,
            complete
        });
        const errMsg = "\u6682\u65F6\u4E0D\u652F\u6301 API";
        Taro.eventCenter.trigger("__taroNotSupport", {
            name,
            args: [
                option,
                ...args
            ],
            type: "method",
            category: "temporarily"
        });
        if (false) {
            console.warn(errMsg);
            return handle3.success({
                errMsg
            });
        } else {
            return handle3.fail({
                errMsg
            });
        }
    };
}
function weixinCorpSupport(name) {
    return (option = {}, ...args)=>{
        const { success, fail, complete } = option;
        const handle3 = new MethodHandler({
            name,
            success,
            fail,
            complete
        });
        const errMsg = "h5 \u7AEF\u5F53\u524D\u4EC5\u5728\u5FAE\u4FE1\u516C\u4F17\u53F7 JS-SDK \u73AF\u5883\u4E0B\u652F\u6301\u6B64 API";
        Taro.eventCenter.trigger("__taroNotSupport", {
            name,
            args: [
                option,
                ...args
            ],
            type: "method",
            category: "weixin_corp"
        });
        if (false) {
            console.warn(errMsg);
            return handle3.success({
                errMsg
            });
        } else {
            return handle3.fail({
                errMsg
            });
        }
    };
}
function permanentlyNotSupport(name = "") {
    return (option = {}, ...args)=>{
        const { success, fail, complete } = option;
        const handle3 = new MethodHandler({
            name,
            success,
            fail,
            complete
        });
        const errMsg = "\u4E0D\u652F\u6301 API";
        Taro.eventCenter.trigger("__taroNotSupport", {
            name,
            args: [
                option,
                ...args
            ],
            type: "method",
            category: "permanently"
        });
        if (false) {
            console.warn(errMsg);
            return handle3.success({
                errMsg
            });
        } else {
            return handle3.fail({
                errMsg
            });
        }
    };
}
function processOpenApi({ name, defaultOptions, standardMethod, formatOptions = (options3)=>options3, formatResult = (res)=>res }) {
    const notSupported = weixinCorpSupport(name);
    return (options3 = {}, ...args)=>{
        var _a;
        const targetApi = (_a = window === null || window === void 0 ? void 0 : window.wx) === null || _a === void 0 ? void 0 : _a[name];
        const opts = formatOptions(Object.assign({}, defaultOptions, options3));
        if (isFunction(targetApi)) {
            return new Promise((resolve, reject)=>{
                [
                    "fail",
                    "success",
                    "complete"
                ].forEach((k)=>{
                    opts[k] = (preRef)=>{
                        const res = formatResult(preRef);
                        options3[k] && options3[k](res);
                        if (k === "success") {
                            resolve(res);
                        } else if (k === "fail") {
                            reject(res);
                        }
                    };
                    return targetApi(opts);
                });
            });
        } else if (isFunction(standardMethod)) {
            return standardMethod(opts);
        } else {
            return notSupported(options3, ...args);
        }
    };
}
function getCurrentPath() {
    var _a, _b, _c, _d, _e, _f;
    const appConfig = window.__taroAppConfig || {};
    const routePath = getCurrentPage((_a = appConfig.router) === null || _a === void 0 ? void 0 : _a.mode, (_b = appConfig.router) === null || _b === void 0 ? void 0 : _b.basename);
    const homePath = getHomePage((_d = (_c = appConfig.routes) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.path, (_e = appConfig.router) === null || _e === void 0 ? void 0 : _e.basename, (_f = appConfig.router) === null || _f === void 0 ? void 0 : _f.customRoutes, appConfig.entryPagePath);
    return `${routePath === "/" ? homePath : routePath}?stamp=1`;
}
// node_modules/@tarojs/taro-h5/dist/api/ad/index.js
var createRewardedVideoAd = temporarilyNotSupport("createRewardedVideoAd");
var createInterstitialAd = temporarilyNotSupport("createInterstitialAd");
// node_modules/@tarojs/taro-h5/dist/api/ai/facial.js
var stopFaceDetect = temporarilyNotSupport("stopFaceDetect");
var initFaceDetect = temporarilyNotSupport("initFaceDetect");
var faceDetect = temporarilyNotSupport("faceDetect");
// node_modules/@tarojs/taro-h5/dist/api/ai/inference.js
var getInferenceEnvInfo = temporarilyNotSupport("getInferenceEnvInfo");
var createInferenceSession = temporarilyNotSupport("createInferenceSession");
// node_modules/@tarojs/taro-h5/dist/api/ai/visual.js
var isVKSupport = temporarilyNotSupport("isVKSupport");
var createVKSession = temporarilyNotSupport("createVKSession");
// node_modules/@tarojs/taro-h5/dist/api/alipay/index.js
var getOpenUserInfo = temporarilyNotSupport("getOpenUserInfo");
var tradePay = temporarilyNotSupport("tradePay");
// node_modules/@tarojs/taro-h5/dist/api/base/index.js
var import_base64_js = __toESM(require_base64_js());
// node_modules/@tarojs/taro-h5/dist/api/base/crypto.js
var getUserCryptoManager = temporarilyNotSupport("getUserCryptoManager");
// node_modules/@tarojs/taro-h5/dist/api/base/debug.js
var setEnableDebug = temporarilyNotSupport("setEnableDebug");
var getRealtimeLogManager = temporarilyNotSupport("getRealtimeLogManager");
var getLogManager = temporarilyNotSupport("getLogManager");
// node_modules/@tarojs/taro-h5/dist/api/base/performance.js
var reportPerformance = temporarilyNotSupport("reportPerformance");
var getPerformance = temporarilyNotSupport("getPerformance");
var preloadWebview = temporarilyNotSupport("preloadWebview");
var preloadSkylineView = temporarilyNotSupport("preloadSkylineView");
var preloadAssets = temporarilyNotSupport("preloadAssets");
// node_modules/@tarojs/taro-h5/dist/api/base/system.js
var import_platform = __toESM(require_platform());
var openSystemBluetoothSetting = temporarilyNotSupport("openSystemBluetoothSetting");
var openAppAuthorizeSetting = temporarilyNotSupport("openAppAuthorizeSetting");
var getWindowInfo = ()=>{
    const info = {
        /** 设备像素比 */ pixelRatio: window.devicePixelRatio,
        /** 屏幕宽度，单位px */ screenWidth: window.screen.width,
        /** 屏幕高度，单位px */ screenHeight: window.screen.height,
        /** 可使用窗口宽度，单位px */ windowWidth: document.documentElement.clientWidth,
        /** 可使用窗口高度，单位px */ windowHeight: document.documentElement.clientHeight,
        /** 状态栏的高度，单位px */ statusBarHeight: NaN,
        /** 在竖屏正方向下的安全区域 */ safeArea: {
            bottom: 0,
            height: 0,
            left: 0,
            right: 0,
            top: 0,
            width: 0
        }
    };
    return info;
};
var getSystemSetting = ()=>{
    const isLandscape = window.screen.width >= window.screen.height;
    const info = {
        /** 蓝牙的系统开关 */ bluetoothEnabled: false,
        /** 地理位置的系统开关 */ locationEnabled: false,
        /** Wi-Fi 的系统开关 */ wifiEnabled: false,
        /** 设备方向 */ deviceOrientation: isLandscape ? "landscape" : "portrait"
    };
    return info;
};
var getDeviceInfo = ()=>{
    var _a, _b;
    const info = {
        /** 应用二进制接口类型（仅 Android 支持） */ abi: "",
        /** 设备二进制接口类型（仅 Android 支持） */ deviceAbi: "",
        /** 设备性能等级（仅Android小游戏）。取值为：-2 或 0（该设备无法运行小游戏），-1（性能未知），>=1（设备性能值，该值越高，设备性能越好，目前最高不到50） */ benchmarkLevel: -1,
        /** 设备品牌 */ brand: import_platform.default.manufacturer || "unknown",
        /** 设备型号 */ model: import_platform.default.product || "unknown",
        /** 操作系统及版本 */ system: ((_a = import_platform.default.os) === null || _a === void 0 ? void 0 : _a.toString()) || "unknown",
        /** 客户端平台 */ platform: ((_b = import_platform.default.os) === null || _b === void 0 ? void 0 : _b.family) || "unknown",
        /** 设备二进制接口类型（仅 Android 支持） */ CPUType: ""
    };
    return info;
};
var getAppBaseInfo = ()=>{
    var _a;
    let isDarkMode = false;
    if ((_a = window.matchMedia) === null || _a === void 0 ? void 0 : _a.call(window, "(prefers-color-scheme: dark)").matches) {
        isDarkMode = true;
    }
    const info = {
        /** 客户端基础库版本 */ SDKVersion: "",
        /** 是否已打开调试。可通过右上角菜单或 [Taro.setEnableDebug](/docs/apis/base/debug/setEnableDebug) 打开调试。 */ enableDebug: true,
        /** 当前小程序运行的宿主环境 */ // host: { appId: '' },
        /** 微信设置的语言 */ language: navigator.language,
        /** 微信版本号 */ version: "",
        /** 系统当前主题，取值为light或dark，全局配置"darkmode":true时才能获取，否则为 undefined （不支持小游戏） */ theme: isDarkMode ? "dark" : "light"
    };
    return info;
};
var getAppAuthorizeSetting = ()=>{
    const info = {
        /** 允许微信使用相册的开关（仅 iOS 有效） */ albumAuthorized: "not determined",
        /** 允许微信使用蓝牙的开关（仅 iOS 有效） */ bluetoothAuthorized: "not determined",
        /** 允许微信使用摄像头的开关 */ cameraAuthorized: "not determined",
        /** 允许微信使用定位的开关 */ locationAuthorized: "not determined",
        /** 定位准确度。true 表示模糊定位，false 表示精确定位（仅 iOS 有效） */ locationReducedAccuracy: false,
        /** 允许微信使用麦克风的开关 */ microphoneAuthorized: "not determined",
        /** 允许微信通知的开关 */ notificationAuthorized: "not determined",
        /** 允许微信通知带有提醒的开关（仅 iOS 有效） */ notificationAlertAuthorized: "not determined",
        /** 允许微信通知带有标记的开关（仅 iOS 有效） */ notificationBadgeAuthorized: "not determined",
        /** 允许微信通知带有声音的开关（仅 iOS 有效） */ notificationSoundAuthorized: "not determined",
        /** 允许微信使用日历的开关 */ phoneCalendarAuthorized: "not determined"
    };
    return info;
};
var getSystemInfoSync = ()=>{
    const windowInfo = getWindowInfo();
    const systemSetting = getSystemSetting();
    const deviceInfo = getDeviceInfo();
    const appBaseInfo = getAppBaseInfo();
    const appAuthorizeSetting = getAppAuthorizeSetting();
    delete deviceInfo.abi;
    const info = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, windowInfo), systemSetting), deviceInfo), appBaseInfo), {
        /** 用户字体大小（单位px）。以微信客户端「我-设置-通用-字体大小」中的设置为准 */ fontSizeSetting: NaN,
        /** 允许微信使用相册的开关（仅 iOS 有效） */ albumAuthorized: appAuthorizeSetting.albumAuthorized === "authorized",
        /** 允许微信使用摄像头的开关 */ cameraAuthorized: appAuthorizeSetting.cameraAuthorized === "authorized",
        /** 允许微信使用定位的开关 */ locationAuthorized: appAuthorizeSetting.locationAuthorized === "authorized",
        /** 允许微信使用麦克风的开关 */ microphoneAuthorized: appAuthorizeSetting.microphoneAuthorized === "authorized",
        /** 允许微信通知的开关 */ notificationAuthorized: appAuthorizeSetting.notificationAuthorized === "authorized",
        /** 允许微信通知带有提醒的开关（仅 iOS 有效） */ notificationAlertAuthorized: appAuthorizeSetting.notificationAlertAuthorized === "authorized",
        /** 允许微信通知带有标记的开关（仅 iOS 有效） */ notificationBadgeAuthorized: appAuthorizeSetting.notificationBadgeAuthorized === "authorized",
        /** 允许微信通知带有声音的开关（仅 iOS 有效） */ notificationSoundAuthorized: appAuthorizeSetting.notificationSoundAuthorized === "authorized",
        /** 允许微信使用日历的开关 */ phoneCalendarAuthorized: appAuthorizeSetting.phoneCalendarAuthorized === "authorized",
        /** `true` 表示模糊定位，`false` 表示精确定位，仅 iOS 支持 */ locationReducedAccuracy: appAuthorizeSetting.locationReducedAccuracy,
        /** 小程序当前运行环境 */ environment: ""
    });
    return info;
};
var getSystemInfoAsync = (options3 = {})=>__awaiter(void 0, void 0, void 0, function*() {
        const { success, fail, complete } = options3;
        const handle3 = new MethodHandler({
            name: "getSystemInfoAsync",
            success,
            fail,
            complete
        });
        try {
            const info = yield getSystemInfoSync();
            return handle3.success(info);
        } catch (error) {
            return handle3.fail({
                errMsg: error
            });
        }
    });
var getSystemInfo = (options3 = {})=>__awaiter(void 0, void 0, void 0, function*() {
        const { success, fail, complete } = options3;
        const handle3 = new MethodHandler({
            name: "getSystemInfo",
            success,
            fail,
            complete
        });
        try {
            const info = yield getSystemInfoSync();
            return handle3.success(info);
        } catch (error) {
            return handle3.fail({
                errMsg: error
            });
        }
    });
var getSkylineInfoSync = temporarilyNotSupport("getSkylineInfoSync");
var getSkylineInfo = temporarilyNotSupport("getSkylineInfo");
var getRendererUserAgent = temporarilyNotSupport("getRendererUserAgent");
// node_modules/@tarojs/taro-h5/dist/api/base/update.js
var updateWeChatApp = temporarilyNotSupport("updateWeChatApp");
var getUpdateManager = temporarilyNotSupport("getUpdateManager");
// node_modules/lodash-es/isNil.js
function isNil(value) {
    return value == null;
}
var isNil_default = isNil;
// node_modules/@tarojs/taro-h5/dist/api/base/weapp/app-event.js
var import_query_string3 = __toESM(require_query_string());
var unhandledRejectionCallbackManager = new CallbackManager();
var themeChangeCallbackManager = new CallbackManager();
var pageNotFoundCallbackManager = new CallbackManager();
var errorCallbackManager = new CallbackManager();
var appShowCallbackManager = new CallbackManager();
var appHideCallbackManager = new CallbackManager();
var unhandledRejectionListener = (res)=>{
    unhandledRejectionCallbackManager.trigger(res);
};
var themeMatchMedia = null;
var themeChangeListener = (res)=>{
    themeChangeCallbackManager.trigger({
        theme: res.matches ? "dark" : "light"
    });
};
var pageNotFoundListener = (res)=>{
    pageNotFoundCallbackManager.trigger(res);
};
var errorListener = (res)=>{
    errorCallbackManager.trigger(res.stack || res.message || res);
};
var getApp = ()=>{
    var _a;
    const path = (_a = Taro.Current.page) === null || _a === void 0 ? void 0 : _a.path;
    return {
        /** 小程序切前台的路径 */ path: (path === null || path === void 0 ? void 0 : path.substring(0, path.indexOf("?"))) || "",
        /** 小程序切前台的 query 参数 */ query: (0, import_query_string3.parse)(location.search),
        /** 来源信息。 */ referrerInfo: {},
        /** 小程序切前台的[场景值](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/scene.html) */ scene: 0,
        /** shareTicket，详见[获取更多转发信息](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/share.html) */ shareTicket: ""
    };
};
var appShowListener = ()=>{
    if (document.visibilityState !== "hidden") {
        appShowCallbackManager.trigger(getApp());
    }
};
var appHideListener = ()=>{
    if (document.visibilityState === "hidden") {
        appHideCallbackManager.trigger(getApp());
    }
};
var onUnhandledRejection = (callback)=>{
    unhandledRejectionCallbackManager.add(callback);
    if (unhandledRejectionCallbackManager.count() === 1) {
        window.addEventListener("unhandledrejection", unhandledRejectionListener);
    }
};
var onThemeChange = (callback)=>{
    themeChangeCallbackManager.add(callback);
    if (themeChangeCallbackManager.count() === 1) {
        if (isNil_default(themeMatchMedia)) {
            themeMatchMedia = window.matchMedia("(prefers-color-scheme: light)");
        }
        themeMatchMedia.addEventListener("change", themeChangeListener);
    }
};
var onPageNotFound = (callback)=>{
    pageNotFoundCallbackManager.add(callback);
    if (pageNotFoundCallbackManager.count() === 1) {
        Taro.eventCenter.on("__taroRouterNotFound", pageNotFoundListener);
    }
};
var onLazyLoadError = temporarilyNotSupport("onLazyLoadError");
var onError = (callback)=>{
    errorCallbackManager.add(callback);
    if (errorCallbackManager.count() === 1) {
        window.addEventListener("error", errorListener);
    }
};
var onAudioInterruptionEnd = temporarilyNotSupport("onAudioInterruptionEnd");
var onAudioInterruptionBegin = temporarilyNotSupport("onAudioInterruptionBegin");
var onAppShow = (callback)=>{
    appShowCallbackManager.add(callback);
    if (appShowCallbackManager.count() === 1) {
        window.addEventListener("visibilitychange", appShowListener);
    }
};
var onAppHide = (callback)=>{
    appHideCallbackManager.add(callback);
    if (appHideCallbackManager.count() === 1) {
        window.addEventListener("visibilitychange", appHideListener);
    }
};
var offUnhandledRejection = (callback)=>{
    unhandledRejectionCallbackManager.remove(callback);
    if (unhandledRejectionCallbackManager.count() === 0) {
        window.removeEventListener("unhandledrejection", unhandledRejectionListener);
    }
};
var offThemeChange = (callback)=>{
    themeChangeCallbackManager.remove(callback);
    if (themeChangeCallbackManager.count() === 0) {
        if (isNil_default(themeMatchMedia)) {
            themeMatchMedia = window.matchMedia("(prefers-color-scheme: light)");
        }
        themeMatchMedia.removeEventListener("change", themeChangeListener);
        themeMatchMedia = null;
    }
};
var offPageNotFound = (callback)=>{
    pageNotFoundCallbackManager.remove(callback);
    if (pageNotFoundCallbackManager.count() === 0) {
        Taro.eventCenter.off("__taroRouterNotFound", pageNotFoundListener);
    }
};
var offLazyLoadError = temporarilyNotSupport("offLazyLoadError");
var offError = (callback)=>{
    errorCallbackManager.remove(callback);
    if (errorCallbackManager.count() === 0) {
        window.removeEventListener("error", errorListener);
    }
};
var offAudioInterruptionEnd = temporarilyNotSupport("offAudioInterruptionEnd");
var offAudioInterruptionBegin = temporarilyNotSupport("offAudioInterruptionBegin");
var offAppShow = (callback)=>{
    appShowCallbackManager.remove(callback);
    if (appShowCallbackManager.count() === 0) {
        window.removeEventListener("visibilitychange", appShowListener);
    }
};
var offAppHide = (callback)=>{
    appHideCallbackManager.remove(callback);
    if (appHideCallbackManager.count() === 0) {
        window.removeEventListener("visibilitychange", appHideListener);
    }
};
// node_modules/@tarojs/taro-h5/dist/api/base/weapp/life-cycle.js
var launchOptions = {
    path: "",
    query: {},
    scene: 0,
    shareTicket: "",
    referrerInfo: {}
};
function initLaunchOptions(options3 = {}) {
    Object.assign(launchOptions, options3);
}
Taro.eventCenter.once("__taroRouterLaunch", initLaunchOptions);
var getLaunchOptionsSync = ()=>launchOptions;
var getEnterOptionsSync = ()=>launchOptions;
// node_modules/@tarojs/taro-h5/dist/api/base/index.js
var env = {
    FRAMEWORK: "react",
    TARO_ENV: "h5",
    TARO_PLATFORM: "web",
    TARO_VERSION: "3.6.23"
};
function arrayBufferToBase64(arrayBuffer) {
    return (0, import_base64_js.fromByteArray)(arrayBuffer);
}
function base64ToArrayBuffer(base64) {
    return (0, import_base64_js.toByteArray)(base64);
}
// node_modules/@tarojs/taro-h5/dist/api/canvas/CanvasContext.js
var TextBaseLineMap = {
    top: "top",
    bottom: "bottom",
    middle: "middle",
    normal: "alphabetic",
    hanging: "hanging",
    alphabetic: "alphabetic",
    ideographic: "ideographic"
};
var CanvasContext = class {
    set ctx(e) {
        this.__raw__ = e;
    }
    get ctx() {
        return this.__raw__ || {};
    }
    emptyActions() {
        this.actions.length = 0;
    }
    enqueueActions(func, ...args) {
        this.actions.push({
            func,
            args
        });
    }
    set fillStyle(e) {
        this.enqueueActions(()=>{
            this.ctx.fillStyle = e;
        });
    }
    get fillStyle() {
        return this.ctx.fillStyle;
    }
    set font(e) {
        this.ctx.font = e;
    }
    get font() {
        return this.ctx.font;
    }
    set globalAlpha(e) {
        this.enqueueActions(()=>{
            this.ctx.globalAlpha = e;
        });
    }
    get globalAlpha() {
        return this.ctx.globalAlpha;
    }
    set globalCompositeOperation(e) {
        this.enqueueActions(()=>{
            this.ctx.globalCompositeOperation = e;
        });
    }
    get globalCompositeOperation() {
        return this.ctx.globalCompositeOperation;
    }
    set lineCap(e) {
        this.enqueueActions(()=>{
            this.ctx.lineCap = e;
        });
    }
    get lineCap() {
        return this.ctx.lineCap;
    }
    set lineDashOffset(e) {
        this.enqueueActions(()=>{
            this.ctx.lineDashOffset = e;
        });
    }
    get lineDashOffset() {
        return this.ctx.lineDashOffset;
    }
    set lineJoin(e) {
        this.enqueueActions(()=>{
            this.ctx.lineJoin = e;
        });
    }
    get lineJoin() {
        return this.ctx.lineJoin;
    }
    set lineWidth(e) {
        this.enqueueActions(()=>{
            this.ctx.lineWidth = e;
        });
    }
    get lineWidth() {
        return this.ctx.lineWidth;
    }
    set miterLimit(e) {
        this.enqueueActions(()=>{
            this.ctx.miterLimit = e;
        });
    }
    get miterLimit() {
        return this.ctx.miterLimit;
    }
    set shadowBlur(e) {
        this.enqueueActions(()=>{
            this.ctx.shadowBlur = e;
        });
    }
    get shadowBlur() {
        return this.ctx.shadowBlur;
    }
    set shadowColor(e) {
        this.enqueueActions(()=>{
            this.ctx.shadowColor = e;
        });
    }
    get shadowColor() {
        return this.ctx.shadowColor;
    }
    set shadowOffsetX(e) {
        this.enqueueActions(()=>{
            this.ctx.shadowOffsetX = e;
        });
    }
    get shadowOffsetX() {
        return this.ctx.shadowOffsetX;
    }
    set shadowOffsetY(e) {
        this.enqueueActions(()=>{
            this.ctx.shadowOffsetY = e;
        });
    }
    get shadowOffsetY() {
        return this.ctx.shadowOffsetY;
    }
    set strokeStyle(e) {
        this.enqueueActions(()=>{
            this.ctx.strokeStyle = e;
        });
    }
    get strokeStyle() {
        return this.ctx.strokeStyle;
    }
    /** 小程序文档中不包括 ↓↓↓ */ set textAlign(e) {
        this.ctx.textAlign = e;
    }
    get textAlign() {
        return this.ctx.textAlign;
    }
    set textBaseline(e) {
        this.ctx.textBaseline = e;
    }
    get textBaseline() {
        return this.ctx.textBaseline;
    }
    set direction(e) {
        this.ctx.direction = e;
    }
    get direction() {
        return this.ctx.direction;
    }
    set imageSmoothingEnabled(e) {
        this.enqueueActions(()=>{
            this.ctx.imageSmoothingEnabled = e;
        });
    }
    get imageSmoothingEnabled() {
        return this.ctx.imageSmoothingEnabled;
    }
    set imageSmoothingQuality(e) {
        this.enqueueActions(()=>{
            this.ctx.imageSmoothingQuality = e;
        });
    }
    get imageSmoothingQuality() {
        return this.ctx.imageSmoothingQuality;
    }
    set filter(e) {
        this.enqueueActions(()=>{
            this.ctx.filter = e;
        });
    }
    get filter() {
        return this.ctx.filter;
    }
    /** 小程序文档中不包括 ↑↑↑ */ arc(...args) {
        return this.enqueueActions(this.ctx.arc, ...args);
    }
    arcTo(...args) {
        return this.enqueueActions(this.ctx.arcTo, ...args);
    }
    beginPath(...args) {
        return this.enqueueActions(this.ctx.beginPath, ...args);
    }
    bezierCurveTo(...args) {
        return this.enqueueActions(this.ctx.bezierCurveTo, ...args);
    }
    clearRect(...args) {
        return this.enqueueActions(this.ctx.clearRect, ...args);
    }
    clip(...args) {
        return this.enqueueActions(this.ctx.clip, ...args);
    }
    closePath(...args) {
        return this.enqueueActions(this.ctx.closePath, ...args);
    }
    createPattern(imageResource, repetition) {
        if (typeof imageResource === "string") {
            const img = new Image();
            img.src = imageResource;
            return new Promise((resolve, reject)=>{
                img.onload = ()=>{
                    resolve(this.ctx.createPattern(img, repetition));
                };
                img.onerror = reject;
            });
        }
        return this.ctx.createPattern(imageResource, repetition);
    }
    /**
   * 将之前在绘图上下文中的描述（路径、变形、样式）画到 canvas 中。
   * @todo 每次 draw 都会读取 width 和 height
   */ draw(reserve, callback) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                if (!reserve) {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                }
                for (const { func, args } of this.actions){
                    yield func.apply(this.ctx, args);
                }
                this.emptyActions();
                callback && callback();
            } catch (e) {
                throw {
                    errMsg: e.message
                };
            }
        });
    }
    drawImage(imageResource, ...extra) {
        this.enqueueActions(()=>{
            if (typeof imageResource === "string") {
                const img = new Image();
                img.src = imageResource;
                return new Promise((resolve, reject)=>{
                    img.onload = ()=>{
                        this.ctx.drawImage(img, ...extra);
                        resolve();
                    };
                    img.onerror = reject;
                });
            }
            this.ctx.drawImage(imageResource, ...extra);
        });
    }
    fill(...args) {
        return this.enqueueActions(this.ctx.fill, ...args);
    }
    fillRect(...args) {
        return this.enqueueActions(this.ctx.fillRect, ...args);
    }
    fillText(...args) {
        return this.enqueueActions(this.ctx.fillText, ...args);
    }
    lineTo(...args) {
        return this.enqueueActions(this.ctx.lineTo, ...args);
    }
    moveTo(...args) {
        return this.enqueueActions(this.ctx.moveTo, ...args);
    }
    quadraticCurveTo(...args) {
        return this.enqueueActions(this.ctx.quadraticCurveTo, ...args);
    }
    rect(...args) {
        return this.enqueueActions(this.ctx.rect, ...args);
    }
    // @ts-ignore
    reset() {
        return this.ctx.reset();
    }
    restore() {
        return this.ctx.restore();
    }
    rotate(...args) {
        return this.enqueueActions(this.ctx.rotate, ...args);
    }
    save() {
        return this.ctx.save();
    }
    scale(...args) {
        return this.enqueueActions(this.ctx.scale, ...args);
    }
    setFillStyle(color) {
        this.enqueueActions(()=>{
            this.ctx.fillStyle = color;
        });
    }
    setFontSize(fontSize) {
        const arr = this.font.split(/\s/);
        const idx = arr.findIndex((e)=>/^\d+px$/.test(e));
        if (idx !== -1) {
            arr[idx] = `${fontSize}px`;
            this.font = arr.join(" ");
        }
    }
    setGlobalAlpha(alpha) {
        this.globalAlpha = alpha;
    }
    setLineCap(lineCap) {
        this.lineCap = lineCap;
    }
    setLineDash(pattern, offset2) {
        this.enqueueActions(()=>{
            this.ctx.setLineDash(pattern);
            this.ctx.lineDashOffset = offset2;
        });
    }
    setLineJoin(lineJoin) {
        this.lineJoin = lineJoin;
    }
    setLineWidth(lineWidth) {
        this.lineWidth = lineWidth;
    }
    setMiterLimit(miterLimit) {
        this.miterLimit = miterLimit;
    }
    setShadow(offsetX, offsetY, blur2, color) {
        this.enqueueActions(()=>{
            this.ctx.shadowOffsetX = offsetX;
            this.ctx.shadowOffsetY = offsetY;
            this.ctx.shadowColor = color;
            this.ctx.shadowBlur = blur2;
        });
    }
    setStrokeStyle(color) {
        this.enqueueActions(()=>{
            this.ctx.strokeStyle = color;
        });
    }
    setTextAlign(align) {
        this.textAlign = align;
    }
    setTextBaseline(textBaseline) {
        this.textBaseline = TextBaseLineMap[textBaseline] || "alphabetic";
    }
    setTransform(...args) {
        return this.enqueueActions(this.ctx.setTransform, ...args);
    }
    stroke(...args) {
        return this.enqueueActions(this.ctx.stroke, ...args);
    }
    strokeRect(...args) {
        return this.enqueueActions(this.ctx.strokeRect, ...args);
    }
    strokeText(...args) {
        return this.enqueueActions(this.ctx.strokeText, ...args);
    }
    transform(...args) {
        return this.enqueueActions(this.ctx.transform, ...args);
    }
    translate(...args) {
        return this.enqueueActions(this.ctx.translate, ...args);
    }
    measureText(text2) {
        return this.ctx.measureText(text2);
    }
    createCircularGradient(x, y, r) {
        const radialGradient = this.ctx.createRadialGradient(x, y, 0, x, y, r);
        return radialGradient;
    }
    createLinearGradient(x0, y0, x1, y1) {
        return this.ctx.createLinearGradient(x0, y0, x1, y1);
    }
    constructor(canvas, ctx){
        this.actions = [];
        this.canvas = canvas;
        this.ctx = ctx;
    }
};
// node_modules/@tarojs/taro-h5/dist/api/canvas/createCanvasContext.js
var createCanvasContext = (canvasId, inst)=>{
    const el = findDOM(inst);
    const canvas = el === null || el === void 0 ? void 0 : el.querySelector(`canvas[canvas-id="${canvasId}"]`);
    const ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext("2d");
    const context = new CanvasContext(canvas, ctx);
    if (!ctx) return context;
    context.canvas = canvas;
    context.ctx = ctx;
    return context;
};
// node_modules/@tarojs/taro-h5/dist/api/canvas/canvasToTempFilePath.js
var canvasToTempFilePath = ({ canvasId, fileType, quality, success, fail, complete }, inst)=>{
    const handle3 = new MethodHandler({
        name: "canvasToTempFilePath",
        success,
        fail,
        complete
    });
    const el = findDOM(inst);
    const canvas = el === null || el === void 0 ? void 0 : el.querySelector(`canvas[canvas-id="${canvasId}"]`);
    try {
        const dataURL = canvas === null || canvas === void 0 ? void 0 : canvas.toDataURL(`image/${(fileType === "jpg" ? "jpeg" : fileType) || "png"}`, quality);
        return handle3.success({
            tempFilePath: dataURL
        });
    } catch (e) {
        return handle3.fail({
            errMsg: e.message
        });
    }
};
// node_modules/@tarojs/taro-h5/dist/api/canvas/canvasPutImageData.js
var canvasPutImageData = ({ canvasId, data, x, y, success, fail, complete }, inst)=>{
    const handle3 = new MethodHandler({
        name: "canvasPutImageData",
        success,
        fail,
        complete
    });
    const el = findDOM(inst);
    const canvas = el === null || el === void 0 ? void 0 : el.querySelector(`canvas[canvas-id="${canvasId}"]`);
    try {
        const ctx = canvas.getContext("2d");
        ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(data, x, y);
        return handle3.success();
    } catch (e) {
        return handle3.fail({
            errMsg: e.message
        });
    }
};
// node_modules/@tarojs/taro-h5/dist/api/canvas/canvasGetImageData.js
var canvasGetImageData = ({ canvasId, success, fail, complete, x, y, width, height }, inst)=>{
    const handle3 = new MethodHandler({
        name: "canvasGetImageData",
        success,
        fail,
        complete
    });
    const el = findDOM(inst);
    const canvas = el === null || el === void 0 ? void 0 : el.querySelector(`canvas[canvas-id="${canvasId}"]`);
    try {
        const ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext("2d");
        const data = ctx === null || ctx === void 0 ? void 0 : ctx.getImageData(x, y, width, height);
        return handle3.success({
            width,
            height,
            data
        });
    } catch (e) {
        return handle3.fail({
            errMsg: e.message
        });
    }
};
// node_modules/@tarojs/taro-h5/dist/api/canvas/index.js
var createOffscreenCanvas = temporarilyNotSupport("createOffscreenCanvas");
// node_modules/@tarojs/taro-h5/dist/api/cloud/index.js
var cloud = class {
    constructor(){
        this.init = temporarilyNotSupport("cloud.init");
        this.CloudID = temporarilyNotSupport("cloud.CloudID");
        this.callFunction = temporarilyNotSupport("cloud.callFunction");
        this.uploadFile = temporarilyNotSupport("cloud.uploadFile");
        this.downloadFile = temporarilyNotSupport("cloud.downloadFile");
        this.getTempFileURL = temporarilyNotSupport("cloud.getTempFileURL");
        this.deleteFile = temporarilyNotSupport("cloud.deleteFile");
        this.database = temporarilyNotSupport("cloud.database");
        this.callContainer = temporarilyNotSupport("cloud.callContainer");
    }
};
// node_modules/@tarojs/taro-h5/dist/api/data-analysis/index.js
var reportMonitor = temporarilyNotSupport("reportMonitor");
var reportAnalytics = temporarilyNotSupport("reportAnalytics");
var reportEvent = temporarilyNotSupport("reportEvent");
var getExptInfoSync = temporarilyNotSupport("getExptInfoSync");
// node_modules/lodash-es/now.js
var now = function() {
    return root_default.Date.now();
};
var now_default = now;
// node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string2) {
    var index2 = string2.length;
    while(index2-- && reWhitespace.test(string2.charAt(index2))){}
    return index2;
}
var trimmedEndIndex_default = trimmedEndIndex;
// node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string2) {
    return string2 ? string2.slice(0, trimmedEndIndex_default(string2) + 1).replace(reTrimStart, "") : string2;
}
var baseTrim_default = baseTrim;
// node_modules/lodash-es/toNumber.js
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
    if (typeof value == "number") {
        return value;
    }
    if (isSymbol_default(value)) {
        return NAN;
    }
    if (isObject_default(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject_default(other) ? other + "" : other;
    }
    if (typeof value != "string") {
        return value === 0 ? value : +value;
    }
    value = baseTrim_default(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_default = toNumber;
// node_modules/lodash-es/debounce.js
var FUNC_ERROR_TEXT2 = "Expected a function";
var nativeMax = Math.max;
var nativeMin = Math.min;
function debounce(func, wait, options3) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT2);
    }
    wait = toNumber_default(wait) || 0;
    if (isObject_default(options3)) {
        leading = !!options3.leading;
        maxing = "maxWait" in options3;
        maxWait = maxing ? nativeMax(toNumber_default(options3.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options3 ? !!options3.trailing : trailing;
    }
    function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
    }
    function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
        var time = now_default();
        if (shouldInvoke(time)) {
            return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
            return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
    }
    function cancel() {
        if (timerId !== void 0) {
            clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush2() {
        return timerId === void 0 ? result : trailingEdge(now_default());
    }
    function debounced() {
        var time = now_default(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
            if (timerId === void 0) {
                return leadingEdge(lastCallTime);
            }
            if (maxing) {
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
            }
        }
        if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
        }
        return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush2;
    return debounced;
}
var debounce_default = debounce;
// node_modules/lodash-es/throttle.js
var FUNC_ERROR_TEXT3 = "Expected a function";
function throttle(func, wait, options3) {
    var leading = true, trailing = true;
    if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT3);
    }
    if (isObject_default(options3)) {
        leading = "leading" in options3 ? !!options3.leading : leading;
        trailing = "trailing" in options3 ? !!options3.trailing : trailing;
    }
    return debounce_default(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
    });
}
var throttle_default = throttle;
// node_modules/@tarojs/taro-h5/dist/api/device/accelerometer.js
var callbackManager = new CallbackManager();
var devicemotionListener;
var stopAccelerometer = ({ success, fail, complete } = {})=>{
    const res = {};
    const handle3 = new MethodHandler({
        name: "stopAccelerometer",
        success,
        fail,
        complete
    });
    try {
        window.removeEventListener("devicemotion", devicemotionListener, true);
        return handle3.success(res);
    } catch (e) {
        res.errMsg = e.message;
        return handle3.fail(res);
    }
};
var INTERVAL_MAP = {
    game: {
        interval: 20,
        frequency: 50
    },
    ui: {
        interval: 60,
        frequency: 16.67
    },
    normal: {
        interval: 200,
        frequency: 5
    }
};
var startAccelerometer = ({ interval = "normal", success, fail, complete } = {})=>{
    const handle3 = new MethodHandler({
        name: "startAccelerometer",
        success,
        fail,
        complete
    });
    try {
        if (window.DeviceMotionEvent) {
            const intervalObj = INTERVAL_MAP[interval];
            if (devicemotionListener) {
                stopAccelerometer();
            }
            devicemotionListener = throttle_default((evt)=>{
                var _a, _b, _c;
                callbackManager.trigger({
                    x: ((_a = evt.acceleration) === null || _a === void 0 ? void 0 : _a.x) || 0,
                    y: ((_b = evt.acceleration) === null || _b === void 0 ? void 0 : _b.y) || 0,
                    z: ((_c = evt.acceleration) === null || _c === void 0 ? void 0 : _c.z) || 0
                });
            }, intervalObj.interval);
            window.addEventListener("devicemotion", devicemotionListener, true);
        } else {
            throw new Error("accelerometer is not supported");
        }
        return handle3.success();
    } catch (e) {
        return handle3.fail({
            errMsg: e.message
        });
    }
};
var onAccelerometerChange = (callback)=>{
    callbackManager.add(callback);
};
var offAccelerometerChange = (callback)=>{
    callbackManager.remove(callback);
};
// node_modules/@tarojs/taro-h5/dist/api/device/accessibility.js
var checkIsOpenAccessibility = temporarilyNotSupport("checkIsOpenAccessibility");
// node_modules/@tarojs/taro-h5/dist/api/device/battery.js
var getBatteryInfoSync = permanentlyNotSupport("getBatteryInfoSync");
var getBatteryInfo = ({ success, fail, complete } = {})=>__awaiter(void 0, void 0, void 0, function*() {
        var _a;
        const handle3 = new MethodHandler({
            name: "getBatteryInfo",
            success,
            fail,
            complete
        });
        try {
            const battery = yield (_a = navigator.getBattery) === null || _a === void 0 ? void 0 : _a.call(navigator);
            return handle3.success({
                isCharging: battery.charging,
                level: Number(battery.level || 0) * 100
            });
        } catch (error) {
            return handle3.fail({
                errMsg: (error === null || error === void 0 ? void 0 : error.message) || error
            });
        }
    });
// node_modules/@tarojs/taro-h5/dist/api/device/bluetooth.js
var stopBluetoothDevicesDiscovery = temporarilyNotSupport("stopBluetoothDevicesDiscovery");
var startBluetoothDevicesDiscovery = temporarilyNotSupport("startBluetoothDevicesDiscovery");
var openBluetoothAdapter = temporarilyNotSupport("openBluetoothAdapter");
var onBluetoothDeviceFound = temporarilyNotSupport("onBluetoothDeviceFound");
var onBluetoothAdapterStateChange = temporarilyNotSupport("onBluetoothAdapterStateChange");
var offBluetoothDeviceFound = temporarilyNotSupport("offBluetoothDeviceFound");
var offBluetoothAdapterStateChange = temporarilyNotSupport("offBluetoothAdapterStateChange");
var makeBluetoothPair = temporarilyNotSupport("makeBluetoothPair");
var isBluetoothDevicePaired = temporarilyNotSupport("isBluetoothDevicePaired");
var getConnectedBluetoothDevices = temporarilyNotSupport("getConnectedBluetoothDevices");
var getBluetoothDevices = temporarilyNotSupport("getBluetoothDevices");
var getBluetoothAdapterState = temporarilyNotSupport("getBluetoothAdapterState");
var closeBluetoothAdapter = temporarilyNotSupport("closeBluetoothAdapter");
// node_modules/@tarojs/taro-h5/dist/api/device/bluetooth-ble.js
var writeBLECharacteristicValue = temporarilyNotSupport("writeBLECharacteristicValue");
var setBLEMTU = temporarilyNotSupport("setBLEMTU");
var readBLECharacteristicValue = temporarilyNotSupport("readBLECharacteristicValue");
var onBLEMTUChange = temporarilyNotSupport("onBLEMTUChange");
var onBLEConnectionStateChange = temporarilyNotSupport("onBLEConnectionStateChange");
var onBLECharacteristicValueChange = temporarilyNotSupport("onBLECharacteristicValueChange");
var offBLEMTUChange = temporarilyNotSupport("offBLEMTUChange");
var offBLEConnectionStateChange = temporarilyNotSupport("offBLEConnectionStateChange");
var offBLECharacteristicValueChange = temporarilyNotSupport("offBLECharacteristicValueChange");
var notifyBLECharacteristicValueChange = temporarilyNotSupport("notifyBLECharacteristicValueChange");
var getBLEMTU = temporarilyNotSupport("getBLEMTU");
var getBLEDeviceServices = temporarilyNotSupport("getBLEDeviceServices");
var getBLEDeviceRSSI = temporarilyNotSupport("getBLEDeviceRSSI");
var getBLEDeviceCharacteristics = temporarilyNotSupport("getBLEDeviceCharacteristics");
var createBLEConnection = temporarilyNotSupport("createBLEConnection");
var closeBLEConnection = temporarilyNotSupport("closeBLEConnection");
// node_modules/@tarojs/taro-h5/dist/api/device/bluetooth-peripheral.js
var onBLEPeripheralConnectionStateChanged = temporarilyNotSupport("onBLEPeripheralConnectionStateChanged");
var offBLEPeripheralConnectionStateChanged = temporarilyNotSupport("offBLEPeripheralConnectionStateChanged");
var createBLEPeripheralServer = temporarilyNotSupport("createBLEPeripheralServer");
// node_modules/@tarojs/taro-h5/dist/api/device/calendar.js
var ics = __toESM(require_dist2());
var addPhoneRepeatCalendar = (options3)=>{
    const methodName = "addPhoneRepeatCalendar";
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `${methodName}:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { title, startTime = /* @__PURE__ */ new Date().getTime(), allDay = false, description = "", location: location2 = "", endTime, alarm = true, alarmOffset = 0, repeatInterval = "month", repeatEndTime, success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: methodName,
        success,
        fail,
        complete
    });
    if (typeof title !== "string") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "title",
                correct: "String",
                wrong: title
            })
        });
    }
    const start2 = new Date(startTime);
    const end = new Date(endTime || startTime);
    if (!endTime && allDay) {
        end.setDate(end.getDate() + 1);
    }
    const interval = 1e3 * 60 * 60 * 24;
    let days = 1;
    let repeat = 1;
    if (repeatEndTime) {
        const repeatEnd = new Date(repeatEndTime);
        if (repeatEnd < start2) {
            return handle3.fail({
                errMsg: "repeatEndTime must be greater than startTime"
            });
        }
        switch(repeatInterval){
            case "week":
                days = 7;
                break;
            case "month":
                days = 30;
                break;
            case "year":
                days = 365;
                break;
            default:
        }
        repeat = Math.ceil((repeatEnd.getTime() - start2.getTime()) / (interval * days));
    }
    const { error, value } = ics.createEvent({
        title,
        start: parseTime2Array(start2, allDay),
        description,
        location: location2,
        end: parseTime2Array(end, allDay),
        alarms: alarm ? [
            {
                action: "display",
                description,
                trigger: {
                    before: true,
                    seconds: alarmOffset
                },
                duration: {
                    days
                },
                repeat
            }
        ] : []
    });
    if (error || !value) {
        return handle3.fail({
            errMsg: error === null || error === void 0 ? void 0 : error.message
        });
    }
    const url = URL.createObjectURL(new Blob([
        value
    ]));
    createDownload(url, `${title}.ics`);
    return handle3.success();
};
var addPhoneCalendar = (options3)=>{
    const methodName = "addPhoneCalendar";
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `${methodName}:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { title, startTime = /* @__PURE__ */ new Date().getTime(), allDay = false, description = "", location: location2 = "", endTime, alarm = true, alarmOffset = 0, success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: methodName,
        success,
        fail,
        complete
    });
    if (typeof title !== "string") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "title",
                correct: "String",
                wrong: title
            })
        });
    }
    const start2 = new Date(startTime);
    const end = new Date(endTime || startTime);
    if (!endTime && allDay) {
        end.setDate(end.getDate() + 1);
    }
    const { error, value } = ics.createEvent({
        title,
        start: parseTime2Array(start2, allDay),
        description,
        location: location2,
        end: parseTime2Array(end, allDay),
        alarms: alarm ? [
            {
                action: "display",
                description,
                trigger: {
                    before: true,
                    seconds: alarmOffset
                }
            }
        ] : []
    });
    if (error || !value) {
        return handle3.fail({
            errMsg: error === null || error === void 0 ? void 0 : error.message
        });
    }
    const url = URL.createObjectURL(new Blob([
        value
    ]));
    createDownload(url, `${title}.ics`);
    return handle3.success();
};
function parseTime2Array(time, allDay = false) {
    const t = new Date(time);
    const timeArr = [
        t.getFullYear(),
        t.getMonth() + 1,
        t.getDate()
    ];
    if (!allDay) {
        timeArr.push(t.getHours(), t.getMinutes());
    }
    return timeArr;
}
// node_modules/@tarojs/taro-h5/dist/api/storage/background-fetch.js
var setBackgroundFetchToken = temporarilyNotSupport("setBackgroundFetchToken");
var onBackgroundFetchData = temporarilyNotSupport("onBackgroundFetchData");
var getBackgroundFetchToken = temporarilyNotSupport("getBackgroundFetchToken");
var getBackgroundFetchData = temporarilyNotSupport("getBackgroundFetchData");
// node_modules/@tarojs/taro-h5/dist/api/storage/cache-manager.js
var createCacheManager = temporarilyNotSupport("createCacheManager");
// node_modules/@tarojs/taro-h5/dist/api/storage/index.js
function getItem(key) {
    let item;
    try {
        item = JSON.parse(localStorage.getItem(key) || "");
    } catch (e) {}
    if (item && typeof item === "object" && item.hasOwnProperty("data")) {
        return {
            result: true,
            data: item.data
        };
    } else {
        return {
            result: false
        };
    }
}
var setStorageSync = (key, data = "")=>{
    if (typeof key !== "string") {
        console.error(getParameterError({
            name: "setStorage",
            correct: "String",
            wrong: key
        }));
        return;
    }
    const type = typeof data;
    let obj = {};
    if (type === "symbol") {
        obj = {
            data: ""
        };
    } else {
        obj = {
            data
        };
    }
    localStorage.setItem(key, JSON.stringify(obj));
};
var setStorage = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `setStorage:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { key, data, success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: "setStorage",
        success,
        fail,
        complete
    });
    if (typeof key !== "string") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "key",
                correct: "String",
                wrong: key
            })
        });
    }
    setStorageSync(key, data);
    return handle3.success();
};
var revokeBufferURL = temporarilyNotSupport("revokeBufferURL");
var removeStorageSync = (key)=>{
    if (typeof key !== "string") {
        console.error(getParameterError({
            name: "removeStorage",
            correct: "String",
            wrong: key
        }));
        return;
    }
    localStorage.removeItem(key);
};
var removeStorage = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `removeStorage:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { key, success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: "removeStorage",
        success,
        fail,
        complete
    });
    if (typeof key !== "string") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "key",
                correct: "String",
                wrong: key
            })
        });
    }
    removeStorageSync(key);
    return handle3.success();
};
var getStorageSync = (key)=>{
    if (typeof key !== "string") {
        console.error(getParameterError({
            name: "getStorageSync",
            correct: "String",
            wrong: key
        }));
        return;
    }
    const res = getItem(key);
    if (res.result) return res.data;
    return "";
};
var getStorageInfoSync = ()=>{
    const res = {
        keys: Object.keys(localStorage),
        limitSize: NaN,
        currentSize: NaN
    };
    return res;
};
var getStorageInfo = ({ success, fail, complete } = {})=>{
    const handle3 = new MethodHandler({
        name: "getStorageInfo",
        success,
        fail,
        complete
    });
    return handle3.success(getStorageInfoSync());
};
var getStorage = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `getStorage:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { key, success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: "getStorage",
        success,
        fail,
        complete
    });
    if (typeof key !== "string") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "key",
                correct: "String",
                wrong: key
            })
        });
    }
    const { result, data } = getItem(key);
    if (result) {
        return handle3.success({
            data
        });
    } else {
        return handle3.fail({
            errMsg: "data not found"
        });
    }
};
var createBufferURL = temporarilyNotSupport("createBufferURL");
var clearStorageSync = ()=>{
    localStorage.clear();
};
var clearStorage = ({ success, fail, complete } = {})=>{
    const handle3 = new MethodHandler({
        name: "clearStorage",
        success,
        fail,
        complete
    });
    clearStorageSync();
    return handle3.success();
};
var batchSetStorageSync = temporarilyNotSupport("batchSetStorageSync");
var batchSetStorage = temporarilyNotSupport("batchSetStorage");
var batchGetStorageSync = temporarilyNotSupport("batchGetStorageSync");
var batchGetStorage = temporarilyNotSupport("batchGetStorage");
// node_modules/@tarojs/taro-h5/dist/api/device/clipboard.js
var CLIPBOARD_STORAGE_NAME = "taro_clipboard";
document.addEventListener("copy", ()=>{
    var _a;
    setStorage({
        key: CLIPBOARD_STORAGE_NAME,
        data: (_a = window.getSelection()) === null || _a === void 0 ? void 0 : _a.toString()
    }).catch((e)=>{
        console.error(e);
    });
});
var setClipboardData = ({ data, success, fail, complete })=>__awaiter(void 0, void 0, void 0, function*() {
        const handle3 = new MethodHandler({
            name: "setClipboardData",
            success,
            fail,
            complete
        });
        try {
            setStorageSync(CLIPBOARD_STORAGE_NAME, data);
            if (isFunction(document.execCommand)) {
                const textarea = document.createElement("textarea");
                textarea.readOnly = true;
                textarea.value = data;
                textarea.style.position = "absolute";
                textarea.style.width = "100px";
                textarea.style.left = "-10000px";
                document.body.appendChild(textarea);
                textarea.select();
                textarea.setSelectionRange(0, textarea.value.length);
                document.execCommand("copy");
                document.body.removeChild(textarea);
            } else {
                throw new Error("Unsupported Function: 'document.execCommand'.");
            }
            return handle3.success();
        } catch (e) {
            return handle3.fail({
                errMsg: e.message
            });
        }
    });
var getClipboardData = ({ success, fail, complete } = {})=>__awaiter(void 0, void 0, void 0, function*() {
        const handle3 = new MethodHandler({
            name: "getClipboardData",
            success,
            fail,
            complete
        });
        try {
            const data = getStorageSync(CLIPBOARD_STORAGE_NAME);
            return handle3.success({
                data
            });
        } catch (e) {
            return handle3.fail({
                errMsg: e.message
            });
        }
    });
// node_modules/@tarojs/taro-h5/dist/api/device/compass.js
var callbackManager2 = new CallbackManager();
var compassListener;
var deviceorientationEventName = [
    "absolutedeviceorientation",
    "deviceorientationabsolute",
    "deviceorientation"
].find((item)=>{
    if ("on" + item in window) {
        return item;
    }
}) || "";
var stopCompass = ({ success, fail, complete } = {})=>{
    const handle3 = new MethodHandler({
        name: "stopCompass",
        success,
        fail,
        complete
    });
    try {
        window.removeEventListener(deviceorientationEventName, compassListener, true);
        return handle3.success();
    } catch (e) {
        return handle3.fail({
            errMsg: e.message
        });
    }
};
var CompassChangeTrigger = false;
var startCompass = ({ success, fail, complete } = {})=>{
    const handle3 = new MethodHandler({
        name: "startCompass",
        success,
        fail,
        complete
    });
    try {
        if (deviceorientationEventName !== "") {
            if (compassListener) {
                stopCompass();
            }
            compassListener = throttle_default((evt)=>{
                const isAndroid = getDeviceInfo().system === "AndroidOS";
                if (isAndroid && !evt.absolute && !CompassChangeTrigger) {
                    CompassChangeTrigger = true;
                    console.warn("Warning: In 'onCompassChange', your browser is not supported to get the orientation relative to the earth, the orientation data will be related to the initial orientation of the device .");
                }
                const alpha = evt.alpha || 0;
                const accuracy = isAndroid ? evt.absolute ? "high" : "medium" : alpha;
                callbackManager2.trigger({
                    direction: 360 - alpha,
                    accuracy
                });
            }, 5e3);
            window.addEventListener(deviceorientationEventName, compassListener, true);
        } else {
            throw new Error("compass is not supported");
        }
        return handle3.success();
    } catch (e) {
        return handle3.fail({
            errMsg: e.message
        });
    }
};
var onCompassChange = (callback)=>{
    callbackManager2.add(callback);
};
var offCompassChange = (callback)=>{
    callbackManager2.remove(callback);
};
// node_modules/@tarojs/taro-h5/dist/api/device/contact.js
var chooseContact = temporarilyNotSupport("chooseContact");
var addPhoneContact = temporarilyNotSupport("addPhoneContact");
// node_modules/@tarojs/taro-h5/dist/api/device/crypto.js
var getRandomValues = temporarilyNotSupport("getRandomValues");
// node_modules/@tarojs/taro-h5/dist/api/device/gyroscope.js
var stopGyroscope = temporarilyNotSupport("stopGyroscope");
var startGyroscope = temporarilyNotSupport("startGyroscope");
var onGyroscopeChange = temporarilyNotSupport("onGyroscopeChange");
var offGyroscopeChange = temporarilyNotSupport("offGyroscopeChange");
// node_modules/@tarojs/taro-h5/dist/api/device/iBeacon.js
var stopBeaconDiscovery = temporarilyNotSupport("stopBeaconDiscovery");
var startBeaconDiscovery = temporarilyNotSupport("startBeaconDiscovery");
var onBeaconUpdate = temporarilyNotSupport("onBeaconUpdate");
var onBeaconServiceChange = temporarilyNotSupport("onBeaconServiceChange");
var offBeaconUpdate = temporarilyNotSupport("offBeaconUpdate");
var offBeaconServiceChange = temporarilyNotSupport("offBeaconServiceChange");
var getBeacons = temporarilyNotSupport("getBeacons");
// node_modules/@tarojs/taro-h5/dist/api/device/keyboard.js
var onKeyboardHeightChange = temporarilyNotSupport("onKeyboardHeightChange");
var offKeyboardHeightChange = temporarilyNotSupport("offKeyboardHeightChange");
var hideKeyboard = temporarilyNotSupport("hideKeyboard");
var getSelectedTextRange = temporarilyNotSupport("getSelectedTextRange");
// node_modules/@tarojs/taro-h5/dist/api/device/memory.js
var onMemoryWarning = temporarilyNotSupport("onMemoryWarning");
var offMemoryWarning = temporarilyNotSupport("offMemoryWarning");
// node_modules/@tarojs/taro-h5/dist/api/device/motion.js
var callbackManager3 = new CallbackManager();
var deviceMotionListener;
var INTERVAL_MAP2 = {
    game: {
        interval: 20,
        frequency: 50
    },
    ui: {
        interval: 60,
        frequency: 16.67
    },
    normal: {
        interval: 200,
        frequency: 5
    }
};
var stopDeviceMotionListening = ({ success, fail, complete } = {})=>{
    const handle3 = new MethodHandler({
        name: "stopDeviceMotionListening",
        success,
        fail,
        complete
    });
    try {
        window.removeEventListener("deviceorientation", deviceMotionListener, true);
        return handle3.success();
    } catch (e) {
        return handle3.fail({
            errMsg: e.message
        });
    }
};
var startDeviceMotionListening = ({ interval = "normal", success, fail, complete } = {})=>{
    const handle3 = new MethodHandler({
        name: "startDeviceMotionListening",
        success,
        fail,
        complete
    });
    try {
        const intervalObj = INTERVAL_MAP2[interval];
        if (window.DeviceOrientationEvent) {
            if (deviceMotionListener) {
                stopDeviceMotionListening();
            }
            deviceMotionListener = throttle_default((evt)=>{
                callbackManager3.trigger({
                    alpha: evt.alpha,
                    beta: evt.beta,
                    gamma: evt.gamma
                });
            }, intervalObj.interval);
            window.addEventListener("deviceorientation", deviceMotionListener, true);
        } else {
            throw new Error("deviceMotion is not supported");
        }
        return handle3.success();
    } catch (e) {
        return handle3.fail({
            errMsg: e.message
        });
    }
};
var onDeviceMotionChange = (callback)=>{
    callbackManager3.add(callback);
};
var offDeviceMotionChange = (callback)=>{
    callbackManager3.remove(callback);
};
// node_modules/@tarojs/taro-h5/dist/api/device/network.js
function getConnection() {
    return navigator.connection || navigator.mozConnection || navigator.webkitConnection || navigator.msConnection;
}
var getNetworkType = (options3 = {})=>{
    const connection = getConnection();
    const { success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: "getNetworkType",
        success,
        fail,
        complete
    });
    let networkType = "unknown";
    if (!connection) {
        return handle3.success({
            networkType
        });
    }
    if (!isNaN(Number(connection.type))) {
        switch(connection.type){
            case connection.WIFI:
                networkType = "wifi";
                break;
            case connection.CELL_3G:
                networkType = "3g";
                break;
            case connection.CELL_2G:
                networkType = "2g";
                break;
            default:
                networkType = "unknown";
        }
    } else if (connection.type) {
        networkType = connection.type;
    } else if (connection.effectiveType) {
        networkType = connection.effectiveType;
    }
    return handle3.success({
        networkType
    });
};
var networkStatusManager = new CallbackManager();
var networkStatusListener = ()=>__awaiter(void 0, void 0, void 0, function*() {
        const { networkType } = yield getNetworkType();
        const isConnected = networkType !== "none";
        const obj = {
            isConnected,
            networkType
        };
        networkStatusManager.trigger(obj);
    });
var onNetworkWeakChange = temporarilyNotSupport("onNetworkWeakChange");
var onNetworkStatusChange = (callback)=>{
    networkStatusManager.add(callback);
    const connection = getConnection();
    if (connection && networkStatusManager.count() === 1) {
        connection.addEventListener("change", networkStatusListener);
    }
};
var offNetworkWeakChange = temporarilyNotSupport("offNetworkWeakChange");
var offNetworkStatusChange = (callback)=>{
    networkStatusManager.remove(callback);
    const connection = getConnection();
    if (connection && networkStatusManager.count() === 0) {
        connection.removeEventListener("change", networkStatusListener);
    }
};
var getLocalIPAddress = temporarilyNotSupport("getLocalIPAddress");
// node_modules/@tarojs/taro-h5/dist/api/device/nfc.js
var stopHCE = temporarilyNotSupport("stopHCE");
var startHCE = temporarilyNotSupport("startHCE");
var sendHCEMessage = temporarilyNotSupport("sendHCEMessage");
var onHCEMessage = temporarilyNotSupport("onHCEMessage");
var offHCEMessage = temporarilyNotSupport("offHCEMessage");
var getNFCAdapter = temporarilyNotSupport("getNFCAdapter");
var getHCEState = temporarilyNotSupport("getHCEState");
// node_modules/@tarojs/taro-h5/dist/api/device/phone.js
var makePhoneCall = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `makePhoneCall:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { phoneNumber, success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: "makePhoneCall",
        success,
        fail,
        complete
    });
    if (typeof phoneNumber !== "string") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "phoneNumber",
                correct: "String",
                wrong: phoneNumber
            })
        });
    }
    window.location.href = `tel:${phoneNumber}`;
    return handle3.success();
};
// node_modules/@tarojs/taro-h5/dist/api/device/scan.js
var scanCode = processOpenApi({
    name: "scanQRCode",
    defaultOptions: {
        needResult: 1
    },
    formatResult: (res)=>({
            errMsg: res.errMsg === "scanQRCode:ok" ? "scanCode:ok" : res.errMsg,
            result: res.resultStr
        })
});
// node_modules/@tarojs/taro-h5/dist/api/device/screen.js
var setVisualEffectOnCapture = temporarilyNotSupport("setVisualEffectOnCapture");
var setScreenBrightness = temporarilyNotSupport("setScreenBrightness");
var setKeepScreenOn = temporarilyNotSupport("setKeepScreenOn");
var onUserCaptureScreen = temporarilyNotSupport("onUserCaptureScreen");
var offUserCaptureScreen = temporarilyNotSupport("offUserCaptureScreen");
var getScreenBrightness = temporarilyNotSupport("getScreenBrightness");
var onScreenRecordingStateChanged = temporarilyNotSupport("onScreenRecordingStateChanged");
var offScreenRecordingStateChanged = temporarilyNotSupport("offScreenRecordingStateChanged");
var getScreenRecordingState = temporarilyNotSupport("getScreenRecordingState");
// node_modules/@tarojs/taro-h5/dist/api/device/sms.js
var sendSms = temporarilyNotSupport("sendSms");
// node_modules/@tarojs/taro-h5/dist/api/device/vibrate.js
var vibrator = function vibrator2(mm) {
    try {
        return window.navigator.vibrate(mm);
    } catch (e) {
        console.warn("\u5F53\u524D\u6D4F\u89C8\u5668\u4E0D\u652F\u6301 vibrate\u3002");
    }
};
var vibrateShort = ({ success, fail, complete } = {})=>{
    const handle3 = new MethodHandler({
        name: "vibrateShort",
        success,
        fail,
        complete
    });
    if (vibrator(15)) {
        return handle3.success();
    } else {
        return handle3.fail({
            errMsg: "style is not support"
        });
    }
};
var vibrateLong = ({ success, fail, complete } = {})=>{
    const handle3 = new MethodHandler({
        name: "vibrateLong",
        success,
        fail,
        complete
    });
    if (vibrator(400)) {
        return handle3.success();
    } else {
        return handle3.fail({
            errMsg: "style is not support"
        });
    }
};
// node_modules/@tarojs/taro-h5/dist/api/device/wifi.js
var stopWifi = temporarilyNotSupport("stopWifi");
var startWifi = temporarilyNotSupport("startWifi");
var setWifiList = temporarilyNotSupport("setWifiList");
var onWifiConnectedWithPartialInfo = temporarilyNotSupport("onWifiConnectedWithPartialInfo");
var onWifiConnected = temporarilyNotSupport("onWifiConnected");
var onGetWifiList = temporarilyNotSupport("onGetWifiList");
var offWifiConnectedWithPartialInfo = temporarilyNotSupport("offWifiConnectedWithPartialInfo");
var offWifiConnected = temporarilyNotSupport("offWifiConnected");
var offGetWifiList = temporarilyNotSupport("offGetWifiList");
var getWifiList = temporarilyNotSupport("getWifiList");
var getConnectedWifi = temporarilyNotSupport("getConnectedWifi");
var connectWifi = temporarilyNotSupport("connectWifi");
// node_modules/@tarojs/taro-h5/dist/api/ext/index.js
var getExtConfigSync = temporarilyNotSupport("getExtConfigSync");
var getExtConfig = temporarilyNotSupport("getExtConfig");
// node_modules/@tarojs/taro-h5/dist/api/files/index.js
var saveFileToDisk = temporarilyNotSupport("saveFileToDisk");
var saveFile = temporarilyNotSupport("saveFile");
var removeSavedFile = temporarilyNotSupport("removeSavedFile");
var openDocument = temporarilyNotSupport("openDocument");
var getSavedFileList = temporarilyNotSupport("getSavedFileList");
var getSavedFileInfo = temporarilyNotSupport("getSavedFileInfo");
var getFileSystemManager = temporarilyNotSupport("getFileSystemManager");
var getFileInfo = temporarilyNotSupport("getFileInfo");
// node_modules/@tarojs/taro-h5/dist/api/framework/index.js
var getApp2 = function() {
    return Taro.getCurrentInstance().app;
};
var getCurrentInstance2 = Taro.getCurrentInstance;
// node_modules/@tarojs/taro-h5/dist/api/location/getLocation.js
var getLocationByW3CApi = (options3)=>{
    var _a;
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `getLocation:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: "getLocation",
        success,
        fail,
        complete
    });
    const positionOptions = {
        enableHighAccuracy: options3.isHighAccuracy || options3.altitude != null,
        // maximumAge: defaultMaximumAge, // 允许取多久以内的缓存位置
        timeout: options3.highAccuracyExpireTime
    };
    if (((_a = options3.type) === null || _a === void 0 ? void 0 : _a.toUpperCase()) !== "WGS84") {
        return handle3.fail({
            errMsg: "This coordinate system type is not temporarily supported"
        });
    }
    const geolocationSupported = navigator.geolocation;
    if (!geolocationSupported) {
        return handle3.fail({
            errMsg: "The current browser does not support this feature"
        });
    }
    return new Promise((resolve, reject)=>{
        navigator.geolocation.getCurrentPosition((position)=>{
            const result = {
                /** 位置的精确度 */ accuracy: position.coords.accuracy,
                /** 高度，单位 m */ altitude: position.coords.altitude,
                /** 水平精度，单位 m */ horizontalAccuracy: position.coords.accuracy,
                /** 纬度，范围为 -90~90，负数表示南纬 */ latitude: position.coords.latitude,
                /** 经度，范围为 -180~180，负数表示西经 */ longitude: position.coords.longitude,
                /** 速度，单位 m/s */ speed: position.coords.speed,
                /** 垂直精度，单位 m（Android 无法获取，返回 0） */ verticalAccuracy: position.coords.altitudeAccuracy || 0,
                /** 调用结果,自动补充 */ errMsg: ""
            };
            handle3.success(result, {
                resolve,
                reject
            });
        }, (error)=>{
            handle3.fail({
                errMsg: error.message
            }, {
                resolve,
                reject
            });
        }, positionOptions);
    });
};
var getLocation = processOpenApi({
    name: "getLocation",
    standardMethod: getLocationByW3CApi
});
// node_modules/@tarojs/taro-h5/dist/api/location/chooseLocation.js
var import_query_string4 = __toESM(require_query_string());
var container = null;
function createLocationChooser(handler, key = LOCATION_APIKEY, mapOpt = {}) {
    var _a, _b, _c;
    const { latitude, longitude } = mapOpt, opts = __rest(mapOpt, [
        "latitude",
        "longitude"
    ]);
    const query = Object.assign({
        key,
        type: 1,
        coord: ((_a = mapOpt.coord) !== null && _a !== void 0 ? _a : [
            latitude,
            longitude
        ].every((e)=>Number(e) >= 0)) ? `${latitude},${longitude}` : void 0,
        referer: "myapp"
    }, opts);
    if (!container) {
        const html2 = `
<div class='taro_choose_location'>
  <div class='taro_choose_location_bar'>
    <div class='taro_choose_location_back'></div>
    <p class='taro_choose_location_title'>\u4F4D\u7F6E</p>
    <button class='taro_choose_location_submit'>\u5B8C\u6210</button>
  </div>
  <iframe class='taro_choose_location_frame' frameborder='0' src="https://apis.map.qq.com/tools/locpicker?${(0, import_query_string4.stringify)(query, {
            arrayFormat: "comma",
            skipNull: true
        })}" />
</div>
`;
        container = document.createElement("div");
        container.innerHTML = html2;
    }
    const main = container.querySelector(".taro_choose_location");
    function show() {
        setTimeout(()=>{
            main.style.top = "0";
        });
    }
    function hide() {
        main.style.top = "100%";
    }
    function back() {
        hide();
        handler({
            errMsg: "cancel"
        });
    }
    function submit2() {
        hide();
        handler();
    }
    function remove3() {
        container === null || container === void 0 ? void 0 : container.remove();
        container = null;
        window.removeEventListener("popstate", back);
    }
    (_b = container.querySelector(".taro_choose_location_back")) === null || _b === void 0 ? void 0 : _b.addEventListener("click", back);
    (_c = container.querySelector(".taro_choose_location_submit")) === null || _c === void 0 ? void 0 : _c.addEventListener("click", submit2);
    window.addEventListener("popstate", back);
    return {
        show,
        remove: remove3,
        container
    };
}
var chooseLocation = ({ success, fail, complete, mapOpts } = {})=>{
    const key = LOCATION_APIKEY;
    const handle3 = new MethodHandler({
        name: "chooseLocation",
        success,
        fail,
        complete
    });
    return new Promise((resolve, reject)=>{
        const chooseLocation2 = {};
        if (!key) {
            console.warn("chooseLocation api \u4F9D\u8D56\u817E\u8BAF\u5730\u56FE\u5B9A\u4F4Dapi\uFF0C\u9700\u8981\u5728 defineConstants \u4E2D\u914D\u7F6E LOCATION_APIKEY");
            return handle3.fail({
                errMsg: "LOCATION_APIKEY needed"
            }, {
                resolve,
                reject
            });
        }
        const onMessage = (event2)=>{
            const loc = event2.data;
            if (!loc || loc.module !== "locationPicker") return;
            chooseLocation2.name = loc.poiname;
            chooseLocation2.address = loc.poiaddress;
            chooseLocation2.latitude = loc.latlng.lat;
            chooseLocation2.longitude = loc.latlng.lng;
        };
        const chooser = createLocationChooser((res)=>{
            window.removeEventListener("message", onMessage, false);
            setTimeout(()=>{
                chooser.remove();
            }, 300);
            if (res) {
                return handle3.fail(res, {
                    resolve,
                    reject
                });
            } else {
                if (chooseLocation2.latitude && chooseLocation2.longitude) {
                    return handle3.success(chooseLocation2, {
                        resolve,
                        reject
                    });
                } else {
                    return handle3.fail({}, {
                        resolve,
                        reject
                    });
                }
            }
        }, key, mapOpts);
        document.body.appendChild(chooser.container);
        window.addEventListener("message", onMessage, false);
        chooser.show();
    });
};
// node_modules/@tarojs/taro-h5/dist/api/location/index.js
var stopLocationUpdate = temporarilyNotSupport("stopLocationUpdate");
var startLocationUpdateBackground = temporarilyNotSupport("startLocationUpdateBackground");
var startLocationUpdate = temporarilyNotSupport("startLocationUpdate");
var openLocation = processOpenApi({
    name: "openLocation",
    defaultOptions: {
        scale: 18
    }
});
var onLocationChangeError = temporarilyNotSupport("onLocationChangeError");
var onLocationChange = temporarilyNotSupport("onLocationChange");
var offLocationChangeError = temporarilyNotSupport("offLocationChangeError");
var offLocationChange = temporarilyNotSupport("offLocationChange");
var choosePoi = temporarilyNotSupport("choosePoi");
var getFuzzyLocation = temporarilyNotSupport("getFuzzyLocation");
// node_modules/@tarojs/taro-h5/dist/api/media/audio/InnerAudioContext.js
var InnerAudioContext = class {
    set autoplay(e) {
        this.setProperty("autoplay", e);
    }
    get autoplay() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.autoplay) || false;
    }
    get buffered() {
        const { currentTime = 0, buffered: timeRange } = this.Instance || {};
        if (timeRange) {
            for(let i2 = 0; i2 < timeRange.length; i2++){
                if (timeRange.start(i2) <= currentTime && timeRange.end(i2) >= currentTime) {
                    return timeRange.end(i2);
                }
            }
        }
        return 0;
    }
    get currentTime() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.currentTime) || 0;
    }
    set currentTime(e) {
        this.seek(e);
    }
    get duration() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.duration) || 0;
    }
    set loop(e) {
        this.setProperty("loop", e);
    }
    get loop() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.loop) || false;
    }
    get paused() {
        var _a, _b;
        return (_b = (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.paused) !== null && _b !== void 0 ? _b : true;
    }
    set src(e) {
        this.setProperty("src", e);
    }
    get src() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.src) || "";
    }
    set volume(e) {
        this.setProperty("volume", e);
    }
    get volume() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.volume) || 0;
    }
    set playbackRate(e) {
        this.setProperty("playbackRate", e);
    }
    get playbackRate() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.playbackRate) || 0;
    }
    set obeyMuteSwitch(_e) {
        permanentlyNotSupport("InnerAudioContext.obeyMuteSwitch")();
    }
    get obeyMuteSwitch() {
        return true;
    }
    set startTime(e) {
        this.__startTime = e;
    }
    get startTime() {
        return this.__startTime || 0;
    }
    set referrerPolicy(e) {
        var _a;
        (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.setAttribute("referrerpolicy", e);
    }
    get referrerPolicy() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.getAttribute("referrerpolicy")) || "origin";
    }
    setProperty(key, value) {
        if (this.Instance) {
            this.Instance[key] = value;
        }
    }
    constructor(){
        this.__startTime = 0;
        this.__isFirstPlay = true;
        this.play = ()=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.play();
        };
        this.pause = ()=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.pause();
        };
        this.stop = ()=>{
            this.pause();
            this.seek(0);
            this.stopStack.trigger();
        };
        this.seek = (position)=>{
            if (this.Instance) {
                this.Instance.currentTime = position;
            }
        };
        this.destroy = ()=>{
            this.stop();
            if (this.Instance) {
                this.Instance = void 0;
            }
        };
        this.onCanplay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("canplay", callback);
        };
        this.onPlay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("play", callback);
        };
        this.onPause = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("pause", callback);
        };
        this.onStop = (callback = ()=>{})=>this.stopStack.add(callback);
        this.onEnded = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("ended", callback);
        };
        this.onTimeUpdate = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("timeupdate", callback);
        };
        this.onError = (callback)=>this.errorStack.add(callback);
        this.onWaiting = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("waiting", callback);
        };
        this.onSeeking = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("seeking", callback);
        };
        this.onSeeked = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("seeked", callback);
        };
        this.offCanplay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("canplay", callback);
        };
        this.offPlay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("play", callback);
        };
        this.offPause = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("pause", callback);
        };
        this.offStop = (callback = ()=>{})=>this.stopStack.remove(callback);
        this.offEnded = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("ended", callback);
        };
        this.offTimeUpdate = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("timeupdate", callback);
        };
        this.offError = (callback = ()=>{})=>this.errorStack.remove(callback);
        this.offWaiting = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("waiting", callback);
        };
        this.offSeeking = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("seeking", callback);
        };
        this.offSeeked = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("seeked", callback);
        };
        this.Instance = new Audio();
        this.errorStack = new CallbackManager();
        this.stopStack = new CallbackManager();
        this.Instance.onerror = this.errorStack.trigger;
        Taro.eventCenter.on("__taroRouterChange", ()=>{
            this.stop();
        });
        this.onPlay(()=>{
            if (this.__isFirstPlay) {
                this.__isFirstPlay = false;
                this.seek(this.startTime);
            }
        });
    }
};
// node_modules/@tarojs/taro-h5/dist/api/media/audio/index.js
var stopVoice = temporarilyNotSupport("stopVoice");
var setInnerAudioOption = temporarilyNotSupport("setInnerAudioOption");
var playVoice = temporarilyNotSupport("playVoice");
var pauseVoice = temporarilyNotSupport("pauseVoice");
var getAvailableAudioSources = temporarilyNotSupport("getAvailableAudioSources");
var createWebAudioContext = temporarilyNotSupport("createWebAudioContext");
var createMediaAudioPlayer = temporarilyNotSupport("createMediaAudioPlayer");
var createInnerAudioContext = ()=>new InnerAudioContext();
var createAudioContext = temporarilyNotSupport("createAudioContext");
// node_modules/@tarojs/taro-h5/dist/api/media/background-audio/BackgroundAudioManager.js
var BackgroundAudioManager = class {
    set src(e) {
        this.setProperty("src", e);
    }
    get src() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.src) || "";
    }
    set startTime(e) {
        this.__startTime = e;
    }
    get startTime() {
        return this.__startTime || 0;
    }
    set title(e) {
        this.dataset("title", e);
    }
    get title() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.title) || "";
    }
    set epname(e) {
        this.dataset("epname", e);
    }
    get epname() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.epname) || "";
    }
    set singer(e) {
        this.dataset("singer", e);
    }
    get singer() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.singer) || "";
    }
    set coverImgUrl(e) {
        this.dataset("coverImgUrl", e);
    }
    get coverImgUrl() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.coverImgUrl) || "";
    }
    set webUrl(e) {
        this.dataset("webUrl", e);
    }
    get webUrl() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.webUrl) || "";
    }
    set protocol(e) {
        this.dataset("protocol", e);
    }
    get protocol() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.protocol) || "";
    }
    set playbackRate(e) {
        this.setProperty("playbackRate", e);
    }
    get playbackRate() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.playbackRate) || 0;
    }
    get duration() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.duration) || 0;
    }
    get currentTime() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.currentTime) || 0;
    }
    get paused() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.paused) || false;
    }
    get buffered() {
        const { currentTime = 0, buffered: timeRange } = this.Instance || {};
        if (timeRange) {
            for(let i2 = 0; i2 < timeRange.length; i2++){
                if (timeRange.start(i2) <= currentTime && timeRange.end(i2) >= currentTime) {
                    return timeRange.end(i2);
                }
            }
        }
        return 0;
    }
    set referrerPolicy(e) {
        var _a;
        (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.setAttribute("referrerpolicy", e);
    }
    get referrerPolicy() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.getAttribute("referrerpolicy")) || "origin";
    }
    setProperty(key, value) {
        if (this.Instance) {
            this.Instance[key] = value;
        }
    }
    dataset(key, value) {
        if (this.Instance) {
            this.Instance.dataset[key] = value;
        }
    }
    constructor(){
        this.__startTime = 0;
        this.play = ()=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.play();
        };
        this.pause = ()=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.pause();
        };
        this.seek = (position)=>{
            if (this.Instance) {
                this.Instance.currentTime = position;
            }
        };
        this.stop = ()=>{
            this.pause();
            this.seek(0);
            this.stopStack.trigger();
        };
        this.onCanplay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("canplay", callback);
        };
        this.onWaiting = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("waiting", callback);
        };
        this.onError = (callback)=>this.errorStack.add(callback);
        this.onPlay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("play", callback);
        };
        this.onPause = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("pause", callback);
        };
        this.onSeeking = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("seeking", callback);
        };
        this.onSeeked = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("seeked", callback);
        };
        this.onEnded = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("ended", callback);
        };
        this.onStop = (callback = ()=>{})=>this.stopStack.add(callback);
        this.onTimeUpdate = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("timeupdate", callback);
        };
        this.onPrev = permanentlyNotSupport("BackgroundAudioManager.onPrev");
        this.onNext = permanentlyNotSupport("BackgroundAudioManager.onNext");
        this.offCanplay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("canplay", callback);
        };
        this.offWaiting = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("waiting", callback);
        };
        this.offError = (callback = ()=>{})=>this.errorStack.remove(callback);
        this.offPlay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("play", callback);
        };
        this.offPause = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("pause", callback);
        };
        this.offSeeking = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("seeking", callback);
        };
        this.offSeeked = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("seeked", callback);
        };
        this.offEnded = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("ended", callback);
        };
        this.offStop = (callback = ()=>{})=>this.stopStack.remove(callback);
        this.offTimeUpdate = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("timeupdate", callback);
        };
        this.offPrev = permanentlyNotSupport("BackgroundAudioManager.offPrev");
        this.offNext = permanentlyNotSupport("BackgroundAudioManager.offNext");
        this.Instance = new Audio();
        this.errorStack = new CallbackManager();
        this.stopStack = new CallbackManager();
        this.Instance.onerror = this.errorStack.trigger;
        this.Instance.autoplay = true;
        this.onPlay(()=>{
            if (this.currentTime !== this.startTime) {
                this.seek(this.startTime);
            }
        });
    }
};
// node_modules/@tarojs/taro-h5/dist/api/media/background-audio/index.js
var stopBackgroundAudio = temporarilyNotSupport("stopBackgroundAudio");
var seekBackgroundAudio = temporarilyNotSupport("seekBackgroundAudio");
var playBackgroundAudio = temporarilyNotSupport("playBackgroundAudio");
var pauseBackgroundAudio = temporarilyNotSupport("pauseBackgroundAudio");
var onBackgroundAudioStop = temporarilyNotSupport("onBackgroundAudioStop");
var onBackgroundAudioPlay = temporarilyNotSupport("onBackgroundAudioPlay");
var onBackgroundAudioPause = temporarilyNotSupport("onBackgroundAudioPause");
var getBackgroundAudioPlayerState = temporarilyNotSupport("getBackgroundAudioPlayerState");
var getBackgroundAudioManager = ()=>new BackgroundAudioManager();
// node_modules/@tarojs/taro-h5/dist/api/media/camera.js
var createCameraContext = temporarilyNotSupport("createCameraContext");
// node_modules/@tarojs/taro-h5/dist/api/media/image/saveImageToPhotosAlbum.js
var saveImageToPhotosAlbum = (options3)=>{
    const methodName = "saveImageToPhotosAlbum";
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `${methodName}:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { filePath, success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: methodName,
        success,
        fail,
        complete
    });
    if (typeof filePath !== "string") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "filePath",
                correct: "String",
                wrong: filePath
            })
        });
    }
    createDownload(filePath);
    return handle3.success();
};
// node_modules/@tarojs/taro-h5/dist/api/media/image/getImageInfo.js
var getImageInfo = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `getImageInfo:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const getBase64Image = (image)=>{
        try {
            const canvas = document.createElement("canvas");
            canvas.width = image.width;
            canvas.height = image.height;
            const ctx = canvas.getContext("2d");
            ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0, image.width, image.height);
            return canvas.toDataURL("image/png");
        } catch (e) {
            console.error("getImageInfo:get base64 fail", e);
        }
    };
    const { src, success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: "getImageInfo",
        success,
        fail,
        complete
    });
    return new Promise((resolve, reject)=>{
        const image = new Image();
        image.crossOrigin = "";
        image.onload = ()=>{
            handle3.success({
                width: image.naturalWidth,
                height: image.naturalHeight,
                path: getBase64Image(image) || src
            }, {
                resolve,
                reject
            });
        };
        image.onerror = (e)=>{
            handle3.fail({
                errMsg: e.message
            }, {
                resolve,
                reject
            });
        };
        image.src = src;
    });
};
// node_modules/@tarojs/taro-h5/dist/api/media/image/previewImage.js
var previewImage = (options3)=>__awaiter(void 0, void 0, void 0, function*() {
        defineCustomElement();
        defineCustomElement2();
        function loadImage2(url, loadFail) {
            return new Promise((resolve)=>{
                const item = document.createElement("taro-swiper-item-core");
                item.style.cssText = "display:flex;align-items:start;justify-content:center;overflow-y:scroll;";
                const image = new Image();
                image.style.maxWidth = "100%";
                image.src = url;
                const div = document.createElement("div");
                div.classList.add("swiper-zoom-container");
                div.style.cssText = "display:flex;align-items:center;justify-content:center;max-width:100%;min-height:100%;";
                div.appendChild(image);
                item.appendChild(div);
                resolve(item);
                if (isFunction(loadFail)) {
                    image.addEventListener("error", (err)=>{
                        loadFail({
                            errMsg: err.message
                        });
                    });
                }
            });
        }
        const isObject6 = shouldBeObject(options3);
        if (!isObject6.flag) {
            const res = {
                errMsg: `previewImage:fail ${isObject6.msg}`
            };
            console.error(res.errMsg);
            return Promise.reject(res);
        }
        const { urls = [], current = "", success, fail, complete } = options3;
        const handle3 = new MethodHandler({
            name: "previewImage",
            success,
            fail,
            complete
        });
        const container2 = document.createElement("div");
        const removeHandler = ()=>{
            eventCenter.off("__taroRouterChange", removeHandler);
            container2.remove();
        };
        eventCenter.on("__taroRouterChange", removeHandler);
        container2.classList.add("preview-image");
        container2.style.cssText = "position:fixed;top:0;left:0;z-index:1050;width:100%;height:100%;overflow:hidden;outline:0;background-color:#111;";
        container2.addEventListener("click", removeHandler);
        const swiper = document.createElement("taro-swiper-core");
        swiper.full = true;
        swiper.zoom = true;
        let children2 = [];
        try {
            children2 = yield Promise.all(urls.map((e)=>loadImage2(e, fail)));
        } catch (error) {
            return handle3.fail({
                errMsg: error
            });
        }
        for(let i2 = 0; i2 < children2.length; i2++){
            const child = children2[i2];
            swiper.appendChild(child);
        }
        const currentIndex = typeof current === "number" ? current : urls.indexOf(current);
        swiper.current = currentIndex;
        container2.appendChild(swiper);
        document.body.appendChild(container2);
        return handle3.success();
    });
// node_modules/@tarojs/taro-h5/dist/api/media/video/chooseMedia.js
var import_is_mobile = __toESM(require_is_mobile());
// node_modules/@tarojs/taro-h5/dist/api/ui/animation/index.js
var StyleSheet = class {
    constructor(){
        this.$style = null;
        this.sheet = null;
        this.appendStyleSheet = ()=>{
            if (this.$style) {
                const head2 = document.getElementsByTagName("head")[0];
                this.$style.setAttribute("type", "text/css");
                this.$style.setAttribute("data-type", "Taro");
                head2.appendChild(this.$style);
                this.sheet = this.$style.sheet;
            }
            if (this.sheet && !("insertRule" in this.sheet)) {
                console.warn("\u5F53\u524D\u6D4F\u89C8\u5668\u4E0D\u652F\u6301 stylesheet.insertRule \u63A5\u53E3");
            }
        };
        this.add = (cssText, index2 = 0)=>{
            var _a;
            if (this.sheet === null) {
                this.appendStyleSheet();
            }
            (_a = this.sheet) === null || _a === void 0 ? void 0 : _a.insertRule(cssText, index2);
        };
        this.$style = document.createElement("style");
    }
};
var styleSheet = new StyleSheet();
var TRANSITION_END = "transitionend";
var TRANSFORM = "transform";
var $detect = document.createElement("div");
$detect.style.cssText = "-webkit-animation-name:webkit;-moz-animation-name:moz;-ms-animation-name:ms;animation-name:standard;";
if ($detect.style["animation-name"] === "standard") {
    TRANSITION_END = "transitionend";
    TRANSFORM = "transform";
} else if ($detect.style["-webkit-animation-name"] === "webkit") {
    TRANSITION_END = "webkitTransitionEnd";
    TRANSFORM = "-webkit-transform";
} else if ($detect.style["-moz-animation-name"] === "moz") {
    TRANSITION_END = "mozTransitionEnd";
    TRANSFORM = "-moz-transform";
} else if ($detect.style["-ms-animation-name"] === "ms") {
    TRANSITION_END = "msTransitionEnd";
    TRANSFORM = "-ms-transform";
}
var animId = 0;
var Animation = class {
    transformUnit(...args) {
        const ret = [];
        args.forEach((each2)=>{
            ret.push(isNaN(each2) ? each2 : `${each2}${this.unit}`);
        });
        return ret;
    }
    // 设置默认值
    setDefault(duration, delay, timingFunction, transformOrigin) {
        this.DEFAULT = {
            duration,
            delay,
            timingFunction,
            transformOrigin
        };
    }
    matrix(a, b, c, d, tx, ty) {
        this.transform.push(`matrix(${a}, ${b}, ${c}, ${d}, ${tx}, ${ty})`);
        return this;
    }
    matrix3d(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4) {
        this.transform.push(`matrix3d(${a1}, ${b1}, ${c1}, ${d1}, ${a2}, ${b2}, ${c2}, ${d2}, ${a3}, ${b3}, ${c3}, ${d3}, ${a4}, ${b4}, ${c4}, ${d4})`);
        return this;
    }
    rotate(angle) {
        this.transform.push(`rotate(${angle}deg)`);
        return this;
    }
    rotate3d(x, y, z, angle) {
        if (typeof y !== "number") {
            this.transform.push(`rotate3d(${x})`);
        } else {
            this.transform.push(`rotate3d(${x}, ${y || 0}, ${z || 0}, ${angle || 0}deg)`);
        }
        return this;
    }
    rotateX(angle) {
        this.transform.push(`rotateX(${angle}deg)`);
        return this;
    }
    rotateY(angle) {
        this.transform.push(`rotateY(${angle}deg)`);
        return this;
    }
    rotateZ(angle) {
        this.transform.push(`rotateZ(${angle}deg)`);
        return this;
    }
    scale(x, y) {
        this.transform.push(`scale(${x}, ${y})`);
        return this;
    }
    scale3d(x, y, z) {
        this.transform.push(`scale3d(${x}, ${y}, ${z})`);
        return this;
    }
    scaleX(scale) {
        this.transform.push(`scaleX(${scale})`);
        return this;
    }
    scaleY(scale) {
        this.transform.push(`scaleY(${scale})`);
        return this;
    }
    scaleZ(scale) {
        this.transform.push(`scaleZ(${scale})`);
        return this;
    }
    skew(x, y) {
        this.transform.push(`skew(${x}, ${y})`);
        return this;
    }
    skewX(angle) {
        this.transform.push(`skewX(${angle})`);
        return this;
    }
    skewY(angle) {
        this.transform.push(`skewY(${angle})`);
        return this;
    }
    translate(x, y) {
        [x, y] = this.transformUnit(x, y);
        this.transform.push(`translate(${x}, ${y})`);
        return this;
    }
    translate3d(x, y, z) {
        [x, y, z] = this.transformUnit(x, y, z);
        this.transform.push(`translate3d(${x}, ${y}, ${z})`);
        return this;
    }
    translateX(translate) {
        [translate] = this.transformUnit(translate);
        this.transform.push(`translateX(${translate})`);
        return this;
    }
    translateY(translate) {
        [translate] = this.transformUnit(translate);
        this.transform.push(`translateY(${translate})`);
        return this;
    }
    translateZ(translate) {
        [translate] = this.transformUnit(translate);
        this.transform.push(`translateZ(${translate})`);
        return this;
    }
    opacity(value) {
        this.rules.push(`opacity: ${value}`);
        return this;
    }
    backgroundColor(value) {
        this.rules.push(`background-color: ${value}`);
        return this;
    }
    width(value) {
        [value] = this.transformUnit(value);
        this.rules.push(`width: ${value}`);
        return this;
    }
    height(value) {
        [value] = this.transformUnit(value);
        this.rules.push(`height: ${value}`);
        return this;
    }
    top(value) {
        [value] = this.transformUnit(value);
        this.rules.push(`top: ${value}`);
        return this;
    }
    right(value) {
        [value] = this.transformUnit(value);
        this.rules.push(`right: ${value}`);
        return this;
    }
    bottom(value) {
        [value] = this.transformUnit(value);
        this.rules.push(`bottom: ${value}`);
        return this;
    }
    left(value) {
        [value] = this.transformUnit(value);
        this.rules.push(`left: ${value}`);
        return this;
    }
    // 关键帧载入
    step(arg = {}) {
        const { DEFAULT } = this;
        const { duration = DEFAULT.duration, delay = DEFAULT.delay, timingFunction = DEFAULT.timingFunction, transformOrigin = DEFAULT.transformOrigin } = arg;
        this.steps.push([
            this.rules.map((rule)=>`${rule}!important`).join(";"),
            `${this.transform.join(" ")}!important`,
            `${TRANSFORM}-origin: ${transformOrigin}`,
            `transition: all ${duration}ms ${timingFunction} ${delay}ms`
        ].filter((item)=>item !== "" && item !== `${TRANSFORM}:`).join(";"));
        this.rules = [];
        this.transform = [
            `${TRANSFORM}:`
        ];
        return this;
    }
    // 创建底层数据
    createAnimationData() {
        const animIndex = `taro-h5-poly-fill/${this.id}/create-animation__${this.animationMapCount++}`;
        this.animationMap[animIndex] = this.steps.length;
        this.steps.forEach((step, index2)=>{
            const selector = index2 === 0 ? `[animation="${animIndex}"], [data-animation="${animIndex}"]` : `[animation="${animIndex}--${index2}"], [data-animation="${animIndex}--${index2}"]`;
            styleSheet.add(`${selector} { ${step} }`);
        });
        this.steps = [];
        return animIndex;
    }
    // 动画数据产出
    export() {
        return this.createAnimationData();
    }
    constructor({ duration = 400, delay = 0, timingFunction = "linear", transformOrigin = "50% 50% 0", unit = "px" } = {}){
        this.rules = [];
        this.transform = [
            `${TRANSFORM}:`
        ];
        this.steps = [];
        this.animationMap = {};
        this.animationMapCount = 0;
        this.setDefault(duration, delay, timingFunction, transformOrigin);
        this.unit = unit;
        let animAttr = "animation";
        this.id = ++animId;
        document.body.addEventListener(TRANSITION_END, (e)=>{
            const target = e.target;
            if (target.getAttribute(animAttr) === null) {
                animAttr = "data-animation";
            }
            const animData = target.getAttribute(animAttr);
            if (animData === null) return;
            const [animName, animPath] = animData.split("__");
            if (animName === `taro-h5-poly-fill/${this.id}/create-animation`) {
                const [animIndex, __stepIndex = 0] = animPath.split("--");
                const stepIndex = Number(__stepIndex);
                const animStepsCount = this.animationMap[`${animName}__${animIndex}`];
                const animStepsMaxIndex = animStepsCount - 1;
                if (stepIndex < animStepsMaxIndex) {
                    target.setAttribute(animAttr, `${animName}__${animIndex}--${stepIndex + 1}`);
                    if (animAttr === "animation") {
                        target.setAttribute("data-animation", `${animName}__${animIndex}--${stepIndex + 1}`);
                    }
                }
            }
        });
    }
};
var createAnimation = (option)=>{
    return new Animation(option);
};
// node_modules/@tarojs/taro-h5/dist/api/ui/background.js
var setBackgroundTextStyle = temporarilyNotSupport("setBackgroundTextStyle");
var setBackgroundColor = temporarilyNotSupport("setBackgroundColor");
// node_modules/@tarojs/taro-h5/dist/api/ui/custom-component.js
var nextTick3 = Taro.nextTick;
// node_modules/@tarojs/taro-h5/dist/api/ui/fonts.js
var loadFontFace = (options3)=>__awaiter(void 0, void 0, void 0, function*() {
        options3 = Object.assign({
            global: false
        }, options3);
        const { success, fail, complete, family, source, desc = {} } = options3;
        const handle3 = new MethodHandler({
            name: "loadFontFace",
            success,
            fail,
            complete
        });
        const fonts = document.fonts;
        if (fonts) {
            const fontFace = new FontFace(family, source, desc);
            try {
                yield fontFace.load();
                fonts.add(fontFace);
                return handle3.success({
                    status: "loaded"
                });
            } catch (error) {
                return handle3.fail({
                    status: "error",
                    errMsg: error.message || error
                });
            }
        } else {
            const style = document.createElement("style");
            let innerText = `font-family:"${family}";src:${source};font-style:${desc.style || "normal"};font-weight:${desc.weight || "normal"};font-variant:${desc.variant || "normal"};`;
            if (desc.ascentOverride) {
                innerText += `ascent-override:${desc.ascentOverride};`;
            }
            if (desc.descentOverride) {
                innerText += `descent-override:${desc.descentOverride};`;
            }
            if (desc.featureSettings) {
                innerText += `font-feature-settings:${desc.featureSettings};`;
            }
            if (desc.lineGapOverride) {
                innerText += `line-gap-override:${desc.lineGapOverride};`;
            }
            if (desc.stretch) {
                innerText += `font-stretch:${desc.stretch};`;
            }
            if (desc.unicodeRange) {
                innerText += `unicode-range:${desc.unicodeRange};`;
            }
            if (desc.variationSettings) {
                innerText += `font-variation-settings:${desc.variationSettings};`;
            }
            style.innerText = `@font-face{${innerText}}`;
            document.head.appendChild(style);
            return handle3.success({
                status: "loaded"
            });
        }
    });
// node_modules/@tarojs/taro-h5/dist/api/ui/interaction/actionSheet.js
var noop = function() {};
var ActionSheet = class {
    create(options3 = {}) {
        return new Promise((resolve)=>{
            const { maskStyle, actionSheetStyle, menuStyle, cellStyle, cancelStyle } = this.style;
            const config = Object.assign(Object.assign({}, this.options), options3);
            this.lastConfig = config;
            this.el = document.createElement("div");
            this.el.className = "taro__actionSheet";
            this.el.style.opacity = "0";
            this.el.style.transition = "opacity 0.2s linear";
            this.mask = document.createElement("div");
            this.mask.setAttribute("style", inlineStyle(maskStyle));
            this.actionSheet = document.createElement("div");
            this.actionSheet.setAttribute("style", inlineStyle(actionSheetStyle));
            this.menu = document.createElement("div");
            this.menu.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, menuStyle), {
                color: config.itemColor
            })));
            this.cells = config.itemList.map((item, index2)=>{
                const cell = document.createElement("div");
                cell.className = "taro-actionsheet__cell";
                cell.setAttribute("style", inlineStyle(cellStyle));
                cell.textContent = item;
                cell.dataset.tapIndex = `${index2}`;
                cell.onclick = (e)=>{
                    this.hide();
                    const target = e.currentTarget;
                    const index3 = Number(target === null || target === void 0 ? void 0 : target.dataset.tapIndex) || 0;
                    resolve(index3);
                };
                return cell;
            });
            this.cancel = document.createElement("div");
            this.cancel.setAttribute("style", inlineStyle(cancelStyle));
            this.cancel.textContent = "\u53D6\u6D88";
            this.cells.forEach((item)=>this.menu.appendChild(item));
            this.actionSheet.appendChild(this.menu);
            this.actionSheet.appendChild(this.cancel);
            this.el.appendChild(this.mask);
            this.el.appendChild(this.actionSheet);
            const cb = ()=>{
                this.hide();
                resolve("cancel");
            };
            this.mask.onclick = cb;
            this.cancel.onclick = cb;
            document.body.appendChild(this.el);
            setTimeout(()=>{
                this.el.style.opacity = "1";
                setTransform(this.actionSheet, "translate(0, 0)");
            }, 0);
        });
    }
    show(options3 = {}) {
        return new Promise((resolve)=>{
            const config = Object.assign(Object.assign({}, this.options), options3);
            this.lastConfig = config;
            if (this.hideOpacityTimer) clearTimeout(this.hideOpacityTimer);
            if (this.hideDisplayTimer) clearTimeout(this.hideDisplayTimer);
            if (config.itemColor) this.menu.style.color = config.itemColor;
            const { cellStyle } = this.style;
            config.itemList.forEach((item, index2)=>{
                let cell;
                if (this.cells[index2]) {
                    cell = this.cells[index2];
                } else {
                    cell = document.createElement("div");
                    cell.className = "taro-actionsheet__cell";
                    cell.setAttribute("style", inlineStyle(cellStyle));
                    cell.dataset.tapIndex = `${index2}`;
                    this.cells.push(cell);
                    this.menu.appendChild(cell);
                }
                cell.textContent = item;
                cell.onclick = (e)=>{
                    this.hide();
                    const target = e.currentTarget;
                    const index3 = Number(target === null || target === void 0 ? void 0 : target.dataset.tapIndex) || 0;
                    resolve(index3);
                };
            });
            const cellsLen = this.cells.length;
            const itemListLen = config.itemList.length;
            if (cellsLen > itemListLen) {
                for(let i2 = itemListLen; i2 < cellsLen; i2++){
                    this.menu.removeChild(this.cells[i2]);
                }
                this.cells.splice(itemListLen);
            }
            const cb = ()=>{
                this.hide();
                resolve("cancel");
            };
            this.mask.onclick = cb;
            this.cancel.onclick = cb;
            this.el.style.display = "block";
            setTimeout(()=>{
                this.el.style.opacity = "1";
                setTransform(this.actionSheet, "translate(0, 0)");
            }, 0);
        });
    }
    hide() {
        if (this.hideOpacityTimer) clearTimeout(this.hideOpacityTimer);
        if (this.hideDisplayTimer) clearTimeout(this.hideDisplayTimer);
        this.hideOpacityTimer = setTimeout(()=>{
            this.el.style.opacity = "0";
            setTransform(this.actionSheet, "translate(0, 100%)");
            this.hideDisplayTimer = setTimeout(()=>{
                this.el.style.display = "none";
            }, 200);
        }, 0);
    }
    constructor(){
        this.options = {
            itemList: [],
            itemColor: "#000000",
            success: noop,
            fail: noop,
            complete: noop
        };
        this.style = {
            maskStyle: {
                position: "fixed",
                "z-index": "1000",
                top: "0",
                right: "0",
                left: "0",
                bottom: "0",
                background: "rgba(0,0,0,0.6)"
            },
            actionSheetStyle: {
                "z-index": "4999",
                position: "fixed",
                left: "0",
                bottom: "0",
                "-webkit-transform": "translate(0, 100%)",
                transform: "translate(0, 100%)",
                width: "100%",
                "line-height": "1.6",
                background: "#EFEFF4",
                "-webkit-transition": "-webkit-transform .3s",
                transition: "transform .3s"
            },
            menuStyle: {
                "background-color": "#FCFCFD"
            },
            cellStyle: {
                position: "relative",
                padding: "10px 0",
                "text-align": "center",
                "font-size": "18px"
            },
            cancelStyle: {
                "margin-top": "6px",
                padding: "10px 0",
                "text-align": "center",
                "font-size": "18px",
                color: "#000000",
                "background-color": "#FCFCFD"
            }
        };
        this.lastConfig = {};
    }
};
// node_modules/@tarojs/taro-h5/dist/api/ui/interaction/modal.js
var Modal = class {
    create(options3 = {}) {
        return new Promise((resolve)=>{
            var _a, _b;
            const { maskStyle, modalStyle, titleStyle, textStyle, footStyle, btnStyle } = this.style;
            const config = Object.assign(Object.assign({}, this.options), options3);
            this.el = document.createElement("div");
            this.el.className = "taro__modal";
            this.el.style.opacity = "0";
            this.el.style.transition = "opacity 0.2s linear";
            const eventHandler = (e)=>{
                e.stopPropagation();
                e.preventDefault();
            };
            const mask = document.createElement("div");
            mask.className = "taro-modal__mask";
            mask.setAttribute("style", inlineStyle(maskStyle));
            mask.ontouchmove = eventHandler;
            const modal2 = document.createElement("div");
            modal2.className = "taro-modal__content";
            modal2.setAttribute("style", inlineStyle(modalStyle));
            modal2.ontouchmove = eventHandler;
            const titleCSS = config.title ? titleStyle : Object.assign(Object.assign({}, titleStyle), {
                display: "none"
            });
            this.title = document.createElement("div");
            this.title.className = "taro-modal__title";
            this.title.setAttribute("style", inlineStyle(titleCSS));
            this.title.textContent = config.title;
            const textCSS = config.title ? textStyle : Object.assign(Object.assign({}, textStyle), {
                padding: "40px 20px 26px",
                color: "#353535"
            });
            this.text = document.createElement("div");
            this.text.className = "taro-modal__text";
            this.text.setAttribute("style", inlineStyle(textCSS));
            this.text.textContent = config.content;
            const foot = document.createElement("div");
            foot.className = "taro-modal__foot";
            foot.setAttribute("style", inlineStyle(footStyle));
            const cancelCSS = Object.assign(Object.assign({}, btnStyle), {
                color: config.cancelColor,
                display: config.showCancel ? "block" : "none"
            });
            this.cancel = document.createElement("div");
            this.cancel.className = "taro-model__btn taro-model__cancel";
            this.cancel.setAttribute("style", inlineStyle(cancelCSS));
            this.cancel.textContent = config.cancelText;
            this.cancel.onclick = ()=>{
                this.hide();
                resolve("cancel");
            };
            this.confirm = document.createElement("div");
            this.confirm.className = "taro-model__btn taro-model__confirm";
            this.confirm.setAttribute("style", inlineStyle(btnStyle));
            this.confirm.style.color = config.confirmColor;
            this.confirm.textContent = config.confirmText;
            this.confirm.onclick = ()=>{
                this.hide();
                resolve("confirm");
            };
            foot.appendChild(this.cancel);
            foot.appendChild(this.confirm);
            modal2.appendChild(this.title);
            modal2.appendChild(this.text);
            modal2.appendChild(foot);
            this.el.appendChild(mask);
            this.el.appendChild(modal2);
            document.body.appendChild(this.el);
            setTimeout(()=>{
                this.el.style.opacity = "1";
            }, 0);
            this.currentPath = (_b = (_a = Current.page) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : getCurrentPath();
        });
    }
    show(options3 = {}) {
        return new Promise((resolve)=>{
            var _a, _b;
            const config = Object.assign(Object.assign({}, this.options), options3);
            if (this.hideOpacityTimer) clearTimeout(this.hideOpacityTimer);
            if (this.hideDisplayTimer) clearTimeout(this.hideDisplayTimer);
            const { textStyle } = this.style;
            if (config.title) {
                this.title.textContent = config.title;
                this.title.style.display = "block";
                this.text.setAttribute("style", inlineStyle(textStyle));
            } else {
                this.title.textContent = "";
                this.title.style.display = "none";
                const textCSS = Object.assign(Object.assign({}, textStyle), {
                    padding: "40px 20px 26px",
                    color: "#353535"
                });
                this.text.setAttribute("style", inlineStyle(textCSS));
            }
            this.text.textContent = config.content || "";
            this.cancel.style.display = config.showCancel ? "block" : "none";
            this.cancel.textContent = config.cancelText || "";
            this.cancel.style.color = config.cancelColor || "";
            this.confirm.textContent = config.confirmText || "";
            this.confirm.style.color = config.confirmColor || "";
            this.cancel.onclick = ()=>{
                this.hide();
                resolve("cancel");
            };
            this.confirm.onclick = ()=>{
                this.hide();
                resolve("confirm");
            };
            this.el.style.display = "block";
            setTimeout(()=>{
                this.el.style.opacity = "1";
            }, 0);
            this.currentPath = (_b = (_a = Current.page) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : getCurrentPath();
        });
    }
    hide() {
        if (this.hideOpacityTimer) clearTimeout(this.hideOpacityTimer);
        if (this.hideDisplayTimer) clearTimeout(this.hideDisplayTimer);
        this.currentPath = null;
        this.hideOpacityTimer = setTimeout(()=>{
            this.el.style.opacity = "0";
            this.hideDisplayTimer = setTimeout(()=>{
                this.el.style.display = "none";
            }, 200);
        }, 0);
    }
    constructor(){
        this.options = {
            title: "",
            content: "",
            showCancel: true,
            cancelText: "\u53D6\u6D88",
            cancelColor: "#000000",
            confirmText: "\u786E\u5B9A",
            confirmColor: "#3CC51F"
        };
        this.style = {
            maskStyle: {
                position: "fixed",
                "z-index": "1000",
                top: "0",
                right: "0",
                left: "0",
                bottom: "0",
                background: "rgba(0,0,0,0.6)"
            },
            modalStyle: {
                "z-index": "4999",
                position: "fixed",
                top: "50%",
                left: "50%",
                transform: "translate(-50%, -50%)",
                width: "80%",
                "max-width": "300px",
                "border-radius": "3px",
                "text-align": "center",
                "line-height": "1.6",
                overflow: "hidden",
                background: "#FFFFFF"
            },
            titleStyle: {
                padding: "20px 24px 9px",
                "font-size": "18px"
            },
            textStyle: {
                padding: "0 24px 12px",
                "min-height": "40px",
                "font-size": "15px",
                "line-height": "1.3",
                color: "#808080"
            },
            footStyle: {
                position: "relative",
                "line-height": "48px",
                "font-size": "18px",
                display: "flex"
            },
            btnStyle: {
                position: "relative",
                "-webkit-box-flex": "1",
                "-webkit-flex": "1",
                flex: "1"
            }
        };
    }
};
// node_modules/@tarojs/taro-h5/dist/api/ui/interaction/toast.js
var Toast = class {
    create(options3 = {}, _type = "toast") {
        var _a, _b;
        const { maskStyle, toastStyle, successStyle, errrorStyle, loadingStyle, imageStyle, textStyle } = this.style;
        const config = Object.assign(Object.assign(Object.assign({}, this.options), options3), {
            _type
        });
        this.el = document.createElement("div");
        this.el.className = "taro__toast";
        this.el.style.opacity = "0";
        this.el.style.transition = "opacity 0.1s linear";
        this.el.ontouchmove = (e)=>{
            e.stopPropagation();
            e.preventDefault();
        };
        this.mask = document.createElement("div");
        this.mask.setAttribute("style", inlineStyle(maskStyle));
        this.mask.style.display = config.mask ? "block" : "none";
        this.icon = document.createElement("p");
        if (config.image) {
            this.icon.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, imageStyle), {
                "background-image": `url(${config.image})`
            })));
        } else {
            const iconStyle = config.icon === "loading" ? loadingStyle : config.icon === "error" ? errrorStyle : successStyle;
            this.icon.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, iconStyle), config.icon === "none" ? {
                display: "none"
            } : {})));
        }
        this.toast = document.createElement("div");
        this.toast.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, toastStyle), config.icon === "none" ? {
            "min-height": "0",
            padding: "10px 15px"
        } : {})));
        this.title = document.createElement("p");
        this.title.setAttribute("style", inlineStyle(textStyle));
        this.title.textContent = config.title;
        this.toast.appendChild(this.icon);
        this.toast.appendChild(this.title);
        this.el.appendChild(this.mask);
        this.el.appendChild(this.toast);
        document.body.appendChild(this.el);
        setTimeout(()=>{
            this.el.style.opacity = "1";
        }, 0);
        this.type = config._type;
        config.duration >= 0 && this.hide(config.duration, this.type);
        this.currentPath = (_b = (_a = Current.page) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : getCurrentPath();
        return "";
    }
    show(options3 = {}, _type = "toast") {
        var _a, _b;
        const config = Object.assign(Object.assign(Object.assign({}, this.options), options3), {
            _type
        });
        if (this.hideOpacityTimer) clearTimeout(this.hideOpacityTimer);
        if (this.hideDisplayTimer) clearTimeout(this.hideDisplayTimer);
        this.title.textContent = config.title || "";
        this.mask.style.display = config.mask ? "block" : "none";
        const { toastStyle, successStyle, errrorStyle, loadingStyle, imageStyle } = this.style;
        if (config.image) {
            this.icon.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, imageStyle), {
                "background-image": `url(${config.image})`
            })));
        } else {
            if (!config.image && config.icon) {
                const iconStyle = config.icon === "loading" ? loadingStyle : config.icon === "error" ? errrorStyle : successStyle;
                this.icon.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, iconStyle), config.icon === "none" ? {
                    display: "none"
                } : {})));
            }
        }
        this.toast.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, toastStyle), config.icon === "none" ? {
            "min-height": "0",
            padding: "10px 15px"
        } : {})));
        this.el.style.display = "block";
        setTimeout(()=>{
            this.el.style.opacity = "1";
        }, 0);
        this.type = config._type;
        config.duration >= 0 && this.hide(config.duration, this.type);
        this.currentPath = (_b = (_a = Current.page) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : getCurrentPath();
        return "";
    }
    hide(duration = 0, type = "") {
        if (type && type !== this.type) return;
        if (this.hideOpacityTimer) clearTimeout(this.hideOpacityTimer);
        if (this.hideDisplayTimer) clearTimeout(this.hideDisplayTimer);
        this.currentPath = null;
        this.hideOpacityTimer = setTimeout(()=>{
            this.el.style.opacity = "0";
            this.hideDisplayTimer = setTimeout(()=>{
                this.el.style.display = "none";
            }, 100);
        }, duration);
    }
    constructor(){
        this.options = {
            title: "",
            icon: "none",
            image: "",
            duration: 1500,
            mask: false
        };
        this.style = {
            maskStyle: {
                position: "fixed",
                "z-index": "1000",
                top: "0",
                right: "0",
                left: "0",
                bottom: "0"
            },
            toastStyle: {
                "z-index": "5000",
                "box-sizing": "border-box",
                display: "flex",
                "flex-direction": "column",
                "justify-content": "center",
                "-webkit-justify-content": "center",
                position: "fixed",
                top: "50%",
                left: "50%",
                "min-width": "120px",
                "max-width": "200px",
                "min-height": "120px",
                padding: "15px",
                transform: "translate(-50%, -50%)",
                "border-radius": "5px",
                "text-align": "center",
                "line-height": "1.6",
                color: "#FFFFFF",
                background: "rgba(17, 17, 17, 0.7)"
            },
            successStyle: {
                margin: "6px auto",
                width: "38px",
                height: "38px",
                background: "transparent url(data:image/svg+xml;base64,PHN2ZyB0PSIxNjM5NTQ4OTYzMjA0IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjQzNDgiIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIj48cGF0aCBkPSJNMjE5Ljk1MiA1MTIuNTc2bDIxMC40MzIgMjEwLjQzMi00NS4yNDggNDUuMjU2LTIxMC40MzItMjEwLjQzMnoiIHAtaWQ9IjQzNDkiIGZpbGw9IiNmZmZmZmYiPjwvcGF0aD48cGF0aCBkPSJNNzk5LjY3MiAyNjIuMjY0bDQ1LjI1NiA0NS4yNTYtNDYwLjQ2NCA0NjAuNDY0LTQ1LjI1Ni00NS4yNTZ6IiBwLWlkPSI0MzUwIiBmaWxsPSIjZmZmZmZmIj48L3BhdGg+PC9zdmc+) no-repeat",
                "background-size": "100%"
            },
            errrorStyle: {
                margin: "6px auto",
                width: "38px",
                height: "38px",
                background: "transparent url(data:image/svg+xml;base64,PHN2ZyB0PSIxNjM5NTUxMDU1MTgzIiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjE0MDc2IiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PHBhdGggZD0iTTUxMiA2NEMyNjQuNTggNjQgNjQgMjY0LjU4IDY0IDUxMnMyMDAuNTggNDQ4IDQ0OCA0NDggNDQ4LTIwMC41OCA0NDgtNDQ4Uzc1OS40MiA2NCA1MTIgNjR6IG0wIDc1MmEzNiAzNiAwIDEgMSAzNi0zNiAzNiAzNiAwIDAgMS0zNiAzNnogbTUxLjgzLTU1MS45NUw1NDggNjM2YTM2IDM2IDAgMCAxLTcyIDBsLTE1LjgzLTM3MS45NWMtMC4xLTEuMzMtMC4xNy0yLjY4LTAuMTctNC4wNWE1MiA1MiAwIDAgMSAxMDQgMGMwIDEuMzctMC4wNyAyLjcyLTAuMTcgNC4wNXoiIHAtaWQ9IjE0MDc3IiBmaWxsPSIjZmZmZmZmIj48L3BhdGg+PC9zdmc+) no-repeat",
                "background-size": "100%"
            },
            loadingStyle: {
                margin: "6px auto",
                width: "38px",
                height: "38px",
                "-webkit-animation": "taroLoading 1s steps(12, end) infinite",
                animation: "taroLoading 1s steps(12, end) infinite",
                background: "transparent url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTIwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PHBhdGggZmlsbD0ibm9uZSIgZD0iTTAgMGgxMDB2MTAwSDB6Ii8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjRTlFOUU5IiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgLTMwKSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iIzk4OTY5NyIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgzMCAxMDUuOTggNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjOUI5OTlBIiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKDYwIDc1Ljk4IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0EzQTFBMiIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSg5MCA2NSA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNBQkE5QUEiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoMTIwIDU4LjY2IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0IyQjJCMiIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgxNTAgNTQuMDIgNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjQkFCOEI5IiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKDE4MCA1MCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNDMkMwQzEiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTE1MCA0NS45OCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNDQkNCQ0IiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTEyMCA0MS4zNCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNEMkQyRDIiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTkwIDM1IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0RBREFEQSIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgtNjAgMjQuMDIgNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjRTJFMkUyIiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKC0zMCAtNS45OCA2NSkiLz48L3N2Zz4=) no-repeat",
                "background-size": "100%"
            },
            imageStyle: {
                margin: "6px auto",
                width: "40px",
                height: "40px",
                background: "transparent no-repeat",
                "background-size": "100%"
            },
            textStyle: {
                margin: "0",
                "font-size": "16px"
            }
        };
    }
};
// node_modules/@tarojs/taro-h5/dist/api/ui/interaction/index.js
var status = "default";
function init(doc3) {
    if (status === "ready") return;
    const taroStyle = doc3.createElement("style");
    taroStyle.textContent = '@font-face{font-weight:normal;font-style:normal;font-family:"taro";src:url("data:application/x-font-ttf;charset=utf-8;base64, AAEAAAALAIAAAwAwR1NVQrD+s+0AAAE4AAAAQk9TLzJWs0t/AAABfAAAAFZjbWFwqVgGvgAAAeAAAAGGZ2x5Zph7qG0AAANwAAAAdGhlYWQRFoGhAAAA4AAAADZoaGVhCCsD7AAAALwAAAAkaG10eAg0AAAAAAHUAAAADGxvY2EADAA6AAADaAAAAAhtYXhwAQ4AJAAAARgAAAAgbmFtZYrphEEAAAPkAAACVXBvc3S3shtSAAAGPAAAADUAAQAAA+gAAABaA+gAAAAAA+gAAQAAAAAAAAAAAAAAAAAAAAMAAQAAAAEAAADih+FfDzz1AAsD6AAAAADXB57LAAAAANcHnssAAP/sA+gDOgAAAAgAAgAAAAAAAAABAAAAAwAYAAEAAAAAAAIAAAAKAAoAAAD/AAAAAAAAAAEAAAAKAB4ALAABREZMVAAIAAQAAAAAAAAAAQAAAAFsaWdhAAgAAAABAAAAAQAEAAQAAAABAAgAAQAGAAAAAQAAAAAAAQK8AZAABQAIAnoCvAAAAIwCegK8AAAB4AAxAQIAAAIABQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUGZFZABAAHjqCAPoAAAAWgPoABQAAAABAAAAAAAAA+gAAABkAAAD6AAAAAAABQAAAAMAAAAsAAAABAAAAV4AAQAAAAAAWAADAAEAAAAsAAMACgAAAV4ABAAsAAAABgAEAAEAAgB46gj//wAAAHjqCP//AAAAAAABAAYABgAAAAEAAgAAAQYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAKAAAAAAAAAACAAAAeAAAAHgAAAABAADqCAAA6ggAAAACAAAAAAAAAAwAOgABAAD/7AAyABQAAgAANzMVFB4UKAAAAAABAAAAAAO7AzoAFwAAEy4BPwE+AR8BFjY3ATYWFycWFAcBBiInPQoGBwUHGgzLDCELAh0LHwsNCgr9uQoeCgGzCyEOCw0HCZMJAQoBvgkCCg0LHQv9sQsKAAAAAAAAEgDeAAEAAAAAAAAAHQAAAAEAAAAAAAEABAAdAAEAAAAAAAIABwAhAAEAAAAAAAMABAAoAAEAAAAAAAQABAAsAAEAAAAAAAUACwAwAAEAAAAAAAYABAA7AAEAAAAAAAoAKwA/AAEAAAAAAAsAEwBqAAMAAQQJAAAAOgB9AAMAAQQJAAEACAC3AAMAAQQJAAIADgC/AAMAAQQJAAMACADNAAMAAQQJAAQACADVAAMAAQQJAAUAFgDdAAMAAQQJAAYACADzAAMAAQQJAAoAVgD7AAMAAQQJAAsAJgFRCiAgQ3JlYXRlZCBieSBmb250LWNhcnJpZXIKICB3ZXVpUmVndWxhcndldWl3ZXVpVmVyc2lvbiAxLjB3ZXVpR2VuZXJhdGVkIGJ5IHN2ZzJ0dGYgZnJvbSBGb250ZWxsbyBwcm9qZWN0Lmh0dHA6Ly9mb250ZWxsby5jb20ACgAgACAAQwByAGUAYQB0AGUAZAAgAGIAeQAgAGYAbwBuAHQALQBjAGEAcgByAGkAZQByAAoAIAAgAHcAZQB1AGkAUgBlAGcAdQBsAGEAcgB3AGUAdQBpAHcAZQB1AGkAVgBlAHIAcwBpAG8AbgAgADEALgAwAHcAZQB1AGkARwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABzAHYAZwAyAHQAdABmACAAZgByAG8AbQAgAEYAbwBuAHQAZQBsAGwAbwAgAHAAcgBvAGoAZQBjAHQALgBoAHQAdABwADoALwAvAGYAbwBuAHQAZQBsAGwAbwAuAGMAbwBtAAAAAAIAAAAAAAAACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwECAQMBBAABeAd1bmlFQTA4AAAAAAA=") format("truetype");}@-webkit-keyframes taroLoading{0%{-webkit-transform:rotate3d(0, 0, 1, 0deg);}100%{-webkit-transform:rotate3d(0, 0, 1, 360deg);transform:rotate3d(0, 0, 1, 360deg);}}@keyframes taroLoading{0%{-webkit-transform:rotate3d(0, 0, 1, 0deg);}100%{-webkit-transform:rotate3d(0, 0, 1, 360deg);transform:rotate3d(0, 0, 1, 360deg);}}.taro-modal__foot:after {content: "";position: absolute;left: 0;top: 0;right: 0;height: 1px;border-top: 1px solid #D5D5D6;color: #D5D5D6;-webkit-transform-origin: 0 0;transform-origin: 0 0;-webkit-transform: scaleY(0.5);transform: scaleY(0.5);} .taro-model__btn:active {background-color: #EEEEEE}.taro-model__btn:not(:first-child):after {content: "";position: absolute;left: 0;top: 0;width: 1px;bottom: 0;border-left: 1px solid #D5D5D6;color: #D5D5D6;-webkit-transform-origin: 0 0;transform-origin: 0 0;-webkit-transform: scaleX(0.5);transform: scaleX(0.5);}.taro-actionsheet__cell:not(:first-child):after {content: "";position: absolute;left: 0;top: 0;right: 0;height: 1px;border-top: 1px solid #e5e5e5;color: #e5e5e5;-webkit-transform-origin: 0 0;transform-origin: 0 0;-webkit-transform: scaleY(0.5);transform: scaleY(0.5);}';
    doc3.querySelector("head").appendChild(taroStyle);
    status = "ready";
}
var toast = new Toast();
var modal = new Modal();
var actionSheet = new ActionSheet();
var showToast = (options3 = {
    title: ""
})=>{
    init(document);
    options3 = Object.assign({
        title: "",
        icon: "success",
        image: "",
        duration: 1500,
        mask: false
    }, options3);
    const { success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: "showToast",
        success,
        fail,
        complete
    });
    if (typeof options3.title !== "string") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "title",
                correct: "String",
                wrong: options3.title
            })
        });
    }
    if (typeof options3.duration !== "number") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "duration",
                correct: "Number",
                wrong: options3.duration
            })
        });
    }
    if (options3.image && typeof options3.image !== "string") options3.image = "";
    options3.mask = !!options3.mask;
    let errMsg = "";
    if (!toast.el) {
        errMsg = toast.create(options3, "toast");
    } else {
        errMsg = toast.show(options3, "toast");
    }
    return handle3.success({
        errMsg
    });
};
var hideToast = ({ noConflict = false, success, fail, complete } = {})=>{
    const handle3 = new MethodHandler({
        name: "hideToast",
        success,
        fail,
        complete
    });
    if (!toast.el) return handle3.success();
    toast.hide(0, noConflict ? "toast" : "");
    return handle3.success();
};
var showLoading = (options3 = {
    title: ""
})=>{
    init(document);
    options3 = Object.assign({
        title: "",
        mask: false
    }, options3);
    const { success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: "showLoading",
        success,
        fail,
        complete
    });
    const config = {
        icon: "loading",
        image: "",
        duration: -1
    };
    options3 = Object.assign({}, options3, config);
    if (typeof options3.title !== "string") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "title",
                correct: "String",
                wrong: options3.title
            })
        });
    }
    options3.mask = !!options3.mask;
    let errMsg = "";
    if (!toast.el) {
        errMsg = toast.create(options3, "loading");
    } else {
        errMsg = toast.show(options3, "loading");
    }
    return handle3.success({
        errMsg
    });
};
var hideLoading = ({ noConflict = false, success, fail, complete } = {})=>{
    const handle3 = new MethodHandler({
        name: "hideLoading",
        success,
        fail,
        complete
    });
    if (!toast.el) return handle3.success();
    toast.hide(0, noConflict ? "loading" : "");
    return handle3.success();
};
var showModal = (options3 = {})=>__awaiter(void 0, void 0, void 0, function*() {
        init(document);
        options3 = Object.assign({
            title: "",
            content: "",
            showCancel: true,
            cancelText: "\u53D6\u6D88",
            cancelColor: "#000000",
            confirmText: "\u786E\u5B9A",
            confirmColor: "#3CC51F"
        }, options3);
        const { success, fail, complete } = options3;
        const handle3 = new MethodHandler({
            name: "showModal",
            success,
            fail,
            complete
        });
        if (typeof options3.title !== "string") {
            return handle3.fail({
                errMsg: getParameterError({
                    para: "title",
                    correct: "String",
                    wrong: options3.title
                })
            });
        }
        if (typeof options3.content !== "string") {
            return handle3.fail({
                errMsg: getParameterError({
                    para: "content",
                    correct: "String",
                    wrong: options3.content
                })
            });
        }
        if (typeof options3.cancelText !== "string") {
            return handle3.fail({
                errMsg: getParameterError({
                    para: "cancelText",
                    correct: "String",
                    wrong: options3.cancelText
                })
            });
        }
        if (options3.cancelText.replace(/[\u0391-\uFFE5]/g, "aa").length > 8) {
            return handle3.fail({
                errMsg: "cancelText length should not larger then 4 Chinese characters"
            });
        }
        if (typeof options3.confirmText !== "string") {
            return handle3.fail({
                errMsg: getParameterError({
                    para: "confirmText",
                    correct: "String",
                    wrong: options3.confirmText
                })
            });
        }
        if (options3.confirmText.replace(/[\u0391-\uFFE5]/g, "aa").length > 8) {
            return handle3.fail({
                errMsg: "confirmText length should not larger then 4 Chinese characters"
            });
        }
        if (typeof options3.cancelColor !== "string") {
            return handle3.fail({
                errMsg: getParameterError({
                    para: "cancelColor",
                    correct: "String",
                    wrong: options3.cancelColor
                })
            });
        }
        if (typeof options3.confirmColor !== "string") {
            return handle3.fail({
                errMsg: getParameterError({
                    para: "confirmColor",
                    correct: "String",
                    wrong: options3.confirmColor
                })
            });
        }
        options3.showCancel = !!options3.showCancel;
        let result = "";
        if (!modal.el) {
            result = yield modal.create(options3);
        } else {
            result = yield modal.show(options3);
        }
        const res = {
            cancel: false,
            confirm: false
        };
        res[result] = true;
        return handle3.success(res);
    });
function hideModal() {
    if (!modal.el) return;
    modal.hide();
}
var showActionSheet = (options3 = {
    itemList: []
}, methodName = "showActionSheet")=>__awaiter(void 0, void 0, void 0, function*() {
        init(document);
        options3 = Object.assign({
            itemColor: "#000000",
            itemList: []
        }, options3);
        const { success, fail, complete } = options3;
        const handle3 = new MethodHandler({
            name: methodName,
            success,
            fail,
            complete
        });
        if (!Array.isArray(options3.itemList)) {
            return handle3.fail({
                errMsg: getParameterError({
                    para: "itemList",
                    correct: "Array",
                    wrong: options3.itemList
                })
            });
        }
        if (options3.itemList.length < 1) {
            return handle3.fail({
                errMsg: "parameter error: parameter.itemList should have at least 1 item"
            });
        }
        if (options3.itemList.length > 6) {
            return handle3.fail({
                errMsg: "parameter error: parameter.itemList should not be large than 6"
            });
        }
        for(let i2 = 0; i2 < options3.itemList.length; i2++){
            if (typeof options3.itemList[i2] !== "string") {
                return handle3.fail({
                    errMsg: getParameterError({
                        para: `itemList[${i2}]`,
                        correct: "String",
                        wrong: options3.itemList[i2]
                    })
                });
            }
        }
        if (typeof options3.itemColor !== "string") {
            return handle3.fail({
                errMsg: getParameterError({
                    para: "itemColor",
                    correct: "String",
                    wrong: options3.itemColor
                })
            });
        }
        let result = "";
        if (!actionSheet.el) {
            result = yield actionSheet.create(options3);
        } else {
            result = yield actionSheet.show(options3);
        }
        if (typeof result === "string") {
            return handle3.fail({
                errMsg: result
            });
        } else {
            return handle3.success({
                tapIndex: result
            });
        }
    });
Taro.eventCenter.on("__afterTaroRouterChange", ()=>{
    var _a, _b;
    if (toast.currentPath && toast.currentPath !== ((_a = Current.page) === null || _a === void 0 ? void 0 : _a.path)) {
        hideToast();
        hideLoading();
    }
    if (modal.currentPath && modal.currentPath !== ((_b = Current.page) === null || _b === void 0 ? void 0 : _b.path)) {
        hideModal();
    }
});
var enableAlertBeforeUnload = temporarilyNotSupport("enableAlertBeforeUnload");
var disableAlertBeforeUnload = temporarilyNotSupport("disableAlertBeforeUnload");
// node_modules/@tarojs/taro-h5/dist/api/ui/menu.js
var getMenuButtonBoundingClientRect = temporarilyNotSupport("getMenuButtonBoundingClientRect");
// node_modules/@tarojs/taro-h5/dist/api/ui/navigation-bar/index.js
var showNavigationBarLoading = temporarilyNotSupport("showNavigationBarLoading");
function setNavigationBarTitle(options3) {
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `setNavigationBarTitle:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { title, success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: "setNavigationBarTitle",
        success,
        fail,
        complete
    });
    if (!title || typeof title !== "string") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "title",
                correct: "String",
                wrong: title
            })
        });
    }
    setTitle(title);
    return handle3.success();
}
var setNavigationBarColor = (options3)=>{
    const { backgroundColor, success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: "setNavigationBarColor",
        success,
        fail,
        complete
    });
    const meta = document.createElement("meta");
    meta.setAttribute("name", "theme-color");
    meta.setAttribute("content", backgroundColor);
    document.head.appendChild(meta);
    return handle3.success();
};
var hideNavigationBarLoading = temporarilyNotSupport("hideNavigationBarLoading");
var hideHomeButton = temporarilyNotSupport("hideHomeButton");
// node_modules/@tarojs/taro-h5/dist/api/ui/pull-down-refresh.js
var startPullDownRefresh = function({ success, fail, complete } = {}) {
    const handle3 = new MethodHandler({
        name: "startPullDownRefresh",
        success,
        fail,
        complete
    });
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroStartPullDownRefresh", {
            successHandler: (res = {})=>handle3.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle3.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var stopPullDownRefresh = function({ success, fail, complete } = {}) {
    const handle3 = new MethodHandler({
        name: "stopPullDownRefresh",
        success,
        fail,
        complete
    });
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroStopPullDownRefresh", {
            successHandler: (res = {})=>handle3.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle3.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
// node_modules/@tarojs/taro-h5/dist/api/ui/scroll/index.js
var timer;
var FRAME_DURATION = 17;
var pageScrollTo = ({ scrollTop, selector = "", offsetTop = 0, duration = 300, success, fail, complete })=>{
    let scrollFunc;
    const handle3 = new MethodHandler({
        name: "pageScrollTo",
        success,
        fail,
        complete
    });
    return new Promise((resolve, reject)=>{
        var _a, _b, _c;
        try {
            if (scrollTop === void 0 && !selector) {
                return handle3.fail({
                    errMsg: 'scrollTop" \u6216 "selector" \u9700\u8981\u5176\u4E4B\u4E00'
                }, {
                    resolve,
                    reject
                });
            }
            const usingWindowScroll = (_a = window.__taroAppConfig) === null || _a === void 0 ? void 0 : _a.usingWindowScroll;
            const id = (_c = (_b = Current.page) === null || _b === void 0 ? void 0 : _b.path) === null || _c === void 0 ? void 0 : _c.replace(/([^a-z0-9\u00a0-\uffff_-])/ig, "\\$1");
            const el = id ? document.querySelector(`.taro_page#${id}`) : document.querySelector(".taro_page") || document.querySelector(".taro_router");
            if (!scrollFunc) {
                if (usingWindowScroll) {
                    scrollFunc = (pos)=>{
                        if (pos === void 0) {
                            return window.pageYOffset;
                        } else {
                            window.scrollTo(0, pos);
                        }
                    };
                } else {
                    scrollFunc = (pos)=>{
                        if (pos === void 0) {
                            return el.scrollTop;
                        } else {
                            el.scrollTop = pos;
                        }
                    };
                }
            }
            if (scrollTop && selector) {
                console.warn('"scrollTop" \u6216 "selector" \u5EFA\u8BAE\u53EA\u8BBE\u4E00\u4E2A\u503C\uFF0C\u5168\u90E8\u8BBE\u7F6E\u4F1A\u5FFD\u7565selector');
            }
            const from = scrollFunc();
            let to;
            if (selector) {
                const el2 = document.querySelector(selector);
                to = ((el2 === null || el2 === void 0 ? void 0 : el2.offsetTop) || 0) + offsetTop;
            } else {
                to = typeof scrollTop === "number" ? scrollTop : 0;
            }
            const delta = to - from;
            const frameCnt = duration / FRAME_DURATION;
            const easeFunc = getTimingFunc(easeInOut, frameCnt);
            const scroll3 = (frame = 0)=>{
                const dest = from + delta * easeFunc(frame);
                scrollFunc(dest);
                if (frame < frameCnt) {
                    timer && clearTimeout(timer);
                    timer = setTimeout(()=>{
                        scroll3(frame + 1);
                    }, FRAME_DURATION);
                } else {
                    return handle3.success({}, {
                        resolve,
                        reject
                    });
                }
            };
            scroll3();
        } catch (e) {
            return handle3.fail({
                errMsg: e.message
            }, {
                resolve,
                reject
            });
        }
    });
};
// node_modules/@tarojs/taro-h5/dist/api/ui/sticky.js
var setTopBarText = temporarilyNotSupport("setTopBarText");
// node_modules/@tarojs/taro-h5/dist/api/ui/tab-bar.js
var tabConf;
function initTabBarApis(config = {}) {
    tabConf = config.tabBar;
}
var showTabBarRedDot = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `showTabBarRedDot:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { index: index2, success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: "showTabBarRedDot",
        success,
        fail,
        complete
    });
    if (typeof index2 !== "number") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "index",
                correct: "Number",
                wrong: index2
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroShowTabBarRedDotHandler", {
            index: index2,
            successHandler: (res = {})=>handle3.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle3.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var showTabBar = (options3 = {})=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `showTabBar:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { animation, success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: "showTabBar",
        success,
        fail,
        complete
    });
    if (options3.hasOwnProperty("animation") && typeof animation !== "boolean") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "animation",
                correct: "Boolean",
                wrong: animation
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroShowTabBar", {
            animation,
            successHandler: (res = {})=>handle3.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle3.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var setTabBarStyle = (options3 = {})=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `setTabBarStyle:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { color, selectedColor, backgroundColor, borderStyle, success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: "setTabBarStyle",
        success,
        fail,
        complete
    });
    let errMsg;
    if (color && !isValidColor(color)) {
        errMsg = "color";
    } else if (selectedColor && !isValidColor(selectedColor)) {
        errMsg = "selectedColor";
    } else if (backgroundColor && !isValidColor(backgroundColor)) {
        errMsg = "backgroundColor";
    } else if (borderStyle && !/^(black|white)$/.test(borderStyle)) {
        errMsg = "borderStyle";
    }
    if (errMsg) {
        return handle3.fail({
            errMsg: `invalid ${errMsg}`
        });
    }
    if (!tabConf) {
        return handle3.fail();
    }
    const obj = {};
    if (color) obj.color = color;
    if (selectedColor) obj.selectedColor = selectedColor;
    if (backgroundColor) obj.backgroundColor = backgroundColor;
    if (borderStyle) obj.borderStyle = borderStyle;
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroSetTabBarStyle", {
            color,
            selectedColor,
            backgroundColor,
            borderStyle,
            successHandler: (res = {})=>handle3.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle3.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var setTabBarItem = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `setTabBarItem:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { index: index2, text: text2, iconPath, selectedIconPath, success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: "setTabBarItem",
        success,
        fail,
        complete
    });
    if (typeof index2 !== "number") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "index",
                correct: "Number",
                wrong: index2
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroSetTabBarItem", {
            index: index2,
            text: text2,
            iconPath,
            selectedIconPath,
            successHandler: (res = {})=>handle3.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle3.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var setTabBarBadge = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `setTabBarBadge:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { index: index2, text: text2, success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: "setTabBarBadge",
        success,
        fail,
        complete
    });
    if (typeof index2 !== "number") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "index",
                correct: "Number",
                wrong: index2
            })
        });
    }
    if (typeof text2 !== "string") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "text",
                correct: "String",
                wrong: text2
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroSetTabBarBadge", {
            index: index2,
            text: text2.replace(/[\u0391-\uFFE5]/g, "aa").length > 4 ? "..." : text2,
            successHandler: (res = {})=>handle3.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle3.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var removeTabBarBadge = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `removeTabBarBadge:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { index: index2, success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: "removeTabBarBadge",
        success,
        fail,
        complete
    });
    if (typeof index2 !== "number") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "index",
                correct: "Number",
                wrong: index2
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroRemoveTabBarBadge", {
            index: index2,
            successHandler: (res = {})=>handle3.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle3.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var hideTabBarRedDot = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `hideTabBarRedDot:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { index: index2, success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: "hideTabBarRedDot",
        success,
        fail,
        complete
    });
    if (typeof index2 !== "number") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "index",
                correct: "Number",
                wrong: index2
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroHideTabBarRedDotHandler", {
            index: index2,
            successHandler: (res = {})=>handle3.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle3.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var hideTabBar = (options3 = {})=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `hideTabBar:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { animation, success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: "hideTabBar",
        success,
        fail,
        complete
    });
    if (options3.hasOwnProperty("animation") && typeof animation !== "boolean") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "animation",
                correct: "Boolean",
                wrong: animation
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroHideTabBar", {
            animation,
            successHandler: (res = {})=>handle3.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle3.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
// node_modules/@tarojs/taro-h5/dist/api/ui/window.js
var callbackManager4 = new CallbackManager();
var resizeListener = ()=>{
    callbackManager4.trigger({
        windowWidth: window.screen.width,
        windowHeight: window.screen.height
    });
};
var setWindowSize = temporarilyNotSupport("setWindowSize");
var onWindowResize = (callback)=>{
    callbackManager4.add(callback);
    if (callbackManager4.count() === 1) {
        window.addEventListener("resize", resizeListener);
    }
};
var offWindowResize = (callback)=>{
    callbackManager4.remove(callback);
    if (callbackManager4.count() === 0) {
        window.removeEventListener("resize", resizeListener);
    }
};
var checkIsPictureInPictureActive = temporarilyNotSupport("checkIsPictureInPictureActive");
// node_modules/@tarojs/taro-h5/dist/api/media/video/chooseMedia.js
var chooseMedia = function(options3, methodName = "chooseMedia") {
    var _a;
    return __awaiter(this, void 0, void 0, function*() {
        const isObject6 = shouldBeObject(options3);
        if (!isObject6.flag) {
            const res2 = {
                errMsg: `${methodName}:fail ${isObject6.msg}`
            };
            console.error(res2.errMsg);
            return Promise.reject(res2);
        }
        const { count = 9, mediaId = "taroChooseMedia", mediaType = [
            "image",
            "video"
        ], sourceType = [
            "album",
            "camera"
        ], // sizeType = ['original', 'compressed'], // TODO 考虑通过 ffmpeg 支持压缩
        // maxDuration = 10, // TODO 考虑通过 ffmpeg 剪裁视频
        camera = "back", success, fail, complete } = options3;
        const handle3 = new MethodHandler({
            name: methodName,
            success,
            fail,
            complete
        });
        const withImage = mediaType.length < 1 || mediaType.indexOf("image") > -1;
        const withVideo = mediaType.length < 1 || mediaType.indexOf("video") > -1;
        const res = {
            tempFiles: [],
            type: withImage && withVideo ? "mix" : withImage ? "image" : "video"
        };
        if (count && typeof count !== "number") {
            res.errMsg = getParameterError({
                para: "count",
                correct: "Number",
                wrong: count
            });
            return handle3.fail(res);
        }
        let el = document.getElementById(mediaId);
        if (!el) {
            el = document.createElement("input");
            el.setAttribute("type", "file");
            el.setAttribute("id", mediaId);
            el.setAttribute("style", "position: fixed; top: -4000px; left: -3000px; z-index: -300;");
        }
        if (count > 1) {
            el.setAttribute("multiple", "multiple");
        } else {
            el.removeAttribute("multiple");
        }
        if ((0, import_is_mobile.isMobile)()) {
            if (sourceType.length > 1 || sourceType.length < 1) {
                try {
                    const { tapIndex } = yield showActionSheet({
                        itemList: [
                            "\u62CD\u6444",
                            "\u4ECE\u76F8\u518C\u9009\u62E9"
                        ]
                    }, methodName);
                    sourceType.splice(0, sourceType.length, tapIndex === 0 ? "camera" : "album");
                } catch (e) {
                    return handle3.fail({
                        errMsg: (_a = e.errMsg) === null || _a === void 0 ? void 0 : _a.replace("^.*:fail ", "")
                    });
                }
            }
        }
        if (sourceType.includes("camera")) {
            el.setAttribute("capture", camera === "front" ? "user" : "environment");
        } else {
            el.removeAttribute("capture");
        }
        if (res.type === "image") {
            el.setAttribute("accept", "image/*");
        } else if (res.type === "video") {
            el.setAttribute("accept", "video/*");
        } else {
            el.setAttribute("accept", "image/*, video/*");
        }
        return new Promise((resolve, reject)=>{
            if (!el) return;
            document.body.appendChild(el);
            el.onchange = function(e) {
                return __awaiter(this, void 0, void 0, function*() {
                    const target = e.target;
                    if (target) {
                        const files = target.files || [];
                        const arr = [
                            ...files
                        ];
                        yield Promise.all(arr.map((item)=>__awaiter(this, void 0, void 0, function*() {
                                var _a2;
                                try {
                                    (_a2 = res.tempFiles) === null || _a2 === void 0 ? void 0 : _a2.push((yield loadMedia(item)));
                                } catch (error) {
                                    console.error(error);
                                }
                            })));
                    }
                    handle3.success(res, {
                        resolve,
                        reject
                    });
                    target.value = "";
                });
            };
            el.onabort = ()=>handle3.fail({
                    errMsg: "abort"
                }, {
                    resolve,
                    reject
                });
            el.oncancel = ()=>handle3.fail({
                    errMsg: "cancel"
                }, {
                    resolve,
                    reject
                });
            el.onerror = (e)=>handle3.fail({
                    errMsg: e.toString()
                }, {
                    resolve,
                    reject
                });
            el.click();
        }).finally(()=>{
            if (!el) return;
            document.body.removeChild(el);
        });
        function loadMedia(file) {
            const dataUrl = URL.createObjectURL(file);
            const res2 = {
                tempFilePath: dataUrl,
                size: file.size,
                duration: 0,
                height: 0,
                width: 0,
                thumbTempFilePath: "",
                fileType: file.type,
                originalFileObj: file
            };
            if (/^video\//.test(res2.fileType)) {
                const video = document.createElement("video");
                const reader = new FileReader();
                video.crossOrigin = "Anonymous";
                video.preload = "metadata";
                video.src = res2.tempFilePath;
                return new Promise((resolve, reject)=>{
                    reader.onload = (event2)=>{
                        var _a2;
                        res2.tempFilePath = (_a2 = event2.target) === null || _a2 === void 0 ? void 0 : _a2.result;
                    };
                    reader.onerror = (e)=>reject(e);
                    reader.readAsDataURL(res2.originalFileObj);
                    video.onloadedmetadata = ()=>{
                        res2.duration = video.duration;
                        res2.height = video.videoHeight;
                        res2.width = video.videoWidth;
                    };
                    video.oncanplay = ()=>{
                        res2.thumbTempFilePath = getThumbTempFilePath(video, res2.height, res2.width, 0.8);
                        resolve(res2);
                    };
                    video.onerror = (e)=>reject(e);
                });
            } else {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = res2.tempFilePath;
                return new Promise((resolve, reject)=>{
                    if (img.complete) {
                        res2.height = img.height;
                        res2.width = img.width;
                        res2.thumbTempFilePath = getThumbTempFilePath(img, res2.height, res2.width, 0.8);
                        resolve(res2);
                    } else {
                        img.onload = ()=>{
                            res2.height = img.height;
                            res2.width = img.width;
                            res2.thumbTempFilePath = getThumbTempFilePath(img, res2.height, res2.width, 0.8);
                            resolve(res2);
                        };
                        img.onerror = (e)=>reject(e);
                    }
                });
            }
        }
        function getThumbTempFilePath(el2, height = 0, width = height, quality = 0.8) {
            const max = 256;
            const canvas = document.createElement("canvas");
            if (height > max || width > max) {
                const radio = height / width;
                if (radio > 1) {
                    height = max;
                    width = height / radio;
                } else {
                    width = max;
                    height = width * radio;
                }
            }
            canvas.height = height;
            canvas.width = width;
            const ctx = canvas.getContext("2d");
            ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(el2, 0, 0, canvas.width, canvas.height);
            return canvas.toDataURL("image/jpeg", quality);
        }
    });
};
// node_modules/@tarojs/taro-h5/dist/api/media/image/chooseImage.js
var chooseImage = function(options3) {
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `chooseImage:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    let camera = "back";
    const { sourceType = [
        "album",
        "camera"
    ], success, complete, fail } = options3, args = __rest(options3, [
        "sourceType",
        "success",
        "complete",
        "fail"
    ]);
    if (sourceType.includes("camera") && sourceType.indexOf("user") > -1) {
        camera = "front";
    }
    function parseRes(res) {
        const { tempFiles = [], errMsg } = res;
        return {
            tempFilePaths: tempFiles.map((item)=>item.tempFilePath),
            tempFiles: tempFiles.map((item)=>({
                    path: item.tempFilePath,
                    size: item.size,
                    type: item.fileType,
                    originalFileObj: item.originalFileObj
                })),
            errMsg
        };
    }
    return chooseMedia(Object.assign(Object.assign({
        mediaId: "taroChooseImage"
    }, args), {
        sourceType,
        mediaType: [
            "image"
        ],
        camera,
        success: (res)=>{
            const param = parseRes(res);
            success === null || success === void 0 ? void 0 : success(param);
            complete === null || complete === void 0 ? void 0 : complete(param);
        },
        fail: (err)=>{
            fail === null || fail === void 0 ? void 0 : fail(err);
            complete === null || complete === void 0 ? void 0 : complete(err);
        }
    }), "chooseImage").then(parseRes);
};
// node_modules/@tarojs/taro-h5/dist/api/media/image/index.js
var previewMedia = temporarilyNotSupport("previewMedia");
var compressImage = temporarilyNotSupport("compressImage");
var chooseMessageFile = permanentlyNotSupport("chooseMessageFile");
var editImage = temporarilyNotSupport("editImage");
var cropImage = temporarilyNotSupport("cropImage");
// node_modules/@tarojs/taro-h5/dist/api/media/live.js
var createLivePusherContext = temporarilyNotSupport("createLivePusherContext");
var createLivePlayerContext = temporarilyNotSupport("createLivePlayerContext");
// node_modules/@tarojs/taro-h5/dist/api/media/map.js
var createMapContext = temporarilyNotSupport("createMapContext");
// node_modules/@tarojs/taro-h5/dist/api/media/media-recorder.js
var createMediaRecorder = temporarilyNotSupport("createMediaRecorder");
// node_modules/@tarojs/taro-h5/dist/api/media/recorder.js
var stopRecord = temporarilyNotSupport("stopRecord");
var startRecord = temporarilyNotSupport("startRecord");
var getRecorderManager = temporarilyNotSupport("getRecorderManager");
// node_modules/@tarojs/taro-h5/dist/api/media/video/saveVideoToPhotosAlbum.js
var saveVideoToPhotosAlbum = (options3)=>{
    const methodName = "saveVideoToPhotosAlbum";
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `${methodName}:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { filePath, success, fail, complete } = options3;
    const handle3 = new MethodHandler({
        name: methodName,
        success,
        fail,
        complete
    });
    if (typeof filePath !== "string") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "filePath",
                correct: "String",
                wrong: filePath
            })
        });
    }
    createDownload(filePath);
    return handle3.success();
};
// node_modules/whatwg-fetch/fetch.js
var g = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
typeof global !== "undefined" && global || {};
var support = {
    searchParams: "URLSearchParams" in g,
    iterable: "Symbol" in g && "iterator" in Symbol,
    blob: "FileReader" in g && "Blob" in g && function() {
        try {
            new Blob();
            return true;
        } catch (e) {
            return false;
        }
    }(),
    formData: "FormData" in g,
    arrayBuffer: "ArrayBuffer" in g
};
function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj);
}
if (support.arrayBuffer) {
    viewClasses = [
        "[object Int8Array]",
        "[object Uint8Array]",
        "[object Uint8ClampedArray]",
        "[object Int16Array]",
        "[object Uint16Array]",
        "[object Int32Array]",
        "[object Uint32Array]",
        "[object Float32Array]",
        "[object Float64Array]"
    ];
    isArrayBufferView = ArrayBuffer.isView || function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
    };
}
var viewClasses;
var isArrayBufferView;
function normalizeName(name) {
    if (typeof name !== "string") {
        name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
        throw new TypeError('Invalid character in header field name: "' + name + '"');
    }
    return name.toLowerCase();
}
function normalizeValue(value) {
    if (typeof value !== "string") {
        value = String(value);
    }
    return value;
}
function iteratorFor(items) {
    var iterator = {
        next: function() {
            var value = items.shift();
            return {
                done: value === void 0,
                value
            };
        }
    };
    if (support.iterable) {
        iterator[Symbol.iterator] = function() {
            return iterator;
        };
    }
    return iterator;
}
function Headers(headers) {
    this.map = {};
    if (headers instanceof Headers) {
        headers.forEach(function(value, name) {
            this.append(name, value);
        }, this);
    } else if (Array.isArray(headers)) {
        headers.forEach(function(header) {
            if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
            }
            this.append(header[0], header[1]);
        }, this);
    } else if (headers) {
        Object.getOwnPropertyNames(headers).forEach(function(name) {
            this.append(name, headers[name]);
        }, this);
    }
}
Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ", " + value : value;
};
Headers.prototype["delete"] = function(name) {
    delete this.map[normalizeName(name)];
};
Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null;
};
Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name));
};
Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
};
Headers.prototype.forEach = function(callback, thisArg) {
    for(var name in this.map){
        if (this.map.hasOwnProperty(name)) {
            callback.call(thisArg, this.map[name], name, this);
        }
    }
};
Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
        items.push(name);
    });
    return iteratorFor(items);
};
Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
        items.push(value);
    });
    return iteratorFor(items);
};
Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
        items.push([
            name,
            value
        ]);
    });
    return iteratorFor(items);
};
if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}
function consumed(body) {
    if (body._noBody) return;
    if (body.bodyUsed) {
        return Promise.reject(new TypeError("Already read"));
    }
    body.bodyUsed = true;
}
function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
        reader.onload = function() {
            resolve(reader.result);
        };
        reader.onerror = function() {
            reject(reader.error);
        };
    });
}
function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise;
}
function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
    var encoding = match ? match[1] : "utf-8";
    reader.readAsText(blob, encoding);
    return promise;
}
function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);
    for(var i2 = 0; i2 < view.length; i2++){
        chars[i2] = String.fromCharCode(view[i2]);
    }
    return chars.join("");
}
function bufferClone(buf) {
    if (buf.slice) {
        return buf.slice(0);
    } else {
        var view = new Uint8Array(buf.byteLength);
        view.set(new Uint8Array(buf));
        return view.buffer;
    }
}
function Body() {
    this.bodyUsed = false;
    this._initBody = function(body) {
        this.bodyUsed = this.bodyUsed;
        this._bodyInit = body;
        if (!body) {
            this._noBody = true;
            this._bodyText = "";
        } else if (typeof body === "string") {
            this._bodyText = body;
        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
        } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([
                this._bodyArrayBuffer
            ]);
        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
            this._bodyArrayBuffer = bufferClone(body);
        } else {
            this._bodyText = body = Object.prototype.toString.call(body);
        }
        if (!this.headers.get("content-type")) {
            if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
        }
    };
    if (support.blob) {
        this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
                return rejected;
            }
            if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([
                    this._bodyArrayBuffer
                ]));
            } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
            } else {
                return Promise.resolve(new Blob([
                    this._bodyText
                ]));
            }
        };
    }
    this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
            var isConsumed = consumed(this);
            if (isConsumed) {
                return isConsumed;
            } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
            } else {
                return Promise.resolve(this._bodyArrayBuffer);
            }
        } else if (support.blob) {
            return this.blob().then(readBlobAsArrayBuffer);
        } else {
            throw new Error("could not read as ArrayBuffer");
        }
    };
    this.text = function() {
        var rejected = consumed(this);
        if (rejected) {
            return rejected;
        }
        if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
        } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
        } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
        } else {
            return Promise.resolve(this._bodyText);
        }
    };
    if (support.formData) {
        this.formData = function() {
            return this.text().then(decode);
        };
    }
    this.json = function() {
        return this.text().then(JSON.parse);
    };
    return this;
}
var methods = [
    "CONNECT",
    "DELETE",
    "GET",
    "HEAD",
    "OPTIONS",
    "PATCH",
    "POST",
    "PUT",
    "TRACE"
];
function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input, options3) {
    if (!(this instanceof Request)) {
        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
    }
    options3 = options3 || {};
    var body = options3.body;
    if (input instanceof Request) {
        if (input.bodyUsed) {
            throw new TypeError("Already read");
        }
        this.url = input.url;
        this.credentials = input.credentials;
        if (!options3.headers) {
            this.headers = new Headers(input.headers);
        }
        this.method = input.method;
        this.mode = input.mode;
        this.signal = input.signal;
        if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
        }
    } else {
        this.url = String(input);
    }
    this.credentials = options3.credentials || this.credentials || "same-origin";
    if (options3.headers || !this.headers) {
        this.headers = new Headers(options3.headers);
    }
    this.method = normalizeMethod(options3.method || this.method || "GET");
    this.mode = options3.mode || this.mode || null;
    this.signal = options3.signal || this.signal || function() {
        if ("AbortController" in g) {
            var ctrl = new AbortController();
            return ctrl.signal;
        }
    }();
    this.referrer = null;
    if ((this.method === "GET" || this.method === "HEAD") && body) {
        throw new TypeError("Body not allowed for GET or HEAD requests");
    }
    this._initBody(body);
    if (this.method === "GET" || this.method === "HEAD") {
        if (options3.cache === "no-store" || options3.cache === "no-cache") {
            var reParamSearch = /([?&])_=[^&]*/;
            if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + /* @__PURE__ */ new Date().getTime());
            } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + /* @__PURE__ */ new Date().getTime();
            }
        }
    }
}
Request.prototype.clone = function() {
    return new Request(this, {
        body: this._bodyInit
    });
};
function decode(body) {
    var form = new FormData();
    body.trim().split("&").forEach(function(bytes) {
        if (bytes) {
            var split2 = bytes.split("=");
            var name = split2.shift().replace(/\+/g, " ");
            var value = split2.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
    });
    return form;
}
function parseHeaders(rawHeaders) {
    var headers = new Headers();
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
    preProcessedHeaders.split("\r").map(function(header) {
        return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
    }).forEach(function(line) {
        var parts = line.split(":");
        var key = parts.shift().trim();
        if (key) {
            var value = parts.join(":").trim();
            try {
                headers.append(key, value);
            } catch (error) {
                console.warn("Response " + error.message);
            }
        }
    });
    return headers;
}
Body.call(Request.prototype);
function Response(bodyInit, options3) {
    if (!(this instanceof Response)) {
        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
    }
    if (!options3) {
        options3 = {};
    }
    this.type = "default";
    this.status = options3.status === void 0 ? 200 : options3.status;
    if (this.status < 200 || this.status > 599) {
        throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
    }
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = options3.statusText === void 0 ? "" : "" + options3.statusText;
    this.headers = new Headers(options3.headers);
    this.url = options3.url || "";
    this._initBody(bodyInit);
}
Body.call(Response.prototype);
Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
    });
};
Response.error = function() {
    var response = new Response(null, {
        status: 200,
        statusText: ""
    });
    response.ok = false;
    response.status = 0;
    response.type = "error";
    return response;
};
var redirectStatuses = [
    301,
    302,
    303,
    307,
    308
];
Response.redirect = function(url, status2) {
    if (redirectStatuses.indexOf(status2) === -1) {
        throw new RangeError("Invalid status code");
    }
    return new Response(null, {
        status: status2,
        headers: {
            location: url
        }
    });
};
var DOMException2 = g.DOMException;
try {
    new DOMException2();
} catch (err) {
    DOMException2 = function(message, name) {
        this.message = message;
        this.name = name;
        var error = Error(message);
        this.stack = error.stack;
    };
    DOMException2.prototype = Object.create(Error.prototype);
    DOMException2.prototype.constructor = DOMException2;
}
function fetch2(input, init23) {
    return new Promise(function(resolve, reject) {
        var request2 = new Request(input, init23);
        if (request2.signal && request2.signal.aborted) {
            return reject(new DOMException2("Aborted", "AbortError"));
        }
        var xhr = new XMLHttpRequest();
        function abortXhr() {
            xhr.abort();
        }
        xhr.onload = function() {
            var options3 = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
            };
            if (request2.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options3.status = 200;
            } else {
                options3.status = xhr.status;
            }
            options3.url = "responseURL" in xhr ? xhr.responseURL : options3.headers.get("X-Request-URL");
            var body = "response" in xhr ? xhr.response : xhr.responseText;
            setTimeout(function() {
                resolve(new Response(body, options3));
            }, 0);
        };
        xhr.onerror = function() {
            setTimeout(function() {
                reject(new TypeError("Network request failed"));
            }, 0);
        };
        xhr.ontimeout = function() {
            setTimeout(function() {
                reject(new TypeError("Network request timed out"));
            }, 0);
        };
        xhr.onabort = function() {
            setTimeout(function() {
                reject(new DOMException2("Aborted", "AbortError"));
            }, 0);
        };
        function fixUrl(url) {
            try {
                return url === "" && g.location.href ? g.location.href : url;
            } catch (e) {
                return url;
            }
        }
        xhr.open(request2.method, fixUrl(request2.url), true);
        if (request2.credentials === "include") {
            xhr.withCredentials = true;
        } else if (request2.credentials === "omit") {
            xhr.withCredentials = false;
        }
        if ("responseType" in xhr) {
            if (support.blob) {
                xhr.responseType = "blob";
            } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
            }
        }
        if (init23 && typeof init23.headers === "object" && !(init23.headers instanceof Headers || g.Headers && init23.headers instanceof g.Headers)) {
            var names = [];
            Object.getOwnPropertyNames(init23.headers).forEach(function(name) {
                names.push(normalizeName(name));
                xhr.setRequestHeader(name, normalizeValue(init23.headers[name]));
            });
            request2.headers.forEach(function(value, name) {
                if (names.indexOf(name) === -1) {
                    xhr.setRequestHeader(name, value);
                }
            });
        } else {
            request2.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
            });
        }
        if (request2.signal) {
            request2.signal.addEventListener("abort", abortXhr);
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                    request2.signal.removeEventListener("abort", abortXhr);
                }
            };
        }
        xhr.send(typeof request2._bodyInit === "undefined" ? null : request2._bodyInit);
    });
}
fetch2.polyfill = true;
if (!g.fetch) {
    g.fetch = fetch2;
    g.Headers = Headers;
    g.Request = Request;
    g.Response = Response;
}
// node_modules/@tarojs/taro-h5/dist/api/media/video/getVideoInfo.js
var getVideoInfo = function(options3) {
    return __awaiter(this, void 0, void 0, function*() {
        const isObject6 = shouldBeObject(options3);
        if (!isObject6.flag) {
            const res2 = {
                errMsg: `getVideoInfo:fail ${isObject6.msg}`
            };
            console.error(res2.errMsg);
            return Promise.reject(res2);
        }
        const res = {
            orientation: "up",
            type: "",
            duration: 0,
            size: 0,
            height: 0,
            width: 0,
            fps: 30,
            bitrate: 0
        };
        const { src, success, fail, complete } = options3;
        const handle3 = new MethodHandler({
            name: "getVideoInfo",
            success,
            fail,
            complete
        });
        if (typeof src !== "string") {
            res.errMsg = getParameterError({
                para: "src",
                correct: "String",
                wrong: src
            });
            return handle3.fail(res);
        }
        const video = document.createElement("video");
        video.crossOrigin = "Anonymous";
        video.preload = "metadata";
        video.src = src;
        return new Promise((resolve, reject)=>{
            video.onloadedmetadata = ()=>{
                res.duration = video.duration;
                res.height = video.videoHeight;
                res.width = video.videoWidth;
                fetch(src).then((e)=>__awaiter(this, void 0, void 0, function*() {
                        const blob = yield e.blob();
                        res.type = blob.type;
                        res.size = blob.size;
                        res.bitrate = blob.size / video.duration;
                        handle3.success(res, {
                            resolve,
                            reject
                        });
                    })).catch((e)=>{
                    handle3.fail({
                        errMsg: e.toString()
                    }, {
                        resolve,
                        reject
                    });
                });
            };
        });
    });
};
// node_modules/@tarojs/taro-h5/dist/api/media/video/chooseVideo.js
var chooseVideo = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `chooseVideo:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { sourceType = [
        "album",
        "camera"
    ], // TODO 考虑通过 ffmpeg 支持压缩
    // compressed = true,
    maxDuration = 60, camera = "back", success, fail, complete } = options3;
    function parseRes(res) {
        const { tempFiles = [], errMsg } = res;
        const [video] = tempFiles;
        return Object.assign(Object.assign({}, video), {
            errMsg
        });
    }
    return chooseMedia({
        mediaId: "taroChooseVideo",
        sourceType,
        mediaType: [
            "video"
        ],
        maxDuration,
        camera,
        success: (res)=>{
            const param = parseRes(res);
            success === null || success === void 0 ? void 0 : success(param);
            complete === null || complete === void 0 ? void 0 : complete(param);
        },
        fail: (err)=>{
            fail === null || fail === void 0 ? void 0 : fail(err);
            complete === null || complete === void 0 ? void 0 : complete(err);
        }
    }, "chooseVideo").then(parseRes);
};
// node_modules/@tarojs/taro-h5/dist/api/media/video/index.js
var openVideoEditor = temporarilyNotSupport("openVideoEditor");
var createVideoContext = (id, inst)=>{
    const el = findDOM(inst);
    return el === null || el === void 0 ? void 0 : el.querySelector(`taro-video-core[id=${id}]`);
};
var compressVideo = temporarilyNotSupport("compressVideo");
// node_modules/@tarojs/taro-h5/dist/api/media/video-decoder.js
var createVideoDecoder = temporarilyNotSupport("createVideoDecoder");
// node_modules/@tarojs/taro-h5/dist/api/media/video-processing.js
var createMediaContainer = temporarilyNotSupport("createMediaContainer");
// node_modules/@tarojs/taro-h5/dist/api/media/voip.js
var updateVoIPChatMuteConfig = temporarilyNotSupport("updateVoIPChatMuteConfig");
var subscribeVoIPVideoMembers = temporarilyNotSupport("subscribeVoIPVideoMembers");
var setEnable1v1Chat = temporarilyNotSupport("setEnable1v1Chat");
var onVoIPVideoMembersChanged = temporarilyNotSupport("onVoIPVideoMembersChanged");
var onVoIPChatStateChanged = temporarilyNotSupport("onVoIPChatStateChanged");
var onVoIPChatSpeakersChanged = temporarilyNotSupport("onVoIPChatSpeakersChanged");
var onVoIPChatMembersChanged = temporarilyNotSupport("onVoIPChatMembersChanged");
var onVoIPChatInterrupted = temporarilyNotSupport("onVoIPChatInterrupted");
var offVoIPChatSpeakersChanged = temporarilyNotSupport("offVoIPChatSpeakersChanged");
var offVoIPVideoMembersChanged = temporarilyNotSupport("offVoIPVideoMembersChanged");
var offVoIPChatStateChanged = temporarilyNotSupport("offVoIPChatStateChanged");
var offVoIPChatMembersChanged = temporarilyNotSupport("offVoIPChatMembersChanged");
var offVoIPChatInterrupted = temporarilyNotSupport("offVoIPChatInterrupted");
var joinVoIPChat = temporarilyNotSupport("joinVoIPChat");
var join1v1Chat = temporarilyNotSupport("join1v1Chat");
var exitVoIPChat = temporarilyNotSupport("exitVoIPChat");
// node_modules/@tarojs/taro-h5/dist/api/navigate/index.js
var openEmbeddedMiniProgram = temporarilyNotSupport("openEmbeddedMiniProgram");
var navigateToMiniProgram = temporarilyNotSupport("navigateToMiniProgram");
var navigateBackMiniProgram = temporarilyNotSupport("navigateBackMiniProgram");
var exitMiniProgram = temporarilyNotSupport("exitMiniProgram");
var openBusinessView = temporarilyNotSupport("openBusinessView");
// node_modules/@tarojs/taro-h5/dist/api/network/utils.js
var NETWORK_TIMEOUT = 6e4;
var XHR_STATS = {
    UNSENT: 0,
    OPENED: 1,
    HEADERS_RECEIVED: 2,
    LOADING: 3,
    DONE: 4
};
var setHeader = (xhr, header)=>{
    let headerKey;
    for(headerKey in header){
        xhr.setRequestHeader(headerKey, header[headerKey]);
    }
};
var convertObjectUrlToBlob = (url)=>{
    return new Promise((resolve, reject)=>{
        const xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.responseType = "blob";
        xhr.withCredentials = true;
        xhr.onload = function() {
            if (this.status === 200) {
                resolve(this.response);
            } else {
                reject({
                    status: this.status
                });
            }
        };
        xhr.send();
    });
};
// node_modules/@tarojs/taro-h5/dist/api/network/download.js
var createDownloadTask = ({ url, header, withCredentials = true, timeout, success, error })=>{
    let timeoutInter;
    const apiName = "downloadFile";
    const xhr = new XMLHttpRequest();
    const callbackManager5 = {
        headersReceived: new CallbackManager(),
        progressUpdate: new CallbackManager()
    };
    xhr.open("GET", url, true);
    xhr.withCredentials = !!withCredentials;
    xhr.responseType = "blob";
    setHeader(xhr, header);
    xhr.onprogress = (e)=>{
        const { loaded, total } = e;
        callbackManager5.progressUpdate.trigger({
            progress: Math.round(loaded / total * 100),
            totalBytesWritten: loaded,
            totalBytesExpectedToWrite: total
        });
    };
    xhr.onreadystatechange = ()=>{
        if (xhr.readyState !== XHR_STATS.HEADERS_RECEIVED) return;
        callbackManager5.headersReceived.trigger({
            header: xhr.getAllResponseHeaders()
        });
    };
    xhr.onload = ()=>{
        const response = xhr.response;
        const status2 = xhr.status;
        success({
            errMsg: `${apiName}:ok`,
            statusCode: status2,
            tempFilePath: window.URL.createObjectURL(response)
        });
    };
    xhr.onabort = ()=>{
        clearTimeout(timeoutInter);
        error({
            errMsg: `${apiName}:fail abort`
        });
    };
    xhr.onerror = (e)=>{
        error({
            errMsg: `${apiName}:fail ${e.message}`
        });
    };
    const abort = ()=>{
        xhr.abort();
    };
    const send = ()=>{
        xhr.send();
        timeoutInter = setTimeout(()=>{
            xhr.onabort = null;
            xhr.onload = null;
            xhr.onprogress = null;
            xhr.onreadystatechange = null;
            xhr.onerror = null;
            abort();
            error({
                errMsg: `${apiName}:fail timeout`
            });
        }, timeout || NETWORK_TIMEOUT);
    };
    send();
    const onHeadersReceived = callbackManager5.headersReceived.add;
    const offHeadersReceived = callbackManager5.headersReceived.remove;
    const onProgressUpdate = callbackManager5.progressUpdate.add;
    const offProgressUpdate = callbackManager5.progressUpdate.remove;
    return {
        abort,
        onHeadersReceived,
        offHeadersReceived,
        onProgressUpdate,
        offProgressUpdate
    };
};
var downloadFile = ({ url, header, withCredentials, timeout, success, fail, complete })=>{
    let task;
    const result = new Promise((resolve, reject)=>{
        task = createDownloadTask({
            url,
            header,
            withCredentials,
            timeout,
            success: (res)=>{
                success && success(res);
                complete && complete(res);
                resolve(res);
            },
            error: (res)=>{
                fail && fail(res);
                complete && complete(res);
                reject(res);
            }
        });
    });
    result.headersReceive = task.onHeadersReceived.bind(task);
    result.progress = task.onProgressUpdate.bind(task);
    const properties = {};
    Object.keys(task).forEach((key)=>{
        properties[key] = {
            get () {
                return typeof task[key] === "function" ? task[key].bind(task) : task[key];
            }
        };
    });
    return Object.defineProperties(result, properties);
};
// node_modules/@tarojs/taro-h5/dist/api/network/mdns.js
var stopLocalServiceDiscovery = temporarilyNotSupport("stopLocalServiceDiscovery");
var startLocalServiceDiscovery = temporarilyNotSupport("startLocalServiceDiscovery");
var onLocalServiceResolveFail = temporarilyNotSupport("onLocalServiceResolveFail");
var onLocalServiceLost = temporarilyNotSupport("onLocalServiceLost");
var onLocalServiceFound = temporarilyNotSupport("onLocalServiceFound");
var onLocalServiceDiscoveryStop = temporarilyNotSupport("onLocalServiceDiscoveryStop");
var offLocalServiceResolveFail = temporarilyNotSupport("offLocalServiceResolveFail");
var offLocalServiceLost = temporarilyNotSupport("offLocalServiceLost");
var offLocalServiceFound = temporarilyNotSupport("offLocalServiceFound");
var offLocalServiceDiscoveryStop = temporarilyNotSupport("offLocalServiceDiscoveryStop");
// node_modules/abortcontroller-polyfill/dist/abortcontroller-polyfill-only.js
(function(factory) {
    false ? (false)(factory) : factory();
})(function() {
    "use strict";
    function _arrayLikeToArray(r, a) {
        (null == a || a > r.length) && (a = r.length);
        for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
        return n;
    }
    function _assertThisInitialized2(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e;
    }
    function _callSuper(t, o, e) {
        return o = _getPrototypeOf2(o), _possibleConstructorReturn(t, _isNativeReflectConstruct2() ? Reflect.construct(o, e || [], _getPrototypeOf2(t).constructor) : o.apply(t, e));
    }
    function _classCallCheck(a, n) {
        if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties2(e, r) {
        for(var t = 0; t < r.length; t++){
            var o = r[t];
            o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
        }
    }
    function _createClass2(e, r, t) {
        return r && _defineProperties2(e.prototype, r), t && _defineProperties2(e, t), Object.defineProperty(e, "prototype", {
            writable: false
        }), e;
    }
    function _createForOfIteratorHelper(r, e) {
        var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
        if (!t) {
            if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
                t && (r = t);
                var n = 0, F = function() {};
                return {
                    s: F,
                    n: function() {
                        return n >= r.length ? {
                            done: true
                        } : {
                            done: false,
                            value: r[n++]
                        };
                    },
                    e: function(r2) {
                        throw r2;
                    },
                    f: F
                };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var o, a = true, u = false;
        return {
            s: function() {
                t = t.call(r);
            },
            n: function() {
                var r2 = t.next();
                return a = r2.done, r2;
            },
            e: function(r2) {
                u = true, o = r2;
            },
            f: function() {
                try {
                    a || null == t.return || t.return();
                } finally{
                    if (u) throw o;
                }
            }
        };
    }
    function _get() {
        return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
            var p = _superPropBase(e, t);
            if (p) {
                var n = Object.getOwnPropertyDescriptor(p, t);
                return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
            }
        }, _get.apply(null, arguments);
    }
    function _getPrototypeOf2(t) {
        return _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
            return t2.__proto__ || Object.getPrototypeOf(t2);
        }, _getPrototypeOf2(t);
    }
    function _inherits(t, e) {
        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
        t.prototype = Object.create(e && e.prototype, {
            constructor: {
                value: t,
                writable: true,
                configurable: true
            }
        }), Object.defineProperty(t, "prototype", {
            writable: false
        }), e && _setPrototypeOf2(t, e);
    }
    function _isNativeReflectConstruct2() {
        try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t2) {}
        return (_isNativeReflectConstruct2 = function() {
            return !!t;
        })();
    }
    function _possibleConstructorReturn(t, e) {
        if (e && ("object" == typeof e || "function" == typeof e)) return e;
        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
        return _assertThisInitialized2(t);
    }
    function _setPrototypeOf2(t, e) {
        return _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
            return t2.__proto__ = e2, t2;
        }, _setPrototypeOf2(t, e);
    }
    function _superPropBase(t, o) {
        for(; !({}).hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf2(t)););
        return t;
    }
    function _superPropGet(t, o, e, r) {
        var p = _get(_getPrototypeOf2(1 & r ? t.prototype : t), o, e);
        return 2 & r && "function" == typeof p ? function(t2) {
            return p.apply(e, t2);
        } : p;
    }
    function _toPrimitive(t, r) {
        if ("object" != typeof t || !t) return t;
        var e = t[Symbol.toPrimitive];
        if (void 0 !== e) {
            var i2 = e.call(t, r || "default");
            if ("object" != typeof i2) return i2;
            throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === r ? String : Number)(t);
    }
    function _toPropertyKey(t) {
        var i2 = _toPrimitive(t, "string");
        return "symbol" == typeof i2 ? i2 : i2 + "";
    }
    function _unsupportedIterableToArray(r, a) {
        if (r) {
            if ("string" == typeof r) return _arrayLikeToArray(r, a);
            var t = ({}).toString.call(r).slice(8, -1);
            return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
        }
    }
    (function(self2) {
        return {
            NativeAbortSignal: self2.AbortSignal,
            NativeAbortController: self2.AbortController
        };
    })(typeof self !== "undefined" ? self : global);
    function createAbortEvent(reason) {
        var event2;
        try {
            event2 = new Event("abort");
        } catch (e) {
            if (typeof document !== "undefined") {
                if (!document.createEvent) {
                    event2 = document.createEventObject();
                    event2.type = "abort";
                } else {
                    event2 = document.createEvent("Event");
                    event2.initEvent("abort", false, false);
                }
            } else {
                event2 = {
                    type: "abort",
                    bubbles: false,
                    cancelable: false
                };
            }
        }
        event2.reason = reason;
        return event2;
    }
    function normalizeAbortReason(reason) {
        if (reason === void 0) {
            if (typeof document === "undefined") {
                reason = new Error("This operation was aborted");
                reason.name = "AbortError";
            } else {
                try {
                    reason = new DOMException("signal is aborted without reason");
                    Object.defineProperty(reason, "name", {
                        value: "AbortError"
                    });
                } catch (err) {
                    reason = new Error("This operation was aborted");
                    reason.name = "AbortError";
                }
            }
        }
        return reason;
    }
    var Emitter = function() {
        function Emitter2() {
            _classCallCheck(this, Emitter2);
            Object.defineProperty(this, "listeners", {
                value: {},
                writable: true,
                configurable: true
            });
        }
        return _createClass2(Emitter2, [
            {
                key: "addEventListener",
                value: function addEventListener(type, callback, options3) {
                    if (!(type in this.listeners)) {
                        this.listeners[type] = [];
                    }
                    this.listeners[type].push({
                        callback,
                        options: options3
                    });
                }
            },
            {
                key: "removeEventListener",
                value: function removeEventListener(type, callback) {
                    if (!(type in this.listeners)) {
                        return;
                    }
                    var stack = this.listeners[type];
                    for(var i2 = 0, l = stack.length; i2 < l; i2++){
                        if (stack[i2].callback === callback) {
                            stack.splice(i2, 1);
                            return;
                        }
                    }
                }
            },
            {
                key: "dispatchEvent",
                value: function dispatchEvent(event2) {
                    var _this = this;
                    if (!(event2.type in this.listeners)) {
                        return;
                    }
                    var stack = this.listeners[event2.type];
                    var stackToCall = stack.slice();
                    var _loop = function _loop2() {
                        var listener = stackToCall[i2];
                        try {
                            listener.callback.call(_this, event2);
                        } catch (e) {
                            Promise.resolve().then(function() {
                                throw e;
                            });
                        }
                        if (listener.options && listener.options.once) {
                            _this.removeEventListener(event2.type, listener.callback);
                        }
                    };
                    for(var i2 = 0, l = stackToCall.length; i2 < l; i2++){
                        _loop();
                    }
                    return !event2.defaultPrevented;
                }
            }
        ]);
    }();
    var AbortSignal = function(_Emitter) {
        function AbortSignal2() {
            var _this2;
            _classCallCheck(this, AbortSignal2);
            _this2 = _callSuper(this, AbortSignal2);
            if (!_this2.listeners) {
                Emitter.call(_this2);
            }
            Object.defineProperty(_this2, "aborted", {
                value: false,
                writable: true,
                configurable: true
            });
            Object.defineProperty(_this2, "onabort", {
                value: null,
                writable: true,
                configurable: true
            });
            Object.defineProperty(_this2, "reason", {
                value: void 0,
                writable: true,
                configurable: true
            });
            return _this2;
        }
        _inherits(AbortSignal2, _Emitter);
        return _createClass2(AbortSignal2, [
            {
                key: "toString",
                value: function toString3() {
                    return "[object AbortSignal]";
                }
            },
            {
                key: "dispatchEvent",
                value: function dispatchEvent(event2) {
                    if (event2.type === "abort") {
                        this.aborted = true;
                        if (typeof this.onabort === "function") {
                            this.onabort.call(this, event2);
                        }
                    }
                    _superPropGet(AbortSignal2, "dispatchEvent", this, 3)([
                        event2
                    ]);
                }
            },
            {
                key: "throwIfAborted",
                value: function throwIfAborted() {
                    var aborted = this.aborted, _this$reason = this.reason, reason = _this$reason === void 0 ? "Aborted" : _this$reason;
                    if (!aborted) return;
                    throw reason;
                }
            }
        ], [
            {
                key: "timeout",
                value: function timeout(time) {
                    var controller = new AbortController2();
                    setTimeout(function() {
                        return controller.abort(new DOMException("This signal is timeout in ".concat(time, "ms"), "TimeoutError"));
                    }, time);
                    return controller.signal;
                }
            },
            {
                key: "any",
                value: function any(iterable) {
                    var controller = new AbortController2();
                    function abort() {
                        controller.abort(this.reason);
                        clean();
                    }
                    function clean() {
                        var _iterator = _createForOfIteratorHelper(iterable), _step;
                        try {
                            for(_iterator.s(); !(_step = _iterator.n()).done;){
                                var signal2 = _step.value;
                                signal2.removeEventListener("abort", abort);
                            }
                        } catch (err) {
                            _iterator.e(err);
                        } finally{
                            _iterator.f();
                        }
                    }
                    var _iterator2 = _createForOfIteratorHelper(iterable), _step2;
                    try {
                        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                            var signal = _step2.value;
                            if (signal.aborted) {
                                controller.abort(signal.reason);
                                break;
                            } else signal.addEventListener("abort", abort);
                        }
                    } catch (err) {
                        _iterator2.e(err);
                    } finally{
                        _iterator2.f();
                    }
                    return controller.signal;
                }
            }
        ]);
    }(Emitter);
    var AbortController2 = function() {
        function AbortController3() {
            _classCallCheck(this, AbortController3);
            Object.defineProperty(this, "signal", {
                value: new AbortSignal(),
                writable: true,
                configurable: true
            });
        }
        return _createClass2(AbortController3, [
            {
                key: "abort",
                value: function abort(reason) {
                    var signalReason = normalizeAbortReason(reason);
                    var event2 = createAbortEvent(signalReason);
                    this.signal.reason = signalReason;
                    this.signal.dispatchEvent(event2);
                }
            },
            {
                key: "toString",
                value: function toString3() {
                    return "[object AbortController]";
                }
            }
        ]);
    }();
    if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        AbortController2.prototype[Symbol.toStringTag] = "AbortController";
        AbortSignal.prototype[Symbol.toStringTag] = "AbortSignal";
    }
    function polyfillNeeded(self2) {
        if (self2.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
            console.log("__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill");
            return true;
        }
        return typeof self2.Request === "function" && !self2.Request.prototype.hasOwnProperty("signal") || !self2.AbortController;
    }
    (function(self2) {
        if (!polyfillNeeded(self2)) {
            return;
        }
        self2.AbortController = AbortController2;
        self2.AbortSignal = AbortSignal;
    })(typeof self !== "undefined" ? self : global);
});
// node_modules/jsonp-retry/dist/jsonp.esm.js
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty12 = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
    if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
}
function shouldUseNative() {
    try {
        if (!Object.assign) {
            return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
        }
        var test2 = {};
        for(var i2 = 0; i2 < 10; i2++){
            test2["_" + String.fromCharCode(i2)] = i2;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
        });
        if (order2.join("") !== "0123456789") {
            return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
        }
        return true;
    } catch (err) {
        return false;
    }
}
var objectAssign$1 = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for(var s = 1; s < arguments.length; s++){
        from = Object(arguments[s]);
        for(var key in from){
            if (hasOwnProperty12.call(from, key)) {
                to[key] = from[key];
            }
        }
        if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for(var i2 = 0; i2 < symbols.length; i2++){
                if (propIsEnumerable.call(from, symbols[i2])) {
                    to[symbols[i2]] = from[symbols[i2]];
                }
            }
        }
    }
    return to;
};
var enc = encodeURIComponent;
function serializeParams2(params) {
    if (!params) {
        return "";
    }
    return Object.keys(params).map(function(item) {
        return item + "=" + enc(params[item]);
    }).join("&");
}
function isFunction3(fn) {
    return typeof fn === "function";
}
function getUrlQueryParamByName(url, name) {
    if (!url) {
        url = window.location.href;
    }
    name = name.replace(/[[]]/g, "\\$&");
    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)");
    var results = regex.exec(url);
    if (!results) {
        return null;
    }
    if (!results[2]) {
        return "";
    }
    return decodeURIComponent(results[2].replace(/\+/g, " "));
}
function updateQueryStringParamByName(url, name, value) {
    var re = new RegExp("([?&])" + name + "=.*?(&|$)", "i");
    var separator = url.indexOf("?") !== -1 ? "&" : "?";
    if (url.match(re)) {
        return url.replace(re, "$1" + name + "=" + value + "$2");
    }
    return url + separator + name + "=" + value;
}
var win$1 = typeof window !== "undefined" ? window : global;
var localStorageName = "localStorage";
var storage = win$1[localStorageName];
var store = {
    disabled: false,
    set: function set2(key, val) {
        if (val === void 0) {
            return store.remove(key);
        }
        storage.setItem(key, store.serialize(val));
        return val;
    },
    get: function get(key, defaultVal) {
        var val = store.deserialize(storage.getItem(key));
        return val === void 0 ? defaultVal : val;
    },
    remove: function remove(key) {
        storage.removeItem(key);
    },
    clear: function clear() {
        storage.clear();
    },
    has: function has(key) {
        return store.get(key) !== void 0;
    },
    forEach: function forEach2(callback) {
        for(var i2 = 0; i2 < storage.length; i2++){
            var key = storage.key(i2);
            callback(key, store.get(key));
        }
    },
    getAll: function getAll() {
        var ret = {};
        store.forEach(function(key, val) {
            ret[key] = val;
        });
        return ret;
    },
    serialize: function serialize(value) {
        return JSON.stringify(value);
    },
    deserialize: function deserialize(value) {
        if (typeof value !== "string") {
            return;
        }
        try {
            return JSON.parse(value);
        } catch (err) {
            return value || void 0;
        }
    }
};
try {
    testKey = "__store__";
    store.set(testKey, testKey);
    if (store.get(testKey) !== testKey) {
        store.disabled = true;
    }
    store.remove(testKey);
} catch (err) {
    store.disabled = true;
}
var testKey;
store.enabled = !store.disabled;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
} : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var win2 = typeof window !== "undefined" ? window : global;
var canUsePromise = function() {
    return "Promise" in win2 && _typeof(isFunction3(Promise));
}();
var noop2 = function noop3() {};
var encodeC = encodeURIComponent;
var doc2 = win2.document;
var head = doc2 ? doc2.head || doc2.getElementsByTagName("head")[0] : null;
var TIMEOUT_CONST = 2e3;
var defaultConfig = {
    timeout: TIMEOUT_CONST,
    retryTimes: 2,
    backup: null,
    params: {},
    jsonp: "callback",
    name: null,
    cache: false,
    useStore: false,
    storeCheck: null,
    storeSign: null,
    storeCheckKey: null,
    dataCheck: null,
    charset: "UTF-8"
};
var timestamp = /* @__PURE__ */ new Date().getTime();
function jsonp$1(url, opts, cb) {
    if (isFunction3(url)) {
        cb = url;
        opts = {};
    } else if (url && (typeof url === "undefined" ? "undefined" : _typeof(url)) === "object") {
        cb = opts;
        opts = url || {};
        url = opts.url;
    }
    if (isFunction3(opts)) {
        cb = opts;
        opts = {};
    }
    if (!opts) {
        opts = {};
    }
    opts = objectAssign$1({}, defaultConfig, opts);
    url = url || opts.url;
    cb = cb || noop2;
    if (!url || typeof url !== "string") {
        cb(new Error("Param url is needed!"));
        if (!jsonp$1.promiseClose && canUsePromise) {
            return new Promise(function(resolve, reject) {
                return reject(new Error("Param url is needed!"));
            });
        }
        return;
    }
    var urlWithParams = generateJsonpUrlWithParams(url, opts.params);
    var datafromStore = getDataFromStore({
        useStore: opts.useStore,
        storeKey: urlWithParams,
        storeCheck: opts.storeCheck,
        storeCheckKey: opts.storeCheckKey,
        storeSign: opts.storeSign,
        dataCheck: opts.dataCheck
    });
    if (datafromStore) {
        cb(null, datafromStore);
        if (!jsonp$1.promiseClose && canUsePromise) {
            return new Promise(function(resolve) {
                return resolve(datafromStore);
            });
        }
        return;
    }
    opts.originalUrl = urlWithParams;
    if (!jsonp$1.promiseClose && canUsePromise) {
        return new Promise(function(resolve, reject) {
            fetchData(urlWithParams, opts, function(err, data) {
                if (err) {
                    cb(err);
                    return reject(err);
                }
                cb(null, data);
                resolve(data);
            });
        });
    }
    fetchData(urlWithParams, opts, cb);
}
function generateJsonpUrlWithParams(url, params) {
    params = typeof params === "string" ? params : serializeParams2(params);
    url += (~url.indexOf("?") ? "&" : "?") + ("" + params);
    url = url.replace("?&", "?");
    return url;
}
function fetchData(url, opts, cb) {
    var originalUrl = opts.originalUrl;
    var charset = opts.charset;
    var jsonpUrlQueryParam = getUrlQueryParamByName(url, opts.jsonp);
    var funcId = (jsonpUrlQueryParam === "?" ? false : jsonpUrlQueryParam) || opts.name || "__jsonp" + timestamp++;
    var gotoBackupInfo = arguments[3] || null;
    if (jsonpUrlQueryParam) {
        if (jsonpUrlQueryParam === "?") {
            url = updateQueryStringParamByName(url, opts.jsonp, encodeC(funcId));
        }
    } else {
        url += (url.split("").pop() === "&" ? "" : "&") + (opts.jsonp + "=" + encodeC(funcId));
    }
    if (!opts.cache) {
        url += (url.split("").pop() === "&" ? "" : "&") + ("_=" + /* @__PURE__ */ new Date().getTime());
    }
    clearTimeout(win2["timer_" + funcId]);
    var prevFunc = win2[funcId];
    win2[funcId] = function(data) {
        prevFunc && prevFunc(data);
        cleanup(funcId);
        if (gotoBackupInfo) {
            data.__$$backupCall = gotoBackupInfo;
        }
        if (opts.dataCheck) {
            if (opts.dataCheck(data) !== false) {
                setDataToStore({
                    useStore: opts.useStore,
                    storeKey: originalUrl,
                    data
                });
                return cb(null, data);
            }
            if (fallback(originalUrl, opts, cb) === false) {
                cb(new Error("Data check error, and no fallback"));
            }
        } else {
            setDataToStore({
                useStore: opts.useStore,
                storeKey: originalUrl,
                data
            });
            cb(null, data);
        }
    };
    var script = appendScriptTagToHead({
        url,
        charset
    });
    var timeout = opts.timeout != null ? opts.timeout : TIMEOUT_CONST;
    win2["timer_" + funcId] = setTimeout(function() {
        cleanup(funcId);
        if (typeof opts.retryTimes === "number" && opts.retryTimes > 0) {
            opts.retryTimes--;
            return fetchData(originalUrl, opts, cb);
        }
        if (fallback(originalUrl, opts, cb) === false) {
            return cb(new Error("Timeout and no data return"));
        }
    }, timeout);
    function cleanup(funcId2) {
        if (script.parentNode) {
            script.parentNode.removeChild(script);
        }
        win2[funcId2] = noop2;
        clearTimeout(win2["timer_" + funcId2]);
    }
}
function storeCheckFn(storeData, storeCheckKey, storeSign) {
    if (storeData && storeCheckKey && storeSign) {
        return storeData[storeCheckKey] && storeData[storeCheckKey] === storeSign;
    }
    return false;
}
function getDataFromStore(_ref) {
    var useStore = _ref.useStore, storeKey = _ref.storeKey, storeCheck = _ref.storeCheck, storeCheckKey = _ref.storeCheckKey, storeSign = _ref.storeSign, dataCheck = _ref.dataCheck;
    useStore = useStore ? store.enabled : false;
    if (useStore) {
        var storeData = store.get(storeKey);
        storeCheck = storeCheck || storeCheckFn;
        if (storeCheck(storeData, storeCheckKey, storeSign)) {
            if (!dataCheck || storeData && dataCheck && dataCheck(storeData) !== false) {
                return storeData;
            }
        }
    }
    return null;
}
function getDataFromStoreWithoutCheck(_ref2) {
    var useStore = _ref2.useStore, storeKey = _ref2.storeKey, dataCheck = _ref2.dataCheck;
    useStore = useStore ? store.enabled : false;
    if (useStore) {
        var storeData = store.get(storeKey);
        if (!dataCheck || storeData && dataCheck && dataCheck(storeData) !== false) {
            return storeData;
        }
    }
    return null;
}
function setDataToStore(_ref3) {
    var useStore = _ref3.useStore, storeKey = _ref3.storeKey, data = _ref3.data;
    useStore = useStore ? store.enabled : false;
    if (useStore) {
        store.set(storeKey, data);
    }
}
function fallback(url, opts, cb) {
    var backup = opts.backup;
    var backupWithParams = void 0;
    if (backup) {
        if (typeof backup === "string") {
            delete opts.backup;
            backupWithParams = generateJsonpUrlWithParams(backup, opts.params);
            return fetchData(backupWithParams, opts, cb, {
                backup
            });
        } else if (Array.isArray(backup)) {
            if (backup.length) {
                var backupUrl = backup.shift();
                backupWithParams = generateJsonpUrlWithParams(backupUrl, opts.params);
                return fetchData(backupWithParams, opts, cb, {
                    backup: backupUrl
                });
            }
        }
    }
    var dataFromStoreWithoutCheck = getDataFromStoreWithoutCheck({
        useStore: opts.useStore,
        storeKey: url,
        dataCheck: opts.dataCheck
    });
    if (dataFromStoreWithoutCheck) {
        cb(null, dataFromStoreWithoutCheck);
        return true;
    }
    return false;
}
function appendScriptTagToHead(_ref4) {
    var url = _ref4.url, charset = _ref4.charset;
    if (!doc2) {
        return;
    }
    var script = doc2.createElement("script");
    script.type = "text/javascript";
    if (charset) {
        script.charset = charset;
    }
    script.src = url;
    head.appendChild(script);
    return script;
}
var jsonp_esm_default = jsonp$1;
// node_modules/@tarojs/taro-h5/dist/api/network/request/index.js
var { Link: Link2 } = Taro;
function generateRequestUrlWithParams(url = "", params) {
    params = typeof params === "string" ? params : serializeParams(params);
    if (params) {
        url += (~url.indexOf("?") ? "&" : "?") + params;
    }
    url = url.replace("?&", "?");
    return url;
}
function _request(options3 = {}) {
    const { success, complete, fail } = options3;
    const params = {};
    const res = {};
    let { cache: cache2 = "default", credentials, data, dataType, header = {}, jsonp, method = "GET", mode, responseType, signal, timeout, url = "" } = options3, opts = __rest(options3, [
        "cache",
        "credentials",
        "data",
        "dataType",
        "header",
        "jsonp",
        "method",
        "mode",
        "responseType",
        "signal",
        "timeout",
        "url"
    ]);
    if (typeof timeout !== "number") {
        timeout = NETWORK_TIMEOUT;
    }
    Object.assign(params, opts);
    if (jsonp) {
        params.params = data;
        params.cache = opts.jsonpCache;
        params.timeout = timeout;
        if (typeof jsonp === "string") {
            params.name = jsonp;
        }
        return jsonp_esm_default(url, params).then((data2)=>{
            res.statusCode = 200;
            res.data = data2;
            isFunction(success) && success(res);
            isFunction(complete) && complete(res);
            return res;
        }).catch((err)=>{
            isFunction(fail) && fail(err);
            isFunction(complete) && complete(res);
            return Promise.reject(err);
        });
    }
    params.method = method;
    const methodUpper = params.method.toUpperCase();
    params.cache = cache2;
    if (methodUpper === "GET" || methodUpper === "HEAD") {
        url = generateRequestUrlWithParams(url, data);
    } else if ([
        "[object Array]",
        "[object Object]"
    ].indexOf(Object.prototype.toString.call(data)) >= 0) {
        const keyOfContentType = Object.keys(header).find((item)=>item.toLowerCase() === "content-type");
        if (!keyOfContentType) {
            header["Content-Type"] = "application/json";
        }
        const contentType = header[keyOfContentType || "Content-Type"];
        if (contentType.indexOf("application/json") >= 0) {
            params.body = JSON.stringify(data);
        } else if (contentType.indexOf("application/x-www-form-urlencoded") >= 0) {
            params.body = serializeParams(data);
        } else {
            params.body = data;
        }
    } else {
        params.body = data;
    }
    if (header) {
        params.headers = header;
    }
    if (mode) {
        params.mode = mode;
    }
    let timeoutTimer = null;
    let controller = null;
    if (signal) {
        params.signal = signal;
    } else {
        controller = new window.AbortController();
        params.signal = controller.signal;
        timeoutTimer = setTimeout(function() {
            if (controller) controller.abort();
        }, timeout);
    }
    params.credentials = credentials;
    const p = fetch(url, params).then((response)=>{
        if (timeoutTimer) {
            clearTimeout(timeoutTimer);
            timeoutTimer = null;
        }
        if (controller) {
            controller = null;
        }
        if (!response) {
            const errorResponse = {
                ok: false
            };
            throw errorResponse;
        }
        res.statusCode = response.status;
        res.header = {};
        for (const key of response.headers.keys()){
            res.header[key] = response.headers.get(key);
        }
        if (responseType === "arraybuffer") {
            return response.arrayBuffer();
        }
        if (res.statusCode !== 204) {
            if (dataType === "json" || typeof dataType === "undefined") {
                return response.json().catch(()=>{
                    return null;
                });
            }
        }
        if (responseType === "text" || dataType === "text") {
            return response.text();
        }
        return Promise.resolve(null);
    }).then((data2)=>{
        res.data = data2;
        isFunction(success) && success(res);
        isFunction(complete) && complete(res);
        return res;
    }).catch((err)=>{
        if (timeoutTimer) {
            clearTimeout(timeoutTimer);
            timeoutTimer = null;
        }
        if (controller) {
            controller = null;
        }
        isFunction(fail) && fail(err);
        isFunction(complete) && complete(res);
        err.statusCode = res.statusCode;
        err.errMsg = err.message;
        return Promise.reject(err);
    });
    if (!p.abort && controller) {
        p.abort = (cb)=>{
            if (controller) {
                cb && cb();
                controller.abort();
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                    timeoutTimer = null;
                }
            }
        };
    }
    return p;
}
function taroInterceptor(chain) {
    return _request(chain.requestParams);
}
var link = new Link2(taroInterceptor);
var request = (...args)=>{
    const [url = "", options3 = {}] = args;
    if (typeof url === "string") {
        options3.url = url;
    } else {
        Object.assign(options3, url);
    }
    return link.request(options3);
};
var addInterceptor = link.addInterceptor.bind(link);
var cleanInterceptors = link.cleanInterceptors.bind(link);
// node_modules/@tarojs/taro-h5/dist/api/network/tcp.js
var createTCPSocket = temporarilyNotSupport("createTCPSocket");
// node_modules/@tarojs/taro-h5/dist/api/network/udp.js
var createUDPSocket = temporarilyNotSupport("createUDPSocket");
// node_modules/@tarojs/taro-h5/dist/api/network/upload.js
var createUploadTask = ({ url, filePath, formData = {}, name, header, timeout, fileName, withCredentials = true, success, error })=>{
    let timeoutInter;
    let formKey;
    const apiName = "uploadFile";
    const xhr = new XMLHttpRequest();
    const form = new FormData();
    const callbackManager5 = {
        headersReceived: new CallbackManager(),
        progressUpdate: new CallbackManager()
    };
    xhr.open("POST", url);
    xhr.withCredentials = !!withCredentials;
    setHeader(xhr, header);
    for(formKey in formData){
        form.append(formKey, formData[formKey]);
    }
    xhr.upload.onprogress = (e)=>{
        const { loaded, total } = e;
        callbackManager5.progressUpdate.trigger({
            progress: Math.round(loaded / total * 100),
            totalBytesSent: loaded,
            totalBytesExpectedToSend: total
        });
    };
    xhr.onreadystatechange = ()=>{
        if (xhr.readyState !== XHR_STATS.HEADERS_RECEIVED) return;
        callbackManager5.headersReceived.trigger({
            header: xhr.getAllResponseHeaders()
        });
    };
    xhr.onload = ()=>{
        const status2 = xhr.status;
        clearTimeout(timeoutInter);
        success({
            errMsg: `${apiName}:ok`,
            statusCode: status2,
            data: xhr.responseText || xhr.response
        });
    };
    xhr.onabort = ()=>{
        clearTimeout(timeoutInter);
        error({
            errMsg: `${apiName}:fail abort`
        });
    };
    xhr.onerror = (e)=>{
        clearTimeout(timeoutInter);
        error({
            errMsg: `${apiName}:fail ${e.message}`
        });
    };
    const abort = ()=>{
        clearTimeout(timeoutInter);
        xhr.abort();
    };
    const send = ()=>{
        xhr.send(form);
        timeoutInter = setTimeout(()=>{
            xhr.onabort = null;
            xhr.onload = null;
            xhr.upload.onprogress = null;
            xhr.onreadystatechange = null;
            xhr.onerror = null;
            abort();
            error({
                errMsg: `${apiName}:fail timeout`
            });
        }, timeout || NETWORK_TIMEOUT);
    };
    convertObjectUrlToBlob(filePath).then((fileObj)=>{
        if (!fileName) {
            fileName = typeof fileObj !== "string" && fileObj.name;
        }
        form.append(name, fileObj, fileName || `file-${Date.now()}`);
        send();
    }).catch((e)=>{
        error({
            errMsg: `${apiName}:fail ${e.message}`
        });
    });
    const onHeadersReceived = callbackManager5.headersReceived.add;
    const offHeadersReceived = callbackManager5.headersReceived.remove;
    const onProgressUpdate = callbackManager5.progressUpdate.add;
    const offProgressUpdate = callbackManager5.progressUpdate.remove;
    return {
        abort,
        onHeadersReceived,
        offHeadersReceived,
        onProgressUpdate,
        offProgressUpdate
    };
};
var uploadFile = ({ url, filePath, name, header, formData, timeout, fileName, withCredentials, success, fail, complete })=>{
    let task;
    const result = new Promise((resolve, reject)=>{
        task = createUploadTask({
            url,
            header,
            name,
            filePath,
            formData,
            timeout,
            fileName,
            withCredentials,
            success: (res)=>{
                success && success(res);
                complete && complete(res);
                resolve(res);
            },
            error: (res)=>{
                fail && fail(res);
                complete && complete(res);
                reject(res);
            }
        });
    });
    result.headersReceive = task.onHeadersReceived.bind(task);
    result.progress = task.onProgressUpdate.bind(task);
    const properties = {};
    Object.keys(task).forEach((key)=>{
        properties[key] = {
            get () {
                return typeof task[key] === "function" ? task[key].bind(task) : task[key];
            }
        };
    });
    return Object.defineProperties(result, properties);
};
// node_modules/@tarojs/taro-h5/dist/api/network/websocket/socketTask.js
var SocketTask = class {
    get readyState() {
        return this.ws.readyState;
    }
    send(opts = {}) {
        if (typeof opts !== "object" || !opts) opts = {};
        const { data = "", success, fail, complete } = opts;
        if (this.readyState !== 1) {
            const res2 = {
                errMsg: "SocketTask.send:fail SocketTask.readState is not OPEN"
            };
            console.error(res2.errMsg);
            isFunction(fail) && fail(res2);
            isFunction(complete) && complete(res2);
            return Promise.reject(res2);
        }
        this.ws.send(data);
        const res = {
            errMsg: "sendSocketMessage:ok"
        };
        isFunction(success) && success(res);
        isFunction(complete) && complete(res);
        return Promise.resolve(res);
    }
    close(opts = {}) {
        if (typeof opts !== "object" || !opts) opts = {};
        const { code = 1e3, reason = "server complete,close", success, complete } = opts;
        this.closeDetail = {
            code,
            reason
        };
        this._destroyWhenClose && this._destroyWhenClose();
        this.ws.close();
        const res = {
            errMsg: "closeSocket:ok"
        };
        isFunction(success) && success(res);
        isFunction(complete) && complete(res);
        return Promise.resolve(res);
    }
    onOpen(func) {
        this.ws.onopen = func;
    }
    onMessage(func) {
        this.ws.onmessage = func;
    }
    onClose(func) {
        this.ws.onclose = ()=>{
            this._destroyWhenClose && this._destroyWhenClose();
            func(this.closeDetail || {
                code: 1006,
                reason: "abnormal closure"
            });
        };
    }
    onError(func) {
        this.ws.onerror = func;
    }
    constructor(url, protocols){
        if (protocols && protocols.length) {
            this.ws = new WebSocket(url, protocols);
        } else {
            this.ws = new WebSocket(url);
        }
        this.CONNECTING = 0;
        this.OPEN = 1;
        this.CLOSING = 2;
        this.CLOSED = 3;
    }
};
// node_modules/@tarojs/taro-h5/dist/api/network/websocket/index.js
var socketTasks = [];
var socketsCounter = 1;
function sendSocketMessage() {
    console.warn("Deprecated.Please use socketTask.send instead.");
}
function onSocketOpen() {
    console.warn("Deprecated.Please use socketTask.onOpen instead.");
}
function onSocketMessage() {
    console.warn("Deprecated.Please use socketTask.onMessage instead.");
}
function onSocketError() {
    console.warn("Deprecated.Please use socketTask.onError instead.");
}
function onSocketClose() {
    console.warn("Deprecated.Please use socketTask.onClose instead.");
}
function connectSocket(options3) {
    const name = "connectSocket";
    return new Promise((resolve, reject)=>{
        const isObject6 = shouldBeObject(options3);
        if (!isObject6.flag) {
            const res = {
                errMsg: `${name}:fail ${isObject6.msg}`
            };
            console.error(res.errMsg);
            return reject(res);
        }
        const { url, protocols, success, fail, complete } = options3;
        const handle3 = new MethodHandler({
            name,
            success,
            fail,
            complete
        });
        if (typeof url !== "string") {
            return handle3.fail({
                errMsg: getParameterError({
                    para: "url",
                    correct: "String",
                    wrong: url
                })
            }, {
                resolve,
                reject
            });
        }
        if (!url.startsWith("ws://") && !url.startsWith("wss://")) {
            return handle3.fail({
                errMsg: `request:fail invalid url "${url}"`
            }, {
                resolve,
                reject
            });
        }
        const _protocols = Array.isArray(protocols) ? protocols : null;
        if (socketTasks.length >= 5) {
            return handle3.fail({
                errMsg: "\u540C\u65F6\u6700\u591A\u53D1\u8D77 5 \u4E2A socket \u8BF7\u6C42\uFF0C\u66F4\u591A\u8BF7\u53C2\u8003\u6587\u6863\u3002"
            }, {
                resolve,
                reject
            });
        }
        const task = new SocketTask(url, _protocols);
        task._destroyWhenClose = function() {
            socketTasks = socketTasks.filter((socketTask)=>socketTask !== this);
        };
        socketTasks.push(task);
        handle3.success({
            socketTaskId: socketsCounter++
        });
        return resolve(task);
    });
}
function closeSocket() {
    console.warn("Deprecated.Please use socketTask.close instead.");
}
// node_modules/@tarojs/taro-h5/dist/api/open-api/account.js
var getAccountInfoSync = temporarilyNotSupport("getAccountInfoSync");
// node_modules/@tarojs/taro-h5/dist/api/open-api/address.js
var chooseAddress = temporarilyNotSupport("chooseAddress");
// node_modules/@tarojs/taro-h5/dist/api/open-api/authorize.js
var authorizeForMiniProgram = temporarilyNotSupport("authorizeForMiniProgram");
var authorize = temporarilyNotSupport("authorize");
// node_modules/@tarojs/taro-h5/dist/api/open-api/card.js
var openCard = temporarilyNotSupport("openCard");
var addCard = temporarilyNotSupport("addCard");
// node_modules/@tarojs/taro-h5/dist/api/open-api/channels-live.js
var reserveChannelsLive = temporarilyNotSupport("reserveChannelsLive");
var openChannelsUserProfile = temporarilyNotSupport("openChannelsUserProfile");
var openChannelsLive = temporarilyNotSupport("openChannelsLive");
var openChannelsEvent = temporarilyNotSupport("openChannelsEvent");
var openChannelsActivity = temporarilyNotSupport("openChannelsActivity");
var getChannelsShareKey = temporarilyNotSupport("getChannelsShareKey");
var getChannelsLiveNoticeInfo = temporarilyNotSupport("getChannelsLiveNoticeInfo");
var getChannelsLiveInfo = temporarilyNotSupport("getChannelsLiveInfo");
// node_modules/@tarojs/taro-h5/dist/api/open-api/customer-service.js
var openCustomerServiceChat = temporarilyNotSupport("openCustomerServiceChat");
// node_modules/@tarojs/taro-h5/dist/api/open-api/device-voip.js
var requestDeviceVoIP = temporarilyNotSupport("requestDeviceVoIP");
var getDeviceVoIPList = temporarilyNotSupport("getDeviceVoIPList");
// node_modules/@tarojs/taro-h5/dist/api/open-api/facial.js
var checkIsSupportFacialRecognition = temporarilyNotSupport("checkIsSupportFacialRecognition");
var startFacialRecognitionVerify = temporarilyNotSupport("startFacialRecognitionVerify");
var startFacialRecognitionVerifyAndUploadVideo = temporarilyNotSupport("startFacialRecognitionVerifyAndUploadVideo");
var faceVerifyForPay = temporarilyNotSupport("faceVerifyForPay");
// node_modules/@tarojs/taro-h5/dist/api/open-api/favorites.js
var addVideoToFavorites = temporarilyNotSupport("addVideoToFavorites");
var addFileToFavorites = temporarilyNotSupport("addFileToFavorites");
// node_modules/@tarojs/taro-h5/dist/api/open-api/group.js
var getGroupEnterInfo = temporarilyNotSupport("getGroupEnterInfo");
// node_modules/@tarojs/taro-h5/dist/api/open-api/invoice.js
var chooseInvoiceTitle = temporarilyNotSupport("chooseInvoiceTitle");
var chooseInvoice = temporarilyNotSupport("chooseInvoice");
// node_modules/@tarojs/taro-h5/dist/api/open-api/license-plate.js
var chooseLicensePlate = temporarilyNotSupport("chooseLicensePlate");
// node_modules/@tarojs/taro-h5/dist/api/open-api/login.js
var pluginLogin = temporarilyNotSupport("pluginLogin");
var login = temporarilyNotSupport("login");
var checkSession = temporarilyNotSupport("checkSession");
// node_modules/@tarojs/taro-h5/dist/api/open-api/my-miniprogram.js
var checkIsAddedToMyMiniProgram = temporarilyNotSupport("checkIsAddedToMyMiniProgram");
// node_modules/@tarojs/taro-h5/dist/api/open-api/privacy.js
var requirePrivacyAuthorize = temporarilyNotSupport("requirePrivacyAuthorize");
var openPrivacyContract = temporarilyNotSupport("openPrivacyContract");
var onNeedPrivacyAuthorization = temporarilyNotSupport("onNeedPrivacyAuthorization");
var getPrivacySetting = temporarilyNotSupport("getPrivacySetting");
// node_modules/@tarojs/taro-h5/dist/api/open-api/red-package.js
var showRedPackage = temporarilyNotSupport("showRedPackage");
// node_modules/@tarojs/taro-h5/dist/api/open-api/settings.js
var openSetting = temporarilyNotSupport("openSetting");
var getSetting = temporarilyNotSupport("getSetting");
// node_modules/@tarojs/taro-h5/dist/api/open-api/soter.js
var startSoterAuthentication = temporarilyNotSupport("startSoterAuthentication");
var checkIsSupportSoterAuthentication = temporarilyNotSupport("checkIsSupportSoterAuthentication");
var checkIsSoterEnrolledInDevice = temporarilyNotSupport("checkIsSoterEnrolledInDevice");
// node_modules/@tarojs/taro-h5/dist/api/open-api/subscribe-message.js
var requestSubscribeMessage = temporarilyNotSupport("requestSubscribeMessage");
var requestSubscribeDeviceMessage = temporarilyNotSupport("requestSubscribeDeviceMessage");
// node_modules/@tarojs/taro-h5/dist/api/open-api/user-info.js
var getUserProfile = temporarilyNotSupport("getUserProfile");
var getUserInfo = temporarilyNotSupport("getUserInfo");
// node_modules/@tarojs/taro-h5/dist/api/open-api/werun.js
var shareToWeRun = temporarilyNotSupport("shareToWeRun");
var getWeRunData = temporarilyNotSupport("getWeRunData");
// node_modules/@tarojs/taro-h5/dist/api/payment/index.js
var requestPayment = temporarilyNotSupport("requestPayment");
var requestPluginPayment = temporarilyNotSupport("requestPluginPayment");
var requestOrderPayment = temporarilyNotSupport("requestOrderPayment");
// node_modules/@tarojs/taro-h5/dist/api/qq/index.js
var openQzonePublish = temporarilyNotSupport("openQzonePublish");
var getQQRunData = temporarilyNotSupport("getQQRunData");
var setOfficialDress = temporarilyNotSupport("setOfficialDress");
var setCustomDress = temporarilyNotSupport("setCustomDress");
var updateQQApp = temporarilyNotSupport("updateQQApp");
var addRecentColorSign = temporarilyNotSupport("addRecentColorSign");
var getGuildInfo = temporarilyNotSupport("getGuildInfo");
var applyAddToMyApps = temporarilyNotSupport("applyAddToMyApps");
var isAddedToMyApps = temporarilyNotSupport("isAddedToMyApps");
// node_modules/@tarojs/taro-h5/dist/api/share/index.js
var updateShareMenu = temporarilyNotSupport("updateShareMenu");
var showShareMenu = temporarilyNotSupport("showShareMenu");
var showShareImageMenu = temporarilyNotSupport("showShareImageMenu");
var shareVideoMessage = temporarilyNotSupport("shareVideoMessage");
var shareFileMessage = temporarilyNotSupport("shareFileMessage");
var onCopyUrl = temporarilyNotSupport("onCopyUrl");
var offCopyUrl = temporarilyNotSupport("offCopyUrl");
var hideShareMenu = temporarilyNotSupport("hideShareMenu");
var getShareInfo = temporarilyNotSupport("getShareInfo");
var authPrivateMessage = permanentlyNotSupport("authPrivateMessage");
// node_modules/@tarojs/taro-h5/dist/api/swan/index.js
var setPageInfo = temporarilyNotSupport("setPageInfo");
var ocrIdCard = temporarilyNotSupport("ocrIdCard");
var ocrBankCard = temporarilyNotSupport("ocrBankCard");
var ocrDrivingLicense = temporarilyNotSupport("ocrDrivingLicense");
var ocrVehicleLicense = temporarilyNotSupport("ocrVehicleLicense");
var textReview = temporarilyNotSupport("textReview");
var textToAudio = temporarilyNotSupport("textToAudio");
var imageAudit = temporarilyNotSupport("imageAudit");
var advancedGeneralIdentify = temporarilyNotSupport("advancedGeneralIdentify");
var objectDetectIdentify = temporarilyNotSupport("objectDetectIdentify");
var carClassify = temporarilyNotSupport("carClassify");
var dishClassify = temporarilyNotSupport("dishClassify");
var logoClassify = temporarilyNotSupport("logoClassify");
var animalClassify = temporarilyNotSupport("animalClassify");
var plantClassify = temporarilyNotSupport("plantClassify");
var getSwanId = temporarilyNotSupport("getSwanId");
var requestPolymerPayment = temporarilyNotSupport("requestPolymerPayment");
var navigateToSmartGameProgram = temporarilyNotSupport("navigateToSmartGameProgram");
var navigateToSmartProgram = temporarilyNotSupport("navigateToSmartProgram");
var navigateBackSmartProgram = temporarilyNotSupport("navigateBackSmartProgram");
var preloadSubPackage = temporarilyNotSupport("preloadSubPackage");
// node_modules/@tarojs/taro-h5/dist/api/worker/index.js
var createWorker = temporarilyNotSupport("createWorker");
// node_modules/@tarojs/taro-h5/dist/api/wxml/IntersectionObserver.js
var TaroH5IntersectionObserver = class {
    // selector 的容器节点
    get container() {
        const container2 = this._component !== null ? findDOM(this._component) || document : document;
        return container2;
    }
    createInst() {
        this.disconnect();
        const { left = 0, top = 0, bottom = 0, right = 0 } = this._rootMargin;
        return new IntersectionObserver((entries)=>{
            entries.forEach((entry)=>{
                const _callback = this._getCallbackByElement(entry.target);
                const result = {
                    boundingClientRect: entry.boundingClientRect,
                    intersectionRatio: entry.intersectionRatio,
                    intersectionRect: entry.intersectionRect,
                    relativeRect: entry.rootBounds || {
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    },
                    time: entry.time
                };
                if (!this._isInited && this._options.initialRatio <= Math.min.apply(Math, this._options.thresholds)) {
                    return;
                }
                _callback && _callback.call(this, result);
            });
            this._isInited = true;
        }, {
            root: this._root,
            rootMargin: [
                `${top}px`,
                `${right}px`,
                `${bottom}px`,
                `${left}px`
            ].join(" "),
            threshold: this._options.thresholds
        });
    }
    disconnect() {
        if (this._observerInst) {
            let listener;
            while(listener = this._listeners.pop()){
                this._observerInst.unobserve(listener.element);
            }
            this._observerInst.disconnect();
        }
    }
    observe(targetSelector, callback) {
        if (this._listeners.length) return;
        if (!this._observerInst) {
            console.warn("Intersection observer will be ignored because no relative nodes are found.");
            return;
        }
        const nodeList = this._options.observeAll ? this.container.querySelectorAll(targetSelector) : [
            this.container.querySelector(targetSelector)
        ];
        Taro.nextTick(()=>{
            nodeList.forEach((element)=>{
                if (!element) return;
                this._observerInst.observe(element);
                this._listeners.push({
                    element,
                    callback
                });
            });
        });
    }
    relativeTo(selector, margins) {
        if (this._listeners.length) {
            console.error('Relative nodes cannot be added after "observe" call in IntersectionObserver');
            return this;
        }
        this._root = this.container.querySelector(selector) || null;
        if (margins) {
            this._rootMargin = margins;
        }
        this._observerInst = this.createInst();
        return this;
    }
    relativeToViewport(margins) {
        return this.relativeTo(".taro_page", margins);
    }
    _getCallbackByElement(element) {
        const listener = this._listeners.find((listener2)=>listener2.element === element);
        return listener ? listener.callback : null;
    }
    constructor(component, options3 = {}){
        this._options = {
            thresholds: [
                0
            ],
            initialRatio: 0,
            observeAll: false
        };
        this._listeners = [];
        this._rootMargin = {};
        this._isInited = false;
        this._component = component;
        Object.assign(this._options, options3);
    }
};
// node_modules/@tarojs/taro-h5/dist/api/wxml/MediaQueryObserver.js
function generateMediaQueryStr(descriptor) {
    const mediaQueryArr = [];
    const descriptorMenu = [
        "width",
        "minWidth",
        "maxWidth",
        "height",
        "minHeight",
        "maxHeight",
        "orientation"
    ];
    for (const item of descriptorMenu){
        if (item !== "orientation" && descriptor[item] && Number(descriptor[item]) >= 0) {
            mediaQueryArr.push(`(${toKebabCase(item)}: ${Number(descriptor[item])}px)`);
        }
        if (item === "orientation" && descriptor[item]) {
            mediaQueryArr.push(`(${toKebabCase(item)}: ${descriptor[item]})`);
        }
    }
    return mediaQueryArr.join(" and ");
}
var MediaQueryObserver = class {
    // 监听页面媒体查询变化情况
    observe(descriptor, callback) {
        if (isFunction(callback)) {
            this._mediaQueryObserver = window.matchMedia(generateMediaQueryStr(descriptor));
            this._listener = (ev)=>{
                callback({
                    matches: ev.matches
                });
            };
            callback({
                matches: this._mediaQueryObserver.matches
            });
            if ("addEventListener" in this._mediaQueryObserver) {
                this._mediaQueryObserver.addEventListener("change", this._listener);
            } else {
                this._mediaQueryObserver.addListener(this._listener);
            }
        }
    }
    // 停止监听，销毁媒体查询对象
    disconnect() {
        if (this._mediaQueryObserver && this._listener) {
            if ("removeEventListener" in this._mediaQueryObserver) {
                this._mediaQueryObserver.removeEventListener("change", this._listener);
            } else {
                this._mediaQueryObserver.removeListener(this._listener);
            }
        }
    }
};
// node_modules/@tarojs/taro-h5/dist/api/wxml/nodesRef.js
var NodesRef = class {
    context(cb) {
        const { _selector, _component, _single, _selectorQuery } = this;
        _selectorQuery._push(_selector, _component, _single, {
            context: true
        }, cb);
        return _selectorQuery;
    }
    node(cb) {
        const { _selector, _component, _single, _selectorQuery } = this;
        _selectorQuery._push(_selector, _component, _single, {
            nodeCanvasType: true,
            node: true
        }, cb);
        return _selectorQuery;
    }
    boundingClientRect(cb) {
        const { _selector, _component, _single, _selectorQuery } = this;
        _selectorQuery._push(_selector, _component, _single, {
            id: true,
            dataset: true,
            rect: true,
            size: true
        }, cb);
        return _selectorQuery;
    }
    scrollOffset(cb) {
        const { _selector, _component, _single, _selectorQuery } = this;
        _selectorQuery._push(_selector, _component, _single, {
            id: true,
            dataset: true,
            scrollOffset: true
        }, cb);
        return _selectorQuery;
    }
    fields(fields, cb) {
        const { _selector, _component, _single, _selectorQuery } = this;
        const { id, dataset, rect, size, scrollOffset, properties = [], computedStyle = [] } = fields;
        _selectorQuery._push(_selector, _component, _single, {
            id,
            dataset,
            rect,
            size,
            scrollOffset,
            properties,
            computedStyle
        }, cb);
        return _selectorQuery;
    }
    constructor(selector, querySelectorQuery, single){
        this._component = querySelectorQuery._component;
        this._selector = selector;
        this._selectorQuery = querySelectorQuery;
        this._single = single;
    }
};
// node_modules/@tarojs/taro-h5/dist/api/wxml/selectorQuery.js
function filter(fields, dom, selector) {
    if (!dom) return null;
    const isViewport = selector === ".taro_page";
    const { id, dataset, rect, size, scrollOffset, properties = [], computedStyle = [], nodeCanvasType, node, context } = fields;
    const res = {};
    if (nodeCanvasType && node) {
        const tagName = dom.tagName;
        res.node = {
            id: dom.id,
            $taroElement: dom
        };
        if (/^taro-canvas-core/i.test(tagName)) {
            const type = dom.type || "";
            res.nodeCanvasType = type;
            const canvas = dom.getElementsByTagName("canvas")[0];
            if (/^(2d|webgl)/i.test(type) && canvas) {
                res.node = canvas;
            } else {
                res.node = null;
            }
        } else if (/^taro-scroll-view-core/i.test(tagName)) {
            res.nodeCanvasType = "";
            res.node = dom;
            dom.scrollTo = dom.mpScrollToMethod;
            dom.scrollIntoView = dom.mpScrollIntoViewMethod;
        } else {
            res.nodeCanvasType = "";
            res.node = dom;
        }
        return res;
    }
    if (context) {
        const tagName = dom.tagName;
        if (/^taro-video-core/i.test(tagName)) {
            return {
                context: dom
            };
        } else if (/^taro-canvas-core/i.test(tagName)) {
            const type = dom.type || "2d";
            const canvas = dom === null || dom === void 0 ? void 0 : dom.querySelector("canvas");
            const ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext(type);
            return {
                context: new CanvasContext(canvas, ctx)
            };
        } else if (/^taro-live-player-core/i.test(tagName)) {
            console.error("\u6682\u65F6\u4E0D\u652F\u6301\u901A\u8FC7 NodesRef.context \u83B7\u53D6 LivePlayerContext");
        } else if (/^taro-editor-core/i.test(tagName)) {
            console.error("\u6682\u65F6\u4E0D\u652F\u6301\u901A\u8FC7 NodesRef.context \u83B7\u53D6 EditorContext");
        } else if (/^taro-map-core/i.test(tagName)) {
            console.error("\u6682\u65F6\u4E0D\u652F\u6301\u901A\u8FC7 NodesRef.context \u83B7\u53D6 MapContext");
        }
        return;
    }
    if (id) res.id = dom.id;
    if (dataset) res.dataset = Object.assign({}, dom.dataset);
    if (rect || size) {
        const { left, right, top, bottom, width, height } = dom.getBoundingClientRect();
        if (rect) {
            if (!isViewport) {
                res.left = left;
                res.right = right;
                res.top = top;
                res.bottom = bottom;
            } else {
                res.left = 0;
                res.right = 0;
                res.top = 0;
                res.bottom = 0;
            }
        }
        if (size) {
            if (!isViewport) {
                res.width = width;
                res.height = height;
            } else {
                res.width = dom.clientWidth;
                res.height = dom.clientHeight;
            }
        }
    }
    if (scrollOffset) {
        res.scrollLeft = dom.scrollLeft;
        res.scrollTop = dom.scrollTop;
    }
    if (properties.length) {
        properties.forEach((prop)=>{
            const attr2 = dom.getAttribute(prop);
            if (attr2) res[prop] = attr2;
        });
    }
    if (computedStyle.length) {
        const styles3 = window.getComputedStyle(dom);
        computedStyle.forEach((key)=>{
            const value = styles3.getPropertyValue(key) || styles3[key];
            if (value) res[key] = value;
        });
    }
    return res;
}
function queryBat(queue, cb) {
    const result = [];
    queue.forEach((item)=>{
        var _a;
        const { selector, single, fields, component } = item;
        const container2 = component !== null ? findDOM(component) || document : document;
        let selectSelf = false;
        if (container2 !== document) {
            const $nodeList = (_a = container2.parentNode) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selector);
            if ($nodeList) {
                for(let i2 = 0, len = $nodeList.length; i2 < len; ++i2){
                    if (container2 === $nodeList[i2]) {
                        selectSelf = true;
                        break;
                    }
                }
            }
        }
        if (single) {
            const el = selectSelf === true ? container2 : container2.querySelector(selector);
            result.push(filter(fields, el, selector));
        } else {
            const $children = container2.querySelectorAll(selector);
            const children2 = [];
            selectSelf === true && children2.push(container2);
            for(let i2 = 0, len = $children.length; i2 < len; ++i2){
                children2.push($children[i2]);
            }
            result.push(children2.map((dom)=>filter(fields, dom)));
        }
    });
    cb(result);
}
var SelectorQuery = class {
    in(component) {
        this._component = component;
        return this;
    }
    select(selector) {
        if (typeof selector === "string") selector = selector.replace(">>>", ">");
        return new NodesRef(selector, this, true);
    }
    selectAll(selector) {
        if (typeof selector === "string") selector = selector.replace(">>>", ">");
        return new NodesRef(selector, this, false);
    }
    selectViewport() {
        return new NodesRef(".taro_page", this, true);
    }
    exec(cb) {
        Taro.nextTick(()=>{
            queryBat(this._queue, (res)=>{
                const _queueCb = this._queueCb;
                res.forEach((item, index2)=>{
                    const cb2 = _queueCb[index2];
                    isFunction(cb2) && cb2.call(this, item);
                });
                isFunction(cb) && cb.call(this, res);
            });
        });
        return this;
    }
    _push(selector, component, single, fields, callback = null) {
        this._queue.push({
            component,
            selector,
            single,
            fields
        });
        this._queueCb.push(callback);
    }
    constructor(){
        this._defaultWebviewId = null;
        this._webviewId = null;
        this._queue = [];
        this._queueCb = [];
        this._component;
    }
};
// node_modules/@tarojs/taro-h5/dist/api/wxml/index.js
var createSelectorQuery = ()=>{
    return new SelectorQuery();
};
var createIntersectionObserver = (component, options3)=>{
    return new TaroH5IntersectionObserver(component, options3);
};
var createMediaQueryObserver = ()=>{
    return new MediaQueryObserver();
};
// node_modules/@tarojs/taro-h5/dist/api/taro.js
var { Behavior: Behavior2, getEnv: getEnv2, ENV_TYPE: ENV_TYPE2, Link: Link3, interceptors: interceptors2, interceptorify: interceptorify2, Current: Current2, options: options2, eventCenter: eventCenter2, Events: Events2, preload } = Taro;
var taro = {
    // @ts-ignore
    Behavior: Behavior2,
    getEnv: getEnv2,
    ENV_TYPE: ENV_TYPE2,
    Link: Link3,
    interceptors: interceptors2,
    interceptorify: interceptorify2,
    Current: Current2,
    getCurrentInstance: getCurrentInstance2,
    options: options2,
    nextTick: nextTick3,
    eventCenter: eventCenter2,
    Events: Events2,
    preload,
    history,
    navigateBack,
    navigateTo,
    reLaunch,
    redirectTo,
    getCurrentPages,
    switchTab
};
var requirePlugin = permanentlyNotSupport("requirePlugin");
function getConfig() {
    var _a;
    if (this === null || this === void 0 ? void 0 : this.pxTransformConfig) return this.pxTransformConfig;
    return (_a = taro).config || (_a.config = {});
}
var defaultDesignWidth2 = 750;
var defaultDesignRatio2 = {
    640: 2.34 / 2,
    750: 1,
    828: 1.81 / 2
};
var defaultBaseFontSize2 = 20;
var defaultUnitPrecision2 = 5;
var defaultTargetUnit2 = "rem";
var initPxTransform = function({ designWidth = defaultDesignWidth2, deviceRatio = defaultDesignRatio2, baseFontSize = defaultBaseFontSize2, unitPrecision = defaultUnitPrecision2, targetUnit = defaultTargetUnit2 }) {
    const config = getConfig.call(this);
    config.designWidth = designWidth;
    config.deviceRatio = deviceRatio;
    config.baseFontSize = baseFontSize;
    config.targetUnit = targetUnit;
    config.unitPrecision = unitPrecision;
};
var pxTransform = function(size = 0) {
    const config = getConfig.call(this);
    const baseFontSize = config.baseFontSize || defaultBaseFontSize2;
    const deviceRatio = config.deviceRatio || defaultDesignRatio2;
    const designWidth = ((input = 0)=>isFunction(config.designWidth) ? config.designWidth(input) : config.designWidth)(size);
    if (!(designWidth in config.deviceRatio)) {
        throw new Error(`deviceRatio \u914D\u7F6E\u4E2D\u4E0D\u5B58\u5728 ${designWidth} \u7684\u8BBE\u7F6E\uFF01`);
    }
    const targetUnit = config.targetUnit || defaultTargetUnit2;
    const unitPrecision = config.unitPrecision || defaultUnitPrecision2;
    const formatSize = ~~size;
    let rootValue = 1 / deviceRatio[designWidth];
    switch(targetUnit){
        case "vw":
            rootValue = designWidth / 100;
            break;
        case "px":
            rootValue *= 2;
            break;
        default:
            rootValue *= baseFontSize * 2;
    }
    let val = formatSize / rootValue;
    if (unitPrecision >= 0 && unitPrecision <= 100) {
        val = Number(val.toFixed(unitPrecision));
    }
    return val + targetUnit;
};
var canIUseWebp = function() {
    const canvas = document.createElement("canvas");
    return canvas.toDataURL("image/webp").indexOf("data:image/webp") === 0;
};
var getAppInfo = function() {
    const config = getConfig.call(this);
    return {
        platform: "web",
        taroVersion: "3.6.23",
        designWidth: config.designWidth
    };
};
taro.requirePlugin = requirePlugin;
taro.getApp = getApp2;
taro.pxTransform = pxTransform;
taro.initPxTransform = initPxTransform;
taro.canIUseWebp = canIUseWebp;
taro.useAddToFavorites = useAddToFavorites;
taro.useDidHide = useDidHide;
taro.useDidShow = useDidShow;
taro.useError = useError;
taro.useLaunch = useLaunch;
taro.useLoad = useLoad;
taro.useOptionMenuClick = useOptionMenuClick;
taro.usePageNotFound = usePageNotFound;
taro.usePageScroll = usePageScroll;
taro.usePullDownRefresh = usePullDownRefresh;
taro.usePullIntercept = usePullIntercept;
taro.useReachBottom = useReachBottom;
taro.useReady = useReady;
taro.useResize = useResize;
taro.useRouter = useRouter;
taro.useSaveExitState = useSaveExitState;
taro.useShareAppMessage = useShareAppMessage;
taro.useShareTimeline = useShareTimeline;
taro.useTabItemTap = useTabItemTap;
taro.useTitleClick = useTitleClick;
taro.useScope = useScope;
taro.useUnhandledRejection = useUnhandledRejection;
taro.useUnload = useUnload;
// node_modules/@tarojs/plugin-platform-h5/dist/runtime/apis/index.js
var list = null;
function canIUse(scheme = "") {
    if (list === null) {
        list = Object.assign(Object.assign(Object.assign({}, definition.apis), definition.components), {
            canIUse: "*"
        });
    }
    if (!scheme) return false;
    const o = set_default({}, scheme, true);
    return isMatchWith_default(list, o, (a, b)=>{
        if (a === "*" || b === true) return true;
    });
}
// node_modules/@tarojs/components/dist/components/helper.js
function notSupport(name = "", instance = {}) {
    console.error(`H5 \u6682\u4E0D\u652F\u6301 ${name} \u7EC4\u4EF6\uFF01`);
    taro.eventCenter.trigger("__taroNotSupport", {
        name,
        instance,
        type: "component",
        category: "temporarily"
    });
}
function handleStencilNodes(el) {
    var _a;
    (_a = el === null || el === void 0 ? void 0 : el.childNodes) === null || _a === void 0 ? void 0 : _a.forEach((item)=>{
        if (item.nodeType === document.COMMENT_NODE && item["s-cn"]) item["s-cn"] = false;
        if (item.nodeType !== document.COMMENT_NODE && item["s-sr"]) item["s-sr"] = false;
    });
}
// node_modules/@tarojs/components/dist/components/taro-ad-core.js
var Ad = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Ad", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-ad-core"
]);
function defineCustomElement$1() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-ad-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-ad-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Ad);
                }
                break;
        }
    });
}
var defineCustomElement3 = defineCustomElement$1;
// node_modules/@tarojs/components/dist/components/taro-ad-custom-core.js
var AdCustom = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("AdCustom", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-ad-custom-core"
]);
function defineCustomElement$12() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-ad-custom-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-ad-custom-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, AdCustom);
                }
                break;
        }
    });
}
var defineCustomElement4 = defineCustomElement$12;
// node_modules/@tarojs/components/dist/components/taro-animation-video-core.js
var AnimationVideo = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("AnimationVideo", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-animation-video-core"
]);
function defineCustomElement$13() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-animation-video-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-animation-video-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, AnimationVideo);
                }
                break;
        }
    });
}
var defineCustomElement5 = defineCustomElement$13;
// node_modules/@tarojs/components/dist/components/taro-animation-view-core.js
var AnimationView = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("AnimationView", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-animation-view-core"
]);
function defineCustomElement$14() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-animation-view-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-animation-view-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, AnimationView);
                }
                break;
        }
    });
}
var defineCustomElement6 = defineCustomElement$14;
// node_modules/@tarojs/components/dist/components/taro-ar-camera-core.js
var ArCamera = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("ArCamera", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-ar-camera-core"
]);
function defineCustomElement$15() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-ar-camera-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-ar-camera-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, ArCamera);
                }
                break;
        }
    });
}
var defineCustomElement7 = defineCustomElement$15;
// node_modules/@tarojs/components/dist/components/taro-audio-core.js
var indexCss = "audio{outline:none;max-width:100%}";
var Audio2 = proxyCustomElement(class extends H {
    bindevent() {
        this.audio.addEventListener("timeupdate", (e)=>{
            this.onTimeUpdate.emit({
                duration: e.srcElement.duration,
                currentTime: e.srcElement.duration
            });
        });
        this.audio.addEventListener("ended", ()=>{
            this.onEnded.emit();
        });
        this.audio.addEventListener("play", ()=>{
            this.onPlay.emit();
        });
        this.audio.addEventListener("pause", (e)=>{
            this.onPause.emit(e);
        });
        this.audio.addEventListener("error", (e)=>{
            var _a;
            this.onError.emit({
                errMsg: (_a = e.srcElement.error) === null || _a === void 0 ? void 0 : _a.code
            });
        });
    }
    componentDidLoad() {
        this.bindevent();
    }
    render() {
        const { src, controls, autoplay, loop, muted, nativeProps } = this;
        return h("audio", Object.assign({
            src,
            controls,
            autoplay,
            loop,
            muted,
            ref: (audio)=>{
                this.audio = audio;
            }
        }, nativeProps));
    }
    static get style() {
        return indexCss;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onError = createEvent(this, "error", 7);
        this.onPlay = createEvent(this, "play", 7);
        this.onPause = createEvent(this, "pause", 7);
        this.onTimeUpdate = createEvent(this, "timeupdate", 7);
        this.onEnded = createEvent(this, "ended", 7);
        this.src = void 0;
        this.controls = true;
        this.autoplay = false;
        this.loop = false;
        this.muted = false;
        this.nativeProps = {};
    }
}, [
    0,
    "taro-audio-core",
    {
        "src": [
            1
        ],
        "controls": [
            4
        ],
        "autoplay": [
            4
        ],
        "loop": [
            4
        ],
        "muted": [
            4
        ],
        "nativeProps": [
            16
        ]
    }
]);
function defineCustomElement$16() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-audio-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-audio-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Audio2);
                }
                break;
        }
    });
}
var defineCustomElement8 = defineCustomElement$16;
// node_modules/@tarojs/components/dist/components/taro-aweme-data-core.js
var AwemeData = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("AwemeData", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-aweme-data-core"
]);
function defineCustomElement$17() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-aweme-data-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-aweme-data-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, AwemeData);
                }
                break;
        }
    });
}
var defineCustomElement9 = defineCustomElement$17;
// node_modules/@tarojs/components/dist/components/taro-block-core.js
var Block = proxyCustomElement(class extends H {
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-block-core"
]);
// node_modules/@tarojs/components/dist/components/index2.js
function createCommonjsModule(fn, basedir, module2) {
    return module2 = {
        path: basedir,
        exports: {},
        require: function(path, base) {
            return commonjsRequire();
        }
    }, fn(module2, module2.exports), module2.exports;
}
function commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var classnames = createCommonjsModule(function(module2) {
    (function() {
        var hasOwn = {}.hasOwnProperty;
        function classNames() {
            var classes = [];
            for(var i2 = 0; i2 < arguments.length; i2++){
                var arg = arguments[i2];
                if (!arg) continue;
                var argType = typeof arg;
                if (argType === "string" || argType === "number") {
                    classes.push(arg);
                } else if (Array.isArray(arg)) {
                    if (arg.length) {
                        var inner = classNames.apply(null, arg);
                        if (inner) {
                            classes.push(inner);
                        }
                    }
                } else if (argType === "object") {
                    if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
                        classes.push(arg.toString());
                        continue;
                    }
                    for(var key in arg){
                        if (hasOwn.call(arg, key) && arg[key]) {
                            classes.push(key);
                        }
                    }
                }
            }
            return classes.join(" ");
        }
        if (module2.exports) {
            classNames.default = classNames;
            module2.exports = classNames;
        } else {
            window.classNames = classNames;
        }
    })();
});
// node_modules/@tarojs/components/dist/components/taro-button-core.js
var indexCss2 = `.weui-loading{vertical-align:middle;background:url("data:image/svg+xml;charset=utf8, %3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120' viewBox='0 0 100 100'%3E%3Cpath fill='none' d='M0 0h100v100H0z'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23E9E9E9' rx='5' ry='5' transform='translate(0 -30)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23989697' rx='5' ry='5' transform='rotate(30 105.98 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%239B999A' rx='5' ry='5' transform='rotate(60 75.98 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23A3A1A2' rx='5' ry='5' transform='rotate(90 65 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23ABA9AA' rx='5' ry='5' transform='rotate(120 58.66 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23B2B2B2' rx='5' ry='5' transform='rotate(150 54.02 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23BAB8B9' rx='5' ry='5' transform='rotate(180 50 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23C2C0C1' rx='5' ry='5' transform='rotate(-150 45.98 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23CBCBCB' rx='5' ry='5' transform='rotate(-120 41.34 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23D2D2D2' rx='5' ry='5' transform='rotate(-90 35 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23DADADA' rx='5' ry='5' transform='rotate(-60 24.02 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23E2E2E2' rx='5' ry='5' transform='rotate(-30 -5.98 65)'/%3E%3C/svg%3E") 0 0/100% no-repeat;width:20px;height:20px;-webkit-animation:1s steps(12,end) infinite weuiLoading;animation:1s steps(12,end) infinite weuiLoading;display:inline-block}@-webkit-keyframes weuiLoading{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes weuiLoading{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.weui-btn_loading .weui-loading{margin:-.2em .34em 0 0}.weui-btn_loading.weui-btn_primary,.weui-btn_loading.weui-btn_warn{color:rgba(255,255,255,.6)}.weui-btn_loading.weui-btn_primary{background-color:#179b16}.weui-btn_loading.weui-btn_warn{background-color:#ce3c39}taro-button-core{-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none;text-align:center;color:#000;-webkit-tap-highlight-color:transparent;background-color:#f8f8f8;border-width:0;border-radius:5px;outline:0;width:100%;margin-left:auto;margin-right:auto;padding-left:14px;padding-right:14px;font-size:18px;line-height:2.55556;text-decoration:none;display:block;position:relative;overflow:hidden}taro-button-core:focus{outline:0}taro-button-core:not([disabled]):active{color:rgba(0,0,0,.6);background-color:#dedede}taro-button-core:after{-webkit-box-sizing:border-box;box-sizing:border-box;content:" ";-webkit-transform-origin:0 0;transform-origin:0 0;border:1px solid rgba(0,0,0,.2);border-radius:10px;width:200%;height:200%;position:absolute;top:0;left:0;-webkit-transform:scale(.5);transform:scale(.5)}taro-button-core+taro-button-core{margin-top:15px}taro-button-core[type=default]{color:#000;background-color:#f8f8f8}taro-button-core[type=default]:not([disabled]):visited{color:#000}taro-button-core[type=default]:not([disabled]):active{color:rgba(0,0,0,.6);background-color:#dedede}taro-button-core[size=mini]{width:auto;padding:0 1.32em;font-size:13px;line-height:2.3;display:inline-block}taro-button-core[plain],taro-button-core[plain][type=default],taro-button-core[plain][type=primary]{background-color:transparent;border-width:1px}taro-button-core[disabled]{color:rgba(255,255,255,.6)}taro-button-core[disabled][type=default]{color:rgba(0,0,0,.3);background-color:#f7f7f7}taro-button-core[disabled][type=primary]{background-color:#9ed99d}taro-button-core[disabled][type=warn]{background-color:#ec8b89}taro-button-core[loading] .weui-loading{margin:-.2em .34em 0 0}taro-button-core[loading][type=primary],taro-button-core[loading][type=warn]{color:rgba(255,255,255,.6)}taro-button-core[loading][type=primary]{background-color:#179b16}taro-button-core[loading][type=warn]{background-color:#ce3c39}taro-button-core[plain][type=primary]{color:#1aad19;border:1px solid #1aad19}taro-button-core[plain][type=primary]:not([disabled]):active{color:rgba(26,173,25,.6);background-color:transparent;border-color:rgba(26,173,25,.6)}taro-button-core[plain][type=primary]:after{border-width:0}taro-button-core[plain][type=warn]{color:#e64340;border:1px solid #e64340}taro-button-core[plain][type=warn]:not([disabled]):active{color:rgba(230,67,64,.6);background-color:transparent;border-color:rgba(230,67,64,.6)}taro-button-core[plain][type=warn]:after{border-width:0}taro-button-core[plain],taro-button-core[plain][type=default]{color:#353535;border:1px solid #353535}taro-button-core[plain]:not([disabled]):active,taro-button-core[plain][type=default]:not([disabled]):active{color:rgba(53,53,53,.6);background-color:transparent;border-color:rgba(53,53,53,.6)}taro-button-core[plain]:after,taro-button-core[plain][type=default]:after{border-width:0}taro-button-core[type=primary]{color:#fff;background-color:#1aad19}taro-button-core[type=primary]:not([disabled]):visited{color:#fff}taro-button-core[type=primary]:not([disabled]):active{color:rgba(255,255,255,.6);background-color:#179b16}taro-button-core[type=warn]{color:#fff;background-color:#e64340}taro-button-core[type=warn]:not([disabled]):visited{color:#fff}taro-button-core[type=warn]:not([disabled]):active{color:rgba(255,255,255,.6);background-color:#ce3c39}taro-button-core[plain][disabled],taro-button-core[plain][disabled][type=primary]{color:rgba(0,0,0,.3);background-color:#f7f7f7;border:1px solid rgba(0,0,0,.2)}`;
var Button = proxyCustomElement(class extends H {
    onClick(e) {
        if (this.disabled) {
            e.stopPropagation();
        }
    }
    onTouchStart() {
        if (this.disabled) {
            return;
        }
        this.touch = true;
        if (this.hoverClass && !this.disabled) {
            setTimeout(()=>{
                if (this.touch) {
                    this.hover = true;
                }
            }, this.hoverStartTime);
        }
    }
    onTouchEnd() {
        if (this.disabled) {
            return;
        }
        this.touch = false;
        if (this.hoverClass && !this.disabled) {
            setTimeout(()=>{
                if (!this.touch) {
                    this.hover = false;
                }
            }, this.hoverStayTime);
        }
        if (this.formType === "submit") {
            this.onSubmit.emit();
        } else if (this.formType === "reset") {
            this.onReset.emit();
        }
    }
    render() {
        const { disabled, hoverClass, type, size, plain, loading, hover } = this;
        const cls = classnames({
            [`${hoverClass}`]: hover && !disabled
        });
        return h(Host, {
            class: cls,
            type,
            plain,
            loading,
            size,
            disabled
        }, loading && h("i", {
            class: "weui-loading"
        }), h("slot", null));
    }
    get el() {
        return this;
    }
    static get style() {
        return indexCss2;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onSubmit = createEvent(this, "tarobuttonsubmit", 7);
        this.onReset = createEvent(this, "tarobuttonreset", 7);
        this.disabled = void 0;
        this.hoverClass = "button-hover";
        this.type = "";
        this.hoverStartTime = 20;
        this.hoverStayTime = 70;
        this.size = void 0;
        this.plain = void 0;
        this.loading = false;
        this.formType = null;
        this.hover = false;
        this.touch = false;
    }
}, [
    4,
    "taro-button-core",
    {
        "disabled": [
            4
        ],
        "hoverClass": [
            1,
            "hover-class"
        ],
        "type": [
            1
        ],
        "hoverStartTime": [
            2,
            "hover-start-time"
        ],
        "hoverStayTime": [
            2,
            "hover-stay-time"
        ],
        "size": [
            1
        ],
        "plain": [
            4
        ],
        "loading": [
            4
        ],
        "formType": [
            513,
            "form-type"
        ],
        "hover": [
            32
        ],
        "touch": [
            32
        ]
    },
    [
        [
            0,
            "click",
            "onClick"
        ],
        [
            1,
            "touchstart",
            "onTouchStart"
        ],
        [
            1,
            "touchend",
            "onTouchEnd"
        ]
    ]
]);
function defineCustomElement$18() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-button-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-button-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Button);
                }
                break;
        }
    });
}
var defineCustomElement10 = defineCustomElement$18;
// node_modules/@tarojs/components/dist/components/taro-camera-core.js
var Camera = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Camera", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-camera-core"
]);
function defineCustomElement$19() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-camera-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-camera-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Camera);
                }
                break;
        }
    });
}
var defineCustomElement11 = defineCustomElement$19;
// node_modules/@tarojs/components/dist/components/taro-canvas-core.js
var indexCss3 = "taro-canvas-core{width:300px;height:150px;display:block;position:relative}";
var LONG_TAP_DELAY = 500;
var Canvas = proxyCustomElement(class extends H {
    componentDidRender() {
        const [canvas] = this.el.children;
        if (!this.height || !this.width) {
            let style = window.getComputedStyle(canvas);
            this.height || (this.height = style.height);
            this.width || (this.width = style.width);
        }
        canvas.height = parseInt(this.height);
        canvas.width = parseInt(this.width);
    }
    render() {
        const { canvasId, nativeProps } = this;
        return h("canvas", Object.assign({
            "canvas-id": canvasId,
            style: {
                width: "100%",
                height: "100%"
            },
            onTouchStart: this.onTouchStart,
            onTouchMove: this.onTouchMove,
            onTouchCancel: this.onTouchEnd,
            onTouchEnd: this.onTouchEnd
        }, nativeProps));
    }
    get el() {
        return this;
    }
    static get style() {
        return indexCss3;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onLongTap = createEvent(this, "longtap", 7);
        this.onTouchStart = ()=>{
            this.timer = setTimeout(()=>{
                this.onLongTap.emit();
            }, LONG_TAP_DELAY);
        };
        this.onTouchMove = ()=>{
            clearTimeout(this.timer);
        };
        this.onTouchEnd = ()=>{
            clearTimeout(this.timer);
        };
        this.canvasId = void 0;
        this.height = void 0;
        this.width = void 0;
        this.nativeProps = {};
    }
}, [
    0,
    "taro-canvas-core",
    {
        "canvasId": [
            1,
            "id"
        ],
        "height": [
            1537
        ],
        "width": [
            1537
        ],
        "nativeProps": [
            16
        ]
    }
]);
function defineCustomElement$110() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-canvas-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-canvas-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Canvas);
                }
                break;
        }
    });
}
var defineCustomElement12 = defineCustomElement$110;
// node_modules/@tarojs/components/dist/components/taro-channel-live-core.js
var ChannelLive = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("ChannelLive", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-channel-live-core"
]);
function defineCustomElement$111() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-channel-live-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-channel-live-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, ChannelLive);
                }
                break;
        }
    });
}
var defineCustomElement13 = defineCustomElement$111;
// node_modules/@tarojs/components/dist/components/taro-channel-video-core.js
var ChannelVideo = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("ChannelVideo", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-channel-video-core"
]);
function defineCustomElement$112() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-channel-video-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-channel-video-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, ChannelVideo);
                }
                break;
        }
    });
}
var defineCustomElement14 = defineCustomElement$112;
// node_modules/@tarojs/components/dist/components/taro-checkbox-core.js
var indexCss4 = 'page,body{--weui-cellMarginLR:16px;--weui-cellPaddingLR:16px}.weui-cells__group{border:0}.weui-cells__group:first-child{margin-top:0}.weui-cells__group_form{margin-top:24px}.weui-cells__group_form .weui-cells{margin-left:var(--weui-cellMarginLR);margin-right:var(--weui-cellMarginLR)}.weui-cells__group_form .weui-cells:before,.weui-cells__group_form .weui-cells:after{left:var(--weui-cellPaddingLR);right:var(--weui-cellPaddingLR)}.weui-cells__group_form .weui-cell{padding:16px var(--weui-cellPaddingLR)}.weui-cells__group_form .weui-cell:before{left:var(--weui-cellPaddingLR);right:var(--weui-cellPaddingLR)}.weui-cells__group_form .weui-cell:not(.weui-cell_vertical) .weui-cell__hd{padding-right:16px}.weui-cells__group_form .weui-cell:not(.weui-cell_vertical) .weui-cell__ft{padding-left:16px}.weui-cells__group_form .weui-cells__title{margin-top:24px;margin-bottom:8px;padding:0 32px}.weui-cells__group_form:first-child .weui-cells__title{margin-top:0}.weui-cells__group_form .weui-cells__tips{padding:0 calc(var(--weui-cellMarginLR) + var(--weui-cellPaddingLR));color:var(--weui-FG-2);margin-top:8px}.weui-cells__group_form .weui-cells__tips a{font-weight:700}.weui-cells__group_form .weui-cells__tips_warn{color:var(--weui-RED)}.weui-cells__group_form .weui-label{max-width:5em;margin-right:8px}.weui-cells__group_form .weui-cell_access:active:after,.weui-cells__group_form .weui-cell_active:active:after{border-radius:8px}.weui-cells__group_form .weui-cell_warn input{color:#e64340}.weui-cells__group_form .weui-icon-warn,.weui-cells__group_form .weui-cell_switch:active:after,.weui-cells__group_form .weui-cell_vcode:active:after,.weui-cells__group_form .weui-cell_readonly:active:after,.weui-cells__group_form .weui-cell_disabled:active:after{display:none}.weui-cells__group_form input,.weui-cells__group_form textarea,.weui-cells__group_form label[for]{-webkit-tap-highlight-color:transparent}.weui-cells__group_form .weui-cell_wrap{-ms-flex-align:initial;align-items:initial;padding-top:8px;padding-bottom:8px}.weui-cells__group_form .weui-cell_wrap .weui-cell__hd{padding-right:0}.weui-cells__group_form .weui-cell_wrap .weui-label{margin-top:8px}.weui-cells__group_form .weui-cell_wrap .weui-cell__bd{-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-align:center;align-items:center;display:-ms-flexbox;display:flex}.weui-cells__group_form .weui-cell__control{margin:8px 0 8px 16px}.weui-cells__group_form .weui-cell__control_flex{-ms-flex:1;flex:1;min-width:30vw}.weui-cells__group_form .weui-vcode-btn{color:#000;background-color:#f8f8f8;border-radius:6px;width:auto;height:auto;padding:0 12px;font-size:16px;line-height:2}.weui-cells__group_form .weui-vcode-btn:before{display:none}.weui-cells__group_form .weui-cell_vcode.weui-cell_wrap{padding-top:4px;padding-bottom:4px}.weui-cells__group_form .weui-cell_vcode.weui-cell_wrap .weui-label{margin-top:12px}.weui-cells__group_form .weui-cell_vcode.weui-cell_wrap .weui-input{min-height:1.88235em;font-size:17px}.weui-cells__group_form .weui-cells_checkbox .weui-check__label:before{left:calc(40px + var(--weui-cellPaddingLR))}.weui-cells__group_form .weui-cell_select{padding:0}.weui-cells__group_form .weui-cell_select-before .weui-cell__hd{padding-right:0}.weui-cells__group_form .weui-cell_switch{padding:12px 16px}.weui-cells__group_form-primary{margin-top:32px}.weui-cells__group_form-primary .weui-cells{background:var(--weui-BG-1);border-radius:8px;overflow:hidden}.weui-cells__group_form-primary .weui-cells:before,.weui-cells__group_form-primary .weui-cells:after{display:none}.weui-cells__group_form-primary .weui-cell_access:active:after,.weui-cells__group_form-primary .weui-cell_active:active:after{border-radius:0}.taro-checkbox{display:inline-block;position:relative}.taro-checkbox_checked{-webkit-appearance:none;-moz-appearance:none;appearance:none;vertical-align:0;color:#1aad19;background-color:#fff;border:1px solid #d1d1d1;border-radius:3px;outline:0;width:23px;height:23px;min-height:0;font-size:23px;display:inline-block;position:relative;top:5px}.taro-checkbox_checked:checked:before{vertical-align:middle;text-decoration:inherit;text-align:center;text-transform:none;font-variant:normal;font-family:weui;font-style:normal;font-weight:400;font-size:inherit;color:inherit;content:"\uEA08";speak:none;display:inline-block;position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-48%)scale(.73);transform:translate(-50%,-48%)scale(.73)}';
var Checkbox = proxyCustomElement(class extends H {
    watchId(newVal) {
        if (!this.isWillLoadCalled) return;
        if (newVal) this.inputEl.setAttribute("id", newVal);
    }
    componentWillLoad() {
        this.isWillLoadCalled = true;
    }
    componentDidRender() {
        this.id && this.el.removeAttribute("id");
    }
    render() {
        const { checked, name, color, value, disabled, nativeProps } = this;
        return h(Host, {
            className: "weui-cells_checkbox"
        }, h("input", Object.assign({
            ref: (dom)=>{
                if (!dom) return;
                this.inputEl = dom;
                if (this.id) dom.setAttribute("id", this.id);
            },
            type: "checkbox",
            value,
            name,
            class: "taro-checkbox_checked",
            style: {
                color
            },
            checked,
            disabled,
            onChange: this.handleChange
        }, nativeProps)), h("slot", null));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "id": [
                "watchId"
            ]
        };
    }
    static get style() {
        return indexCss4;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "checkboxchange", 7);
        this.handleChange = (e)=>{
            e.stopPropagation();
            this.onChange.emit({
                value: this.value
            });
        };
        this.name = void 0;
        this.value = "";
        this.color = void 0;
        this.id = void 0;
        this.checked = false;
        this.disabled = false;
        this.nativeProps = {};
        this.isWillLoadCalled = false;
    }
}, [
    4,
    "taro-checkbox-core",
    {
        "name": [
            1
        ],
        "value": [
            1032
        ],
        "color": [
            1
        ],
        "id": [
            1025
        ],
        "checked": [
            4
        ],
        "disabled": [
            4
        ],
        "nativeProps": [
            16
        ],
        "isWillLoadCalled": [
            32
        ]
    }
]);
function defineCustomElement$113() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-checkbox-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-checkbox-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Checkbox);
                }
                break;
        }
    });
}
var defineCustomElement15 = defineCustomElement$113;
// node_modules/@tarojs/components/dist/components/taro-checkbox-group-core.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CheckboxGroup_value;
var CheckboxGroup = proxyCustomElement(class extends H {
    function(e) {
        e.stopPropagation();
        if (e.target.tagName !== "TARO-CHECKBOX-CORE") return;
        const childList = this.el.querySelectorAll("taro-checkbox-core");
        __classPrivateFieldSet(this, _CheckboxGroup_value, this.getValues(childList), "f");
        this.onChange.emit({
            value: __classPrivateFieldGet(this, _CheckboxGroup_value, "f")
        });
    }
    componentDidLoad() {
        const childList = this.el.querySelectorAll("taro-checkbox-core");
        childList.forEach((element)=>{
            element.setAttribute("name", this.name || this.uniqueName);
        });
        Object.defineProperty(this.el, "value", {
            get: ()=>{
                if (!__classPrivateFieldGet(this, _CheckboxGroup_value, "f")) {
                    const childList2 = this.el.querySelectorAll("taro-checkbox-core");
                    __classPrivateFieldSet(this, _CheckboxGroup_value, this.getValues(childList2), "f");
                }
                return __classPrivateFieldGet(this, _CheckboxGroup_value, "f");
            },
            configurable: true
        });
    }
    getValues(childList) {
        return Array.from(childList).filter((element)=>{
            const checkbox = element.querySelector("input");
            return checkbox === null || checkbox === void 0 ? void 0 : checkbox.checked;
        }).map((element)=>element.value);
    }
    render() {
        return h(Host, null);
    }
    get el() {
        return this;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "change", 7);
        this.uniqueName = Date.now().toString(36);
        _CheckboxGroup_value.set(this, void 0);
        this.name = void 0;
    }
}, [
    0,
    "taro-checkbox-group-core",
    {
        "name": [
            8
        ]
    },
    [
        [
            0,
            "checkboxchange",
            "function"
        ]
    ]
]);
_CheckboxGroup_value = /* @__PURE__ */ new WeakMap();
function defineCustomElement$114() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-checkbox-group-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-checkbox-group-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, CheckboxGroup);
                }
                break;
        }
    });
}
var defineCustomElement16 = defineCustomElement$114;
// node_modules/@tarojs/components/dist/components/taro-comment-detail-core.js
var CommentDetail = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("CommentDetail", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-comment-detail-core"
]);
function defineCustomElement$115() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-comment-detail-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-comment-detail-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, CommentDetail);
                }
                break;
        }
    });
}
var defineCustomElement17 = defineCustomElement$115;
// node_modules/@tarojs/components/dist/components/taro-comment-list-core.js
var CommentList = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("CommentList", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-comment-list-core"
]);
function defineCustomElement$116() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-comment-list-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-comment-list-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, CommentList);
                }
                break;
        }
    });
}
var defineCustomElement18 = defineCustomElement$116;
// node_modules/@tarojs/components/dist/components/taro-contact-button-core.js
var ContactButton = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("ContactButton", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-contact-button-core"
]);
function defineCustomElement$117() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-contact-button-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-contact-button-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, ContactButton);
                }
                break;
        }
    });
}
var defineCustomElement19 = defineCustomElement$117;
// node_modules/@tarojs/components/dist/components/taro-cover-image-core.js
var indexCss5 = "taro-cover-image-core{width:320px;height:240px;overflow:hidden}";
var CoverImage = proxyCustomElement(class extends H {
    imageOnLoad() {
        const { width, height } = this.imgRef;
        this.onLoad.emit({
            width,
            height
        });
    }
    imageOnError(e) {
        this.onError.emit(e);
    }
    render() {
        const { src, imageOnLoad, imageOnError, nativeProps } = this;
        return h("img", Object.assign({
            ref: (img)=>this.imgRef = img,
            src,
            onLoad: imageOnLoad.bind(this),
            onError: imageOnError.bind(this)
        }, nativeProps));
    }
    static get style() {
        return indexCss5;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onLoad = createEvent(this, "load", 7);
        this.onError = createEvent(this, "error", 7);
        this.src = void 0;
        this.nativeProps = {};
    }
}, [
    0,
    "taro-cover-image-core",
    {
        "src": [
            1
        ],
        "nativeProps": [
            16
        ]
    }
]);
function defineCustomElement$118() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-cover-image-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-cover-image-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, CoverImage);
                }
                break;
        }
    });
}
var defineCustomElement20 = defineCustomElement$118;
// node_modules/@tarojs/components/dist/components/taro-cover-view-core.js
var coverViewCss = "taro-cover-view-core{display:block}";
var CoverView = proxyCustomElement(class extends H {
    onTouchStart() {
        if (this.hoverClass) {
            this.touch = true;
            setTimeout(()=>{
                if (this.touch) {
                    this.hover = true;
                }
            }, this.hoverStartTime);
        }
        this.timeoutEvent = setTimeout(()=>{
            this.onLongPress.emit();
        }, 350);
        this.startTime = Date.now();
    }
    onTouchMove() {
        clearTimeout(this.timeoutEvent);
    }
    onTouchEnd() {
        const spanTime = Date.now() - this.startTime;
        if (spanTime < 350) {
            clearTimeout(this.timeoutEvent);
        }
        if (this.hoverClass) {
            this.touch = false;
            setTimeout(()=>{
                if (!this.touch) {
                    this.hover = false;
                }
            }, this.hoverStayTime);
        }
    }
    render() {
        const cls = classnames({
            [`${this.hoverClass}`]: this.hover
        });
        let attr2 = {};
        if (!!this.animation) {
            attr2["animation"] = this.animation;
            attr2["data-animation"] = this.animation;
        }
        return h(Host, Object.assign({
            class: cls
        }, attr2), h("slot", null));
    }
    static get style() {
        return coverViewCss;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onLongPress = createEvent(this, "longpress", 7);
        this.startTime = 0;
        this.animation = void 0;
        this.hoverClass = void 0;
        this.hoverStartTime = 50;
        this.hoverStayTime = 400;
        this.hover = false;
        this.touch = false;
    }
}, [
    4,
    "taro-cover-view-core",
    {
        "animation": [
            1
        ],
        "hoverClass": [
            1,
            "hover-class"
        ],
        "hoverStartTime": [
            2,
            "hover-start-time"
        ],
        "hoverStayTime": [
            2,
            "hover-stay-time"
        ],
        "hover": [
            32
        ],
        "touch": [
            32
        ]
    },
    [
        [
            1,
            "touchstart",
            "onTouchStart"
        ],
        [
            1,
            "touchmove",
            "onTouchMove"
        ],
        [
            1,
            "touchend",
            "onTouchEnd"
        ]
    ]
]);
function defineCustomElement$119() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-cover-view-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-cover-view-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, CoverView);
                }
                break;
        }
    });
}
var defineCustomElement21 = defineCustomElement$119;
// node_modules/@tarojs/components/dist/components/taro-custom-wrapper-core.js
var CustomWrapper = proxyCustomElement(class extends H {
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-custom-wrapper-core"
]);
function defineCustomElement$120() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-custom-wrapper-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-custom-wrapper-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, CustomWrapper);
                }
                break;
        }
    });
}
var defineCustomElement22 = defineCustomElement$120;
// node_modules/@tarojs/components/dist/components/taro-editor-core.js
var Editor = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Editor", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-editor-core"
]);
function defineCustomElement$121() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-editor-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-editor-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Editor);
                }
                break;
        }
    });
}
var defineCustomElement23 = defineCustomElement$121;
// node_modules/@tarojs/components/dist/components/taro-follow-swan-core.js
var FollowSwan = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("FollowSwan", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-follow-swan-core"
]);
function defineCustomElement$122() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-follow-swan-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-follow-swan-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, FollowSwan);
                }
                break;
        }
    });
}
var defineCustomElement24 = defineCustomElement$122;
// node_modules/@tarojs/components/dist/components/taro-form-core.js
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Form_value;
var Form = proxyCustomElement(class extends H {
    onButtonSubmit(e) {
        e.stopPropagation();
        __classPrivateFieldSet2(this, _Form_value, this.getFormValue(), "f");
        this.onSubmit.emit({
            value: __classPrivateFieldGet2(this, _Form_value, "f")
        });
    }
    onButtonReset(e) {
        e.stopPropagation();
        this.form.reset();
    }
    componentDidLoad() {
        __classPrivateFieldSet2(this, _Form_value, this.getFormValue(), "f");
        Object.defineProperty(this.el, "value", {
            get: ()=>__classPrivateFieldGet2(this, _Form_value, "f"),
            configurable: true
        });
    }
    componentDidRender() {
        if (!this.originalAppendChild) {
            this.originalAppendChild = this.el.appendChild;
            this.originalInsertBefore = this.el.insertBefore;
            this.originalReplaceChild = this.el.replaceChild;
            this.originalRemoveChild = this.el.removeChild;
        }
        if (!this.form) {
            this.el.appendChild = this.originalAppendChild;
            this.el.insertBefore = this.originalInsertBefore;
            this.el.replaceChild = this.originalReplaceChild;
            this.el.removeChild = this.originalRemoveChild;
            return;
        }
        this.el.appendChild = (newChild)=>{
            return this.form.appendChild(newChild);
        };
        this.el.insertBefore = (newChild, refChild)=>{
            return this.form.insertBefore(newChild, refChild);
        };
        this.el.replaceChild = (newChild, oldChild)=>{
            return this.form.replaceChild(newChild, oldChild);
        };
        this.el.removeChild = (oldChild)=>{
            return this.form.removeChild(oldChild);
        };
    }
    getFormValue() {
        const el = this.el;
        const elements = [];
        const tagElements = el.getElementsByTagName("input");
        for(let j = 0; j < tagElements.length; j++){
            elements.push(tagElements[j]);
        }
        const formItem = {};
        const hash = {};
        elements.forEach((item)=>{
            if (typeof item.name !== "string") return;
            if (item.className.indexOf("weui-switch") !== -1) {
                formItem[item.name] = item.checked;
                return;
            }
            if (item.type === "radio") {
                if (item.checked) {
                    hash[item.name] = true;
                    formItem[item.name] = item.value;
                } else {
                    if (!hash[item.name]) {
                        formItem[item.name] = "";
                    }
                }
                return;
            }
            if (item.type === "checkbox") {
                if (item.checked) {
                    if (hash[item.name]) {
                        formItem[item.name].push(item.value);
                    } else {
                        hash[item.name] = true;
                        formItem[item.name] = [
                            item.value
                        ];
                    }
                } else {
                    if (!hash[item.name]) {
                        formItem[item.name] = [];
                    }
                }
                return;
            }
            formItem[item.name] = item.value;
        });
        const textareaElements = el.getElementsByTagName("textarea");
        const textareaEleArr = [];
        for(let i2 = 0; i2 < textareaElements.length; i2++){
            textareaEleArr.push(textareaElements[i2]);
        }
        textareaEleArr.forEach((v)=>{
            if (typeof v.name !== "string") return;
            formItem[v.name] = v.value;
        });
        return formItem;
    }
    render() {
        return h("form", {
            ref: (dom)=>{
                this.form = dom;
            }
        }, h("slot", null));
    }
    get el() {
        return this;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onSubmit = createEvent(this, "submit", 7);
        _Form_value.set(this, {});
    }
}, [
    4,
    "taro-form-core",
    void 0,
    [
        [
            0,
            "tarobuttonsubmit",
            "onButtonSubmit"
        ],
        [
            0,
            "tarobuttonreset",
            "onButtonReset"
        ]
    ]
]);
_Form_value = /* @__PURE__ */ new WeakMap();
function defineCustomElement$123() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-form-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-form-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Form);
                }
                break;
        }
    });
}
var defineCustomElement25 = defineCustomElement$123;
// node_modules/@tarojs/components/dist/components/taro-functional-page-navigator-core.js
var FunctionalPageNavigator = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("FunctionalPageNavigator", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-functional-page-navigator-core"
]);
function defineCustomElement$124() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-functional-page-navigator-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-functional-page-navigator-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, FunctionalPageNavigator);
                }
                break;
        }
    });
}
var defineCustomElement26 = defineCustomElement$124;
// node_modules/@tarojs/components/dist/components/taro-grid-view-core.js
var GridView = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("GridView", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-grid-view-core"
]);
function defineCustomElement$125() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-grid-view-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-grid-view-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, GridView);
                }
                break;
        }
    });
}
var defineCustomElement27 = defineCustomElement$125;
// node_modules/@tarojs/components/dist/components/taro-icon-core.js
var indexCss6 = '.weui-icon-circle:before{content:"\uEA01"}.weui-icon-download:before{content:"\uEA02"}.weui-icon-info:before{content:"\uEA03"}.weui-icon-safe-success:before{content:"\uEA04"}.weui-icon-safe-warn:before{content:"\uEA05"}.weui-icon-success:before{content:"\uEA06"}.weui-icon-success-circle:before{content:"\uEA07"}.weui-icon-success-no-circle:before{content:"\uEA08"}.weui-icon-waiting:before{content:"\uEA09"}.weui-icon-waiting-circle:before{content:"\uEA0A"}.weui-icon-warn:before{content:"\uEA0B"}.weui-icon-info-circle:before{content:"\uEA0C"}.weui-icon-cancel:before{content:"\uEA0D"}.weui-icon-search:before{content:"\uEA0E"}.weui-icon-clear:before{content:"\uEA0F"}.weui-icon-back:before{content:"\uEA10"}.weui-icon-delete:before{content:"\uEA11"}.weui-icon-success{color:#09bb07;font-size:23px}.weui-icon-waiting{color:#10aeff;font-size:23px}.weui-icon-warn{color:#f43530;font-size:23px}.weui-icon-info{color:#10aeff;font-size:23px}.weui-icon-success-circle,.weui-icon-success-no-circle{color:#09bb07;font-size:23px}.weui-icon-waiting-circle{color:#10aeff;font-size:23px}.weui-icon-circle{color:#c9c9c9;font-size:23px}.weui-icon-download,.weui-icon-info-circle{color:#09bb07;font-size:23px}.weui-icon-safe-success{color:#09bb07}.weui-icon-safe-warn{color:#ffbe00}.weui-icon-cancel{color:#f43530;font-size:22px}.weui-icon-search,.weui-icon-clear{color:#b2b2b2;font-size:14px}.weui-icon-delete.weui-icon_gallery-delete{color:#fff;font-size:22px}.weui-icon_msg{font-size:93px}.weui-icon_msg.weui-icon-warn{color:#f76260}.weui-icon_msg-primary{font-size:93px}.weui-icon_msg-primary.weui-icon-warn{color:#ffbe00}';
var Icon = proxyCustomElement(class extends H {
    render() {
        const { type, size, color } = this;
        const iconType = type === null || type === void 0 ? void 0 : type.replace(/_/g, "-");
        const cls = classnames({
            [`weui-icon-${iconType}`]: true
        });
        const style = {
            "font-size": `${size}px`,
            color
        };
        return h(Host, {
            class: cls,
            style
        });
    }
    static get style() {
        return indexCss6;
    }
    constructor(){
        super();
        this.__registerHost();
        this.type = void 0;
        this.size = "23";
        this.color = void 0;
    }
}, [
    0,
    "taro-icon-core",
    {
        "type": [
            1
        ],
        "size": [
            8
        ],
        "color": [
            1
        ]
    }
]);
function defineCustomElement$126() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-icon-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-icon-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Icon);
                }
                break;
        }
    });
}
var defineCustomElement28 = defineCustomElement$126;
// node_modules/@tarojs/components/dist/components/taro-image-core.js
var indexCss7 = 'img[src=""]{opacity:0}taro-image-core{width:auto;height:auto;font-size:0;display:inline-block;position:relative;overflow:hidden}.taro-img.taro-img__widthfix{height:100%}.taro-img__mode-scaletofill{width:100%;height:100%}.taro-img__mode-aspectfit{max-width:100%;max-height:100%}.taro-img__mode-aspectfill{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.taro-img__mode-aspectfill--width{min-width:100%;height:100%}.taro-img__mode-aspectfill--height{width:100%;min-height:100%}.taro-img__mode-widthfix{width:100%}.taro-img__mode-heightfix{height:100%}.taro-img__mode-top{width:100%}.taro-img__mode-bottom{width:100%;position:absolute;bottom:0}.taro-img__mode-left{height:100%}.taro-img__mode-right{height:100%;position:absolute;right:0}.taro-img__mode-topright{position:absolute;right:0}.taro-img__mode-bottomleft{position:absolute;bottom:0}.taro-img__mode-bottomright{position:absolute;bottom:0;right:0}';
var Image2 = proxyCustomElement(class extends H {
    componentDidLoad() {
        if (!this.lazyLoad) return;
        const lazyImg = new IntersectionObserver((entries)=>{
            if (entries[entries.length - 1].isIntersecting) {
                lazyImg.unobserve(this.imgRef);
                this.didLoad = true;
            }
        }, {
            rootMargin: "300px 0px"
        });
        lazyImg.observe(this.imgRef);
    }
    imageOnLoad() {
        const { width, height, naturalWidth, naturalHeight } = this.imgRef;
        this.onLoad.emit({
            width,
            height
        });
        this.aspectFillMode = naturalWidth > naturalHeight ? "width" : "height";
    }
    imageOnError(e) {
        this.onError.emit(e);
    }
    render() {
        const { src, lazyLoad: lazyLoad2 = false, aspectFillMode = "width", imageOnLoad, imageOnError, nativeProps, didLoad } = this;
        const mode = this.mode || "scaleToFill";
        const cls = classnames({
            "taro-img__widthfix": mode === "widthFix"
        });
        const imgCls = classnames(`taro-img__mode-${mode.toLowerCase().replace(/\s/g, "")}`, {
            [`taro-img__mode-aspectfill--${aspectFillMode}`]: mode === "aspectFill"
        });
        return h(Host, {
            class: cls
        }, src ? h("img", Object.assign({
            ref: (img)=>this.imgRef = img,
            class: imgCls,
            src: lazyLoad2 && !didLoad ? void 0 : src,
            onLoad: imageOnLoad.bind(this),
            onError: imageOnError.bind(this)
        }, nativeProps)) : "");
    }
    static get style() {
        return indexCss7;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onLoad = createEvent(this, "load", 7);
        this.onError = createEvent(this, "error", 7);
        this.src = void 0;
        this.mode = "scaleToFill";
        this.lazyLoad = false;
        this.nativeProps = {};
        this.aspectFillMode = "width";
        this.didLoad = false;
    }
}, [
    0,
    "taro-image-core",
    {
        "src": [
            1
        ],
        "mode": [
            1
        ],
        "lazyLoad": [
            4,
            "lazy-load"
        ],
        "nativeProps": [
            16
        ],
        "aspectFillMode": [
            32
        ],
        "didLoad": [
            32
        ]
    }
]);
function defineCustomElement$127() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-image-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-image-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Image2);
                }
                break;
        }
    });
}
var defineCustomElement29 = defineCustomElement$127;
// node_modules/@tarojs/components/dist/components/taro-inline-payment-panel-core.js
var InlinePaymentPanel = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("InlinePaymentPanel", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-inline-payment-panel-core"
]);
function defineCustomElement$128() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-inline-payment-panel-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-inline-payment-panel-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, InlinePaymentPanel);
                }
                break;
        }
    });
}
var defineCustomElement30 = defineCustomElement$128;
// node_modules/@tarojs/components/dist/components/taro-input-core.js
var indexCss8 = ".weui-input{-webkit-appearance:none;font-size:inherit;color:inherit;background-color:transparent;border:0;outline:0;width:100%;height:1.47059em;line-height:1.47059}.weui-input::-webkit-outer-spin-button,.weui-input::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}taro-input-core{display:block}input{text-overflow:clip;text-align:inherit;white-space:nowrap;height:1.4rem;display:block;overflow:hidden}";
function getTrueType(type, confirmType, password) {
    if (confirmType === "search") type = "search";
    if (password) type = "password";
    if (typeof type === "undefined") {
        return "text";
    }
    if (!type) {
        throw new Error("unexpected type");
    }
    if (type === "digit") type = "number";
    return type;
}
function fixControlledValue(value) {
    return value !== null && value !== void 0 ? value : "";
}
var Input = proxyCustomElement(class extends H {
    focus() {
        var _this = this;
        return _async_to_generator(function*() {
            _this.inputRef.focus();
        })();
    }
    watchAutoFocus(newValue, oldValue) {
        var _a;
        if (!oldValue && newValue) {
            (_a = this.inputRef) === null || _a === void 0 ? void 0 : _a.focus();
        }
    }
    watchValue(newValue) {
        const value = fixControlledValue(newValue);
        if (this.inputRef.value !== value) {
            this.inputRef.value = value;
        }
    }
    componentDidLoad() {
        var _a, _b, _c, _d, _e;
        if (this.type === "file") {
            this.fileListener = ()=>{
                this.onInput.emit();
            };
            (_a = this.inputRef) === null || _a === void 0 ? void 0 : _a.addEventListener("change", this.fileListener);
        } else {
            (_b = this.inputRef) === null || _b === void 0 ? void 0 : _b.addEventListener("compositionstart", this.handleComposition);
            (_c = this.inputRef) === null || _c === void 0 ? void 0 : _c.addEventListener("compositionend", this.handleComposition);
            (_d = this.inputRef) === null || _d === void 0 ? void 0 : _d.addEventListener("beforeinput", this.handleBeforeInput);
            (_e = this.inputRef) === null || _e === void 0 ? void 0 : _e.addEventListener("textInput", this.handleBeforeInput);
        }
    }
    disconnectedCallback() {
        var _a, _b, _c, _d, _e;
        if (this.type === "file") {
            (_a = this.inputRef) === null || _a === void 0 ? void 0 : _a.removeEventListener("change", this.fileListener);
        } else {
            (_b = this.inputRef) === null || _b === void 0 ? void 0 : _b.removeEventListener("compositionstart", this.handleComposition);
            (_c = this.inputRef) === null || _c === void 0 ? void 0 : _c.removeEventListener("compositionend", this.handleComposition);
            (_d = this.inputRef) === null || _d === void 0 ? void 0 : _d.removeEventListener("beforeinput", this.handleBeforeInput);
            (_e = this.inputRef) === null || _e === void 0 ? void 0 : _e.removeEventListener("textInput", this.handleBeforeInput);
        }
    }
    render() {
        const { value, type, password, placeholder, autoFocus, disabled, maxlength, confirmType, name, nativeProps } = this;
        return h("input", Object.assign({
            ref: (input)=>{
                this.inputRef = input;
                if (autoFocus && input) input.focus();
            },
            class: "weui-input",
            type: getTrueType(type, confirmType, password),
            placeholder,
            autoFocus,
            disabled,
            maxlength,
            name,
            onInput: this.handleInput,
            onFocus: this.handleFocus,
            onBlur: this.handleBlur,
            onChange: this.handleChange,
            onKeyDown: this.handleKeyDown,
            onPaste: this.handlePaste,
            onCompositionStart: this.handleComposition,
            onCompositionEnd: this.handleComposition
        }, nativeProps, {
            value: fixControlledValue(value)
        }));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "autoFocus": [
                "watchAutoFocus"
            ],
            "value": [
                "watchValue"
            ]
        };
    }
    static get style() {
        return indexCss8;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onInput = createEvent(this, "input", 7);
        this.onPaste = createEvent(this, "paste", 7);
        this.onFocus = createEvent(this, "focus", 7);
        this.onBlur = createEvent(this, "blur", 7);
        this.onConfirm = createEvent(this, "confirm", 7);
        this.onChange = createEvent(this, "change", 7);
        this.onKeyDown = createEvent(this, "keydown", 7);
        this.isOnComposition = false;
        this.isOnPaste = false;
        this.onInputExcuted = false;
        this.handleInput = (e)=>{
            e.stopPropagation();
            const { type, maxlength, confirmType, password } = this;
            if (!this.isOnComposition && !this.onInputExcuted) {
                let value = e.target.value;
                const inputType = getTrueType(type, confirmType, password);
                this.onInputExcuted = true;
                if (inputType === "number" && value && maxlength > -1 && maxlength <= value.length) {
                    value = value.substring(0, maxlength);
                    e.target.value = value;
                }
                this.value = value;
                this.onInput.emit({
                    value,
                    cursor: value.length
                });
                this.onInputExcuted = false;
            }
        };
        this.handlePaste = (e)=>{
            e.stopPropagation();
            this.isOnPaste = true;
            this.onPaste.emit({
                value: e.target.value
            });
        };
        this.handleFocus = (e)=>{
            e.stopPropagation();
            this.onInputExcuted = false;
            this.onFocus.emit({
                value: e.target.value
            });
        };
        this.handleBlur = (e)=>{
            e.stopPropagation();
            this.onBlur.emit({
                value: e.target.value
            });
        };
        this.handleChange = (e)=>{
            e.stopPropagation();
            this.onChange.emit({
                value: e.target.value
            });
            if (this.isOnPaste) {
                this.isOnPaste = false;
                this.value = e.target.value;
                this.onInput.emit({
                    value: e.target.value,
                    cursor: e.target.value.length
                });
            }
        };
        this.handleKeyDown = (e)=>{
            e.stopPropagation();
            const { value } = e.target;
            const keyCode = e.keyCode || e.code;
            this.onInputExcuted = false;
            this.onKeyDown.emit({
                value,
                cursor: value.length,
                keyCode
            });
            keyCode === 13 && this.onConfirm.emit({
                value
            });
        };
        this.handleComposition = (e)=>{
            e.stopPropagation();
            if (!(e.target instanceof HTMLInputElement)) return;
            if (e.type === "compositionend") {
                this.isOnComposition = false;
                this.value = e.target.value;
                this.onInput.emit({
                    value: e.target.value,
                    cursor: e.target.value.length
                });
            } else {
                this.isOnComposition = true;
            }
        };
        this.handleBeforeInput = (e)=>{
            if (!e.data) return;
            const isNumber = e.data && /[0-9]/.test(e.data);
            if (this.type === "number" && !isNumber) {
                e.preventDefault();
            }
            if (this.type === "digit" && !isNumber) {
                if (e.data !== "." || e.data === "." && e.target.value.indexOf(".") > -1) {
                    e.preventDefault();
                }
            }
        };
        this.value = "";
        this.type = void 0;
        this.password = false;
        this.placeholder = void 0;
        this.disabled = false;
        this.maxlength = 140;
        this.autoFocus = false;
        this.confirmType = "done";
        this.name = void 0;
        this.nativeProps = {};
    }
}, [
    0,
    "taro-input-core",
    {
        "value": [
            1025
        ],
        "type": [
            1
        ],
        "password": [
            4
        ],
        "placeholder": [
            1
        ],
        "disabled": [
            4
        ],
        "maxlength": [
            2
        ],
        "autoFocus": [
            4,
            "focus"
        ],
        "confirmType": [
            1,
            "confirm-type"
        ],
        "name": [
            1
        ],
        "nativeProps": [
            16
        ],
        "focus": [
            64
        ]
    }
]);
function defineCustomElement$129() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-input-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-input-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Input);
                }
                break;
        }
    });
}
var defineCustomElement31 = defineCustomElement$129;
// node_modules/@tarojs/components/dist/components/taro-keyboard-accessory-core.js
var KeyboardAccessory = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("KeyboardAccessory", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-keyboard-accessory-core"
]);
function defineCustomElement$130() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-keyboard-accessory-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-keyboard-accessory-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, KeyboardAccessory);
                }
                break;
        }
    });
}
var defineCustomElement32 = defineCustomElement$130;
// node_modules/@tarojs/components/dist/components/taro-label-core.js
var Label = proxyCustomElement(class extends H {
    render() {
        return h("label", {
            htmlFor: this.for
        }, h("slot", null));
    }
    constructor(){
        super();
        this.__registerHost();
        this.for = void 0;
    }
}, [
    4,
    "taro-label-core",
    {
        "for": [
            1
        ]
    }
]);
function defineCustomElement$131() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-label-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-label-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Label);
                }
                break;
        }
    });
}
var defineCustomElement33 = defineCustomElement$131;
// node_modules/@tarojs/components/dist/components/taro-lifestyle-core.js
var Lifestyle = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Lifestyle", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-lifestyle-core"
]);
function defineCustomElement$132() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-lifestyle-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-lifestyle-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Lifestyle);
                }
                break;
        }
    });
}
var defineCustomElement34 = defineCustomElement$132;
// node_modules/@tarojs/components/dist/components/taro-like-core.js
var Like = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Like", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-like-core"
]);
function defineCustomElement$133() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-like-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-like-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Like);
                }
                break;
        }
    });
}
var defineCustomElement35 = defineCustomElement$133;
// node_modules/@tarojs/components/dist/components/taro-list-view-core.js
var ListView = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("ListView", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-list-view-core"
]);
function defineCustomElement$134() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-list-view-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-list-view-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, ListView);
                }
                break;
        }
    });
}
var defineCustomElement36 = defineCustomElement$134;
// node_modules/@tarojs/components/dist/components/taro-live-player-core.js
var LivePlayer = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("LivePlayer", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-live-player-core"
]);
function defineCustomElement$135() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-live-player-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-live-player-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, LivePlayer);
                }
                break;
        }
    });
}
var defineCustomElement37 = defineCustomElement$135;
// node_modules/@tarojs/components/dist/components/taro-live-pusher-core.js
var LivePusher = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("LivePusher", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-live-pusher-core"
]);
function defineCustomElement$136() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-live-pusher-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-live-pusher-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, LivePusher);
                }
                break;
        }
    });
}
var defineCustomElement38 = defineCustomElement$136;
// node_modules/@tarojs/components/dist/components/taro-login-core.js
var Login = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Login", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-login-core"
]);
function defineCustomElement$137() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-login-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-login-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Login);
                }
                break;
        }
    });
}
var defineCustomElement39 = defineCustomElement$137;
// node_modules/@tarojs/components/dist/components/taro-lottie-core.js
var Lottie = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Lottie", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-lottie-core"
]);
function defineCustomElement$138() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-lottie-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-lottie-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Lottie);
                }
                break;
        }
    });
}
var defineCustomElement40 = defineCustomElement$138;
// node_modules/@tarojs/components/dist/components/taro-map-core.js
var Map3 = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Map", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-map-core"
]);
function defineCustomElement$139() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-map-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-map-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Map3);
                }
                break;
        }
    });
}
var defineCustomElement41 = defineCustomElement$139;
// node_modules/@tarojs/components/dist/components/taro-match-media-core.js
var MatchMedia = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("MatchMedia", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-match-media-core"
]);
function defineCustomElement$140() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-match-media-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-match-media-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, MatchMedia);
                }
                break;
        }
    });
}
var defineCustomElement42 = defineCustomElement$140;
// node_modules/@tarojs/components/dist/components/taro-movable-area-core.js
var areaCss = "taro-movable-area-core{width:10px;height:10px;display:block;position:relative}";
var MovableArea = proxyCustomElement(class extends H {
    connectedCallback() {
        this.observer = new MutationObserver((mutations)=>{
            mutations.forEach((mutation)=>{
                var _a, _b;
                if (mutation.attributeName === "class" || mutation.attributeName === "style") {
                    const offsetWidth = this.element.offsetWidth;
                    const offsetHeight = this.element.offsetHeight;
                    if (offsetWidth !== ((_a = this.offset) === null || _a === void 0 ? void 0 : _a.width) || offsetHeight !== ((_b = this.offset) === null || _b === void 0 ? void 0 : _b.height)) {
                        this.updateArea();
                    }
                    this.offset = {
                        width: offsetWidth,
                        height: offsetHeight
                    };
                }
            });
        });
        this.observer.observe(this.element, {
            attributes: true
        });
    }
    disconnectedCallback() {
        var _a;
        (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    componentDidLoad() {
        this.viewsChanged();
    }
    render() {
        return h(Host, {
            onTouchStart: this.handleTouchStart,
            onTouchMove: this.handleTouchMove,
            onTouchEnd: this.handleTouchEnd
        });
    }
    get element() {
        return this;
    }
    static get style() {
        return areaCss;
    }
    constructor(){
        super();
        this.__registerHost();
        this.views = [];
        this.scaleLength = 0;
        this.viewsChanged = ()=>{
            this.views = [];
            const elements = this.element.querySelectorAll("taro-movable-view-core");
            Array.from(elements).forEach((element)=>{
                this.views.push(element);
            });
            this.updateArea();
        };
        this.handleTouchStart = (e)=>{
            const touches = e.touches;
            if (!touches || touches.length <= 1) {
                return;
            }
            const gap = {
                width: touches[1].pageX - touches[0].pageX,
                height: touches[1].pageY - touches[0].pageY
            };
            this.scaleLength = Math.sqrt(gap.width * gap.width + gap.height * gap.height);
            if (this.scaleArea) {
                return;
            }
            const find2 = (target, views)=>{
                const loop = (e2, t)=>{
                    if (!(e2 = e2.parentNode)) {
                        return false;
                    }
                    return (!(e2 instanceof H) || e2 !== document.body) && (e2 === t || e2 === t.element || e2.element === t || loop(e2, t));
                };
                for(let i2 = 0; i2 < views.length; i2++){
                    const view = views[i2];
                    if (target === view["element"] || loop(target, view)) {
                        return view;
                    }
                }
            };
            const touch1 = find2(touches[0].target, this.views);
            const touch2 = find2(touches[1].target, this.views);
            this.scaleTarget = touch1 && touch1 === touch2 ? touch1 : void 0;
        };
        this.handleTouchMove = (e)=>{
            const touches = e.touches;
            if (!touches || touches.length <= 1) {
                return;
            }
            e.preventDefault();
            const gap = {
                width: touches[1].pageX - touches[0].pageX,
                height: touches[1].pageY - touches[0].pageY
            };
            if (this.scaleLength > 0) {
                this.updateScale(Math.sqrt(gap.width * gap.width + gap.height * gap.height) / this.scaleLength);
            }
        };
        this.handleTouchEnd = (e)=>{
            var _a, _b;
            if (e.touches && e.touches.length || !e.changedTouches) {
                return;
            }
            this.scaleLength = 0;
            if (this.scaleArea) {
                this.views.forEach((element)=>{
                    var _a2;
                    (_a2 = element["endScale"]) === null || _a2 === void 0 ? void 0 : _a2.call(element);
                });
            } else {
                (_b = (_a = this.scaleTarget) === null || _a === void 0 ? void 0 : _a["endScale"]) === null || _b === void 0 ? void 0 : _b.call(_a);
            }
            this.scaleTarget = void 0;
        };
        this.updateScale = (scale)=>{
            var _a, _b;
            if (!scale || scale === 1) {
                return;
            }
            if (this.scaleArea) {
                this.views.forEach((element)=>{
                    var _a2;
                    (_a2 = element["setScale"]) === null || _a2 === void 0 ? void 0 : _a2.call(element, scale);
                });
            } else {
                (_b = (_a = this.scaleTarget) === null || _a === void 0 ? void 0 : _a["setScale"]) === null || _b === void 0 ? void 0 : _b.call(_a, scale);
            }
        };
        this.updateArea = ()=>{
            const computedStyle = window.getComputedStyle(this.element);
            const clientRect = this.element.getBoundingClientRect();
            const horizontal = [
                "Left",
                "Right"
            ].map((e)=>{
                return parseFloat(computedStyle["border" + e + "Width"]) + parseFloat(computedStyle["padding" + e]);
            });
            const vertical = [
                "Top",
                "Bottom"
            ].map((e)=>{
                return parseFloat(computedStyle["border" + e + "Width"]) + parseFloat(computedStyle["padding" + e]);
            });
            this.views.forEach((element)=>{
                var _a;
                (_a = element["setParent"]) === null || _a === void 0 ? void 0 : _a.call(element, {
                    element: this.element,
                    area: {
                        height: clientRect.height - vertical[0] - vertical[1],
                        width: clientRect.width - horizontal[0] - horizontal[1]
                    }
                });
            });
        };
        this.scaleArea = void 0;
    }
}, [
    0,
    "taro-movable-area-core",
    {
        "scaleArea": [
            4,
            "scale-area"
        ]
    }
]);
function defineCustomElement$141() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-movable-area-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-movable-area-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, MovableArea);
                }
                break;
        }
    });
}
var defineCustomElement43 = defineCustomElement$141;
// node_modules/@tarojs/components/dist/components/taro-movable-view-core.js
var viewCss = "taro-movable-view-core{width:10px;height:10px;display:inline-block;position:absolute;top:0;left:0}";
var MovableView = proxyCustomElement(class extends H {
    watchX(newValue) {
        this.setTransform(parseFloat(`${newValue || 0}`), this.translateY);
    }
    watchY(newValue) {
        this.setTransform(this.translateX, parseFloat(`${newValue || 0}`));
    }
    watchScaleMinOrMax() {
        if (!this.scale) return false;
        this.updateScale(this.currentScale, true);
        this.setOriginScale(this.currentScale);
    }
    watchScaleValue(scale) {
        if (!this.scale) {
            return false;
        }
        this.updateScale(scale, true);
        this.setOriginScale(scale);
        return scale;
    }
    /**
   * 设置父节点
   */ setParent({ element, area }) {
        var _this = this;
        return _async_to_generator(function*() {
            const scale = _this.scale ? _this.scaleValue : 1;
            _this.area = area;
            _this.parent = element;
            _this.updateOffset();
            _this.updateScaleOffset(scale);
            _this.updateBoundary();
            _this.setTransform(Number(_this.x) + _this.scaleOffset.x, Number(_this.y) + _this.scaleOffset.y, scale, "", true);
            _this.setOriginScale(scale);
        })();
    }
    /**
   * 结束缩放
   */ endScale() {
        var _this = this;
        return _async_to_generator(function*() {
            _this.scaling = false;
            _this.setOriginScale(_this.currentScale);
        })();
    }
    /**
   * 更新缩放
   */ setScale(scale) {
        var _this = this;
        return _async_to_generator(function*() {
            if (!_this.scale) {
                return;
            }
            _this.scaling = true;
            _this.updateScale(scale * _this.originScale);
        })();
    }
    connectedCallback() {
        this.observer = new MutationObserver((mutations)=>{
            mutations.forEach((mutation)=>{
                const name = mutation.attributeName;
                if (name && [
                    "class",
                    "style"
                ].includes(name)) {
                    const oldValue = mutation.oldValue;
                    const newValue = mutation.target.getAttribute(name);
                    if (oldValue === newValue) {
                        return;
                    }
                    const filter3 = (input)=>{
                        return input === null || input === void 0 ? void 0 : input.split(";").filter((item)=>{
                            return ![
                                "transform",
                                "will-change"
                            ].find((key)=>{
                                return item.trim().startsWith(key);
                            });
                        }).join(";");
                    };
                    if (name === "style" && filter3(newValue) === filter3(oldValue)) {
                        return;
                    }
                    this.updateOffset();
                    this.updateScaleOffset();
                    this.updateBoundary();
                    this.setTransform(this.translateX, this.translateY);
                }
            });
        });
        this.observer.observe(this.element, {
            attributes: true,
            attributeOldValue: true
        });
    }
    disconnectedCallback() {
        var _a;
        (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    componentDidLoad() {
        this.element.style.transformOrigin = "center";
        this.xMove = [
            "horizontal",
            "all"
        ].includes(this.direction);
        this.yMove = [
            "vertical",
            "all"
        ].includes(this.direction);
        if (this.friction <= 0) {
            this.friction = 2;
        }
        if (this.x || this.y) {
            const x = parseFloat(`${this.x || 0}`);
            const y = parseFloat(`${this.y || 0}`);
            this.setTransform(x, y);
        }
    }
    render() {
        return h(Host, {
            onTouchStart: this.handleTouchStart,
            onTouchMove: this.handleTouchMove,
            onTouchEnd: this.handleTouchEnd
        });
    }
    get element() {
        return this;
    }
    static get watchers() {
        return {
            "x": [
                "watchX"
            ],
            "y": [
                "watchY"
            ],
            "scaleMin": [
                "watchScaleMinOrMax"
            ],
            "scaleMax": [
                "watchScaleMinOrMax"
            ],
            "scaleValue": [
                "watchScaleValue"
            ]
        };
    }
    static get style() {
        return viewCss;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "change", 7);
        this.onScale = createEvent(this, "scale", 7);
        this.onHTouchMove = createEvent(this, "htouchmove", 7);
        this.onVTouchMove = createEvent(this, "vtouchmove", 7);
        this.translateX = 0;
        this.translateY = 0;
        this.origin = {
            x: 0,
            y: 0
        };
        this.area = {
            width: 0,
            height: 0
        };
        this.originScale = 1;
        this.currentScale = 1;
        this.width = 0;
        this.height = 0;
        this.minX = 0;
        this.minY = 0;
        this.maxX = 0;
        this.maxY = 0;
        this.baseX = 0;
        this.baseY = 0;
        this.offset = {
            x: 0,
            y: 0
        };
        this.scaleOffset = {
            x: 0,
            y: 0
        };
        this.getLimitXY = (x, y)=>{
            let outOfBounds = false;
            x > this.maxX ? (x = this.maxX, outOfBounds = true) : x < this.minX && (x = this.minX, outOfBounds = true);
            y > this.maxY ? (y = this.maxY, outOfBounds = true) : y < this.minY && (y = this.minY, outOfBounds = true);
            return {
                x,
                y,
                outOfBounds
            };
        };
        this.animationTo = (x, y, scale, source, noEmitChange, emitScale, callback)=>{
            if (this.animation) {
                this.setTransform(x, y, scale, source, noEmitChange, emitScale);
                callback === null || callback === void 0 ? void 0 : callback();
            } else {
                this.setTransform(x, y, scale, source, noEmitChange, emitScale);
            }
        };
        this.setTransform = (x, y, scale, source, noEmitChange, emitScale)=>{
            x = Number(x.toFixed(1));
            y = Number(y.toFixed(1));
            scale = Number((scale !== null && scale !== void 0 ? scale : this.currentScale).toFixed(3));
            if (!this.outOfBounds) {
                const limit = this.getLimitXY(x, y);
                x = limit.x;
                y = limit.y;
            }
            const subtract = (e, t)=>{
                return +((1e3 * e - 1e3 * t) / 1e3).toFixed(1);
            };
            const realX = subtract(x, this.scaleOffset.x);
            const realY = subtract(y, this.scaleOffset.y);
            if (this.translateX !== x || this.translateY !== y) {
                !noEmitChange && this.onChange.emit({
                    x: realX,
                    y: realY,
                    source
                });
            }
            if (scale !== this.currentScale) {
                emitScale && this.onScale.emit({
                    scale,
                    x: realX,
                    y: realY
                });
            }
            const transform2 = `translateX(${x}px) translateY(${y}px) translateZ(0px) scale(${scale})`;
            this.element.style.transform = transform2;
            this.element.style.webkitTransform = transform2;
            this.translateX = x;
            this.translateY = y;
            this.currentScale = scale;
        };
        this.updateOffset = ()=>{
            const offset2 = (element, parent2)=>{
                if (element === parent2 || !element.offsetParent) {
                    return {
                        left: 0,
                        top: 0
                    };
                }
                const current2 = offset2(element.offsetParent, parent2);
                return {
                    left: element.offsetLeft + current2.left,
                    top: element.offsetTop + current2.top
                };
            };
            if (!this.parent) {
                return;
            }
            const current = offset2(this.element, this.parent);
            this.offset.x = current.left;
            this.offset.y = current.top;
        };
        this.updateScaleOffset = (scale = this.currentScale)=>{
            const rect = this.element.getBoundingClientRect();
            this.height = rect.height / this.currentScale;
            this.width = rect.width / this.currentScale;
            this.scaleOffset.x = (this.width * scale - this.width) / 2;
            this.scaleOffset.y = (this.height * scale - this.height) / 2;
        };
        this.updateBoundary = ()=>{
            const x1 = 0 - this.offset.x + this.scaleOffset.x;
            const x2 = this.area.width - this.width - this.offset.x - this.scaleOffset.x;
            this.minX = Math.min(x1, x2);
            this.maxX = Math.max(x1, x2);
            const y1 = 0 - this.offset.y + this.scaleOffset.y;
            const y2 = this.area.height - this.height - this.offset.y - this.scaleOffset.y;
            this.minY = Math.min(y1, y2);
            this.maxY = Math.max(y1, y2);
        };
        this.updateScale = (scale, animation, animationCallback)=>{
            if (!this.scale) {
                return;
            }
            const target = this.adjustScale(scale);
            this.updateScaleOffset(target);
            this.updateBoundary();
            const { x, y } = this.getLimitXY(this.translateX, this.translateY);
            if (animation) {
                this.animationTo(x, y, target, "", true, true, animationCallback);
            } else if (!this.updating) {
                this.updating = true;
                requestAnimationFrame(()=>{
                    this.setTransform(x, y, target, "", true, true);
                    this.updating = false;
                });
            }
        };
        this.setOriginScale = (scale)=>{
            this.originScale = scale;
        };
        this.adjustScale = (scale)=>{
            return Math.min(10, this.scaleMax, Math.max(0.5, this.scaleMin, scale));
        };
        this.handleTouchStart = (e)=>{
            const touches = e.touches;
            if (this.disabled || touches.length > 1 || !this.element) {
                return;
            }
            const touch = touches[0];
            this.touching = true;
            this.firstMoveFireEvent = false;
            this.origin.x = touch.screenX;
            this.origin.y = touch.screenY;
            this.baseX = this.translateX;
            this.baseY = this.translateY;
            this.element.style.willChange = "transform";
        };
        this.handleTouchMove = (e)=>{
            const touches = e.touches;
            if (this.disabled || !this.element || this.scaling || !this.touching || touches.length > 1) {
                return;
            }
            e.preventDefault();
            const touch = touches[0];
            const x = touch.screenX - this.origin.x;
            const y = touch.screenY - this.origin.y;
            this.setTransform(this.xMove ? x + this.baseX : 0, this.yMove ? y + this.baseY : 0);
            if (!this.firstMoveFireEvent) {
                this.firstMoveFireEvent = true;
                const onTouchMove3 = Math.abs(x) > Math.abs(y) ? this.onHTouchMove : this.onVTouchMove;
                onTouchMove3.emit({
                    originalEvent: e,
                    bubbles: false,
                    capturePhase: false,
                    composed: true,
                    extraFields: {
                        touches: e.touches || {},
                        changedTouches: e.changedTouches || {}
                    }
                });
            }
        };
        this.handleTouchEnd = (e)=>{
            const touch = e.changedTouches[0];
            if (this.disabled || !this.touching || !touch) {
                return;
            }
            this.touching = false;
            const x = touch.screenX - this.origin.x;
            const y = touch.screenY - this.origin.y;
            this.setTransform(this.xMove ? x + this.baseX : 0, this.yMove ? y + this.baseY : 0);
        };
        this.x = 0;
        this.y = 0;
        this.direction = "none";
        this.outOfBounds = false;
        this.inertia = false;
        this.friction = 2;
        this.damping = 20;
        this.disabled = false;
        this.scale = false;
        this.scaleMin = 0.5;
        this.scaleMax = 10;
        this.scaleValue = 1;
        this.animation = true;
    }
}, [
    0,
    "taro-movable-view-core",
    {
        "x": [
            8
        ],
        "y": [
            8
        ],
        "direction": [
            1
        ],
        "outOfBounds": [
            4,
            "out-of-bounds"
        ],
        "inertia": [
            4
        ],
        "friction": [
            2
        ],
        "damping": [
            2
        ],
        "disabled": [
            4
        ],
        "scale": [
            4
        ],
        "scaleMin": [
            2,
            "scale-min"
        ],
        "scaleMax": [
            2,
            "scale-max"
        ],
        "scaleValue": [
            2,
            "scale-value"
        ],
        "animation": [
            4
        ],
        "setParent": [
            64
        ],
        "endScale": [
            64
        ],
        "setScale": [
            64
        ]
    }
]);
function defineCustomElement$142() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-movable-view-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-movable-view-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, MovableView);
                }
                break;
        }
    });
}
var defineCustomElement44 = defineCustomElement$142;
// node_modules/@tarojs/components/dist/components/taro-native-slot-core.js
var NativeSlot = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("NativeSlot", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-native-slot-core"
]);
function defineCustomElement$143() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-native-slot-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-native-slot-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, NativeSlot);
                }
                break;
        }
    });
}
var defineCustomElement45 = defineCustomElement$143;
// node_modules/@tarojs/components/dist/components/taro-navigation-bar-core.js
var NavigationBar = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("NavigationBar", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-navigation-bar-core"
]);
function defineCustomElement$144() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-navigation-bar-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-navigation-bar-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, NavigationBar);
                }
                break;
        }
    });
}
var defineCustomElement46 = defineCustomElement$144;
// node_modules/@tarojs/components/dist/components/taro-navigator-core.js
var indexCss9 = ".navigator-hover{background:#efefef}";
var Navigator = proxyCustomElement(class extends H {
    onClick() {
        const { openType, onSuccess, onFail, onComplete } = this;
        let promise = Promise.resolve();
        switch(openType){
            case "navigate":
                promise = taro.navigateTo({
                    url: this.url
                });
                break;
            case "redirect":
                promise = taro.redirectTo({
                    url: this.url
                });
                break;
            case "switchTab":
                promise = taro.switchTab({
                    url: this.url
                });
                break;
            case "reLaunch":
                promise = taro.reLaunch({
                    url: this.url
                });
                break;
            case "navigateBack":
                promise = taro.navigateBack({
                    delta: this.delta
                });
                break;
            case "exit":
                promise = Promise.reject(new Error('navigator:fail \u6682\u4E0D\u652F\u6301"openType: exit"'));
                break;
        }
        if (promise) {
            promise.then((res)=>{
                onSuccess.emit(res);
            }).catch((res)=>{
                onFail.emit(res);
            }).finally(()=>{
                onComplete.emit();
            });
        }
    }
    render() {
        const { isHover, hoverClass } = this;
        return h(Host, {
            class: classnames({
                [hoverClass]: isHover
            })
        });
    }
    static get style() {
        return indexCss9;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onSuccess = createEvent(this, "cuccess", 7);
        this.onFail = createEvent(this, "fail", 7);
        this.onComplete = createEvent(this, "complete", 7);
        this.hoverClass = void 0;
        this.url = void 0;
        this.openType = "navigate";
        this.isHover = false;
        this.delta = 0;
    }
}, [
    0,
    "taro-navigator-core",
    {
        "hoverClass": [
            1,
            "hover-class"
        ],
        "url": [
            1
        ],
        "openType": [
            1,
            "open-type"
        ],
        "isHover": [
            4,
            "is-hover"
        ],
        "delta": [
            2
        ]
    },
    [
        [
            0,
            "click",
            "onClick"
        ]
    ]
]);
function defineCustomElement$145() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-navigator-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-navigator-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Navigator);
                }
                break;
        }
    });
}
var defineCustomElement47 = defineCustomElement$145;
// node_modules/@tarojs/components/dist/components/taro-official-account-core.js
var OfficialAccount = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("OfficialAccount", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-official-account-core"
]);
function defineCustomElement$146() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-official-account-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-official-account-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, OfficialAccount);
                }
                break;
        }
    });
}
var defineCustomElement48 = defineCustomElement$146;
// node_modules/@tarojs/components/dist/components/taro-open-data-core.js
var OpenData = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("OpenData", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-open-data-core"
]);
function defineCustomElement$147() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-open-data-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-open-data-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, OpenData);
                }
                break;
        }
    });
}
var defineCustomElement49 = defineCustomElement$147;
// node_modules/@tarojs/components/dist/components/taro-page-container-core.js
var PageContainer = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("PageContainer", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-page-container-core"
]);
function defineCustomElement$148() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-page-container-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-page-container-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, PageContainer);
                }
                break;
        }
    });
}
var defineCustomElement50 = defineCustomElement$148;
// node_modules/@tarojs/components/dist/components/taro-page-meta-core.js
var PageMeta = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("PageMeta", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-page-meta-core"
]);
function defineCustomElement$149() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-page-meta-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-page-meta-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, PageMeta);
                }
                break;
        }
    });
}
var defineCustomElement51 = defineCustomElement$149;
// node_modules/@tarojs/components/dist/components/picker-group.js
var TOP = 102;
var LINE_HEIGHT = 34;
var MASK_HEIGHT = LINE_HEIGHT * 7;
var TaroPickerGroup = proxyCustomElement(class extends H {
    getPosition() {
        const transition2 = this.touchEnd ? 0.3 : 0;
        const transformValue = `translate3d(0, ${this.height}px, 0)`;
        const transitionValue = `transform ${transition2}s`;
        return {
            transform: transformValue,
            "-webkit-transform": transformValue,
            transition: transitionValue,
            "-webkit-transition": transitionValue
        };
    }
    formulaUnlimitedScroll(range, absoluteHeight, direction) {
        const { height, updateHeight, columnId } = this;
        const factor = direction === "up" ? 1 : -1;
        this.touchEnd = false;
        updateHeight(-range * factor * LINE_HEIGHT + height, columnId);
        requestAnimationFrame(()=>{
            this.touchEnd = true;
            const index2 = Math.round(absoluteHeight / -LINE_HEIGHT) + range * factor;
            const relativeHeight = TOP - LINE_HEIGHT * index2;
            updateHeight(relativeHeight, columnId, true);
        });
    }
    handleMoveStart(clientY) {
        var _this = this;
        return _async_to_generator(function*() {
            _this.startY = clientY;
            _this.preY = clientY;
            _this.hadMove = false;
        })();
    }
    handleMoving(clientY) {
        var _this = this;
        return _async_to_generator(function*() {
            const y = clientY;
            const deltaY = y - _this.preY;
            _this.preY = y;
            _this.touchEnd = false;
            if (Math.abs(y - _this.startY) > 10) _this.hadMove = true;
            let newPos = _this.height + deltaY;
            if (_this.mode === "time") {
                if (_this.columnId === "0") {
                    if (newPos > TOP - LINE_HEIGHT * 3) {
                        newPos = TOP - LINE_HEIGHT * 27 + deltaY;
                    }
                    if (newPos < TOP - LINE_HEIGHT * 28) {
                        newPos = TOP - LINE_HEIGHT * 4 + deltaY;
                    }
                } else if (_this.columnId === "1") {
                    if (newPos > TOP - LINE_HEIGHT * 3) {
                        newPos = TOP - LINE_HEIGHT * 63 + deltaY;
                    }
                    if (newPos < TOP - LINE_HEIGHT * 64) {
                        newPos = TOP - LINE_HEIGHT * 4 + deltaY;
                    }
                }
            }
            _this.updateHeight(newPos, _this.columnId);
        })();
    }
    handleMoveEnd(clientY) {
        var _this = this;
        return _async_to_generator(function*() {
            const { mode, range, height, updateHeight, columnId } = _this;
            const max = 0;
            const min = -LINE_HEIGHT * (range.length - 1);
            const endY = clientY;
            _this.touchEnd = true;
            let absoluteHeight;
            if (!_this.hadMove) {
                const windowHeight = window.innerHeight;
                const relativeY = windowHeight - MASK_HEIGHT / 2;
                absoluteHeight = height - TOP - (endY - relativeY);
                if (mode === "time") {
                    if (columnId === "0") {
                        if (absoluteHeight > -LINE_HEIGHT * 2.5) {
                            return _this.formulaUnlimitedScroll(24, absoluteHeight, "up");
                        }
                        if (absoluteHeight < -LINE_HEIGHT * 28.5) {
                            return _this.formulaUnlimitedScroll(24, absoluteHeight, "down");
                        }
                    } else if (columnId === "1") {
                        if (absoluteHeight > -LINE_HEIGHT * 2.5) {
                            return _this.formulaUnlimitedScroll(60, absoluteHeight, "up");
                        }
                        if (absoluteHeight < -LINE_HEIGHT * 64.5) {
                            return _this.formulaUnlimitedScroll(60, absoluteHeight, "down");
                        }
                    }
                }
            } else {
                absoluteHeight = height - TOP;
            }
            if (absoluteHeight > max) absoluteHeight = 0;
            if (absoluteHeight < min) absoluteHeight = min;
            const index2 = Math.round(absoluteHeight / -LINE_HEIGHT);
            const relativeHeight = TOP - LINE_HEIGHT * index2;
            if (_this.mode === "date" && typeof _this.updateDay === "function") {
                if (_this.columnId === "0") {
                    _this.updateDay(+_this.range[index2].replace(/[^0-9]/gi, ""), 0);
                }
                if (_this.columnId === "1") {
                    _this.updateDay(+_this.range[index2].replace(/[^0-9]/gi, ""), 1);
                }
                if (_this.columnId === "2") {
                    _this.updateDay(+_this.range[index2].replace(/[^0-9]/gi, ""), 2);
                }
            }
            updateHeight(relativeHeight, columnId, mode === "time");
            _this.onColumnChange.emit({
                columnId,
                height: relativeHeight
            });
        })();
    }
    onMouseDown(e) {
        this.isMove = true;
        this.handleMoveStart(e.clientY);
    }
    onMouseMove(e) {
        if (!this.isMove) return;
        this.handleMoving(e.clientY);
    }
    onMouseMoveEnd(e) {
        if (!this.isMove) return;
        this.isMove = false;
        this.handleMoveEnd(e.clientY);
    }
    onTouchStart(e) {
        this.handleMoveStart(e.changedTouches[0].clientY);
    }
    onTouchMove(e) {
        this.handleMoving(e.changedTouches[0].clientY);
    }
    onTouchEnd(e) {
        this.handleMoveEnd(e.changedTouches[0].clientY);
    }
    render() {
        const { range, rangeKey } = this;
        const pickerItem = range.map((item)=>{
            const content = rangeKey ? item[rangeKey] : item;
            return h("div", {
                class: "weui-picker__item"
            }, content);
        });
        return h(Host, {
            class: "weui-picker__group"
        }, h("div", {
            class: "weui-picker__mask"
        }), h("div", {
            class: "weui-picker__indicator"
        }), h("div", {
            class: "weui-picker__content",
            style: this.getPosition()
        }, pickerItem));
    }
    constructor(){
        super();
        this.__registerHost();
        this.onColumnChange = createEvent(this, "columnChange", 7);
        this.mode = void 0;
        this.range = [];
        this.rangeKey = void 0;
        this.height = void 0;
        this.columnId = void 0;
        this.updateHeight = void 0;
        this.updateDay = void 0;
        this.startY = void 0;
        this.preY = void 0;
        this.hadMove = void 0;
        this.touchEnd = void 0;
        this.isMove = void 0;
    }
}, [
    0,
    "taro-picker-group",
    {
        "mode": [
            1
        ],
        "range": [
            16
        ],
        "rangeKey": [
            1,
            "range-key"
        ],
        "height": [
            2
        ],
        "columnId": [
            1,
            "column-id"
        ],
        "updateHeight": [
            16
        ],
        "updateDay": [
            16
        ],
        "startY": [
            32
        ],
        "preY": [
            32
        ],
        "hadMove": [
            32
        ],
        "touchEnd": [
            32
        ],
        "isMove": [
            32
        ],
        "handleMoveStart": [
            64
        ],
        "handleMoving": [
            64
        ],
        "handleMoveEnd": [
            64
        ]
    },
    [
        [
            1,
            "mousedown",
            "onMouseDown"
        ],
        [
            3,
            "mousemove",
            "onMouseMove"
        ],
        [
            1,
            "mouseup",
            "onMouseMoveEnd"
        ],
        [
            1,
            "mouseleave",
            "onMouseMoveEnd"
        ],
        [
            1,
            "touchstart",
            "onTouchStart"
        ],
        [
            3,
            "touchmove",
            "onTouchMove"
        ],
        [
            1,
            "touchend",
            "onTouchEnd"
        ]
    ]
]);
function defineCustomElement52() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-picker-group"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-picker-group":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, TaroPickerGroup);
                }
                break;
        }
    });
}
// node_modules/@tarojs/components/dist/components/taro-picker-core.js
function getTimeRange(begin, end) {
    const range = [];
    for(let i2 = begin; i2 <= end; i2++){
        range.push(`${i2 < 10 ? "0" : ""}${i2}`);
    }
    return range;
}
var hoursRange = [
    "20",
    "21",
    "22",
    "23",
    ...getTimeRange(0, 23),
    "00",
    "01",
    "02",
    "03"
];
var minutesRange = [
    "56",
    "57",
    "58",
    "59",
    ...getTimeRange(0, 59),
    "00",
    "01",
    "02",
    "03"
];
function verifyValue(value, range) {
    if (!isNaN(+value) && value >= 0 && value < range.length) return true;
    return false;
}
function verifyTime(value) {
    if (!/^\d{1,2}:\d{1,2}$/.test(value)) return false;
    const time = value.split(":").map((num)=>+num);
    if (time[0] < 0 || time[0] > 23) return false;
    if (time[1] < 0 || time[1] > 59) return false;
    return true;
}
function compareTime(t1, t2) {
    const t1List = t1.split(":").map((i2)=>+i2);
    const t2List = t2.split(":").map((i2)=>+i2);
    if (t1List[0] < t2List[0]) return true;
    if (t1List[0] === t2List[0] && t1List[1] <= t2List[1]) return true;
    return false;
}
function verifyDate(dateStr) {
    if (!dateStr) return false;
    const date2 = new Date(dateStr.replace(/-/g, "/"));
    return isNaN(date2.getMonth()) ? false : date2;
}
function getMaxDay(year, month) {
    if (month === 4 || month === 6 || month === 9 || month === 11) return 30;
    if (month === 2) {
        if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) return 29;
        else return 28;
    }
    return 31;
}
function formatValue(value) {
    let res;
    if (Array.isArray(value)) {
        res = value.map((item)=>String(item));
    } else {
        res = value;
    }
    return res;
}
function getDateRange(start2, end) {
    const range = [];
    for(let i2 = start2; i2 <= end; i2++){
        range.push(i2);
    }
    return range;
}
function getYearRange(start2, end) {
    return getDateRange(start2, end);
}
function getMonthRange(start2, end, year) {
    let rangeStart = 1;
    let rangeEnd = 12;
    if (start2.getFullYear() === year) {
        rangeStart = start2.getMonth() + 1;
    }
    if (end.getFullYear() === year) {
        rangeEnd = end.getMonth() + 1;
    }
    return getDateRange(rangeStart, rangeEnd);
}
function getDayRange(start2, end, year, month) {
    let rangeStart = 1;
    let rangeEnd = getMaxDay(year, month);
    if (start2.getFullYear() === year && start2.getMonth() + 1 === month) {
        rangeStart = start2.getDate();
    }
    if (end.getFullYear() === year && end.getMonth() + 1 === month) {
        rangeEnd = end.getDate();
    }
    return getDateRange(rangeStart, rangeEnd);
}
var indexCss10 = '.weui-mask{z-index:1000;background:rgba(0,0,0,.6);position:fixed;inset:0}.weui-mask_transparent{z-index:1000;position:fixed;inset:0}@-webkit-keyframes weuiSlideUp{0%{-webkit-transform:translateY(100%);transform:translateY(100%)}to{-webkit-transform:translate(0,0);transform:translate(0,0)}}@keyframes weuiSlideUp{0%{-webkit-transform:translateY(100%);transform:translateY(100%)}to{-webkit-transform:translate(0,0);transform:translate(0,0)}}.weui-animate-slide-up{-webkit-animation:.3s forwards weuiSlideUp;animation:.3s forwards weuiSlideUp}@-webkit-keyframes weuiSlideDown{0%{-webkit-transform:translate(0,0);transform:translate(0,0)}to{-webkit-transform:translateY(100%);transform:translateY(100%)}}@keyframes weuiSlideDown{0%{-webkit-transform:translate(0,0);transform:translate(0,0)}to{-webkit-transform:translateY(100%);transform:translateY(100%)}}.weui-animate-slide-down{-webkit-animation:.3s forwards weuiSlideDown;animation:.3s forwards weuiSlideDown}@-webkit-keyframes weuiFadeIn{0%{opacity:0}to{opacity:1}}@keyframes weuiFadeIn{0%{opacity:0}to{opacity:1}}.weui-animate-fade-in{-webkit-animation:.3s forwards weuiFadeIn;animation:.3s forwards weuiFadeIn}@-webkit-keyframes weuiFadeOut{0%{opacity:1}to{opacity:0}}@keyframes weuiFadeOut{0%{opacity:1}to{opacity:0}}.weui-animate-fade-out{-webkit-animation:.3s forwards weuiFadeOut;animation:.3s forwards weuiFadeOut}.weui-picker{-webkit-box-sizing:border-box;box-sizing:border-box;z-index:5000;background-color:var(--weui-BG-2);padding-left:0;padding-left:constant(safe-area-inset-left);padding-left:env(safe-area-inset-left);padding-right:0;padding-right:constant(safe-area-inset-right);padding-right:env(safe-area-inset-right);-webkit-backface-visibility:hidden;backface-visibility:hidden;width:100%;-webkit-transition:-webkit-transform .3s;transition:-webkit-transform .3s;transition:transform .3s;transition:transform .3s, -webkit-transform .3s;position:fixed;bottom:0;left:0;-webkit-transform:translateY(100%);transform:translateY(100%)}.weui-picker__hd{text-align:center;background-color:#fff;padding:9px 15px;font-size:17px;display:-ms-flexbox;display:flex;position:relative}.weui-picker__hd:after{content:" ";color:#e5e5e5;-webkit-transform-origin:0 100%;transform-origin:0 100%;border-bottom:1px solid #e5e5e5;height:1px;position:absolute;bottom:0;left:0;right:0;-webkit-transform:scaleY(.5);transform:scaleY(.5)}.weui-picker__action{color:#1aad19;-ms-flex:1;flex:1;display:block}.weui-picker__action:first-child{text-align:left;color:#888}.weui-picker__action:last-child{text-align:right}.weui-picker__bd{background-color:#fff;height:238px;display:-ms-flexbox;display:flex;position:relative;overflow:hidden}.weui-picker__group{-ms-flex:1;flex:1;height:100%;position:relative}.weui-picker__mask{z-index:3;background-color:transparent;background-image:-webkit-gradient(linear,left top, left bottom,from(rgba(255,255,255,.95)),to(rgba(255,255,255,.6))),-webkit-gradient(linear,left top, left bottom,from(rgba(255,255,255,.6)),to(rgba(255,255,255,.95)));background-image:linear-gradient(rgba(255,255,255,.95),rgba(255,255,255,.6)),linear-gradient(rgba(255,255,255,.6),rgba(255,255,255,.95));background-position:top,bottom;background-repeat:no-repeat;background-size:100% 102px;background-attachment:scroll,scroll;background-origin:padding-box,padding-box;background-clip:border-box,border-box;width:100%;height:100%;margin:0 auto;position:absolute;top:0;left:0;-webkit-transform:translateZ(0);transform:translateZ(0)}.weui-picker__indicator{z-index:3;width:100%;height:34px;position:absolute;top:102px;left:0}.weui-picker__indicator:before{content:" ";color:#e5e5e5;-webkit-transform-origin:0 0;transform-origin:0 0;border-top:1px solid #e5e5e5;height:1px;position:absolute;top:0;left:0;right:0;-webkit-transform:scaleY(.5);transform:scaleY(.5)}.weui-picker__indicator:after{content:" ";color:#e5e5e5;-webkit-transform-origin:0 100%;transform-origin:0 100%;border-bottom:1px solid #e5e5e5;height:1px;position:absolute;bottom:0;left:0;right:0;-webkit-transform:scaleY(.5);transform:scaleY(.5)}.weui-picker__content{width:100%;position:absolute;top:0;left:0}.weui-picker__item{text-align:center;color:#000;text-overflow:ellipsis;white-space:nowrap;height:34px;padding:0;line-height:34px;overflow:hidden}.weui-picker__item_disabled{color:#999}.weui-picker,.weui-picker__hd{font-size:12px}';
var Picker = proxyCustomElement(class extends H {
    componentWillLoad() {
        this.isWillLoadCalled = true;
        this.handleProps();
    }
    componentDidLoad() {
        if (this.overlay) {
            document.body.appendChild(this.overlay);
        }
    }
    disconnectedCallback() {
        var _a;
        if (this.overlay) {
            (_a = this.overlay.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this.overlay);
        }
    }
    onPropsChange() {
        if (!this.isWillLoadCalled) return;
        this.handleProps();
    }
    handleProps() {
        const { mode, start: start2, end } = this;
        if (mode === "selector") {
            const value = this.value;
            this.index = [
                verifyValue(value, this.range) ? Math.floor(value) : 0
            ];
        } else if (mode === "multiSelector") {
            const value = this.value;
            this.index = [];
            this.range.forEach((range, index2)=>{
                const val = value === null || value === void 0 ? void 0 : value[index2];
                const item = verifyValue(val, range) ? Math.floor(val) : 0;
                this.index.push(item);
            });
        } else if (mode === "time") {
            let value = this.value;
            if (!verifyTime(value)) {
                console.warn("time picker value illegal");
                value = "0:0";
            }
            const time = value.split(":").map((n)=>+n);
            this.index = time;
        } else if (mode === "date") {
            const value = this.value;
            let _value = verifyDate(value) || new Date(/* @__PURE__ */ new Date().setHours(0, 0, 0, 0));
            const _start = verifyDate(start2) || /* @__PURE__ */ new Date("1970/01/01");
            const _end = verifyDate(end) || /* @__PURE__ */ new Date("2999/01/01");
            if (!(_start <= _end)) {
                throw new Error(`Picker start time must be less than end time.`);
            }
            if (!(_value >= _start && _value <= _end)) {
                _value = _start;
            }
            const currentYear = _value.getFullYear();
            const currentMonth = _value.getMonth() + 1;
            const currentDay = _value.getDate();
            const yearRange = getYearRange(_start.getFullYear(), _end.getFullYear());
            const monthRange = getMonthRange(_start, _end, currentYear);
            const dayRange = getDayRange(_start, _end, currentYear, currentMonth);
            this.index = [
                yearRange.indexOf(currentYear),
                monthRange.indexOf(currentMonth),
                dayRange.indexOf(currentDay)
            ];
            if (!this.pickerDate || this.pickerDate._value.getTime() !== _value.getTime() || this.pickerDate._start.getTime() !== _start.getTime() || this.pickerDate._end.getTime() !== _end.getTime()) {
                this.pickerDate = {
                    _value,
                    _start,
                    _end,
                    _updateValue: [
                        currentYear,
                        currentMonth,
                        currentDay
                    ]
                };
            }
        } else {
            throw new Error(`Picker not support "${mode}" mode.`);
        }
        this.height = this.getHeightByIndex();
        this.pickerValue = this.value;
        if (mode === "date") {
            const val = this.pickerValue;
            if (this.fields === "month") {
                this.pickerValue = val.split("-").slice(0, 2).join("-");
            } else if (this.fields === "year") {
                this.pickerValue = val.split("-")[0];
            }
        }
    }
    render() {
        var _a, _b;
        const { name, mode, fadeOut, hidden } = this;
        let pickerGroup;
        switch(mode){
            case "multiSelector":
                pickerGroup = this.getMultiSelector();
                break;
            case "time":
                pickerGroup = this.getTimeSelector();
                break;
            case "date":
                pickerGroup = this.getDateSelector();
                break;
            default:
                pickerGroup = this.getSelector();
        }
        const clsMask = classnames("weui-mask", "weui-animate-fade-in", {
            "weui-animate-fade-out": fadeOut
        });
        const clsSlider = classnames("weui-picker", "weui-animate-slide-up", {
            "weui-animate-slide-down": fadeOut
        });
        const shouldDivHidden = hidden ? {
            display: "none"
        } : {};
        return h(Host, null, h("div", {
            onClick: this.showPicker
        }, h("slot", null), h("input", {
            type: "hidden",
            name,
            value: formatValue(this.pickerValue)
        })), h("div", {
            class: "weui-picker__overlay",
            style: shouldDivHidden,
            ref: (el)=>{
                this.overlay = el;
            }
        }, h("div", {
            class: clsMask,
            onClick: this.handleCancel
        }), h("div", {
            class: clsSlider
        }, h("div", {
            class: "weui-picker__hd"
        }, h("div", {
            class: "weui-picker__action",
            onClick: this.handleCancel
        }, (_a = this.textProps.cancelText) !== null && _a !== void 0 ? _a : "\u53D6\u6D88"), h("div", {
            class: "weui-picker__action",
            onClick: this.handleChange
        }, (_b = this.textProps.okText) !== null && _b !== void 0 ? _b : "\u786E\u5B9A")), h("div", {
            class: "weui-picker__bd"
        }, pickerGroup), h("input", {
            type: "hidden",
            name,
            value: formatValue(this.pickerValue)
        }))));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "mode": [
                "onPropsChange"
            ],
            "value": [
                "onPropsChange"
            ],
            "range": [
                "onPropsChange"
            ],
            "start": [
                "onPropsChange"
            ],
            "end": [
                "onPropsChange"
            ]
        };
    }
    static get style() {
        return indexCss10;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "change", 7);
        this.onColumnChange = createEvent(this, "columnchange", 7);
        this.onCancel = createEvent(this, "cancel", 7);
        this.index = [];
        this.showPicker = ()=>{
            if (this.disabled) return;
            this.height = this.getHeightByIndex();
            this.hidden = false;
        };
        this.getHeightByIndex = ()=>{
            const height = this.index.map((i2)=>{
                let factor = 0;
                if (this.mode === "time") {
                    factor = LINE_HEIGHT * 4;
                }
                return TOP - LINE_HEIGHT * i2 - factor;
            });
            return height;
        };
        this.hidePicker = ()=>{
            this.fadeOut = true;
            setTimeout(()=>{
                this.hidden = true;
                this.fadeOut = false;
            }, 350);
        };
        this.handleChange = ()=>{
            this.hidePicker();
            this.index = this.height.map((h2)=>(TOP - h2) / LINE_HEIGHT);
            let value = this.index.length && this.mode !== "selector" ? this.index : this.index[0];
            if (this.mode === "time") {
                const range = [
                    hoursRange.slice(),
                    minutesRange.slice()
                ];
                const timeArr = this.index.map((n, i2)=>range[i2][n]);
                this.index = timeArr.map((item)=>parseInt(item));
                value = timeArr.join(":");
            }
            if (this.mode === "date") {
                const { _start, _end, _updateValue } = this.pickerDate;
                const currentYear = _updateValue[0];
                const currentMonth = _updateValue[1];
                const yearRange = getYearRange(_start.getFullYear(), _end.getFullYear());
                const monthRange = getMonthRange(_start, _end, currentYear);
                const dayRange = getDayRange(_start, _end, currentYear, currentMonth);
                const year = yearRange[this.index[0]];
                const month = monthRange[this.index[1]];
                const day = dayRange[this.index[2]];
                if (this.fields === "year") {
                    value = [
                        year
                    ];
                } else if (this.fields === "month") {
                    value = [
                        year,
                        month
                    ];
                } else {
                    value = [
                        year,
                        month,
                        day
                    ];
                }
                value = value.map((item)=>{
                    return item < 10 ? `0${item}` : item;
                }).join("-");
            }
            this.value = value;
            this.pickerValue = this.value;
            this.onChange.emit({
                value
            });
        };
        this.handleColumnChange = (e)=>{
            const { columnId, height } = e.detail;
            this.onColumnChange.emit({
                column: Number(columnId),
                value: (TOP - height) / LINE_HEIGHT
            });
        };
        this.handleCancel = ()=>{
            this.hidePicker();
            this.onCancel.emit();
        };
        this.updateHeight = (height, columnId, needRevise = false)=>{
            const temp = [
                ...this.height
            ];
            temp[columnId] = height;
            this.height = temp;
            if (needRevise) {
                let { start: start2, end } = this;
                if (!verifyTime(start2)) start2 = "00:00";
                if (!verifyTime(end)) end = "23:59";
                if (!compareTime(start2, end)) return;
                const range = [
                    hoursRange.slice(),
                    minutesRange.slice()
                ];
                const timeList = this.height.map((h2)=>(TOP - h2) / LINE_HEIGHT);
                const timeStr = timeList.map((n, i2)=>range[i2][n]).join(":");
                if (!compareTime(start2, timeStr)) {
                    const height2 = start2.split(":").map((i2)=>TOP - LINE_HEIGHT * (+i2 + 4));
                    requestAnimationFrame(()=>this.height = height2);
                } else if (!compareTime(timeStr, end)) {
                    const height2 = end.split(":").map((i2)=>TOP - LINE_HEIGHT * (+i2 + 4));
                    requestAnimationFrame(()=>this.height = height2);
                }
            }
        };
        this.updateDay = (value, fields)=>{
            const { _start, _end, _updateValue } = this.pickerDate;
            _updateValue[fields] = value;
            const currentYear = _updateValue[0];
            const currentMonth = _updateValue[1];
            const currentDay = _updateValue[2];
            if (fields === 0) {
                const monthRange = getMonthRange(_start, _end, currentYear);
                const max = monthRange[monthRange.length - 1];
                const min = monthRange[0];
                if (currentMonth > max) _updateValue[1] = max;
                if (currentMonth < min) _updateValue[1] = min;
                const index2 = monthRange.indexOf(_updateValue[1]);
                const height = TOP - LINE_HEIGHT * index2;
                this.updateDay(_updateValue[1], 1);
                this.updateHeight(height, "1");
            } else if (fields === 1) {
                const dayRange = getDayRange(_start, _end, currentYear, currentMonth);
                const max = dayRange[dayRange.length - 1];
                const min = dayRange[0];
                if (currentDay > max) _updateValue[2] = max;
                if (currentDay < min) _updateValue[2] = min;
                const index2 = dayRange.indexOf(_updateValue[2]);
                const height = TOP - LINE_HEIGHT * index2;
                this.updateDay(_updateValue[2], 2);
                this.updateHeight(height, "2");
            }
        };
        this.getSelector = ()=>{
            return h("taro-picker-group", {
                range: this.range,
                rangeKey: this.rangeKey,
                height: this.height[0],
                updateHeight: this.updateHeight,
                columnId: "0"
            });
        };
        this.getMultiSelector = ()=>{
            return this.range.map((range, index2)=>{
                return h("taro-picker-group", {
                    range,
                    rangeKey: this.rangeKey,
                    height: this.height[index2],
                    updateHeight: this.updateHeight,
                    onColumnChange: this.handleColumnChange,
                    columnId: String(index2)
                });
            });
        };
        this.getTimeSelector = ()=>{
            const hourRange = hoursRange.slice();
            const minRange = minutesRange.slice();
            return [
                h("taro-picker-group", {
                    mode: "time",
                    range: hourRange,
                    height: this.height[0],
                    updateHeight: this.updateHeight,
                    columnId: "0"
                }),
                h("taro-picker-group", {
                    mode: "time",
                    range: minRange,
                    height: this.height[1],
                    updateHeight: this.updateHeight,
                    columnId: "1"
                })
            ];
        };
        this.getDateSelector = ()=>{
            const { fields, height } = this;
            const { _start, _end, _updateValue } = this.pickerDate;
            const currentYear = _updateValue[0];
            const currentMonth = _updateValue[1];
            const yearRange = getYearRange(_start.getFullYear(), _end.getFullYear()).map((item)=>`${item}\u5E74`);
            const monthRange = getMonthRange(_start, _end, currentYear).map((item)=>`${item < 10 ? `0${item}` : item}\u6708`);
            const dayRange = getDayRange(_start, _end, currentYear, currentMonth).map((item)=>`${item < 10 ? `0${item}` : item}\u65E5`);
            const renderView = [
                h("taro-picker-group", {
                    mode: "date",
                    range: yearRange,
                    height: height[0],
                    updateDay: this.updateDay,
                    updateHeight: this.updateHeight,
                    columnId: "0"
                })
            ];
            if (fields === "month" || fields === "day") {
                renderView.push(h("taro-picker-group", {
                    mode: "date",
                    range: monthRange,
                    height: height[1],
                    updateDay: this.updateDay,
                    updateHeight: this.updateHeight,
                    columnId: "1"
                }));
            }
            if (fields === "day") {
                renderView.push(h("taro-picker-group", {
                    mode: "date",
                    range: dayRange,
                    height: height[2],
                    updateDay: this.updateDay,
                    updateHeight: this.updateHeight,
                    columnId: "2"
                }));
            }
            return renderView;
        };
        this.mode = "selector";
        this.disabled = false;
        this.range = [];
        this.rangeKey = void 0;
        this.value = void 0;
        this.start = "";
        this.end = "";
        this.fields = "day";
        this.name = "";
        this.textProps = {};
        this.pickerValue = [];
        this.height = [];
        this.hidden = true;
        this.fadeOut = false;
        this.isWillLoadCalled = false;
    }
}, [
    4,
    "taro-picker-core",
    {
        "mode": [
            1
        ],
        "disabled": [
            4
        ],
        "range": [
            16
        ],
        "rangeKey": [
            1,
            "range-key"
        ],
        "value": [
            1032
        ],
        "start": [
            1
        ],
        "end": [
            1
        ],
        "fields": [
            1
        ],
        "name": [
            1
        ],
        "textProps": [
            16
        ],
        "pickerValue": [
            32
        ],
        "height": [
            32
        ],
        "hidden": [
            32
        ],
        "fadeOut": [
            32
        ],
        "isWillLoadCalled": [
            32
        ]
    }
]);
function defineCustomElement$150() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-picker-core",
        "taro-picker-group"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-picker-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Picker);
                }
                break;
            case "taro-picker-group":
                if (!customElements.get(tagName)) {
                    defineCustomElement52();
                }
                break;
        }
    });
}
var defineCustomElement53 = defineCustomElement$150;
// node_modules/@tarojs/components/dist/components/taro-picker-group.js
var defineCustomElement54 = defineCustomElement52;
// node_modules/@tarojs/components/dist/components/index3.js
function throttle2(fn, threshold = 250, scope) {
    let lastTime = 0;
    let deferTimer;
    return function(...args) {
        const context = scope || this;
        const now3 = Date.now();
        if (now3 - lastTime > threshold) {
            fn.apply(this, args);
            lastTime = now3;
        } else {
            clearTimeout(deferTimer);
            deferTimer = setTimeout(()=>{
                lastTime = now3;
                fn.apply(context, args);
            }, threshold);
        }
    };
}
function debounce2(fn, ms = 250, scope) {
    let timer2;
    return function(...args) {
        const context = scope || this;
        clearTimeout(timer2);
        timer2 = setTimeout(function() {
            fn.apply(context, args);
        }, ms);
    };
}
function isVisible(e) {
    return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length);
}
// node_modules/@tarojs/components/dist/components/taro-picker-view-column-core.js
var columnCss = ".taro-picker-view-column-container{text-align:center;-ms-flex-direction:column;flex-direction:column;-ms-flex:1;flex:1;display:-ms-flexbox;display:flex;position:relative;overflow:hidden scroll}.taro-picker-view-column-container::-webkit-scrollbar{display:none}";
var PickerViewColumn = proxyCustomElement(class extends H {
    onTouchStart() {
        this.onSelectStart.emit();
    }
    onTouchEnd() {
        this.handleSelected();
    }
    componentDidLoad() {
        this.handleChange();
    }
    componentDidUpdate() {
        this.handleChange();
    }
    handleChange() {
        const childList = this.el.childNodes;
        let idx = 0;
        let sum = 0;
        for(const index2 in childList){
            const item = childList[index2];
            if (this.initialPosition === index2 || !item || typeof item.offsetHeight !== "number") {
                break;
            }
            sum += item.offsetHeight;
            idx++;
        }
        this.el.scrollTo({
            top: sum
        });
        if (idx >= childList.length) {
            this.onChange.emit({
                curIndex: this.col,
                selectedIndex: idx - 1
            });
        }
    }
    render() {
        const { paddingVertical = 0 } = this;
        return h(Host, {
            class: "taro-picker-view-column-container",
            style: {
                "padding-top": `${paddingVertical}px`,
                "padding-bottom": `${paddingVertical}px`
            }
        });
    }
    get el() {
        return this;
    }
    static get style() {
        return columnCss;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "onselect", 7);
        this.onSelectStart = createEvent(this, "onselectstart", 7);
        this.onSelectEnd = createEvent(this, "onselectend", 7);
        this.handleSelected = debounce2(()=>{
            const childList = this.el.childNodes;
            let sum = 0;
            let selectedIndex = "0";
            for(const index2 in childList){
                const item = childList[index2];
                const itemHeight = item.offsetHeight;
                if (sum + itemHeight / 2 > this.el.scrollTop) {
                    selectedIndex = index2;
                    break;
                }
                sum += itemHeight;
            }
            this.el.scrollTo({
                top: sum,
                behavior: "smooth"
            });
            this.onChange.emit({
                curIndex: this.col,
                selectedIndex
            });
            this.onSelectEnd.emit();
        }, 500);
        this.col = void 0;
        this.initialPosition = "0";
        this.paddingVertical = 0;
        this.isInit = false;
    }
}, [
    0,
    "taro-picker-view-column-core",
    {
        "col": [
            1
        ],
        "initialPosition": [
            1,
            "initial-position"
        ],
        "paddingVertical": [
            2,
            "padding-vertical"
        ],
        "isInit": [
            32
        ]
    },
    [
        [
            1,
            "touchstart",
            "onTouchStart"
        ],
        [
            1,
            "touchend",
            "onTouchEnd"
        ]
    ]
]);
function defineCustomElement$151() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-picker-view-column-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-picker-view-column-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, PickerViewColumn);
                }
                break;
        }
    });
}
var defineCustomElement55 = defineCustomElement$151;
// node_modules/@tarojs/components/dist/components/taro-picker-view-core.js
function convertStyle(style) {
    if (style) {
        const regex = /([\w-]*)\s*:\s*([^;]*)/g;
        const properties = {};
        let match;
        while(match = regex.exec(style))properties[`${match[1]}`] = match[2].trim();
        return properties;
    }
}
var indexCss11 = ".taro-picker-view-container{display:-ms-flexbox;display:flex;position:relative}.taro-picker-view-mask-container{pointer-events:none;-ms-flex-direction:column;flex-direction:column;display:-ms-flexbox;display:flex;position:absolute;inset:0}.taro-picker-view-mask-indicator{border-top:1px solid #ddd;border-bottom:1px solid #ddd;height:50px;display:-ms-flexbox;display:flex}.taro-picker-view-mask-top{background-image:-webkit-gradient(linear,left top, left bottom,from(rgba(255,255,255,.95)),to(rgba(255,255,255,.6)));background-image:linear-gradient(rgba(255,255,255,.95),rgba(255,255,255,.6));-ms-flex:1;flex:1}.taro-picker-view-mask-bottom{background:-webkit-gradient(linear,left top, left bottom,from(rgba(255,255,255,.6)),to(rgba(255,255,255,.95)));background:linear-gradient(rgba(255,255,255,.6),rgba(255,255,255,.95));-ms-flex:1;flex:1}";
var PickerView = proxyCustomElement(class extends H {
    onPropsChange() {
        this.handleValueChange();
    }
    onSelect(e) {
        e.stopPropagation();
        if (e.target.tagName !== "TARO-PICKER-VIEW-COLUMN-CORE") return;
        let _curIndex = +e.detail.curIndex;
        let _selectedIndex = +e.detail.selectedIndex;
        this.value[_curIndex] = _selectedIndex;
        this.onChange.emit({
            value: this.value
        });
    }
    onSelectStart(e) {
        e.stopPropagation();
        if (e.target.tagName !== "TARO-PICKER-VIEW-COLUMN-CORE") return;
        this.onPickStart.emit();
    }
    onPickerColEnd(e) {
        e.stopPropagation();
        if (e.target.tagName !== "TARO-PICKER-VIEW-COLUMN-CORE") return;
        this.onPickEnd.emit();
    }
    componentDidLoad() {
        this.handleValueChange();
    }
    handleValueChange() {
        const childList = this.el.querySelectorAll("taro-picker-view-column-core");
        childList.forEach((element, index2)=>{
            var _a;
            element.setAttribute("col", `${index2}`);
            let selectIndex = 0;
            if (!!this.value && this.value.length > index2) {
                selectIndex = this.value[index2];
            }
            const pickerHeight = this.el.getBoundingClientRect().height;
            const indicatorHeight = ((_a = this.indicator) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0;
            const paddingVertical = (pickerHeight - indicatorHeight) / 2;
            element.setAttribute("initial-position", `${selectIndex}`);
            element.setAttribute("padding-vertical", `${paddingVertical}`);
        });
    }
    // 过滤非 PickerViewColumn 组件
    componentDidRender() {
        this.el.childNodes.forEach((item)=>{
            const childEle = item;
            if ("TARO-PICKER-VIEW-COLUMN-CORE" !== childEle.tagName && childEle.className !== "taro-picker-view-mask-container") {
                this.el.removeChild(item);
            }
        });
    }
    render() {
        const indicatorCls = classnames("taro-picker-view-mask-indicator", this.indicatorClass);
        const maskTopCls = classnames("taro-picker-view-mask-top", this.maskClass);
        const maskBtmCls = classnames("taro-picker-view-mask-bottom", this.maskClass);
        const indicatorStyle = convertStyle(this.indicatorStyle);
        const maskTopStyle = convertStyle(this.maskStyle);
        const maskBottomStyle = convertStyle(this.maskStyle);
        return h(Host, {
            class: "taro-picker-view-container"
        }, h("slot", null), h("div", {
            class: "taro-picker-view-mask-container"
        }, h("div", {
            class: maskTopCls,
            style: maskTopStyle
        }), h("div", {
            class: indicatorCls,
            style: indicatorStyle,
            ref: (indicator)=>this.indicator = indicator
        }), h("div", {
            class: maskBtmCls,
            style: maskBottomStyle
        })));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "value": [
                "onPropsChange"
            ]
        };
    }
    static get style() {
        return indexCss11;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "change", 7);
        this.onPickStart = createEvent(this, "pickstart", 7);
        this.onPickEnd = createEvent(this, "pickend", 7);
        this.indicatorStyle = void 0;
        this.indicatorClass = void 0;
        this.value = void 0;
        this.maskStyle = void 0;
        this.maskClass = void 0;
    }
}, [
    4,
    "taro-picker-view-core",
    {
        "indicatorStyle": [
            1,
            "indicator-style"
        ],
        "indicatorClass": [
            1,
            "indicator-class"
        ],
        "value": [
            16
        ],
        "maskStyle": [
            1,
            "mask-style"
        ],
        "maskClass": [
            1,
            "mask-class"
        ]
    },
    [
        [
            0,
            "onselect",
            "onSelect"
        ],
        [
            0,
            "onselectstart",
            "onSelectStart"
        ],
        [
            0,
            "onselectend",
            "onPickerColEnd"
        ]
    ]
]);
function defineCustomElement$152() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-picker-view-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-picker-view-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, PickerView);
                }
                break;
        }
    });
}
var defineCustomElement56 = defineCustomElement$152;
// node_modules/@tarojs/components/dist/components/taro-progress-core.js
var indexCss12 = ".weui-progress{-ms-flex-align:center;align-items:center;display:-ms-flexbox;display:flex}";
var Progress = proxyCustomElement(class extends H {
    render() {
        const { percent, showInfo, borderRadius, fontSize, strokeWidth, activeColor, backgroundColor, active } = this;
        const pgPercent = percent > 100 ? 100 : percent < 0 ? 0 : percent;
        const pgHeight = {
            height: strokeWidth + "px",
            backgroundColor
        };
        const transition2 = active ? "width 1s ease-in-out" : "none";
        const pgWidth = {
            width: `${pgPercent}%`,
            transition: transition2,
            WebkitTransition: transition2,
            backgroundColor: activeColor,
            borderRadius: borderRadius ? `${borderRadius}px` : "0px"
        };
        return h(Host, {
            class: "weui-progress"
        }, h("div", {
            class: "weui-progress__bar",
            style: pgHeight
        }, h("div", {
            class: "weui-progress__inner-bar",
            style: pgWidth
        })), showInfo && h("div", {
            class: "weui-progress__opr",
            style: {
                "font-size": `${fontSize}px`
            }
        }, h("span", null, pgPercent, "%")));
    }
    static get style() {
        return indexCss12;
    }
    constructor(){
        super();
        this.__registerHost();
        this.percent = 0;
        this.showInfo = false;
        this.borderRadius = 0;
        this.fontSize = 16;
        this.strokeWidth = 6;
        this.activeColor = "#09BB07";
        this.backgroundColor = "#EBEBEB";
        this.active = false;
    }
}, [
    0,
    "taro-progress-core",
    {
        "percent": [
            2
        ],
        "showInfo": [
            4,
            "show-info"
        ],
        "borderRadius": [
            8,
            "border-radius"
        ],
        "fontSize": [
            8,
            "font-size"
        ],
        "strokeWidth": [
            8,
            "stroke-width"
        ],
        "activeColor": [
            1,
            "active-color"
        ],
        "backgroundColor": [
            1,
            "background-color"
        ],
        "active": [
            4
        ]
    }
]);
function defineCustomElement$153() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-progress-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-progress-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Progress);
                }
                break;
        }
    });
}
var defineCustomElement57 = defineCustomElement$153;
// node_modules/@tarojs/components/dist/components/taro-pull-to-refresh-core.js
var indexCss13 = ".rmc-pull-to-refresh-content{-webkit-transform-origin:0 0;transform-origin:0 0}.rmc-pull-to-refresh-content-wrapper{min-height:100%}.rmc-pull-to-refresh-transition{-webkit-transition:-webkit-transform .3s;transition:-webkit-transform .3s;transition:transform .3s;transition:transform .3s, -webkit-transform .3s}@-webkit-keyframes rmc-pull-to-refresh-indicator{50%{opacity:.2}to{opacity:1}}@keyframes rmc-pull-to-refresh-indicator{50%{opacity:.2}to{opacity:1}}.rmc-pull-to-refresh-indicator{text-align:center;height:30px;line-height:10px}.rmc-pull-to-refresh-indicator>div{background-color:gray;border-radius:100%;width:6px;height:6px;margin:3px;-webkit-animation:.5s linear infinite both rmc-pull-to-refresh-indicator;animation:.5s linear infinite both rmc-pull-to-refresh-indicator;display:inline-block}.rmc-pull-to-refresh-indicator>div:nth-child(0){-webkit-animation-delay:-.1s!important;animation-delay:-.1s!important}.rmc-pull-to-refresh-indicator>div:first-child{-webkit-animation-delay:-.2s!important;animation-delay:-.2s!important}.rmc-pull-to-refresh-indicator>div:nth-child(2){-webkit-animation-delay:-.3s!important;animation-delay:-.3s!important}.rmc-pull-to-refresh-down .rmc-pull-to-refresh-indicator{margin-top:-25px}";
function setTransform2(nodeStyle, value) {
    nodeStyle.transform = value;
    nodeStyle.webkitTransform = value;
    nodeStyle.MozTransform = value;
}
var isWebView = typeof navigator !== "undefined" && /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent);
var INDICATOR = {
    activate: "release",
    deactivate: "pull",
    release: "loading",
    finish: "finish"
};
var supportsPassive = false;
try {
    const opts = Object.defineProperty({}, "passive", {
        get () {
            supportsPassive = true;
        }
    });
    window.addEventListener("cancel", ()=>({}), opts);
} catch (e) {}
var willPreventDefault = supportsPassive ? {
    passive: false
} : false;
var PullToRefresh = proxyCustomElement(class extends H {
    get scrollContainer() {
        return this.el.parentElement || this.el.closest(".taro_page_stationed") || document.querySelector(".taro_page_stationed") || document.querySelector(".taro_page") || document.querySelector(".taro_router") || document.querySelector(".taro-tabbar__panel") || document.body;
    }
    statusChange() {
        var _a, _b, _c, _d;
        const pageEl = this.scrollContainer;
        switch(this.currSt){
            case "release":
                (_b = (_a = pageEl === null || pageEl === void 0 ? void 0 : pageEl.__page) === null || _a === void 0 ? void 0 : _a.onPullDownRefresh) === null || _b === void 0 ? void 0 : _b.call(_a);
                break;
            case "deactivate":
                (_d = (_c = pageEl === null || pageEl === void 0 ? void 0 : pageEl.__page) === null || _c === void 0 ? void 0 : _c.onPullIntercept) === null || _d === void 0 ? void 0 : _d.call(_c);
        }
    }
    disconnectedCallback() {
        this.destroy();
    }
    componentDidLoad() {
        this.init();
        this._isMounted = true;
        taro.eventCenter.on("__taroStartPullDownRefresh", ({ successHandler, errorHandler })=>{
            try {
                this.triggerPullDownRefresh(true);
                successHandler({
                    errMsg: "startPullDownRefresh: ok"
                });
            } catch (e) {
                errorHandler({
                    errMsg: "startPullDownRefresh: fail"
                });
            }
        });
        taro.eventCenter.on("__taroStopPullDownRefresh", ({ successHandler, errorHandler })=>{
            setTimeout(()=>{
                try {
                    this.triggerPullDownRefresh(false);
                    successHandler({
                        errMsg: "stopPullDownRefresh: ok"
                    });
                } catch (e) {
                    errorHandler({
                        errMsg: "stopPullDownRefresh: fail"
                    });
                }
            }, 0);
        });
    }
    render() {
        const renderRefresh = (cls)=>{
            const { currSt, dragOnEdge, prefixCls } = this;
            const cla = classnames(cls, !dragOnEdge && `${prefixCls}-transition`);
            const showIndicator = currSt === "activate" || currSt === "release";
            return h("div", {
                class: `${prefixCls}-content-wrapper`
            }, h("div", {
                class: cla,
                ref: (el)=>{
                    this.contentRef = el;
                }
            }, showIndicator && h("div", {
                class: `${prefixCls}-indicator`
            }, h("div", null), h("div", null), h("div", null)), h("slot", null)));
        };
        if (this.scrollContainer) {
            return renderRefresh(`${this.prefixCls}-content ${this.prefixCls}-down`);
        }
        return h(Host, {
            class: classnames(this.prefixCls, `${this.prefixCls}-down`)
        }, renderRefresh(`${this.prefixCls}-content`));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "currSt": [
                "statusChange"
            ]
        };
    }
    static get style() {
        return indexCss13;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onRefresh = createEvent(this, "refresh", 7);
        this._ScreenY = 0;
        this._startScreenY = 0;
        this._lastScreenY = 0;
        this._isMounted = false;
        this.triggerPullDownRefresh = (flag)=>{
            if (!this.dragOnEdge && this._isMounted) {
                if (flag) {
                    this._lastScreenY = this.distanceToRefresh + 1;
                    this.currSt = "release";
                    this.setContentStyle(this._lastScreenY);
                } else {
                    this.currSt = "finish";
                    this.reset();
                }
            }
        };
        this.init = ()=>{
            const ele = this.scrollContainer;
            const child = this.el.querySelector(".rmc-pull-to-refresh-content");
            this.el.appendChild = child === null || child === void 0 ? void 0 : child.appendChild.bind(child);
            this.el.insertBefore = child === null || child === void 0 ? void 0 : child.insertBefore.bind(child);
            this.el.replaceChild = child === null || child === void 0 ? void 0 : child.replaceChild.bind(child);
            this.el.removeChild = child === null || child === void 0 ? void 0 : child.removeChild.bind(child);
            this._to = {
                touchstart: this.onTouchStart.bind(this, ele),
                touchmove: this.onTouchMove.bind(this, ele),
                touchend: this.onTouchEnd.bind(this, ele),
                touchcancel: this.onTouchEnd.bind(this, ele)
            };
            Object.keys(this._to).forEach((key)=>{
                ele.addEventListener(key, this._to[key], willPreventDefault);
            });
        };
        this.destroy = ()=>{
            const ele = this.scrollContainer;
            Object.keys(this._to).forEach((key)=>{
                ele.removeEventListener(key, this._to[key]);
            });
        };
        this.onTouchStart = (_, e)=>{
            this._ScreenY = this._startScreenY = e.touches[0].screenY;
            this._lastScreenY = this._lastScreenY || 0;
        };
        this.isEdge = (ele)=>{
            const container2 = this.scrollContainer;
            if (container2 && container2 === document.body) {
                const scrollNode = document.scrollingElement ? document.scrollingElement : document.body;
                return scrollNode.scrollTop <= 0;
            }
            return ele.scrollTop <= 0;
        };
        this.damp = (dy)=>{
            if (Math.abs(this._lastScreenY) > this.damping) {
                return 0;
            }
            const ratio = Math.abs(this._ScreenY - this._startScreenY) / window.screen.height;
            dy *= (1 - ratio) * 0.6;
            return dy;
        };
        this.onTouchMove = (ele, e)=>{
            const _screenY = e.touches[0].screenY;
            if (this._startScreenY > _screenY) {
                return;
            }
            if (this.isEdge(ele)) {
                if (!this.dragOnEdge) {
                    this._ScreenY = this._startScreenY = e.touches[0].screenY;
                    this.dragOnEdge = true;
                }
                if (e.cancelable) {
                    e.preventDefault();
                }
                const _diff = Math.round(_screenY - this._ScreenY);
                this._ScreenY = _screenY;
                this._lastScreenY += this.damp(_diff);
                this.setContentStyle(this._lastScreenY);
                if (Math.abs(this._lastScreenY) < this.distanceToRefresh) {
                    if (this.currSt !== "deactivate") {
                        this.currSt = "deactivate";
                    }
                } else {
                    if (this.currSt === "deactivate") {
                        this.currSt = "activate";
                    }
                }
                if (isWebView && e.changedTouches[0].clientY < 0) {
                    this.onTouchEnd();
                }
            }
        };
        this.onTouchEnd = ()=>{
            if (this.dragOnEdge) {
                this.dragOnEdge = false;
            }
            if (this.currSt === "activate") {
                this.currSt = "release";
                this.onRefresh.emit(this);
                this._lastScreenY = this.distanceToRefresh + 1;
                this.setContentStyle(this._lastScreenY);
            } else if (this.currSt === "release") {
                this._lastScreenY = this.distanceToRefresh + 1;
                this.setContentStyle(this._lastScreenY);
            } else {
                this.reset();
            }
        };
        this.reset = ()=>{
            this._lastScreenY = 0;
            this.setContentStyle(0);
        };
        this.setContentStyle = (ty)=>{
            if (this.contentRef) {
                if (ty) {
                    setTransform2(this.contentRef.style, `translate3d(0px,${ty}px,0)`);
                } else {
                    setTransform2(this.contentRef.style, "");
                }
            }
        };
        this.prefixCls = "rmc-pull-to-refresh";
        this.distanceToRefresh = 50;
        this.damping = 100;
        this.indicator = INDICATOR;
        this.currSt = "deactivate";
        this.dragOnEdge = false;
    }
}, [
    4,
    "taro-pull-to-refresh-core",
    {
        "prefixCls": [
            1,
            "prefix-cls"
        ],
        "distanceToRefresh": [
            2,
            "distance-to-refresh"
        ],
        "damping": [
            2
        ],
        "indicator": [
            16
        ],
        "currSt": [
            32
        ],
        "dragOnEdge": [
            32
        ]
    }
]);
function defineCustomElement$154() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-pull-to-refresh-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-pull-to-refresh-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, PullToRefresh);
                }
                break;
        }
    });
}
var defineCustomElement58 = defineCustomElement$154;
// node_modules/@tarojs/components/dist/components/taro-radio-core.js
var Radio = proxyCustomElement(class extends H {
    watchChecked(newVal) {
        if (!this.isWillLoadCalled) return;
        newVal && this.onChange.emit({
            value: this.value
        });
    }
    watchId(newVal) {
        if (!this.isWillLoadCalled) return;
        if (newVal) this.inputEl.setAttribute("id", newVal);
    }
    componentDidRender() {
        this.id && this.el.removeAttribute("id");
    }
    componentWillLoad() {
        this.isWillLoadCalled = true;
    }
    render() {
        const { checked, name, value, disabled, nativeProps } = this;
        return h(Host, {
            className: "weui-cells_checkbox",
            onClick: this.handleClick
        }, h("input", Object.assign({
            ref: (dom)=>{
                if (!dom) return;
                this.inputEl = dom;
                if (this.id) dom.setAttribute("id", this.id);
            },
            type: "radio",
            name,
            value,
            class: "weui-check",
            checked,
            disabled,
            onChange: (e)=>e.stopPropagation()
        }, nativeProps)), h("i", {
            class: "weui-icon-checked"
        }), h("slot", null));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "checked": [
                "watchChecked"
            ],
            "id": [
                "watchId"
            ]
        };
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "radiochange", 7);
        this.handleClick = (e)=>{
            e.stopPropagation();
            if (this.disabled) return;
            if (!this.checked) this.checked = true;
        };
        this.name = void 0;
        this.value = "";
        this.id = void 0;
        this.checked = false;
        this.disabled = false;
        this.nativeProps = {};
        this.isWillLoadCalled = false;
    }
}, [
    4,
    "taro-radio-core",
    {
        "name": [
            1
        ],
        "value": [
            1
        ],
        "id": [
            1025
        ],
        "checked": [
            1540
        ],
        "disabled": [
            4
        ],
        "nativeProps": [
            16
        ],
        "isWillLoadCalled": [
            32
        ]
    }
]);
function defineCustomElement$155() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-radio-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-radio-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Radio);
                }
                break;
        }
    });
}
var defineCustomElement59 = defineCustomElement$155;
// node_modules/@tarojs/components/dist/components/taro-radio-group-core.js
var __classPrivateFieldSet3 = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet3 = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _RadioGroup_value;
var RadioGroup = proxyCustomElement(class extends H {
    function(e) {
        e.stopPropagation();
        if (e.target.tagName !== "TARO-RADIO-CORE") return;
        const target = e.target;
        if (target.checked) {
            const childList = this.el.querySelectorAll("taro-radio-core");
            childList.forEach((element)=>{
                if (element !== target) {
                    element.checked = false;
                }
            });
            __classPrivateFieldSet3(this, _RadioGroup_value, e.detail.value, "f");
            this.onChange.emit({
                value: __classPrivateFieldGet3(this, _RadioGroup_value, "f")
            });
        }
    }
    componentDidLoad() {
        const childList = this.el.querySelectorAll("taro-radio-core");
        childList.forEach((element)=>{
            element.setAttribute("name", this.name || this.uniqueName);
        });
        Object.defineProperty(this.el, "value", {
            get: ()=>{
                if (!__classPrivateFieldGet3(this, _RadioGroup_value, "f")) {
                    const childList2 = this.el.querySelectorAll("taro-radio-core");
                    __classPrivateFieldSet3(this, _RadioGroup_value, this.getValues(childList2), "f");
                }
                return __classPrivateFieldGet3(this, _RadioGroup_value, "f");
            },
            configurable: true
        });
    }
    getValues(childList) {
        let val = "";
        Array.from(childList).forEach((element)=>{
            const checkbox = element.querySelector("input");
            if (checkbox === null || checkbox === void 0 ? void 0 : checkbox.checked) {
                val = checkbox.value || "";
            }
        });
        return val;
    }
    render() {
        return h(Host, {
            class: "weui-cells_radiogroup"
        });
    }
    get el() {
        return this;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "change", 7);
        this.uniqueName = Date.now().toString(36);
        _RadioGroup_value.set(this, void 0);
        this.name = void 0;
    }
}, [
    0,
    "taro-radio-group-core",
    {
        "name": [
            8
        ]
    },
    [
        [
            0,
            "radiochange",
            "function"
        ]
    ]
]);
_RadioGroup_value = /* @__PURE__ */ new WeakMap();
function defineCustomElement$156() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-radio-group-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-radio-group-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, RadioGroup);
                }
                break;
        }
    });
}
var defineCustomElement60 = defineCustomElement$156;
// node_modules/@tarojs/components/dist/components/taro-rich-text-core.js
var indexCss14 = "taro-rich-text-core{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}taro-rich-text-core[selectable=true],taro-rich-text-core[user-select=true]{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;display:block}taro-rich-text-core[space]{white-space:pre-wrap}taro-rich-text-core[space=ensp]{word-spacing:.5em}taro-rich-text-core[space=nbsp]{word-spacing:1em}";
var RichText = proxyCustomElement(class extends H {
    render() {
        const { nodes, renderNode } = this;
        if (Array.isArray(nodes)) {
            return h(Host, null, nodes.map((node)=>renderNode(node)));
        } else {
            return h(Host, {
                innerHTML: nodes
            });
        }
    }
    static get style() {
        return indexCss14;
    }
    constructor(){
        super();
        this.__registerHost();
        this.renderNode = (node)=>{
            if ("type" in node && node.type === "text") {
                const content = (node.text || "").replace(/&nbsp;/g, "\xA0");
                return content;
            } else if ("name" in node && node.name) {
                const { name, attrs, children: children2 } = node;
                const attributes = {};
                let childList = [];
                if (attrs && typeof attrs === "object") {
                    for(const key in attrs){
                        const val = attrs[key];
                        if (key === "style" && typeof val === "string") {
                            const styles3 = val.split(";").map((item)=>item.trim()).filter((item)=>item);
                            const styleObj = {};
                            styles3.forEach((item)=>{
                                if (!item) return;
                                const res = /(.+): *(.+)/g.exec(item);
                                if (!res) return;
                                const [, name2, value] = res;
                                const styleName = name2.replace(/-([a-z])/g, (...args)=>args[1].toUpperCase());
                                styleObj[styleName] = value;
                            });
                            if (Object.keys(styleObj).length) {
                                attributes.style = styleObj;
                            }
                            continue;
                        }
                        attributes[key] = val;
                    }
                }
                if (children2 && children2.length) {
                    childList = children2.map((node2)=>this.renderNode(node2));
                }
                return h(name, attributes, childList);
            }
            return null;
        };
        this.nodes = void 0;
        this.selectable = false;
        this.userSelect = false;
        this.space = void 0;
    }
}, [
    0,
    "taro-rich-text-core",
    {
        "nodes": [
            1
        ],
        "selectable": [
            1028
        ],
        "userSelect": [
            1028,
            "user-select"
        ],
        "space": [
            1
        ]
    }
]);
function defineCustomElement$157() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-rich-text-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-rich-text-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, RichText);
                }
                break;
        }
    });
}
var defineCustomElement61 = defineCustomElement$157;
// node_modules/@tarojs/components/dist/components/taro-root-portal-core.js
var RootPortal = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("RootPortal", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-root-portal-core"
]);
function defineCustomElement$158() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-root-portal-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-root-portal-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, RootPortal);
                }
                break;
        }
    });
}
var defineCustomElement62 = defineCustomElement$158;
// node_modules/@tarojs/components/dist/components/taro-rtc-room-core.js
var RtcRoom = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("RtcRoom", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-rtc-room-core"
]);
function defineCustomElement$159() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-rtc-room-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-rtc-room-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, RtcRoom);
                }
                break;
        }
    });
}
var defineCustomElement63 = defineCustomElement$159;
// node_modules/@tarojs/components/dist/components/taro-rtc-room-item-core.js
var RtcRoomItem = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("RtcRoomItem", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-rtc-room-item-core"
]);
function defineCustomElement$160() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-rtc-room-item-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-rtc-room-item-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, RtcRoomItem);
                }
                break;
        }
    });
}
var defineCustomElement64 = defineCustomElement$160;
// node_modules/@tarojs/components/dist/components/taro-scroll-view-core.js
var indexCss15 = "taro-scroll-view-core{-webkit-overflow-scrolling:auto;width:100%;display:block}taro-scroll-view-core::-webkit-scrollbar{display:none}.taro-scroll-view__scroll-x{overflow:scroll hidden}.taro-scroll-view__scroll-y{overflow:hidden scroll}";
function easeOutScroll(from, to, duration = 500, callback) {
    if (from === to || typeof from !== "number") {
        return;
    }
    const change2 = to - from;
    const sTime = Date.now();
    const isLarger = to >= from;
    function linear(t, b, c, d) {
        return c * t / d + b;
    }
    function step() {
        from = linear(Date.now() - sTime, from, change2, duration);
        if (isLarger && from >= to || !isLarger && to >= from) {
            callback(to);
            return;
        }
        callback(from);
        requestAnimationFrame(step);
    }
    step();
}
var ScrollView = proxyCustomElement(class extends H {
    watchScrollLeft(newVal) {
        const left = Number(newVal);
        const { animated } = this;
        this.mpScrollToMethod({
            left,
            animated
        });
    }
    watchScrollTop(newVal) {
        const top = Number(newVal);
        const { animated } = this;
        this.mpScrollToMethod({
            top,
            animated
        });
    }
    watchScrollIntoView(newVal) {
        this.mpScrollIntoViewMethod(newVal);
    }
    handleScroll(e) {
        var _a;
        if (e instanceof CustomEvent) return;
        e.stopPropagation();
        (_a = e.stopImmediatePropagation) === null || _a === void 0 ? void 0 : _a.call(e);
        const { scrollLeft, scrollTop, scrollHeight, scrollWidth } = this.el;
        this._scrollLeft = scrollLeft;
        this._scrollTop = scrollTop;
        this.upperAndLower();
        this.onScroll.emit({
            scrollLeft,
            scrollTop,
            scrollHeight,
            scrollWidth
        });
    }
    handleTouchMove(e) {
        if (e instanceof CustomEvent) return;
        e.stopPropagation();
    }
    mpScrollToMethod(object2) {
        var _this = this;
        return _async_to_generator(function*() {
            let { top, left, duration, animated = false } = object2;
            if (_this.scrollY && typeof top === "number" && !isNaN(top) && top !== _this._scrollTop) {
                if (animated) {
                    easeOutScroll(_this._scrollTop, top, duration, (pos)=>_this.el.scrollTop = pos);
                } else {
                    _this.el.scrollTop = top;
                }
                _this._scrollTop = top;
            }
            if (_this.scrollX && typeof left === "number" && !isNaN(left) && left !== _this._scrollLeft) {
                if (animated) {
                    easeOutScroll(_this._scrollLeft, left, duration, (pos)=>_this.el.scrollLeft = pos);
                } else {
                    _this.el.scrollLeft = left;
                }
                _this._scrollLeft = left;
            }
        })();
    }
    mpScrollIntoViewMethod(selector) {
        var _this = this;
        return _async_to_generator(function*() {
            var _a;
            if (typeof selector === "string" && selector) {
                (_a = document.querySelector(`#${selector}`)) === null || _a === void 0 ? void 0 : _a.scrollIntoView({
                    behavior: _this.animated ? "smooth" : "auto",
                    block: _this.scrollY ? _this.mpScrollIntoViewAlignment || "center" : "center",
                    inline: _this.scrollX ? _this.mpScrollIntoViewAlignment || "start" : "start"
                });
            }
        })();
    }
    componentDidLoad() {
        const top = Number(this.mpScrollTop);
        const left = Number(this.mpScrollLeft);
        const { animated } = this;
        this.mpScrollToMethod({
            top,
            left,
            animated
        });
    }
    componentDidRender() {
        handleStencilNodes(this.el);
    }
    render() {
        const { scrollX, scrollY } = this;
        const cls = classnames({
            "taro-scroll-view__scroll-x": scrollX,
            "taro-scroll-view__scroll-y": scrollY
        });
        return h(Host, {
            class: cls
        }, h("slot", null));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "mpScrollLeft": [
                "watchScrollLeft"
            ],
            "mpScrollTop": [
                "watchScrollTop"
            ],
            "mpScrollIntoView": [
                "watchScrollIntoView"
            ]
        };
    }
    static get style() {
        return indexCss15;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onScroll = createEvent(this, "scroll", 3);
        this.onScrollToUpper = createEvent(this, "scrolltoupper", 3);
        this.onScrollToLower = createEvent(this, "scrolltolower", 3);
        this._scrollLeft = 0;
        this._scrollTop = 0;
        this.upperAndLower = debounce2(()=>{
            const { offsetWidth, offsetHeight, scrollLeft, scrollTop, scrollHeight, scrollWidth } = this.el;
            const lowerThreshold = Number(this.lowerThreshold);
            const upperThreshold = Number(this.upperThreshold);
            if (!isNaN(lowerThreshold) && (this.scrollY && offsetHeight + scrollTop + lowerThreshold >= scrollHeight || this.scrollX && offsetWidth + scrollLeft + lowerThreshold >= scrollWidth)) {
                this.onScrollToLower.emit({
                    direction: this.scrollX ? "right" : this.scrollY ? "bottom" : ""
                });
            }
            if (!isNaN(upperThreshold) && (this.scrollY && scrollTop <= upperThreshold || this.scrollX && scrollLeft <= upperThreshold)) {
                this.onScrollToUpper.emit({
                    direction: this.scrollX ? "left" : this.scrollY ? "top" : ""
                });
            }
        }, 200);
        this.scrollX = false;
        this.scrollY = false;
        this.upperThreshold = 50;
        this.lowerThreshold = 50;
        this.mpScrollTop = void 0;
        this.mpScrollLeft = void 0;
        this.mpScrollIntoView = void 0;
        this.mpScrollIntoViewAlignment = void 0;
        this.animated = false;
    }
}, [
    4,
    "taro-scroll-view-core",
    {
        "scrollX": [
            4,
            "scroll-x"
        ],
        "scrollY": [
            4,
            "scroll-y"
        ],
        "upperThreshold": [
            8,
            "upper-threshold"
        ],
        "lowerThreshold": [
            8,
            "lower-threshold"
        ],
        "mpScrollTop": [
            520,
            "scroll-top"
        ],
        "mpScrollLeft": [
            520,
            "scroll-left"
        ],
        "mpScrollIntoView": [
            513,
            "scroll-into-view"
        ],
        "mpScrollIntoViewAlignment": [
            1,
            "scroll-into-view-alignment"
        ],
        "animated": [
            4,
            "scroll-with-animation"
        ],
        "mpScrollToMethod": [
            64
        ],
        "mpScrollIntoViewMethod": [
            64
        ]
    },
    [
        [
            1,
            "scroll",
            "handleScroll"
        ],
        [
            1,
            "touchmove",
            "handleTouchMove"
        ]
    ]
]);
function defineCustomElement$161() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-scroll-view-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-scroll-view-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, ScrollView);
                }
                break;
        }
    });
}
var defineCustomElement65 = defineCustomElement$161;
// node_modules/@tarojs/components/dist/components/taro-share-element-core.js
var ShareElement = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("ShareElement", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-share-element-core"
]);
function defineCustomElement$162() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-share-element-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-share-element-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, ShareElement);
                }
                break;
        }
    });
}
var defineCustomElement66 = defineCustomElement$162;
// node_modules/@tarojs/components/dist/components/taro-slider-core.js
var indexCss16 = ".weui-slider{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;padding:15px 18px}.weui-slider__inner{background-color:#e9e9e9;height:2px;position:relative}.weui-slider__track{background-color:#1aad19;width:0;height:2px}.weui-slider__handler{background-color:#fff;border-radius:50%;width:28px;height:28px;margin-top:-14px;margin-left:-14px;position:absolute;top:50%;left:0;-webkit-box-shadow:0 0 4px rgba(0,0,0,.2);box-shadow:0 0 4px rgba(0,0,0,.2)}.weui-slider-box{-ms-flex-align:center;align-items:center;display:-ms-flexbox;display:flex}.weui-slider-box .weui-slider{-ms-flex:1;flex:1}.weui-slider-box__value{color:#888;text-align:center;min-width:24px;margin-left:.5em;font-size:14px}";
var Slider = proxyCustomElement(class extends H {
    function(value) {
        if (!this.isWillLoadCalled) return;
        const { max, min } = this;
        if (value !== null) {
            const val = this.handleValueUpdate(value, min, max);
            this.updateByStep(val);
        }
    }
    componentDidLoad() {
        this.handler.addEventListener("touchstart", this.handleTouchStart);
        this.handler.addEventListener("touchmove", this.handleTouchMove);
        this.handler.addEventListener("touchend", this.handleTouchEnd);
    }
    componentWillLoad() {
        this.isWillLoadCalled = true;
        const { value, max, min } = this;
        const val = this.handleValueUpdate(value, min, max);
        this.updateByStep(val);
    }
    // 根据步长 step 修改 value
    updateByStep(value) {
        const { max, min, step } = this;
        const steps = Math.floor((max - min) / step);
        for(let i2 = 0; i2 <= steps; i2++){
            const current = min + step * i2;
            const next2 = i2 === steps ? null : min + step * (i2 + 1);
            if (value === current) break;
            if (!next2 && value > current) {
                value = current;
            }
            if (next2 && value > current && value < next2) {
                if (value - current < step / 2) {
                    value = current;
                } else {
                    value = next2;
                }
                break;
            }
        }
        const percent = (value - min) / (max - min) * 100;
        this.value = value;
        this.percent = percent;
    }
    render() {
        const { showValue, backgroundColor, activeColor, blockColor, name, percent, value } = this;
        let blockSize = this.blockSize;
        const innerStyles = {
            backgroundColor
        };
        const percentage = percent > 100 ? 100 : percent;
        const trackStyles = {
            width: `${percentage}%`,
            backgroundColor: activeColor
        };
        if (blockSize < 12) {
            blockSize = 12;
        }
        if (blockSize > 28) {
            blockSize = 28;
        }
        const handlerStyles = {
            left: `${percentage}%`,
            width: `${blockSize}px`,
            height: `${blockSize}px`,
            backgroundColor: blockColor,
            marginTop: `-${Math.floor(blockSize / 2)}px`,
            marginLeft: `-${Math.floor(blockSize / 2)}px`
        };
        return h(Host, {
            class: "weui-slider-box"
        }, h("div", {
            class: "weui-slider"
        }, h("div", {
            class: "weui-slider__inner",
            style: innerStyles,
            ref: (c)=>this.sliderInsRef = c
        }, h("div", {
            style: trackStyles,
            class: "weui-slider__track"
        }), h("div", {
            class: "weui-slider__handler",
            ref: (dom)=>{
                if (dom) this.handler = dom;
            },
            style: handlerStyles
        }), h("input", {
            type: "hidden",
            name,
            value
        }))), showValue && h("div", {
            class: "weui-slider-box__value"
        }, value));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "value": [
                "function"
            ]
        };
    }
    static get style() {
        return indexCss16;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "change", 7);
        this.onChanging = createEvent(this, "changing", 7);
        this.handleTouchStart = (e)=>{
            if (this.touching || this.disabled) return;
            this.touching = true;
            this.touchId = e.targetTouches[0].identifier;
            this.totalWidth = this.sliderInsRef.clientWidth || 1;
            this.ogX = e.targetTouches[0].pageX;
            this.ogPercent = this.percent;
        };
        this.handleTouchMove = (e)=>{
            const { disabled, touching, touchId, totalWidth, max, min, ogX, ogPercent } = this;
            if (!touching || disabled) return;
            if (e.targetTouches[0].identifier !== touchId) return;
            e.preventDefault();
            const pageX = e.targetTouches[0].pageX;
            const diffX = pageX - ogX;
            let percent = diffX / totalWidth * 100 + ogPercent;
            percent = this.handleValueUpdate(percent, 0, 100);
            const val = min + percent * 0.01 * (max - min);
            this.updateByStep(val);
            this.onChanging.emit({
                detail: e.detail,
                value: this.value
            });
        };
        this.handleTouchEnd = (e)=>{
            const { disabled, touching } = this;
            if (!touching || disabled) return;
            if (this.percent !== this.ogPercent) {
                this.onChange.emit({
                    detail: e.detail,
                    value: this.value
                });
            }
            this.touching = false;
            this.touchId = null;
            this.ogX = 0;
            this.ogPercent = 0;
        };
        this.handleValueUpdate = (e, min = this.min, max = this.max)=>{
            e = isNaN(e) ? 0 : e;
            return Math.max(min, Math.min(e, max));
        };
        this.min = 0;
        this.max = 100;
        this.step = 1;
        this.disabled = false;
        this.value = 0;
        this.activeColor = "#1aad19";
        this.backgroundColor = "#e9e9e9";
        this.blockSize = 28;
        this.blockColor = "#ffffff";
        this.showValue = false;
        this.name = "";
        this.totalWidth = 1;
        this.touching = false;
        this.ogX = 0;
        this.touchId = null;
        this.percent = 0;
        this.ogPercent = void 0;
        this.isWillLoadCalled = false;
    }
}, [
    0,
    "taro-slider-core",
    {
        "min": [
            2
        ],
        "max": [
            2
        ],
        "step": [
            2
        ],
        "disabled": [
            4
        ],
        "value": [
            1538
        ],
        "activeColor": [
            1,
            "active-color"
        ],
        "backgroundColor": [
            1,
            "background-color"
        ],
        "blockSize": [
            2,
            "block-size"
        ],
        "blockColor": [
            1,
            "block-color"
        ],
        "showValue": [
            4,
            "show-value"
        ],
        "name": [
            1
        ],
        "totalWidth": [
            32
        ],
        "touching": [
            32
        ],
        "ogX": [
            32
        ],
        "touchId": [
            32
        ],
        "percent": [
            32
        ],
        "ogPercent": [
            32
        ],
        "isWillLoadCalled": [
            32
        ]
    }
]);
function defineCustomElement$163() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-slider-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-slider-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Slider);
                }
                break;
        }
    });
}
var defineCustomElement67 = defineCustomElement$163;
// node_modules/@tarojs/components/dist/components/taro-slot-core.js
var Slot = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Slot", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-slot-core"
]);
function defineCustomElement$164() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-slot-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-slot-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Slot);
                }
                break;
        }
    });
}
var defineCustomElement68 = defineCustomElement$164;
// node_modules/@tarojs/components/dist/components/taro-snapshot-core.js
var Snapshot = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Snapshot", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-snapshot-core"
]);
function defineCustomElement$165() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-snapshot-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-snapshot-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Snapshot);
                }
                break;
        }
    });
}
var defineCustomElement69 = defineCustomElement$165;
// node_modules/@tarojs/components/dist/components/taro-sticky-header-core.js
var StickyHeader = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("StickyHeader", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-sticky-header-core"
]);
function defineCustomElement$166() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-sticky-header-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-sticky-header-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, StickyHeader);
                }
                break;
        }
    });
}
var defineCustomElement70 = defineCustomElement$166;
// node_modules/@tarojs/components/dist/components/taro-sticky-section-core.js
var StickySection = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("StickySection", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-sticky-section-core"
]);
function defineCustomElement$167() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-sticky-section-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-sticky-section-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, StickySection);
                }
                break;
        }
    });
}
var defineCustomElement71 = defineCustomElement$167;
// node_modules/ssr-window/ssr-window.esm.js
function isObject4(obj) {
    return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
}
function extend(target, src) {
    if (target === void 0) {
        target = {};
    }
    if (src === void 0) {
        src = {};
    }
    Object.keys(src).forEach(function(key) {
        if (typeof target[key] === "undefined") target[key] = src[key];
        else if (isObject4(src[key]) && isObject4(target[key]) && Object.keys(src[key]).length > 0) {
            extend(target[key], src[key]);
        }
    });
}
var ssrDocument = {
    body: {},
    addEventListener: function() {},
    removeEventListener: function() {},
    activeElement: {
        blur: function() {},
        nodeName: ""
    },
    querySelector: function() {
        return null;
    },
    querySelectorAll: function() {
        return [];
    },
    getElementById: function() {
        return null;
    },
    createEvent: function() {
        return {
            initEvent: function() {}
        };
    },
    createElement: function() {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute: function() {},
            getElementsByTagName: function() {
                return [];
            }
        };
    },
    createElementNS: function() {
        return {};
    },
    importNode: function() {
        return null;
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    }
};
function getDocument() {
    var doc3 = typeof document !== "undefined" ? document : {};
    extend(doc3, ssrDocument);
    return doc3;
}
var ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: ""
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    },
    history: {
        replaceState: function() {},
        pushState: function() {},
        go: function() {},
        back: function() {}
    },
    CustomEvent: function CustomEvent2() {
        return this;
    },
    addEventListener: function() {},
    removeEventListener: function() {},
    getComputedStyle: function() {
        return {
            getPropertyValue: function() {
                return "";
            }
        };
    },
    Image: function() {},
    Date: function() {},
    screen: {},
    setTimeout: function() {},
    clearTimeout: function() {},
    matchMedia: function() {
        return {};
    },
    requestAnimationFrame: function(callback) {
        if (typeof setTimeout === "undefined") {
            callback();
            return null;
        }
        return setTimeout(callback, 0);
    },
    cancelAnimationFrame: function(id) {
        if (typeof setTimeout === "undefined") {
            return;
        }
        clearTimeout(id);
    }
};
function getWindow() {
    var win3 = typeof window !== "undefined" ? window : {};
    extend(win3, ssrWindow);
    return win3;
}
// node_modules/dom7/dom7.esm.js
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
    };
    return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
    } else {
        _construct = function _construct2(Parent2, args2, Class2) {
            var a = [
                null
            ];
            a.push.apply(a, args2);
            var Constructor = Function.bind.apply(Parent2, a);
            var instance = new Constructor();
            if (Class2) _setPrototypeOf(instance, Class2.prototype);
            return instance;
        };
    }
    return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
    _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
        if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class2)) return _cache.get(Class2);
            _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _setPrototypeOf(Wrapper, Class2);
    };
    return _wrapNativeSuper(Class);
}
function _assertThisInitialized(self2) {
    if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
}
function makeReactive(obj) {
    var proto = obj.__proto__;
    Object.defineProperty(obj, "__proto__", {
        get: function get2() {
            return proto;
        },
        set: function set3(value) {
            proto.__proto__ = value;
        }
    });
}
var Dom7 = function(_Array) {
    _inheritsLoose(Dom72, _Array);
    function Dom72(items) {
        var _this;
        _this = _Array.call.apply(_Array, [
            this
        ].concat(items)) || this;
        makeReactive(_assertThisInitialized(_this));
        return _this;
    }
    return Dom72;
}(_wrapNativeSuper(Array));
function arrayFlat(arr) {
    if (arr === void 0) {
        arr = [];
    }
    var res = [];
    arr.forEach(function(el) {
        if (Array.isArray(el)) {
            res.push.apply(res, arrayFlat(el));
        } else {
            res.push(el);
        }
    });
    return res;
}
function arrayFilter2(arr, callback) {
    return Array.prototype.filter.call(arr, callback);
}
function arrayUnique(arr) {
    var uniqueArray = [];
    for(var i2 = 0; i2 < arr.length; i2 += 1){
        if (uniqueArray.indexOf(arr[i2]) === -1) uniqueArray.push(arr[i2]);
    }
    return uniqueArray;
}
function qsa(selector, context) {
    if (typeof selector !== "string") {
        return [
            selector
        ];
    }
    var a = [];
    var res = context.querySelectorAll(selector);
    for(var i2 = 0; i2 < res.length; i2 += 1){
        a.push(res[i2]);
    }
    return a;
}
function $(selector, context) {
    var window2 = getWindow();
    var document2 = getDocument();
    var arr = [];
    if (!context && selector instanceof Dom7) {
        return selector;
    }
    if (!selector) {
        return new Dom7(arr);
    }
    if (typeof selector === "string") {
        var html2 = selector.trim();
        if (html2.indexOf("<") >= 0 && html2.indexOf(">") >= 0) {
            var toCreate = "div";
            if (html2.indexOf("<li") === 0) toCreate = "ul";
            if (html2.indexOf("<tr") === 0) toCreate = "tbody";
            if (html2.indexOf("<td") === 0 || html2.indexOf("<th") === 0) toCreate = "tr";
            if (html2.indexOf("<tbody") === 0) toCreate = "table";
            if (html2.indexOf("<option") === 0) toCreate = "select";
            var tempParent = document2.createElement(toCreate);
            tempParent.innerHTML = html2;
            for(var i2 = 0; i2 < tempParent.childNodes.length; i2 += 1){
                arr.push(tempParent.childNodes[i2]);
            }
        } else {
            arr = qsa(selector.trim(), context || document2);
        }
    } else if (selector.nodeType || selector === window2 || selector === document2) {
        arr.push(selector);
    } else if (Array.isArray(selector)) {
        if (selector instanceof Dom7) return selector;
        arr = selector;
    }
    return new Dom7(arrayUnique(arr));
}
$.fn = Dom7.prototype;
function addClass() {
    for(var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++){
        classes[_key] = arguments[_key];
    }
    var classNames = arrayFlat(classes.map(function(c) {
        return c.split(" ");
    }));
    this.forEach(function(el) {
        var _el$classList;
        (_el$classList = el.classList).add.apply(_el$classList, classNames);
    });
    return this;
}
function removeClass() {
    for(var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){
        classes[_key2] = arguments[_key2];
    }
    var classNames = arrayFlat(classes.map(function(c) {
        return c.split(" ");
    }));
    this.forEach(function(el) {
        var _el$classList2;
        (_el$classList2 = el.classList).remove.apply(_el$classList2, classNames);
    });
    return this;
}
function toggleClass() {
    for(var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){
        classes[_key3] = arguments[_key3];
    }
    var classNames = arrayFlat(classes.map(function(c) {
        return c.split(" ");
    }));
    this.forEach(function(el) {
        classNames.forEach(function(className) {
            el.classList.toggle(className);
        });
    });
}
function hasClass() {
    for(var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){
        classes[_key4] = arguments[_key4];
    }
    var classNames = arrayFlat(classes.map(function(c) {
        return c.split(" ");
    }));
    return arrayFilter2(this, function(el) {
        return classNames.filter(function(className) {
            return el.classList.contains(className);
        }).length > 0;
    }).length > 0;
}
function attr(attrs, value) {
    if (arguments.length === 1 && typeof attrs === "string") {
        if (this[0]) return this[0].getAttribute(attrs);
        return void 0;
    }
    for(var i2 = 0; i2 < this.length; i2 += 1){
        if (arguments.length === 2) {
            this[i2].setAttribute(attrs, value);
        } else {
            for(var attrName in attrs){
                this[i2][attrName] = attrs[attrName];
                this[i2].setAttribute(attrName, attrs[attrName]);
            }
        }
    }
    return this;
}
function removeAttr(attr2) {
    for(var i2 = 0; i2 < this.length; i2 += 1){
        this[i2].removeAttribute(attr2);
    }
    return this;
}
function transform(transform2) {
    for(var i2 = 0; i2 < this.length; i2 += 1){
        this[i2].style.transform = transform2;
    }
    return this;
}
function transition(duration) {
    for(var i2 = 0; i2 < this.length; i2 += 1){
        this[i2].style.transitionDuration = typeof duration !== "string" ? duration + "ms" : duration;
    }
    return this;
}
function on() {
    for(var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++){
        args[_key5] = arguments[_key5];
    }
    var eventType = args[0], targetSelector = args[1], listener = args[2], capture = args[3];
    if (typeof args[1] === "function") {
        eventType = args[0];
        listener = args[1];
        capture = args[2];
        targetSelector = void 0;
    }
    if (!capture) capture = false;
    function handleLiveEvent(e) {
        var target = e.target;
        if (!target) return;
        var eventData = e.target.dom7EventData || [];
        if (eventData.indexOf(e) < 0) {
            eventData.unshift(e);
        }
        if ($(target).is(targetSelector)) listener.apply(target, eventData);
        else {
            var _parents = $(target).parents();
            for(var k = 0; k < _parents.length; k += 1){
                if ($(_parents[k]).is(targetSelector)) listener.apply(_parents[k], eventData);
            }
        }
    }
    function handleEvent(e) {
        var eventData = e && e.target ? e.target.dom7EventData || [] : [];
        if (eventData.indexOf(e) < 0) {
            eventData.unshift(e);
        }
        listener.apply(this, eventData);
    }
    var events = eventType.split(" ");
    var j;
    for(var i2 = 0; i2 < this.length; i2 += 1){
        var el = this[i2];
        if (!targetSelector) {
            for(j = 0; j < events.length; j += 1){
                var event2 = events[j];
                if (!el.dom7Listeners) el.dom7Listeners = {};
                if (!el.dom7Listeners[event2]) el.dom7Listeners[event2] = [];
                el.dom7Listeners[event2].push({
                    listener,
                    proxyListener: handleEvent
                });
                el.addEventListener(event2, handleEvent, capture);
            }
        } else {
            for(j = 0; j < events.length; j += 1){
                var _event = events[j];
                if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
                if (!el.dom7LiveListeners[_event]) el.dom7LiveListeners[_event] = [];
                el.dom7LiveListeners[_event].push({
                    listener,
                    proxyListener: handleLiveEvent
                });
                el.addEventListener(_event, handleLiveEvent, capture);
            }
        }
    }
    return this;
}
function off() {
    for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++){
        args[_key6] = arguments[_key6];
    }
    var eventType = args[0], targetSelector = args[1], listener = args[2], capture = args[3];
    if (typeof args[1] === "function") {
        eventType = args[0];
        listener = args[1];
        capture = args[2];
        targetSelector = void 0;
    }
    if (!capture) capture = false;
    var events = eventType.split(" ");
    for(var i2 = 0; i2 < events.length; i2 += 1){
        var event2 = events[i2];
        for(var j = 0; j < this.length; j += 1){
            var el = this[j];
            var handlers = void 0;
            if (!targetSelector && el.dom7Listeners) {
                handlers = el.dom7Listeners[event2];
            } else if (targetSelector && el.dom7LiveListeners) {
                handlers = el.dom7LiveListeners[event2];
            }
            if (handlers && handlers.length) {
                for(var k = handlers.length - 1; k >= 0; k -= 1){
                    var handler = handlers[k];
                    if (listener && handler.listener === listener) {
                        el.removeEventListener(event2, handler.proxyListener, capture);
                        handlers.splice(k, 1);
                    } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                        el.removeEventListener(event2, handler.proxyListener, capture);
                        handlers.splice(k, 1);
                    } else if (!listener) {
                        el.removeEventListener(event2, handler.proxyListener, capture);
                        handlers.splice(k, 1);
                    }
                }
            }
        }
    }
    return this;
}
function trigger() {
    var window2 = getWindow();
    for(var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++){
        args[_key9] = arguments[_key9];
    }
    var events = args[0].split(" ");
    var eventData = args[1];
    for(var i2 = 0; i2 < events.length; i2 += 1){
        var event2 = events[i2];
        for(var j = 0; j < this.length; j += 1){
            var el = this[j];
            if (window2.CustomEvent) {
                var evt = new window2.CustomEvent(event2, {
                    detail: eventData,
                    bubbles: true,
                    cancelable: true
                });
                el.dom7EventData = args.filter(function(data, dataIndex) {
                    return dataIndex > 0;
                });
                el.dispatchEvent(evt);
                el.dom7EventData = [];
                delete el.dom7EventData;
            }
        }
    }
    return this;
}
function transitionEnd(callback) {
    var dom = this;
    function fireCallBack(e) {
        if (e.target !== this) return;
        callback.call(this, e);
        dom.off("transitionend", fireCallBack);
    }
    if (callback) {
        dom.on("transitionend", fireCallBack);
    }
    return this;
}
function outerWidth(includeMargins) {
    if (this.length > 0) {
        if (includeMargins) {
            var _styles = this.styles();
            return this[0].offsetWidth + parseFloat(_styles.getPropertyValue("margin-right")) + parseFloat(_styles.getPropertyValue("margin-left"));
        }
        return this[0].offsetWidth;
    }
    return null;
}
function outerHeight(includeMargins) {
    if (this.length > 0) {
        if (includeMargins) {
            var _styles2 = this.styles();
            return this[0].offsetHeight + parseFloat(_styles2.getPropertyValue("margin-top")) + parseFloat(_styles2.getPropertyValue("margin-bottom"));
        }
        return this[0].offsetHeight;
    }
    return null;
}
function offset() {
    if (this.length > 0) {
        var window2 = getWindow();
        var document2 = getDocument();
        var el = this[0];
        var box = el.getBoundingClientRect();
        var body = document2.body;
        var clientTop = el.clientTop || body.clientTop || 0;
        var clientLeft = el.clientLeft || body.clientLeft || 0;
        var scrollTop = el === window2 ? window2.scrollY : el.scrollTop;
        var scrollLeft = el === window2 ? window2.scrollX : el.scrollLeft;
        return {
            top: box.top + scrollTop - clientTop,
            left: box.left + scrollLeft - clientLeft
        };
    }
    return null;
}
function styles2() {
    var window2 = getWindow();
    if (this[0]) return window2.getComputedStyle(this[0], null);
    return {};
}
function css(props, value) {
    var window2 = getWindow();
    var i2;
    if (arguments.length === 1) {
        if (typeof props === "string") {
            if (this[0]) return window2.getComputedStyle(this[0], null).getPropertyValue(props);
        } else {
            for(i2 = 0; i2 < this.length; i2 += 1){
                for(var _prop in props){
                    this[i2].style[_prop] = props[_prop];
                }
            }
            return this;
        }
    }
    if (arguments.length === 2 && typeof props === "string") {
        for(i2 = 0; i2 < this.length; i2 += 1){
            this[i2].style[props] = value;
        }
        return this;
    }
    return this;
}
function each(callback) {
    if (!callback) return this;
    this.forEach(function(el, index2) {
        callback.apply(el, [
            el,
            index2
        ]);
    });
    return this;
}
function filter2(callback) {
    var result = arrayFilter2(this, callback);
    return $(result);
}
function html(html2) {
    if (typeof html2 === "undefined") {
        return this[0] ? this[0].innerHTML : null;
    }
    for(var i2 = 0; i2 < this.length; i2 += 1){
        this[i2].innerHTML = html2;
    }
    return this;
}
function text(text2) {
    if (typeof text2 === "undefined") {
        return this[0] ? this[0].textContent.trim() : null;
    }
    for(var i2 = 0; i2 < this.length; i2 += 1){
        this[i2].textContent = text2;
    }
    return this;
}
function is(selector) {
    var window2 = getWindow();
    var document2 = getDocument();
    var el = this[0];
    var compareWith;
    var i2;
    if (!el || typeof selector === "undefined") return false;
    if (typeof selector === "string") {
        if (el.matches) return el.matches(selector);
        if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
        if (el.msMatchesSelector) return el.msMatchesSelector(selector);
        compareWith = $(selector);
        for(i2 = 0; i2 < compareWith.length; i2 += 1){
            if (compareWith[i2] === el) return true;
        }
        return false;
    }
    if (selector === document2) {
        return el === document2;
    }
    if (selector === window2) {
        return el === window2;
    }
    if (selector.nodeType || selector instanceof Dom7) {
        compareWith = selector.nodeType ? [
            selector
        ] : selector;
        for(i2 = 0; i2 < compareWith.length; i2 += 1){
            if (compareWith[i2] === el) return true;
        }
        return false;
    }
    return false;
}
function index() {
    var child = this[0];
    var i2;
    if (child) {
        i2 = 0;
        while((child = child.previousSibling) !== null){
            if (child.nodeType === 1) i2 += 1;
        }
        return i2;
    }
    return void 0;
}
function eq2(index2) {
    if (typeof index2 === "undefined") return this;
    var length = this.length;
    if (index2 > length - 1) {
        return $([]);
    }
    if (index2 < 0) {
        var returnIndex = length + index2;
        if (returnIndex < 0) return $([]);
        return $([
            this[returnIndex]
        ]);
    }
    return $([
        this[index2]
    ]);
}
function append() {
    var newChild;
    var document2 = getDocument();
    for(var k = 0; k < arguments.length; k += 1){
        newChild = k < 0 || arguments.length <= k ? void 0 : arguments[k];
        for(var i2 = 0; i2 < this.length; i2 += 1){
            if (typeof newChild === "string") {
                var tempDiv = document2.createElement("div");
                tempDiv.innerHTML = newChild;
                while(tempDiv.firstChild){
                    this[i2].appendChild(tempDiv.firstChild);
                }
            } else if (newChild instanceof Dom7) {
                for(var j = 0; j < newChild.length; j += 1){
                    this[i2].appendChild(newChild[j]);
                }
            } else {
                this[i2].appendChild(newChild);
            }
        }
    }
    return this;
}
function prepend(newChild) {
    var document2 = getDocument();
    var i2;
    var j;
    for(i2 = 0; i2 < this.length; i2 += 1){
        if (typeof newChild === "string") {
            var tempDiv = document2.createElement("div");
            tempDiv.innerHTML = newChild;
            for(j = tempDiv.childNodes.length - 1; j >= 0; j -= 1){
                this[i2].insertBefore(tempDiv.childNodes[j], this[i2].childNodes[0]);
            }
        } else if (newChild instanceof Dom7) {
            for(j = 0; j < newChild.length; j += 1){
                this[i2].insertBefore(newChild[j], this[i2].childNodes[0]);
            }
        } else {
            this[i2].insertBefore(newChild, this[i2].childNodes[0]);
        }
    }
    return this;
}
function next(selector) {
    if (this.length > 0) {
        if (selector) {
            if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
                return $([
                    this[0].nextElementSibling
                ]);
            }
            return $([]);
        }
        if (this[0].nextElementSibling) return $([
            this[0].nextElementSibling
        ]);
        return $([]);
    }
    return $([]);
}
function nextAll(selector) {
    var nextEls = [];
    var el = this[0];
    if (!el) return $([]);
    while(el.nextElementSibling){
        var _next = el.nextElementSibling;
        if (selector) {
            if ($(_next).is(selector)) nextEls.push(_next);
        } else nextEls.push(_next);
        el = _next;
    }
    return $(nextEls);
}
function prev(selector) {
    if (this.length > 0) {
        var el = this[0];
        if (selector) {
            if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
                return $([
                    el.previousElementSibling
                ]);
            }
            return $([]);
        }
        if (el.previousElementSibling) return $([
            el.previousElementSibling
        ]);
        return $([]);
    }
    return $([]);
}
function prevAll(selector) {
    var prevEls = [];
    var el = this[0];
    if (!el) return $([]);
    while(el.previousElementSibling){
        var _prev = el.previousElementSibling;
        if (selector) {
            if ($(_prev).is(selector)) prevEls.push(_prev);
        } else prevEls.push(_prev);
        el = _prev;
    }
    return $(prevEls);
}
function parent(selector) {
    var parents2 = [];
    for(var i2 = 0; i2 < this.length; i2 += 1){
        if (this[i2].parentNode !== null) {
            if (selector) {
                if ($(this[i2].parentNode).is(selector)) parents2.push(this[i2].parentNode);
            } else {
                parents2.push(this[i2].parentNode);
            }
        }
    }
    return $(parents2);
}
function parents(selector) {
    var parents2 = [];
    for(var i2 = 0; i2 < this.length; i2 += 1){
        var _parent = this[i2].parentNode;
        while(_parent){
            if (selector) {
                if ($(_parent).is(selector)) parents2.push(_parent);
            } else {
                parents2.push(_parent);
            }
            _parent = _parent.parentNode;
        }
    }
    return $(parents2);
}
function closest(selector) {
    var closest2 = this;
    if (typeof selector === "undefined") {
        return $([]);
    }
    if (!closest2.is(selector)) {
        closest2 = closest2.parents(selector).eq(0);
    }
    return closest2;
}
function find(selector) {
    var foundElements = [];
    for(var i2 = 0; i2 < this.length; i2 += 1){
        var found = this[i2].querySelectorAll(selector);
        for(var j = 0; j < found.length; j += 1){
            foundElements.push(found[j]);
        }
    }
    return $(foundElements);
}
function children(selector) {
    var children2 = [];
    for(var i2 = 0; i2 < this.length; i2 += 1){
        var childNodes = this[i2].children;
        for(var j = 0; j < childNodes.length; j += 1){
            if (!selector || $(childNodes[j]).is(selector)) {
                children2.push(childNodes[j]);
            }
        }
    }
    return $(children2);
}
function remove2() {
    for(var i2 = 0; i2 < this.length; i2 += 1){
        if (this[i2].parentNode) this[i2].parentNode.removeChild(this[i2]);
    }
    return this;
}
var noTrigger = "resize scroll".split(" ");
function shortcut(name) {
    function eventHandler() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        if (typeof args[0] === "undefined") {
            for(var i2 = 0; i2 < this.length; i2 += 1){
                if (noTrigger.indexOf(name) < 0) {
                    if (name in this[i2]) this[i2][name]();
                    else {
                        $(this[i2]).trigger(name);
                    }
                }
            }
            return this;
        }
        return this.on.apply(this, [
            name
        ].concat(args));
    }
    return eventHandler;
}
var click = shortcut("click");
var blur = shortcut("blur");
var focus = shortcut("focus");
var focusin = shortcut("focusin");
var focusout = shortcut("focusout");
var keyup = shortcut("keyup");
var keydown = shortcut("keydown");
var keypress = shortcut("keypress");
var submit = shortcut("submit");
var change = shortcut("change");
var mousedown = shortcut("mousedown");
var mousemove = shortcut("mousemove");
var mouseup = shortcut("mouseup");
var mouseenter = shortcut("mouseenter");
var mouseleave = shortcut("mouseleave");
var mouseout = shortcut("mouseout");
var mouseover = shortcut("mouseover");
var touchstart = shortcut("touchstart");
var touchend = shortcut("touchend");
var touchmove = shortcut("touchmove");
var resize = shortcut("resize");
var scroll = shortcut("scroll");
// node_modules/swiper/esm/utils/dom.js
var Methods = {
    addClass,
    removeClass,
    hasClass,
    toggleClass,
    attr,
    removeAttr,
    transform,
    transition,
    on,
    off,
    trigger,
    transitionEnd,
    outerWidth,
    outerHeight,
    styles: styles2,
    offset,
    css,
    each,
    html,
    text,
    is,
    index,
    eq: eq2,
    append,
    prepend,
    next,
    nextAll,
    prev,
    prevAll,
    parent,
    parents,
    closest,
    find,
    children,
    filter: filter2,
    remove: remove2
};
Object.keys(Methods).forEach(function(methodName) {
    Object.defineProperty($.fn, methodName, {
        value: Methods[methodName],
        writable: true
    });
});
var dom_default = $;
// node_modules/swiper/esm/utils/utils.js
function deleteProps(obj) {
    var object2 = obj;
    Object.keys(object2).forEach(function(key) {
        try {
            object2[key] = null;
        } catch (e) {}
        try {
            delete object2[key];
        } catch (e) {}
    });
}
function nextTick4(callback, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return setTimeout(callback, delay);
}
function now2() {
    return Date.now();
}
function getComputedStyle2(el) {
    var window2 = getWindow();
    var style;
    if (window2.getComputedStyle) {
        style = window2.getComputedStyle(el, null);
    }
    if (!style && el.currentStyle) {
        style = el.currentStyle;
    }
    if (!style) {
        style = el.style;
    }
    return style;
}
function getTranslate(el, axis) {
    if (axis === void 0) {
        axis = "x";
    }
    var window2 = getWindow();
    var matrix;
    var curTransform;
    var transformMatrix;
    var curStyle = getComputedStyle2(el, null);
    if (window2.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;
        if (curTransform.split(",").length > 6) {
            curTransform = curTransform.split(", ").map(function(a) {
                return a.replace(",", ".");
            }).join(", ");
        }
        transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
    } else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
        matrix = transformMatrix.toString().split(",");
    }
    if (axis === "x") {
        if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m41;
        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
        else curTransform = parseFloat(matrix[4]);
    }
    if (axis === "y") {
        if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m42;
        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
        else curTransform = parseFloat(matrix[5]);
    }
    return curTransform || 0;
}
function isObject5(o) {
    return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
}
function isNode(node) {
    if (typeof window !== "undefined") {
        return node instanceof HTMLElement;
    }
    return node && (node.nodeType === 1 || node.nodeType === 11);
}
function extend2() {
    var to = Object(arguments.length <= 0 ? void 0 : arguments[0]);
    var noExtend = [
        "__proto__",
        "constructor",
        "prototype"
    ];
    for(var i2 = 1; i2 < arguments.length; i2 += 1){
        var nextSource = i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2];
        if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
            var keysArray = Object.keys(Object(nextSource)).filter(function(key) {
                return noExtend.indexOf(key) < 0;
            });
            for(var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1){
                var nextKey = keysArray[nextIndex];
                var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                if (desc !== void 0 && desc.enumerable) {
                    if (isObject5(to[nextKey]) && isObject5(nextSource[nextKey])) {
                        if (nextSource[nextKey].__swiper__) {
                            to[nextKey] = nextSource[nextKey];
                        } else {
                            extend2(to[nextKey], nextSource[nextKey]);
                        }
                    } else if (!isObject5(to[nextKey]) && isObject5(nextSource[nextKey])) {
                        to[nextKey] = {};
                        if (nextSource[nextKey].__swiper__) {
                            to[nextKey] = nextSource[nextKey];
                        } else {
                            extend2(to[nextKey], nextSource[nextKey]);
                        }
                    } else {
                        to[nextKey] = nextSource[nextKey];
                    }
                }
            }
        }
    }
    return to;
}
function bindModuleMethods(instance, obj) {
    Object.keys(obj).forEach(function(key) {
        if (isObject5(obj[key])) {
            Object.keys(obj[key]).forEach(function(subKey) {
                if (typeof obj[key][subKey] === "function") {
                    obj[key][subKey] = obj[key][subKey].bind(instance);
                }
            });
        }
        instance[key] = obj[key];
    });
}
function classesToSelector(classes) {
    if (classes === void 0) {
        classes = "";
    }
    return "." + classes.trim().replace(/([\.:\/])/g, "\\$1").replace(/ /g, ".");
}
function createElementIfNotDefined($container, params, createElements, checkProps) {
    var document2 = getDocument();
    if (createElements) {
        Object.keys(checkProps).forEach(function(key) {
            if (!params[key] && params.auto === true) {
                var element = document2.createElement("div");
                element.className = checkProps[key];
                $container.append(element);
                params[key] = element;
            }
        });
    }
    return params;
}
// node_modules/swiper/esm/utils/get-support.js
var support2;
function calcSupport() {
    var window2 = getWindow();
    var document2 = getDocument();
    return {
        touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch),
        pointerEvents: !!window2.PointerEvent && "maxTouchPoints" in window2.navigator && window2.navigator.maxTouchPoints >= 0,
        observer: function checkObserver() {
            return "MutationObserver" in window2 || "WebkitMutationObserver" in window2;
        }(),
        passiveListener: function checkPassiveListener() {
            var supportsPassive2 = false;
            try {
                var opts = Object.defineProperty({}, "passive", {
                    // eslint-disable-next-line
                    get: function get2() {
                        supportsPassive2 = true;
                    }
                });
                window2.addEventListener("testPassiveListener", null, opts);
            } catch (e) {}
            return supportsPassive2;
        }(),
        gestures: function checkGestures() {
            return "ongesturestart" in window2;
        }()
    };
}
function getSupport() {
    if (!support2) {
        support2 = calcSupport();
    }
    return support2;
}
// node_modules/swiper/esm/utils/get-device.js
var device;
function calcDevice(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, userAgent = _ref.userAgent;
    var support3 = getSupport();
    var window2 = getWindow();
    var platform2 = window2.navigator.platform;
    var ua = userAgent || window2.navigator.userAgent;
    var device2 = {
        ios: false,
        android: false
    };
    var screenWidth = window2.screen.width;
    var screenHeight = window2.screen.height;
    var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
    var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
    var windows = platform2 === "Win32";
    var macos = platform2 === "MacIntel";
    var iPadScreens = [
        "1024x1366",
        "1366x1024",
        "834x1194",
        "1194x834",
        "834x1112",
        "1112x834",
        "768x1024",
        "1024x768",
        "820x1180",
        "1180x820",
        "810x1080",
        "1080x810"
    ];
    if (!ipad && macos && support3.touch && iPadScreens.indexOf(screenWidth + "x" + screenHeight) >= 0) {
        ipad = ua.match(/(Version)\/([\d.]+)/);
        if (!ipad) ipad = [
            0,
            1,
            "13_0_0"
        ];
        macos = false;
    }
    if (android && !windows) {
        device2.os = "android";
        device2.android = true;
    }
    if (ipad || iphone || ipod) {
        device2.os = "ios";
        device2.ios = true;
    }
    return device2;
}
function getDevice(overrides) {
    if (overrides === void 0) {
        overrides = {};
    }
    if (!device) {
        device = calcDevice(overrides);
    }
    return device;
}
// node_modules/swiper/esm/utils/get-browser.js
var browser;
function calcBrowser() {
    var window2 = getWindow();
    function isSafari() {
        var ua = window2.navigator.userAgent.toLowerCase();
        return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
    }
    return {
        isEdge: !!window2.navigator.userAgent.match(/Edge/g),
        isSafari: isSafari(),
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent)
    };
}
function getBrowser() {
    if (!browser) {
        browser = calcBrowser();
    }
    return browser;
}
// node_modules/swiper/esm/modules/resize/resize.js
var supportsResizeObserver = function supportsResizeObserver2() {
    var window2 = getWindow();
    return typeof window2.ResizeObserver !== "undefined";
};
var resize_default = {
    name: "resize",
    create: function create2() {
        var swiper = this;
        extend2(swiper, {
            resize: {
                observer: null,
                createObserver: function createObserver() {
                    if (!swiper || swiper.destroyed || !swiper.initialized) return;
                    swiper.resize.observer = new ResizeObserver(function(entries) {
                        var width = swiper.width, height = swiper.height;
                        var newWidth = width;
                        var newHeight = height;
                        entries.forEach(function(_ref) {
                            var contentBoxSize = _ref.contentBoxSize, contentRect = _ref.contentRect, target = _ref.target;
                            if (target && target !== swiper.el) return;
                            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                        });
                        if (newWidth !== width || newHeight !== height) {
                            swiper.resize.resizeHandler();
                        }
                    });
                    swiper.resize.observer.observe(swiper.el);
                },
                removeObserver: function removeObserver() {
                    if (swiper.resize.observer && swiper.resize.observer.unobserve && swiper.el) {
                        swiper.resize.observer.unobserve(swiper.el);
                        swiper.resize.observer = null;
                    }
                },
                resizeHandler: function resizeHandler() {
                    if (!swiper || swiper.destroyed || !swiper.initialized) return;
                    swiper.emit("beforeResize");
                    swiper.emit("resize");
                },
                orientationChangeHandler: function orientationChangeHandler() {
                    if (!swiper || swiper.destroyed || !swiper.initialized) return;
                    swiper.emit("orientationchange");
                }
            }
        });
    },
    on: {
        init: function init2(swiper) {
            var window2 = getWindow();
            if (swiper.params.resizeObserver && supportsResizeObserver()) {
                swiper.resize.createObserver();
                return;
            }
            window2.addEventListener("resize", swiper.resize.resizeHandler);
            window2.addEventListener("orientationchange", swiper.resize.orientationChangeHandler);
        },
        destroy: function destroy(swiper) {
            var window2 = getWindow();
            swiper.resize.removeObserver();
            window2.removeEventListener("resize", swiper.resize.resizeHandler);
            window2.removeEventListener("orientationchange", swiper.resize.orientationChangeHandler);
        }
    }
};
// node_modules/swiper/esm/modules/observer/observer.js
function _extends2() {
    _extends2 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends2.apply(this, arguments);
}
var Observer = {
    attach: function attach(target, options3) {
        if (options3 === void 0) {
            options3 = {};
        }
        var window2 = getWindow();
        var swiper = this;
        var ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
        var observer = new ObserverFunc(function(mutations) {
            if (mutations.length === 1) {
                swiper.emit("observerUpdate", mutations[0]);
                return;
            }
            var observerUpdate4 = function observerUpdate5() {
                swiper.emit("observerUpdate", mutations[0]);
            };
            if (window2.requestAnimationFrame) {
                window2.requestAnimationFrame(observerUpdate4);
            } else {
                window2.setTimeout(observerUpdate4, 0);
            }
        });
        observer.observe(target, {
            attributes: typeof options3.attributes === "undefined" ? true : options3.attributes,
            childList: typeof options3.childList === "undefined" ? true : options3.childList,
            characterData: typeof options3.characterData === "undefined" ? true : options3.characterData
        });
        swiper.observer.observers.push(observer);
    },
    init: function init3() {
        var swiper = this;
        if (!swiper.support.observer || !swiper.params.observer) return;
        if (swiper.params.observeParents) {
            var containerParents = swiper.$el.parents();
            for(var i2 = 0; i2 < containerParents.length; i2 += 1){
                swiper.observer.attach(containerParents[i2]);
            }
        }
        swiper.observer.attach(swiper.$el[0], {
            childList: swiper.params.observeSlideChildren
        });
        swiper.observer.attach(swiper.$wrapperEl[0], {
            attributes: false
        });
    },
    destroy: function destroy2() {
        var swiper = this;
        swiper.observer.observers.forEach(function(observer) {
            observer.disconnect();
        });
        swiper.observer.observers = [];
    }
};
var observer_default = {
    name: "observer",
    params: {
        observer: false,
        observeParents: false,
        observeSlideChildren: false
    },
    create: function create3() {
        var swiper = this;
        bindModuleMethods(swiper, {
            observer: _extends2({}, Observer, {
                observers: []
            })
        });
    },
    on: {
        init: function init4(swiper) {
            swiper.observer.init();
        },
        destroy: function destroy3(swiper) {
            swiper.observer.destroy();
        }
    }
};
// node_modules/swiper/esm/components/core/modular.js
var modular_default = {
    useParams: function useParams(instanceParams) {
        var instance = this;
        if (!instance.modules) return;
        Object.keys(instance.modules).forEach(function(moduleName) {
            var module2 = instance.modules[moduleName];
            if (module2.params) {
                extend2(instanceParams, module2.params);
            }
        });
    },
    useModules: function useModules(modulesParams) {
        if (modulesParams === void 0) {
            modulesParams = {};
        }
        var instance = this;
        if (!instance.modules) return;
        Object.keys(instance.modules).forEach(function(moduleName) {
            var module2 = instance.modules[moduleName];
            var moduleParams = modulesParams[moduleName] || {};
            if (module2.on && instance.on) {
                Object.keys(module2.on).forEach(function(moduleEventName) {
                    instance.on(moduleEventName, module2.on[moduleEventName]);
                });
            }
            if (module2.create) {
                module2.create.bind(instance)(moduleParams);
            }
        });
    }
};
// node_modules/swiper/esm/components/core/events-emitter.js
var events_emitter_default = {
    on: function on2(events, handler, priority) {
        var self2 = this;
        if (typeof handler !== "function") return self2;
        var method = priority ? "unshift" : "push";
        events.split(" ").forEach(function(event2) {
            if (!self2.eventsListeners[event2]) self2.eventsListeners[event2] = [];
            self2.eventsListeners[event2][method](handler);
        });
        return self2;
    },
    once: function once(events, handler, priority) {
        var self2 = this;
        if (typeof handler !== "function") return self2;
        function onceHandler() {
            self2.off(events, onceHandler);
            if (onceHandler.__emitterProxy) {
                delete onceHandler.__emitterProxy;
            }
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            handler.apply(self2, args);
        }
        onceHandler.__emitterProxy = handler;
        return self2.on(events, onceHandler, priority);
    },
    onAny: function onAny(handler, priority) {
        var self2 = this;
        if (typeof handler !== "function") return self2;
        var method = priority ? "unshift" : "push";
        if (self2.eventsAnyListeners.indexOf(handler) < 0) {
            self2.eventsAnyListeners[method](handler);
        }
        return self2;
    },
    offAny: function offAny(handler) {
        var self2 = this;
        if (!self2.eventsAnyListeners) return self2;
        var index2 = self2.eventsAnyListeners.indexOf(handler);
        if (index2 >= 0) {
            self2.eventsAnyListeners.splice(index2, 1);
        }
        return self2;
    },
    off: function off2(events, handler) {
        var self2 = this;
        if (!self2.eventsListeners) return self2;
        events.split(" ").forEach(function(event2) {
            if (typeof handler === "undefined") {
                self2.eventsListeners[event2] = [];
            } else if (self2.eventsListeners[event2]) {
                self2.eventsListeners[event2].forEach(function(eventHandler, index2) {
                    if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
                        self2.eventsListeners[event2].splice(index2, 1);
                    }
                });
            }
        });
        return self2;
    },
    emit: function emit() {
        var self2 = this;
        if (!self2.eventsListeners) return self2;
        var events;
        var data;
        var context;
        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){
            args[_key2] = arguments[_key2];
        }
        if (typeof args[0] === "string" || Array.isArray(args[0])) {
            events = args[0];
            data = args.slice(1, args.length);
            context = self2;
        } else {
            events = args[0].events;
            data = args[0].data;
            context = args[0].context || self2;
        }
        data.unshift(context);
        var eventsArray = Array.isArray(events) ? events : events.split(" ");
        eventsArray.forEach(function(event2) {
            if (self2.eventsAnyListeners && self2.eventsAnyListeners.length) {
                self2.eventsAnyListeners.forEach(function(eventHandler) {
                    eventHandler.apply(context, [
                        event2
                    ].concat(data));
                });
            }
            if (self2.eventsListeners && self2.eventsListeners[event2]) {
                self2.eventsListeners[event2].forEach(function(eventHandler) {
                    eventHandler.apply(context, data);
                });
            }
        });
        return self2;
    }
};
// node_modules/swiper/esm/components/core/update/updateSize.js
function updateSize() {
    var swiper = this;
    var width;
    var height;
    var $el = swiper.$el;
    if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) {
        width = swiper.params.width;
    } else {
        width = $el[0].clientWidth;
    }
    if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) {
        height = swiper.params.height;
    } else {
        height = $el[0].clientHeight;
    }
    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
        return;
    }
    width = width - parseInt($el.css("padding-left") || 0, 10) - parseInt($el.css("padding-right") || 0, 10);
    height = height - parseInt($el.css("padding-top") || 0, 10) - parseInt($el.css("padding-bottom") || 0, 10);
    if (Number.isNaN(width)) width = 0;
    if (Number.isNaN(height)) height = 0;
    extend2(swiper, {
        width,
        height,
        size: swiper.isHorizontal() ? width : height
    });
}
// node_modules/swiper/esm/components/core/update/updateSlides.js
function updateSlides() {
    var swiper = this;
    function getDirectionLabel(property) {
        if (swiper.isHorizontal()) {
            return property;
        }
        return ({
            "width": "height",
            "margin-top": "margin-left",
            "margin-bottom ": "margin-right",
            "margin-left": "margin-top",
            "margin-right": "margin-bottom",
            "padding-left": "padding-top",
            "padding-right": "padding-bottom",
            "marginRight": "marginBottom"
        })[property];
    }
    function getDirectionPropertyValue(node, label) {
        return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
    }
    var params = swiper.params;
    var $wrapperEl = swiper.$wrapperEl, swiperSize = swiper.size, rtl = swiper.rtlTranslate, wrongRTL = swiper.wrongRTL;
    var isVirtual = swiper.virtual && params.virtual.enabled;
    var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
    var slides = $wrapperEl.children("." + swiper.params.slideClass);
    var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
    var snapGrid = [];
    var slidesGrid = [];
    var slidesSizesGrid = [];
    var offsetBefore = params.slidesOffsetBefore;
    if (typeof offsetBefore === "function") {
        offsetBefore = params.slidesOffsetBefore.call(swiper);
    }
    var offsetAfter = params.slidesOffsetAfter;
    if (typeof offsetAfter === "function") {
        offsetAfter = params.slidesOffsetAfter.call(swiper);
    }
    var previousSnapGridLength = swiper.snapGrid.length;
    var previousSlidesGridLength = swiper.slidesGrid.length;
    var spaceBetween = params.spaceBetween;
    var slidePosition = -offsetBefore;
    var prevSlideSize = 0;
    var index2 = 0;
    if (typeof swiperSize === "undefined") {
        return;
    }
    if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
        spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
    }
    swiper.virtualSize = -spaceBetween;
    if (rtl) slides.css({
        marginLeft: "",
        marginTop: ""
    });
    else slides.css({
        marginRight: "",
        marginBottom: ""
    });
    var slidesNumberEvenToRows;
    if (params.slidesPerColumn > 1) {
        if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
            slidesNumberEvenToRows = slidesLength;
        } else {
            slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
        }
        if (params.slidesPerView !== "auto" && params.slidesPerColumnFill === "row") {
            slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
        }
    }
    var slideSize;
    var slidesPerColumn = params.slidesPerColumn;
    var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
    var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);
    for(var i2 = 0; i2 < slidesLength; i2 += 1){
        slideSize = 0;
        var slide = slides.eq(i2);
        if (params.slidesPerColumn > 1) {
            var newSlideOrderIndex = void 0;
            var column = void 0;
            var row = void 0;
            if (params.slidesPerColumnFill === "row" && params.slidesPerGroup > 1) {
                var groupIndex = Math.floor(i2 / (params.slidesPerGroup * params.slidesPerColumn));
                var slideIndexInGroup = i2 - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
                var columnsInGroup = groupIndex === 0 ? params.slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
                row = Math.floor(slideIndexInGroup / columnsInGroup);
                column = slideIndexInGroup - row * columnsInGroup + groupIndex * params.slidesPerGroup;
                newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
                slide.css({
                    "-webkit-box-ordinal-group": newSlideOrderIndex,
                    "-moz-box-ordinal-group": newSlideOrderIndex,
                    "-ms-flex-order": newSlideOrderIndex,
                    "-webkit-order": newSlideOrderIndex,
                    order: newSlideOrderIndex
                });
            } else if (params.slidesPerColumnFill === "column") {
                column = Math.floor(i2 / slidesPerColumn);
                row = i2 - column * slidesPerColumn;
                if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {
                    row += 1;
                    if (row >= slidesPerColumn) {
                        row = 0;
                        column += 1;
                    }
                }
            } else {
                row = Math.floor(i2 / slidesPerRow);
                column = i2 - row * slidesPerRow;
            }
            slide.css(getDirectionLabel("margin-top"), row !== 0 ? params.spaceBetween && params.spaceBetween + "px" : "");
        }
        if (slide.css("display") === "none") continue;
        if (params.slidesPerView === "auto") {
            var slideStyles = getComputedStyle(slide[0]);
            var currentTransform = slide[0].style.transform;
            var currentWebKitTransform = slide[0].style.webkitTransform;
            if (currentTransform) {
                slide[0].style.transform = "none";
            }
            if (currentWebKitTransform) {
                slide[0].style.webkitTransform = "none";
            }
            if (params.roundLengths) {
                slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
            } else {
                var width = getDirectionPropertyValue(slideStyles, "width");
                var paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
                var paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
                var marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
                var marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
                var boxSizing = slideStyles.getPropertyValue("box-sizing");
                if (boxSizing && boxSizing === "border-box") {
                    slideSize = width + marginLeft + marginRight;
                } else {
                    var _slide$ = slide[0], clientWidth = _slide$.clientWidth, offsetWidth = _slide$.offsetWidth;
                    slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                }
            }
            if (currentTransform) {
                slide[0].style.transform = currentTransform;
            }
            if (currentWebKitTransform) {
                slide[0].style.webkitTransform = currentWebKitTransform;
            }
            if (params.roundLengths) slideSize = Math.floor(slideSize);
        } else {
            slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
            if (params.roundLengths) slideSize = Math.floor(slideSize);
            if (slides[i2]) {
                slides[i2].style[getDirectionLabel("width")] = slideSize + "px";
            }
        }
        if (slides[i2]) {
            slides[i2].swiperSlideSize = slideSize;
        }
        slidesSizesGrid.push(slideSize);
        if (params.centeredSlides) {
            slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
            if (prevSlideSize === 0 && i2 !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
            if (i2 === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
            if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;
            if (params.roundLengths) slidePosition = Math.floor(slidePosition);
            if (index2 % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
            slidesGrid.push(slidePosition);
        } else {
            if (params.roundLengths) slidePosition = Math.floor(slidePosition);
            if ((index2 - Math.min(swiper.params.slidesPerGroupSkip, index2)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
            slidesGrid.push(slidePosition);
            slidePosition = slidePosition + slideSize + spaceBetween;
        }
        swiper.virtualSize += slideSize + spaceBetween;
        prevSlideSize = slideSize;
        index2 += 1;
    }
    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
    var newSlidesGrid;
    if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
        $wrapperEl.css({
            width: swiper.virtualSize + params.spaceBetween + "px"
        });
    }
    if (params.setWrapperSize) {
        var _$wrapperEl$css;
        $wrapperEl.css((_$wrapperEl$css = {}, _$wrapperEl$css[getDirectionLabel("width")] = swiper.virtualSize + params.spaceBetween + "px", _$wrapperEl$css));
    }
    if (params.slidesPerColumn > 1) {
        var _$wrapperEl$css2;
        swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
        swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
        $wrapperEl.css((_$wrapperEl$css2 = {}, _$wrapperEl$css2[getDirectionLabel("width")] = swiper.virtualSize + params.spaceBetween + "px", _$wrapperEl$css2));
        if (params.centeredSlides) {
            newSlidesGrid = [];
            for(var _i = 0; _i < snapGrid.length; _i += 1){
                var slidesGridItem = snapGrid[_i];
                if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                if (snapGrid[_i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
            }
            snapGrid = newSlidesGrid;
        }
    }
    if (!params.centeredSlides) {
        newSlidesGrid = [];
        for(var _i2 = 0; _i2 < snapGrid.length; _i2 += 1){
            var _slidesGridItem = snapGrid[_i2];
            if (params.roundLengths) _slidesGridItem = Math.floor(_slidesGridItem);
            if (snapGrid[_i2] <= swiper.virtualSize - swiperSize) {
                newSlidesGrid.push(_slidesGridItem);
            }
        }
        snapGrid = newSlidesGrid;
        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
            snapGrid.push(swiper.virtualSize - swiperSize);
        }
    }
    if (snapGrid.length === 0) snapGrid = [
        0
    ];
    if (params.spaceBetween !== 0) {
        var _slides$filter$css;
        var key = swiper.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
        slides.filter(function(_, slideIndex) {
            if (!params.cssMode) return true;
            if (slideIndex === slides.length - 1) {
                return false;
            }
            return true;
        }).css((_slides$filter$css = {}, _slides$filter$css[key] = spaceBetween + "px", _slides$filter$css));
    }
    if (params.centeredSlides && params.centeredSlidesBounds) {
        var allSlidesSize = 0;
        slidesSizesGrid.forEach(function(slideSizeValue) {
            allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;
        var maxSnap = allSlidesSize - swiperSize;
        snapGrid = snapGrid.map(function(snap) {
            if (snap < 0) return -offsetBefore;
            if (snap > maxSnap) return maxSnap + offsetAfter;
            return snap;
        });
    }
    if (params.centerInsufficientSlides) {
        var _allSlidesSize = 0;
        slidesSizesGrid.forEach(function(slideSizeValue) {
            _allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        _allSlidesSize -= params.spaceBetween;
        if (_allSlidesSize < swiperSize) {
            var allSlidesOffset = (swiperSize - _allSlidesSize) / 2;
            snapGrid.forEach(function(snap, snapIndex) {
                snapGrid[snapIndex] = snap - allSlidesOffset;
            });
            slidesGrid.forEach(function(snap, snapIndex) {
                slidesGrid[snapIndex] = snap + allSlidesOffset;
            });
        }
    }
    extend2(swiper, {
        slides,
        snapGrid,
        slidesGrid,
        slidesSizesGrid
    });
    if (slidesLength !== previousSlidesLength) {
        swiper.emit("slidesLengthChange");
    }
    if (snapGrid.length !== previousSnapGridLength) {
        if (swiper.params.watchOverflow) swiper.checkOverflow();
        swiper.emit("snapGridLengthChange");
    }
    if (slidesGrid.length !== previousSlidesGridLength) {
        swiper.emit("slidesGridLengthChange");
    }
    if (params.watchSlidesProgress || params.watchSlidesVisibility) {
        swiper.updateSlidesOffset();
    }
}
// node_modules/swiper/esm/components/core/update/updateAutoHeight.js
function updateAutoHeight(speed) {
    var swiper = this;
    var activeSlides = [];
    var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    var newHeight = 0;
    var i2;
    if (typeof speed === "number") {
        swiper.setTransition(speed);
    } else if (speed === true) {
        swiper.setTransition(swiper.params.speed);
    }
    var getSlideByIndex = function getSlideByIndex2(index3) {
        if (isVirtual) {
            return swiper.slides.filter(function(el) {
                return parseInt(el.getAttribute("data-swiper-slide-index"), 10) === index3;
            })[0];
        }
        return swiper.slides.eq(index3)[0];
    };
    if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) {
        if (swiper.params.centeredSlides) {
            swiper.visibleSlides.each(function(slide) {
                activeSlides.push(slide);
            });
        } else {
            for(i2 = 0; i2 < Math.ceil(swiper.params.slidesPerView); i2 += 1){
                var index2 = swiper.activeIndex + i2;
                if (index2 > swiper.slides.length && !isVirtual) break;
                activeSlides.push(getSlideByIndex(index2));
            }
        }
    } else {
        activeSlides.push(getSlideByIndex(swiper.activeIndex));
    }
    for(i2 = 0; i2 < activeSlides.length; i2 += 1){
        if (typeof activeSlides[i2] !== "undefined") {
            var height = activeSlides[i2].offsetHeight;
            newHeight = height > newHeight ? height : newHeight;
        }
    }
    if (newHeight) swiper.$wrapperEl.css("height", newHeight + "px");
}
// node_modules/swiper/esm/components/core/update/updateSlidesOffset.js
function updateSlidesOffset() {
    var swiper = this;
    var slides = swiper.slides;
    for(var i2 = 0; i2 < slides.length; i2 += 1){
        slides[i2].swiperSlideOffset = swiper.isHorizontal() ? slides[i2].offsetLeft : slides[i2].offsetTop;
    }
}
// node_modules/swiper/esm/components/core/update/updateSlidesProgress.js
function updateSlidesProgress(translate) {
    if (translate === void 0) {
        translate = this && this.translate || 0;
    }
    var swiper = this;
    var params = swiper.params;
    var slides = swiper.slides, rtl = swiper.rtlTranslate;
    if (slides.length === 0) return;
    if (typeof slides[0].swiperSlideOffset === "undefined") swiper.updateSlidesOffset();
    var offsetCenter = -translate;
    if (rtl) offsetCenter = translate;
    slides.removeClass(params.slideVisibleClass);
    swiper.visibleSlidesIndexes = [];
    swiper.visibleSlides = [];
    for(var i2 = 0; i2 < slides.length; i2 += 1){
        var slide = slides[i2];
        var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);
        if (params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) {
            var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
            var slideAfter = slideBefore + swiper.slidesSizesGrid[i2];
            var isVisible2 = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
            if (isVisible2) {
                swiper.visibleSlides.push(slide);
                swiper.visibleSlidesIndexes.push(i2);
                slides.eq(i2).addClass(params.slideVisibleClass);
            }
        }
        slide.progress = rtl ? -slideProgress : slideProgress;
    }
    swiper.visibleSlides = dom_default(swiper.visibleSlides);
}
// node_modules/swiper/esm/components/core/update/updateProgress.js
function updateProgress(translate) {
    var swiper = this;
    if (typeof translate === "undefined") {
        var multiplier = swiper.rtlTranslate ? -1 : 1;
        translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
    }
    var params = swiper.params;
    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    var progress = swiper.progress, isBeginning = swiper.isBeginning, isEnd = swiper.isEnd;
    var wasBeginning = isBeginning;
    var wasEnd = isEnd;
    if (translatesDiff === 0) {
        progress = 0;
        isBeginning = true;
        isEnd = true;
    } else {
        progress = (translate - swiper.minTranslate()) / translatesDiff;
        isBeginning = progress <= 0;
        isEnd = progress >= 1;
    }
    extend2(swiper, {
        progress,
        isBeginning,
        isEnd
    });
    if (params.watchSlidesProgress || params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
    if (isBeginning && !wasBeginning) {
        swiper.emit("reachBeginning toEdge");
    }
    if (isEnd && !wasEnd) {
        swiper.emit("reachEnd toEdge");
    }
    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
        swiper.emit("fromEdge");
    }
    swiper.emit("progress", progress);
}
// node_modules/swiper/esm/components/core/update/updateSlidesClasses.js
function updateSlidesClasses() {
    var swiper = this;
    var slides = swiper.slides, params = swiper.params, $wrapperEl = swiper.$wrapperEl, activeIndex = swiper.activeIndex, realIndex = swiper.realIndex;
    var isVirtual = swiper.virtual && params.virtual.enabled;
    slides.removeClass(params.slideActiveClass + " " + params.slideNextClass + " " + params.slidePrevClass + " " + params.slideDuplicateActiveClass + " " + params.slideDuplicateNextClass + " " + params.slideDuplicatePrevClass);
    var activeSlide;
    if (isVirtual) {
        activeSlide = swiper.$wrapperEl.find("." + params.slideClass + '[data-swiper-slide-index="' + activeIndex + '"]');
    } else {
        activeSlide = slides.eq(activeIndex);
    }
    activeSlide.addClass(params.slideActiveClass);
    if (params.loop) {
        if (activeSlide.hasClass(params.slideDuplicateClass)) {
            $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ')[data-swiper-slide-index="' + realIndex + '"]').addClass(params.slideDuplicateActiveClass);
        } else {
            $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + '[data-swiper-slide-index="' + realIndex + '"]').addClass(params.slideDuplicateActiveClass);
        }
    }
    var nextSlide = activeSlide.nextAll("." + params.slideClass).eq(0).addClass(params.slideNextClass);
    if (params.loop && nextSlide.length === 0) {
        nextSlide = slides.eq(0);
        nextSlide.addClass(params.slideNextClass);
    }
    var prevSlide = activeSlide.prevAll("." + params.slideClass).eq(0).addClass(params.slidePrevClass);
    if (params.loop && prevSlide.length === 0) {
        prevSlide = slides.eq(-1);
        prevSlide.addClass(params.slidePrevClass);
    }
    if (params.loop) {
        if (nextSlide.hasClass(params.slideDuplicateClass)) {
            $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ')[data-swiper-slide-index="' + nextSlide.attr("data-swiper-slide-index") + '"]').addClass(params.slideDuplicateNextClass);
        } else {
            $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + '[data-swiper-slide-index="' + nextSlide.attr("data-swiper-slide-index") + '"]').addClass(params.slideDuplicateNextClass);
        }
        if (prevSlide.hasClass(params.slideDuplicateClass)) {
            $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ')[data-swiper-slide-index="' + prevSlide.attr("data-swiper-slide-index") + '"]').addClass(params.slideDuplicatePrevClass);
        } else {
            $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + '[data-swiper-slide-index="' + prevSlide.attr("data-swiper-slide-index") + '"]').addClass(params.slideDuplicatePrevClass);
        }
    }
    swiper.emitSlidesClasses();
}
// node_modules/swiper/esm/components/core/update/updateActiveIndex.js
function updateActiveIndex(newActiveIndex) {
    var swiper = this;
    var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    var slidesGrid = swiper.slidesGrid, snapGrid = swiper.snapGrid, params = swiper.params, previousIndex = swiper.activeIndex, previousRealIndex = swiper.realIndex, previousSnapIndex = swiper.snapIndex;
    var activeIndex = newActiveIndex;
    var snapIndex;
    if (typeof activeIndex === "undefined") {
        for(var i2 = 0; i2 < slidesGrid.length; i2 += 1){
            if (typeof slidesGrid[i2 + 1] !== "undefined") {
                if (translate >= slidesGrid[i2] && translate < slidesGrid[i2 + 1] - (slidesGrid[i2 + 1] - slidesGrid[i2]) / 2) {
                    activeIndex = i2;
                } else if (translate >= slidesGrid[i2] && translate < slidesGrid[i2 + 1]) {
                    activeIndex = i2 + 1;
                }
            } else if (translate >= slidesGrid[i2]) {
                activeIndex = i2;
            }
        }
        if (params.normalizeSlideIndex) {
            if (activeIndex < 0 || typeof activeIndex === "undefined") activeIndex = 0;
        }
    }
    if (snapGrid.indexOf(translate) >= 0) {
        snapIndex = snapGrid.indexOf(translate);
    } else {
        var skip = Math.min(params.slidesPerGroupSkip, activeIndex);
        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
    }
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    if (activeIndex === previousIndex) {
        if (snapIndex !== previousSnapIndex) {
            swiper.snapIndex = snapIndex;
            swiper.emit("snapIndexChange");
        }
        return;
    }
    var realIndex = parseInt(swiper.slides.eq(activeIndex).attr("data-swiper-slide-index") || activeIndex, 10);
    extend2(swiper, {
        snapIndex,
        realIndex,
        previousIndex,
        activeIndex
    });
    swiper.emit("activeIndexChange");
    swiper.emit("snapIndexChange");
    if (previousRealIndex !== realIndex) {
        swiper.emit("realIndexChange");
    }
    if (swiper.initialized || swiper.params.runCallbacksOnInit) {
        swiper.emit("slideChange");
    }
}
// node_modules/swiper/esm/components/core/update/updateClickedSlide.js
function updateClickedSlide(e) {
    var swiper = this;
    var params = swiper.params;
    var slide = dom_default(e.target).closest("." + params.slideClass)[0];
    var slideFound = false;
    var slideIndex;
    if (slide) {
        for(var i2 = 0; i2 < swiper.slides.length; i2 += 1){
            if (swiper.slides[i2] === slide) {
                slideFound = true;
                slideIndex = i2;
                break;
            }
        }
    }
    if (slide && slideFound) {
        swiper.clickedSlide = slide;
        if (swiper.virtual && swiper.params.virtual.enabled) {
            swiper.clickedIndex = parseInt(dom_default(slide).attr("data-swiper-slide-index"), 10);
        } else {
            swiper.clickedIndex = slideIndex;
        }
    } else {
        swiper.clickedSlide = void 0;
        swiper.clickedIndex = void 0;
        return;
    }
    if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {
        swiper.slideToClickedSlide();
    }
}
// node_modules/swiper/esm/components/core/update/index.js
var update_default = {
    updateSize,
    updateSlides,
    updateAutoHeight,
    updateSlidesOffset,
    updateSlidesProgress,
    updateProgress,
    updateSlidesClasses,
    updateActiveIndex,
    updateClickedSlide
};
// node_modules/swiper/esm/components/core/translate/getTranslate.js
function getSwiperTranslate(axis) {
    if (axis === void 0) {
        axis = this.isHorizontal() ? "x" : "y";
    }
    var swiper = this;
    var params = swiper.params, rtl = swiper.rtlTranslate, translate = swiper.translate, $wrapperEl = swiper.$wrapperEl;
    if (params.virtualTranslate) {
        return rtl ? -translate : translate;
    }
    if (params.cssMode) {
        return translate;
    }
    var currentTranslate = getTranslate($wrapperEl[0], axis);
    if (rtl) currentTranslate = -currentTranslate;
    return currentTranslate || 0;
}
// node_modules/swiper/esm/components/core/translate/setTranslate.js
function setTranslate(translate, byController) {
    var swiper = this;
    var rtl = swiper.rtlTranslate, params = swiper.params, $wrapperEl = swiper.$wrapperEl, wrapperEl = swiper.wrapperEl, progress = swiper.progress;
    var x = 0;
    var y = 0;
    var z = 0;
    if (swiper.isHorizontal()) {
        x = rtl ? -translate : translate;
    } else {
        y = translate;
    }
    if (params.roundLengths) {
        x = Math.floor(x);
        y = Math.floor(y);
    }
    if (params.cssMode) {
        wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y;
    } else if (!params.virtualTranslate) {
        $wrapperEl.transform("translate3d(" + x + "px, " + y + "px, " + z + "px)");
    }
    swiper.previousTranslate = swiper.translate;
    swiper.translate = swiper.isHorizontal() ? x : y;
    var newProgress;
    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
        newProgress = 0;
    } else {
        newProgress = (translate - swiper.minTranslate()) / translatesDiff;
    }
    if (newProgress !== progress) {
        swiper.updateProgress(translate);
    }
    swiper.emit("setTranslate", swiper.translate, byController);
}
// node_modules/swiper/esm/components/core/translate/minTranslate.js
function minTranslate() {
    return -this.snapGrid[0];
}
// node_modules/swiper/esm/components/core/translate/maxTranslate.js
function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1];
}
// node_modules/swiper/esm/components/core/translate/translateTo.js
function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
    if (translate === void 0) {
        translate = 0;
    }
    if (speed === void 0) {
        speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    if (translateBounds === void 0) {
        translateBounds = true;
    }
    var swiper = this;
    var params = swiper.params, wrapperEl = swiper.wrapperEl;
    if (swiper.animating && params.preventInteractionOnTransition) {
        return false;
    }
    var minTranslate2 = swiper.minTranslate();
    var maxTranslate2 = swiper.maxTranslate();
    var newTranslate;
    if (translateBounds && translate > minTranslate2) newTranslate = minTranslate2;
    else if (translateBounds && translate < maxTranslate2) newTranslate = maxTranslate2;
    else newTranslate = translate;
    swiper.updateProgress(newTranslate);
    if (params.cssMode) {
        var isH = swiper.isHorizontal();
        if (speed === 0) {
            wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
        } else {
            if (wrapperEl.scrollTo) {
                var _wrapperEl$scrollTo;
                wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? "left" : "top"] = -newTranslate, _wrapperEl$scrollTo.behavior = "smooth", _wrapperEl$scrollTo));
            } else {
                wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
            }
        }
        return true;
    }
    if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(newTranslate);
        if (runCallbacks) {
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.emit("transitionEnd");
        }
    } else {
        swiper.setTransition(speed);
        swiper.setTranslate(newTranslate);
        if (runCallbacks) {
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.emit("transitionStart");
        }
        if (!swiper.animating) {
            swiper.animating = true;
            if (!swiper.onTranslateToWrapperTransitionEnd) {
                swiper.onTranslateToWrapperTransitionEnd = function transitionEnd5(e) {
                    if (!swiper || swiper.destroyed) return;
                    if (e.target !== this) return;
                    swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                    swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
                    swiper.onTranslateToWrapperTransitionEnd = null;
                    delete swiper.onTranslateToWrapperTransitionEnd;
                    if (runCallbacks) {
                        swiper.emit("transitionEnd");
                    }
                };
            }
            swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
            swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
        }
    }
    return true;
}
// node_modules/swiper/esm/components/core/translate/index.js
var translate_default = {
    getTranslate: getSwiperTranslate,
    setTranslate,
    minTranslate,
    maxTranslate,
    translateTo
};
// node_modules/swiper/esm/components/core/transition/setTransition.js
function setTransition(duration, byController) {
    var swiper = this;
    if (!swiper.params.cssMode) {
        swiper.$wrapperEl.transition(duration);
    }
    swiper.emit("setTransition", duration, byController);
}
// node_modules/swiper/esm/components/core/transition/transitionStart.js
function transitionStart(runCallbacks, direction) {
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    var swiper = this;
    var activeIndex = swiper.activeIndex, params = swiper.params, previousIndex = swiper.previousIndex;
    if (params.cssMode) return;
    if (params.autoHeight) {
        swiper.updateAutoHeight();
    }
    var dir = direction;
    if (!dir) {
        if (activeIndex > previousIndex) dir = "next";
        else if (activeIndex < previousIndex) dir = "prev";
        else dir = "reset";
    }
    swiper.emit("transitionStart");
    if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === "reset") {
            swiper.emit("slideResetTransitionStart");
            return;
        }
        swiper.emit("slideChangeTransitionStart");
        if (dir === "next") {
            swiper.emit("slideNextTransitionStart");
        } else {
            swiper.emit("slidePrevTransitionStart");
        }
    }
}
// node_modules/swiper/esm/components/core/transition/transitionEnd.js
function transitionEnd2(runCallbacks, direction) {
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    var swiper = this;
    var activeIndex = swiper.activeIndex, previousIndex = swiper.previousIndex, params = swiper.params;
    swiper.animating = false;
    if (params.cssMode) return;
    swiper.setTransition(0);
    var dir = direction;
    if (!dir) {
        if (activeIndex > previousIndex) dir = "next";
        else if (activeIndex < previousIndex) dir = "prev";
        else dir = "reset";
    }
    swiper.emit("transitionEnd");
    if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === "reset") {
            swiper.emit("slideResetTransitionEnd");
            return;
        }
        swiper.emit("slideChangeTransitionEnd");
        if (dir === "next") {
            swiper.emit("slideNextTransitionEnd");
        } else {
            swiper.emit("slidePrevTransitionEnd");
        }
    }
}
// node_modules/swiper/esm/components/core/transition/index.js
var transition_default = {
    setTransition,
    transitionStart,
    transitionEnd: transitionEnd2
};
// node_modules/swiper/esm/components/core/slide/slideTo.js
function slideTo(index2, speed, runCallbacks, internal, initial) {
    if (index2 === void 0) {
        index2 = 0;
    }
    if (speed === void 0) {
        speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    if (typeof index2 !== "number" && typeof index2 !== "string") {
        throw new Error("The 'index' argument cannot have type other than 'number' or 'string'. [" + typeof index2 + "] given.");
    }
    if (typeof index2 === "string") {
        var indexAsNumber = parseInt(index2, 10);
        var isValidNumber = isFinite(indexAsNumber);
        if (!isValidNumber) {
            throw new Error("The passed-in 'index' (string) couldn't be converted to 'number'. [" + index2 + "] given.");
        }
        index2 = indexAsNumber;
    }
    var swiper = this;
    var slideIndex = index2;
    if (slideIndex < 0) slideIndex = 0;
    var params = swiper.params, snapGrid = swiper.snapGrid, slidesGrid = swiper.slidesGrid, previousIndex = swiper.previousIndex, activeIndex = swiper.activeIndex, rtl = swiper.rtlTranslate, wrapperEl = swiper.wrapperEl, enabled = swiper.enabled;
    if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
        return false;
    }
    var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
    var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
        swiper.emit("beforeSlideChangeStart");
    }
    var translate = -snapGrid[snapIndex];
    swiper.updateProgress(translate);
    if (params.normalizeSlideIndex) {
        for(var i2 = 0; i2 < slidesGrid.length; i2 += 1){
            var normalizedTranslate = -Math.floor(translate * 100);
            var normalizedGird = Math.floor(slidesGrid[i2] * 100);
            var normalizedGridNext = Math.floor(slidesGrid[i2 + 1] * 100);
            if (typeof slidesGrid[i2 + 1] !== "undefined") {
                if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGird) / 2) {
                    slideIndex = i2;
                } else if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext) {
                    slideIndex = i2 + 1;
                }
            } else if (normalizedTranslate >= normalizedGird) {
                slideIndex = i2;
            }
        }
    }
    if (swiper.initialized && slideIndex !== activeIndex) {
        if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
            return false;
        }
        if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
            if ((activeIndex || 0) !== slideIndex) return false;
        }
    }
    var direction;
    if (slideIndex > activeIndex) direction = "next";
    else if (slideIndex < activeIndex) direction = "prev";
    else direction = "reset";
    if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
        swiper.updateActiveIndex(slideIndex);
        if (params.autoHeight) {
            swiper.updateAutoHeight();
        }
        swiper.updateSlidesClasses();
        if (params.effect !== "slide") {
            swiper.setTranslate(translate);
        }
        if (direction !== "reset") {
            swiper.transitionStart(runCallbacks, direction);
            swiper.transitionEnd(runCallbacks, direction);
        }
        return false;
    }
    if (params.cssMode) {
        var isH = swiper.isHorizontal();
        var t = -translate;
        if (rtl) {
            t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
        }
        if (speed === 0) {
            wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
        } else {
            if (wrapperEl.scrollTo) {
                var _wrapperEl$scrollTo;
                wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? "left" : "top"] = t, _wrapperEl$scrollTo.behavior = "smooth", _wrapperEl$scrollTo));
            } else {
                wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
            }
        }
        return true;
    }
    if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(translate);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit("beforeTransitionStart", speed, internal);
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
    } else {
        swiper.setTransition(speed);
        swiper.setTranslate(translate);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit("beforeTransitionStart", speed, internal);
        swiper.transitionStart(runCallbacks, direction);
        if (!swiper.animating) {
            swiper.animating = true;
            if (!swiper.onSlideToWrapperTransitionEnd) {
                swiper.onSlideToWrapperTransitionEnd = function transitionEnd5(e) {
                    if (!swiper || swiper.destroyed) return;
                    if (e.target !== this) return;
                    swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
                    swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
                    swiper.onSlideToWrapperTransitionEnd = null;
                    delete swiper.onSlideToWrapperTransitionEnd;
                    swiper.transitionEnd(runCallbacks, direction);
                };
            }
            swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
            swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
        }
    }
    return true;
}
// node_modules/swiper/esm/components/core/slide/slideToLoop.js
function slideToLoop(index2, speed, runCallbacks, internal) {
    if (index2 === void 0) {
        index2 = 0;
    }
    if (speed === void 0) {
        speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    var swiper = this;
    var newIndex = index2;
    if (swiper.params.loop) {
        newIndex += swiper.loopedSlides;
    }
    return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}
// node_modules/swiper/esm/components/core/slide/slideNext.js
function slideNext(speed, runCallbacks, internal) {
    if (speed === void 0) {
        speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    var swiper = this;
    var params = swiper.params, animating = swiper.animating, enabled = swiper.enabled;
    if (!enabled) return swiper;
    var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;
    if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix();
        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    }
    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}
// node_modules/swiper/esm/components/core/slide/slidePrev.js
function slidePrev(speed, runCallbacks, internal) {
    if (speed === void 0) {
        speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    var swiper = this;
    var params = swiper.params, animating = swiper.animating, snapGrid = swiper.snapGrid, slidesGrid = swiper.slidesGrid, rtlTranslate = swiper.rtlTranslate, enabled = swiper.enabled;
    if (!enabled) return swiper;
    if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix();
        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    }
    var translate = rtlTranslate ? swiper.translate : -swiper.translate;
    function normalize2(val) {
        if (val < 0) return -Math.floor(Math.abs(val));
        return Math.floor(val);
    }
    var normalizedTranslate = normalize2(translate);
    var normalizedSnapGrid = snapGrid.map(function(val) {
        return normalize2(val);
    });
    var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
    if (typeof prevSnap === "undefined" && params.cssMode) {
        snapGrid.forEach(function(snap) {
            if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;
        });
    }
    var prevIndex;
    if (typeof prevSnap !== "undefined") {
        prevIndex = slidesGrid.indexOf(prevSnap);
        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
    }
    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}
// node_modules/swiper/esm/components/core/slide/slideReset.js
function slideReset(speed, runCallbacks, internal) {
    if (speed === void 0) {
        speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    var swiper = this;
    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}
// node_modules/swiper/esm/components/core/slide/slideToClosest.js
function slideToClosest(speed, runCallbacks, internal, threshold) {
    if (speed === void 0) {
        speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    if (threshold === void 0) {
        threshold = 0.5;
    }
    var swiper = this;
    var index2 = swiper.activeIndex;
    var skip = Math.min(swiper.params.slidesPerGroupSkip, index2);
    var snapIndex = skip + Math.floor((index2 - skip) / swiper.params.slidesPerGroup);
    var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    if (translate >= swiper.snapGrid[snapIndex]) {
        var currentSnap = swiper.snapGrid[snapIndex];
        var nextSnap = swiper.snapGrid[snapIndex + 1];
        if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
            index2 += swiper.params.slidesPerGroup;
        }
    } else {
        var prevSnap = swiper.snapGrid[snapIndex - 1];
        var _currentSnap = swiper.snapGrid[snapIndex];
        if (translate - prevSnap <= (_currentSnap - prevSnap) * threshold) {
            index2 -= swiper.params.slidesPerGroup;
        }
    }
    index2 = Math.max(index2, 0);
    index2 = Math.min(index2, swiper.slidesGrid.length - 1);
    return swiper.slideTo(index2, speed, runCallbacks, internal);
}
// node_modules/swiper/esm/components/core/slide/slideToClickedSlide.js
function slideToClickedSlide() {
    var swiper = this;
    var params = swiper.params, $wrapperEl = swiper.$wrapperEl;
    var slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
    var slideToIndex = swiper.clickedIndex;
    var realIndex;
    if (params.loop) {
        if (swiper.animating) return;
        realIndex = parseInt(dom_default(swiper.clickedSlide).attr("data-swiper-slide-index"), 10);
        if (params.centeredSlides) {
            if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
                swiper.loopFix();
                slideToIndex = $wrapperEl.children("." + params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + params.slideDuplicateClass + ")").eq(0).index();
                nextTick4(function() {
                    swiper.slideTo(slideToIndex);
                });
            } else {
                swiper.slideTo(slideToIndex);
            }
        } else if (slideToIndex > swiper.slides.length - slidesPerView) {
            swiper.loopFix();
            slideToIndex = $wrapperEl.children("." + params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + params.slideDuplicateClass + ")").eq(0).index();
            nextTick4(function() {
                swiper.slideTo(slideToIndex);
            });
        } else {
            swiper.slideTo(slideToIndex);
        }
    } else {
        swiper.slideTo(slideToIndex);
    }
}
// node_modules/swiper/esm/components/core/slide/index.js
var slide_default = {
    slideTo,
    slideToLoop,
    slideNext,
    slidePrev,
    slideReset,
    slideToClosest,
    slideToClickedSlide
};
// node_modules/swiper/esm/components/core/loop/loopCreate.js
function loopCreate() {
    var swiper = this;
    var document2 = getDocument();
    var params = swiper.params, $wrapperEl = swiper.$wrapperEl;
    $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass).remove();
    var slides = $wrapperEl.children("." + params.slideClass);
    if (params.loopFillGroupWithBlank) {
        var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
        if (blankSlidesNum !== params.slidesPerGroup) {
            for(var i2 = 0; i2 < blankSlidesNum; i2 += 1){
                var blankNode = dom_default(document2.createElement("div")).addClass(params.slideClass + " " + params.slideBlankClass);
                $wrapperEl.append(blankNode);
            }
            slides = $wrapperEl.children("." + params.slideClass);
        }
    }
    if (params.slidesPerView === "auto" && !params.loopedSlides) params.loopedSlides = slides.length;
    swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
    swiper.loopedSlides += params.loopAdditionalSlides;
    if (swiper.loopedSlides > slides.length) {
        swiper.loopedSlides = slides.length;
    }
    var prependSlides = [];
    var appendSlides = [];
    slides.each(function(el, index2) {
        var slide = dom_default(el);
        if (index2 < swiper.loopedSlides) {
            appendSlides.push(el);
        }
        if (index2 < slides.length && index2 >= slides.length - swiper.loopedSlides) {
            prependSlides.push(el);
        }
        slide.attr("data-swiper-slide-index", index2);
    });
    for(var _i = 0; _i < appendSlides.length; _i += 1){
        $wrapperEl.append(dom_default(appendSlides[_i].cloneNode(true)).addClass(params.slideDuplicateClass));
    }
    for(var _i2 = prependSlides.length - 1; _i2 >= 0; _i2 -= 1){
        $wrapperEl.prepend(dom_default(prependSlides[_i2].cloneNode(true)).addClass(params.slideDuplicateClass));
    }
}
// node_modules/swiper/esm/components/core/loop/loopFix.js
function loopFix() {
    var swiper = this;
    swiper.emit("beforeLoopFix");
    var activeIndex = swiper.activeIndex, slides = swiper.slides, loopedSlides = swiper.loopedSlides, allowSlidePrev = swiper.allowSlidePrev, allowSlideNext = swiper.allowSlideNext, snapGrid = swiper.snapGrid, rtl = swiper.rtlTranslate;
    var newIndex;
    swiper.allowSlidePrev = true;
    swiper.allowSlideNext = true;
    var snapTranslate = -snapGrid[activeIndex];
    var diff = snapTranslate - swiper.getTranslate();
    if (activeIndex < loopedSlides) {
        newIndex = slides.length - loopedSlides * 3 + activeIndex;
        newIndex += loopedSlides;
        var slideChanged = swiper.slideTo(newIndex, 0, false, true);
        if (slideChanged && diff !== 0) {
            swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
    } else if (activeIndex >= slides.length - loopedSlides) {
        newIndex = -slides.length + activeIndex + loopedSlides;
        newIndex += loopedSlides;
        var _slideChanged = swiper.slideTo(newIndex, 0, false, true);
        if (_slideChanged && diff !== 0) {
            swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    swiper.emit("loopFix");
}
// node_modules/swiper/esm/components/core/loop/loopDestroy.js
function loopDestroy() {
    var swiper = this;
    var $wrapperEl = swiper.$wrapperEl, params = swiper.params, slides = swiper.slides;
    $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + ",." + params.slideClass + "." + params.slideBlankClass).remove();
    slides.removeAttr("data-swiper-slide-index");
}
// node_modules/swiper/esm/components/core/loop/index.js
var loop_default = {
    loopCreate,
    loopFix,
    loopDestroy
};
// node_modules/swiper/esm/components/core/grab-cursor/setGrabCursor.js
function setGrabCursor(moving) {
    var swiper = this;
    if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
    var el = swiper.el;
    el.style.cursor = "move";
    el.style.cursor = moving ? "-webkit-grabbing" : "-webkit-grab";
    el.style.cursor = moving ? "-moz-grabbin" : "-moz-grab";
    el.style.cursor = moving ? "grabbing" : "grab";
}
// node_modules/swiper/esm/components/core/grab-cursor/unsetGrabCursor.js
function unsetGrabCursor() {
    var swiper = this;
    if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
        return;
    }
    swiper.el.style.cursor = "";
}
// node_modules/swiper/esm/components/core/grab-cursor/index.js
var grab_cursor_default = {
    setGrabCursor,
    unsetGrabCursor
};
// node_modules/swiper/esm/components/core/manipulation/appendSlide.js
function appendSlide(slides) {
    var swiper = this;
    var $wrapperEl = swiper.$wrapperEl, params = swiper.params;
    if (params.loop) {
        swiper.loopDestroy();
    }
    if (typeof slides === "object" && "length" in slides) {
        for(var i2 = 0; i2 < slides.length; i2 += 1){
            if (slides[i2]) $wrapperEl.append(slides[i2]);
        }
    } else {
        $wrapperEl.append(slides);
    }
    if (params.loop) {
        swiper.loopCreate();
    }
    if (!(params.observer && swiper.support.observer)) {
        swiper.update();
    }
}
// node_modules/swiper/esm/components/core/manipulation/prependSlide.js
function prependSlide(slides) {
    var swiper = this;
    var params = swiper.params, $wrapperEl = swiper.$wrapperEl, activeIndex = swiper.activeIndex;
    if (params.loop) {
        swiper.loopDestroy();
    }
    var newActiveIndex = activeIndex + 1;
    if (typeof slides === "object" && "length" in slides) {
        for(var i2 = 0; i2 < slides.length; i2 += 1){
            if (slides[i2]) $wrapperEl.prepend(slides[i2]);
        }
        newActiveIndex = activeIndex + slides.length;
    } else {
        $wrapperEl.prepend(slides);
    }
    if (params.loop) {
        swiper.loopCreate();
    }
    if (!(params.observer && swiper.support.observer)) {
        swiper.update();
    }
    swiper.slideTo(newActiveIndex, 0, false);
}
// node_modules/swiper/esm/components/core/manipulation/addSlide.js
function addSlide(index2, slides) {
    var swiper = this;
    var $wrapperEl = swiper.$wrapperEl, params = swiper.params, activeIndex = swiper.activeIndex;
    var activeIndexBuffer = activeIndex;
    if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.slides = $wrapperEl.children("." + params.slideClass);
    }
    var baseLength = swiper.slides.length;
    if (index2 <= 0) {
        swiper.prependSlide(slides);
        return;
    }
    if (index2 >= baseLength) {
        swiper.appendSlide(slides);
        return;
    }
    var newActiveIndex = activeIndexBuffer > index2 ? activeIndexBuffer + 1 : activeIndexBuffer;
    var slidesBuffer = [];
    for(var i2 = baseLength - 1; i2 >= index2; i2 -= 1){
        var currentSlide = swiper.slides.eq(i2);
        currentSlide.remove();
        slidesBuffer.unshift(currentSlide);
    }
    if (typeof slides === "object" && "length" in slides) {
        for(var _i = 0; _i < slides.length; _i += 1){
            if (slides[_i]) $wrapperEl.append(slides[_i]);
        }
        newActiveIndex = activeIndexBuffer > index2 ? activeIndexBuffer + slides.length : activeIndexBuffer;
    } else {
        $wrapperEl.append(slides);
    }
    for(var _i2 = 0; _i2 < slidesBuffer.length; _i2 += 1){
        $wrapperEl.append(slidesBuffer[_i2]);
    }
    if (params.loop) {
        swiper.loopCreate();
    }
    if (!(params.observer && swiper.support.observer)) {
        swiper.update();
    }
    if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
    } else {
        swiper.slideTo(newActiveIndex, 0, false);
    }
}
// node_modules/swiper/esm/components/core/manipulation/removeSlide.js
function removeSlide(slidesIndexes) {
    var swiper = this;
    var params = swiper.params, $wrapperEl = swiper.$wrapperEl, activeIndex = swiper.activeIndex;
    var activeIndexBuffer = activeIndex;
    if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.slides = $wrapperEl.children("." + params.slideClass);
    }
    var newActiveIndex = activeIndexBuffer;
    var indexToRemove;
    if (typeof slidesIndexes === "object" && "length" in slidesIndexes) {
        for(var i2 = 0; i2 < slidesIndexes.length; i2 += 1){
            indexToRemove = slidesIndexes[i2];
            if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
            if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        }
        newActiveIndex = Math.max(newActiveIndex, 0);
    } else {
        indexToRemove = slidesIndexes;
        if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        newActiveIndex = Math.max(newActiveIndex, 0);
    }
    if (params.loop) {
        swiper.loopCreate();
    }
    if (!(params.observer && swiper.support.observer)) {
        swiper.update();
    }
    if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
    } else {
        swiper.slideTo(newActiveIndex, 0, false);
    }
}
// node_modules/swiper/esm/components/core/manipulation/removeAllSlides.js
function removeAllSlides() {
    var swiper = this;
    var slidesIndexes = [];
    for(var i2 = 0; i2 < swiper.slides.length; i2 += 1){
        slidesIndexes.push(i2);
    }
    swiper.removeSlide(slidesIndexes);
}
// node_modules/swiper/esm/components/core/manipulation/index.js
var manipulation_default = {
    appendSlide,
    prependSlide,
    addSlide,
    removeSlide,
    removeAllSlides
};
// node_modules/swiper/esm/components/core/events/onTouchStart.js
function onTouchStart(event2) {
    var swiper = this;
    var document2 = getDocument();
    var window2 = getWindow();
    var data = swiper.touchEventsData;
    var params = swiper.params, touches = swiper.touches, enabled = swiper.enabled;
    if (!enabled) return;
    if (swiper.animating && params.preventInteractionOnTransition) {
        return;
    }
    var e = event2;
    if (e.originalEvent) e = e.originalEvent;
    var $targetEl = dom_default(e.target);
    if (params.touchEventsTarget === "wrapper") {
        if (!$targetEl.closest(swiper.wrapperEl).length) return;
    }
    data.isTouchEvent = e.type === "touchstart";
    if (!data.isTouchEvent && "which" in e && e.which === 3) return;
    if (!data.isTouchEvent && "button" in e && e.button > 0) return;
    if (data.isTouched && data.isMoved) return;
    var swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
    if (swipingClassHasValue && e.target && e.target.shadowRoot && event2.path && event2.path[0]) {
        $targetEl = dom_default(event2.path[0]);
    }
    if (params.noSwiping && $targetEl.closest(params.noSwipingSelector ? params.noSwipingSelector : "." + params.noSwipingClass)[0]) {
        swiper.allowClick = true;
        return;
    }
    if (params.swipeHandler) {
        if (!$targetEl.closest(params.swipeHandler)[0]) return;
    }
    touches.currentX = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
    touches.currentY = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    var startX = touches.currentX;
    var startY = touches.currentY;
    var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
    var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
        if (edgeSwipeDetection === "prevent") {
            event2.preventDefault();
        } else {
            return;
        }
    }
    extend2(data, {
        isTouched: true,
        isMoved: false,
        allowTouchCallbacks: true,
        isScrolling: void 0,
        startMoving: void 0
    });
    touches.startX = startX;
    touches.startY = startY;
    data.touchStartTime = now2();
    swiper.allowClick = true;
    swiper.updateSize();
    swiper.swipeDirection = void 0;
    if (params.threshold > 0) data.allowThresholdMove = false;
    if (e.type !== "touchstart") {
        var preventDefault = true;
        if ($targetEl.is(data.focusableElements)) preventDefault = false;
        if (document2.activeElement && dom_default(document2.activeElement).is(data.focusableElements) && document2.activeElement !== $targetEl[0]) {
            document2.activeElement.blur();
        }
        var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
        if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
            e.preventDefault();
        }
    }
    swiper.emit("touchStart", e);
}
// node_modules/swiper/esm/components/core/events/onTouchMove.js
function onTouchMove(event2) {
    var document2 = getDocument();
    var swiper = this;
    var data = swiper.touchEventsData;
    var params = swiper.params, touches = swiper.touches, rtl = swiper.rtlTranslate, enabled = swiper.enabled;
    if (!enabled) return;
    var e = event2;
    if (e.originalEvent) e = e.originalEvent;
    if (!data.isTouched) {
        if (data.startMoving && data.isScrolling) {
            swiper.emit("touchMoveOpposite", e);
        }
        return;
    }
    if (data.isTouchEvent && e.type !== "touchmove") return;
    var targetTouch = e.type === "touchmove" && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
    var pageX = e.type === "touchmove" ? targetTouch.pageX : e.pageX;
    var pageY = e.type === "touchmove" ? targetTouch.pageY : e.pageY;
    if (e.preventedByNestedSwiper) {
        touches.startX = pageX;
        touches.startY = pageY;
        return;
    }
    if (!swiper.allowTouchMove) {
        swiper.allowClick = false;
        if (data.isTouched) {
            extend2(touches, {
                startX: pageX,
                startY: pageY,
                currentX: pageX,
                currentY: pageY
            });
            data.touchStartTime = now2();
        }
        return;
    }
    if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
        if (swiper.isVertical()) {
            if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
                data.isTouched = false;
                data.isMoved = false;
                return;
            }
        } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
            return;
        }
    }
    if (data.isTouchEvent && document2.activeElement) {
        if (e.target === document2.activeElement && dom_default(e.target).is(data.focusableElements)) {
            data.isMoved = true;
            swiper.allowClick = false;
            return;
        }
    }
    if (data.allowTouchCallbacks) {
        swiper.emit("touchMove", e);
    }
    if (e.targetTouches && e.targetTouches.length > 1) return;
    touches.currentX = pageX;
    touches.currentY = pageY;
    var diffX = touches.currentX - touches.startX;
    var diffY = touches.currentY - touches.startY;
    if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) return;
    if (typeof data.isScrolling === "undefined") {
        var touchAngle;
        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
            data.isScrolling = false;
        } else {
            if (diffX * diffX + diffY * diffY >= 25) {
                touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
                data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
            }
        }
    }
    if (data.isScrolling) {
        swiper.emit("touchMoveOpposite", e);
    }
    if (typeof data.startMoving === "undefined") {
        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
            data.startMoving = true;
        }
    }
    if (data.isScrolling) {
        data.isTouched = false;
        return;
    }
    if (!data.startMoving) {
        return;
    }
    swiper.allowClick = false;
    if (!params.cssMode && e.cancelable) {
        e.preventDefault();
    }
    if (params.touchMoveStopPropagation && !params.nested) {
        e.stopPropagation();
    }
    if (!data.isMoved) {
        if (params.loop) {
            swiper.loopFix();
        }
        data.startTranslate = swiper.getTranslate();
        swiper.setTransition(0);
        if (swiper.animating) {
            swiper.$wrapperEl.trigger("webkitTransitionEnd transitionend");
        }
        data.allowMomentumBounce = false;
        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
            swiper.setGrabCursor(true);
        }
        swiper.emit("sliderFirstMove", e);
    }
    swiper.emit("sliderMove", e);
    data.isMoved = true;
    var diff = swiper.isHorizontal() ? diffX : diffY;
    touches.diff = diff;
    diff *= params.touchRatio;
    if (rtl) diff = -diff;
    swiper.swipeDirection = diff > 0 ? "prev" : "next";
    data.currentTranslate = diff + data.startTranslate;
    var disableParentSwiper = true;
    var resistanceRatio = params.resistanceRatio;
    if (params.touchReleaseOnEdges) {
        resistanceRatio = 0;
    }
    if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
    } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
    }
    if (disableParentSwiper) {
        e.preventedByNestedSwiper = true;
    }
    if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) {
        data.currentTranslate = data.startTranslate;
    }
    if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) {
        data.currentTranslate = data.startTranslate;
    }
    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
        data.currentTranslate = data.startTranslate;
    }
    if (params.threshold > 0) {
        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
            if (!data.allowThresholdMove) {
                data.allowThresholdMove = true;
                touches.startX = touches.currentX;
                touches.startY = touches.currentY;
                data.currentTranslate = data.startTranslate;
                touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                return;
            }
        } else {
            data.currentTranslate = data.startTranslate;
            return;
        }
    }
    if (!params.followFinger || params.cssMode) return;
    if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
    }
    if (params.freeMode) {
        if (data.velocities.length === 0) {
            data.velocities.push({
                position: touches[swiper.isHorizontal() ? "startX" : "startY"],
                time: data.touchStartTime
            });
        }
        data.velocities.push({
            position: touches[swiper.isHorizontal() ? "currentX" : "currentY"],
            time: now2()
        });
    }
    swiper.updateProgress(data.currentTranslate);
    swiper.setTranslate(data.currentTranslate);
}
// node_modules/swiper/esm/components/core/events/onTouchEnd.js
function onTouchEnd(event2) {
    var swiper = this;
    var data = swiper.touchEventsData;
    var params = swiper.params, touches = swiper.touches, rtl = swiper.rtlTranslate, $wrapperEl = swiper.$wrapperEl, slidesGrid = swiper.slidesGrid, snapGrid = swiper.snapGrid, enabled = swiper.enabled;
    if (!enabled) return;
    var e = event2;
    if (e.originalEvent) e = e.originalEvent;
    if (data.allowTouchCallbacks) {
        swiper.emit("touchEnd", e);
    }
    data.allowTouchCallbacks = false;
    if (!data.isTouched) {
        if (data.isMoved && params.grabCursor) {
            swiper.setGrabCursor(false);
        }
        data.isMoved = false;
        data.startMoving = false;
        return;
    }
    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(false);
    }
    var touchEndTime = now2();
    var timeDiff = touchEndTime - data.touchStartTime;
    if (swiper.allowClick) {
        swiper.updateClickedSlide(e);
        swiper.emit("tap click", e);
        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
            swiper.emit("doubleTap doubleClick", e);
        }
    }
    data.lastClickTime = now2();
    nextTick4(function() {
        if (!swiper.destroyed) swiper.allowClick = true;
    });
    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        return;
    }
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    var currentPos;
    if (params.followFinger) {
        currentPos = rtl ? swiper.translate : -swiper.translate;
    } else {
        currentPos = -data.currentTranslate;
    }
    if (params.cssMode) {
        return;
    }
    if (params.freeMode) {
        if (currentPos < -swiper.minTranslate()) {
            swiper.slideTo(swiper.activeIndex);
            return;
        }
        if (currentPos > -swiper.maxTranslate()) {
            if (swiper.slides.length < snapGrid.length) {
                swiper.slideTo(snapGrid.length - 1);
            } else {
                swiper.slideTo(swiper.slides.length - 1);
            }
            return;
        }
        if (params.freeModeMomentum) {
            if (data.velocities.length > 1) {
                var lastMoveEvent = data.velocities.pop();
                var velocityEvent = data.velocities.pop();
                var distance = lastMoveEvent.position - velocityEvent.position;
                var time = lastMoveEvent.time - velocityEvent.time;
                swiper.velocity = distance / time;
                swiper.velocity /= 2;
                if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
                    swiper.velocity = 0;
                }
                if (time > 150 || now2() - lastMoveEvent.time > 300) {
                    swiper.velocity = 0;
                }
            } else {
                swiper.velocity = 0;
            }
            swiper.velocity *= params.freeModeMomentumVelocityRatio;
            data.velocities.length = 0;
            var momentumDuration = 1e3 * params.freeModeMomentumRatio;
            var momentumDistance = swiper.velocity * momentumDuration;
            var newPosition = swiper.translate + momentumDistance;
            if (rtl) newPosition = -newPosition;
            var doBounce = false;
            var afterBouncePosition;
            var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
            var needsLoopFix;
            if (newPosition < swiper.maxTranslate()) {
                if (params.freeModeMomentumBounce) {
                    if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                        newPosition = swiper.maxTranslate() - bounceAmount;
                    }
                    afterBouncePosition = swiper.maxTranslate();
                    doBounce = true;
                    data.allowMomentumBounce = true;
                } else {
                    newPosition = swiper.maxTranslate();
                }
                if (params.loop && params.centeredSlides) needsLoopFix = true;
            } else if (newPosition > swiper.minTranslate()) {
                if (params.freeModeMomentumBounce) {
                    if (newPosition - swiper.minTranslate() > bounceAmount) {
                        newPosition = swiper.minTranslate() + bounceAmount;
                    }
                    afterBouncePosition = swiper.minTranslate();
                    doBounce = true;
                    data.allowMomentumBounce = true;
                } else {
                    newPosition = swiper.minTranslate();
                }
                if (params.loop && params.centeredSlides) needsLoopFix = true;
            } else if (params.freeModeSticky) {
                var nextSlide;
                for(var j = 0; j < snapGrid.length; j += 1){
                    if (snapGrid[j] > -newPosition) {
                        nextSlide = j;
                        break;
                    }
                }
                if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === "next") {
                    newPosition = snapGrid[nextSlide];
                } else {
                    newPosition = snapGrid[nextSlide - 1];
                }
                newPosition = -newPosition;
            }
            if (needsLoopFix) {
                swiper.once("transitionEnd", function() {
                    swiper.loopFix();
                });
            }
            if (swiper.velocity !== 0) {
                if (rtl) {
                    momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
                } else {
                    momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
                }
                if (params.freeModeSticky) {
                    var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
                    var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
                    if (moveDistance < currentSlideSize) {
                        momentumDuration = params.speed;
                    } else if (moveDistance < 2 * currentSlideSize) {
                        momentumDuration = params.speed * 1.5;
                    } else {
                        momentumDuration = params.speed * 2.5;
                    }
                }
            } else if (params.freeModeSticky) {
                swiper.slideToClosest();
                return;
            }
            if (params.freeModeMomentumBounce && doBounce) {
                swiper.updateProgress(afterBouncePosition);
                swiper.setTransition(momentumDuration);
                swiper.setTranslate(newPosition);
                swiper.transitionStart(true, swiper.swipeDirection);
                swiper.animating = true;
                $wrapperEl.transitionEnd(function() {
                    if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
                    swiper.emit("momentumBounce");
                    swiper.setTransition(params.speed);
                    setTimeout(function() {
                        swiper.setTranslate(afterBouncePosition);
                        $wrapperEl.transitionEnd(function() {
                            if (!swiper || swiper.destroyed) return;
                            swiper.transitionEnd();
                        });
                    }, 0);
                });
            } else if (swiper.velocity) {
                swiper.updateProgress(newPosition);
                swiper.setTransition(momentumDuration);
                swiper.setTranslate(newPosition);
                swiper.transitionStart(true, swiper.swipeDirection);
                if (!swiper.animating) {
                    swiper.animating = true;
                    $wrapperEl.transitionEnd(function() {
                        if (!swiper || swiper.destroyed) return;
                        swiper.transitionEnd();
                    });
                }
            } else {
                swiper.emit("_freeModeNoMomentumRelease");
                swiper.updateProgress(newPosition);
            }
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        } else if (params.freeModeSticky) {
            swiper.slideToClosest();
            return;
        } else if (params.freeMode) {
            swiper.emit("_freeModeNoMomentumRelease");
        }
        if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
            swiper.updateProgress();
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
        return;
    }
    var stopIndex = 0;
    var groupSize = swiper.slidesSizesGrid[0];
    for(var i2 = 0; i2 < slidesGrid.length; i2 += i2 < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup){
        var _increment = i2 < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
        if (typeof slidesGrid[i2 + _increment] !== "undefined") {
            if (currentPos >= slidesGrid[i2] && currentPos < slidesGrid[i2 + _increment]) {
                stopIndex = i2;
                groupSize = slidesGrid[i2 + _increment] - slidesGrid[i2];
            }
        } else if (currentPos >= slidesGrid[i2]) {
            stopIndex = i2;
            groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
        }
    }
    var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
    var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (timeDiff > params.longSwipesMs) {
        if (!params.longSwipes) {
            swiper.slideTo(swiper.activeIndex);
            return;
        }
        if (swiper.swipeDirection === "next") {
            if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);
            else swiper.slideTo(stopIndex);
        }
        if (swiper.swipeDirection === "prev") {
            if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);
            else swiper.slideTo(stopIndex);
        }
    } else {
        if (!params.shortSwipes) {
            swiper.slideTo(swiper.activeIndex);
            return;
        }
        var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
        if (!isNavButtonTarget) {
            if (swiper.swipeDirection === "next") {
                swiper.slideTo(stopIndex + increment);
            }
            if (swiper.swipeDirection === "prev") {
                swiper.slideTo(stopIndex);
            }
        } else if (e.target === swiper.navigation.nextEl) {
            swiper.slideTo(stopIndex + increment);
        } else {
            swiper.slideTo(stopIndex);
        }
    }
}
// node_modules/swiper/esm/components/core/events/onResize.js
function onResize() {
    var swiper = this;
    var params = swiper.params, el = swiper.el;
    if (el && el.offsetWidth === 0) return;
    if (params.breakpoints) {
        swiper.setBreakpoint();
    }
    var allowSlideNext = swiper.allowSlideNext, allowSlidePrev = swiper.allowSlidePrev, snapGrid = swiper.snapGrid;
    swiper.allowSlideNext = true;
    swiper.allowSlidePrev = true;
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateSlidesClasses();
    if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
        swiper.slideTo(swiper.slides.length - 1, 0, false, true);
    } else {
        swiper.slideTo(swiper.activeIndex, 0, false, true);
    }
    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.run();
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
    }
}
// node_modules/swiper/esm/components/core/events/onClick.js
function onClick(e) {
    var swiper = this;
    if (!swiper.enabled) return;
    if (!swiper.allowClick) {
        if (swiper.params.preventClicks) e.preventDefault();
        if (swiper.params.preventClicksPropagation && swiper.animating) {
            e.stopPropagation();
            e.stopImmediatePropagation();
        }
    }
}
// node_modules/swiper/esm/components/core/events/onScroll.js
function onScroll() {
    var swiper = this;
    var wrapperEl = swiper.wrapperEl, rtlTranslate = swiper.rtlTranslate, enabled = swiper.enabled;
    if (!enabled) return;
    swiper.previousTranslate = swiper.translate;
    if (swiper.isHorizontal()) {
        if (rtlTranslate) {
            swiper.translate = wrapperEl.scrollWidth - wrapperEl.offsetWidth - wrapperEl.scrollLeft;
        } else {
            swiper.translate = -wrapperEl.scrollLeft;
        }
    } else {
        swiper.translate = -wrapperEl.scrollTop;
    }
    if (swiper.translate === -0) swiper.translate = 0;
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
    var newProgress;
    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
        newProgress = 0;
    } else {
        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
    }
    if (newProgress !== swiper.progress) {
        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
    }
    swiper.emit("setTranslate", swiper.translate, false);
}
// node_modules/swiper/esm/components/core/events/index.js
var dummyEventAttached = false;
function dummyEventListener() {}
function attachEvents() {
    var swiper = this;
    var document2 = getDocument();
    var params = swiper.params, touchEvents = swiper.touchEvents, el = swiper.el, wrapperEl = swiper.wrapperEl, device2 = swiper.device, support3 = swiper.support;
    swiper.onTouchStart = onTouchStart.bind(swiper);
    swiper.onTouchMove = onTouchMove.bind(swiper);
    swiper.onTouchEnd = onTouchEnd.bind(swiper);
    if (params.cssMode) {
        swiper.onScroll = onScroll.bind(swiper);
    }
    swiper.onClick = onClick.bind(swiper);
    var capture = !!params.nested;
    if (!support3.touch && support3.pointerEvents) {
        el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
        document2.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
        document2.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
    } else {
        if (support3.touch) {
            var passiveListener = touchEvents.start === "touchstart" && support3.passiveListener && params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
            el.addEventListener(touchEvents.move, swiper.onTouchMove, support3.passiveListener ? {
                passive: false,
                capture
            } : capture);
            el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
            if (touchEvents.cancel) {
                el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
            }
            if (!dummyEventAttached) {
                document2.addEventListener("touchstart", dummyEventListener);
                dummyEventAttached = true;
            }
        }
        if (params.simulateTouch && !device2.ios && !device2.android || params.simulateTouch && !support3.touch && device2.ios) {
            el.addEventListener("mousedown", swiper.onTouchStart, false);
            document2.addEventListener("mousemove", swiper.onTouchMove, capture);
            document2.addEventListener("mouseup", swiper.onTouchEnd, false);
        }
    }
    if (params.preventClicks || params.preventClicksPropagation) {
        el.addEventListener("click", swiper.onClick, true);
    }
    if (params.cssMode) {
        wrapperEl.addEventListener("scroll", swiper.onScroll);
    }
    if (params.updateOnWindowResize) {
        swiper.on(device2.ios || device2.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
    } else {
        swiper.on("observerUpdate", onResize, true);
    }
}
function detachEvents() {
    var swiper = this;
    var document2 = getDocument();
    var params = swiper.params, touchEvents = swiper.touchEvents, el = swiper.el, wrapperEl = swiper.wrapperEl, device2 = swiper.device, support3 = swiper.support;
    var capture = !!params.nested;
    if (!support3.touch && support3.pointerEvents) {
        el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
        document2.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
        document2.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
    } else {
        if (support3.touch) {
            var passiveListener = touchEvents.start === "onTouchStart" && support3.passiveListener && params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
            el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
            el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
            if (touchEvents.cancel) {
                el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
            }
        }
        if (params.simulateTouch && !device2.ios && !device2.android || params.simulateTouch && !support3.touch && device2.ios) {
            el.removeEventListener("mousedown", swiper.onTouchStart, false);
            document2.removeEventListener("mousemove", swiper.onTouchMove, capture);
            document2.removeEventListener("mouseup", swiper.onTouchEnd, false);
        }
    }
    if (params.preventClicks || params.preventClicksPropagation) {
        el.removeEventListener("click", swiper.onClick, true);
    }
    if (params.cssMode) {
        wrapperEl.removeEventListener("scroll", swiper.onScroll);
    }
    swiper.off(device2.ios || device2.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize);
}
var events_default = {
    attachEvents,
    detachEvents
};
// node_modules/swiper/esm/components/core/breakpoints/setBreakpoint.js
function setBreakpoint() {
    var swiper = this;
    var activeIndex = swiper.activeIndex, initialized = swiper.initialized, _swiper$loopedSlides = swiper.loopedSlides, loopedSlides = _swiper$loopedSlides === void 0 ? 0 : _swiper$loopedSlides, params = swiper.params, $el = swiper.$el;
    var breakpoints = params.breakpoints;
    if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;
    var breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
    if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
    var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : void 0;
    if (breakpointOnlyParams) {
        [
            "slidesPerView",
            "spaceBetween",
            "slidesPerGroup",
            "slidesPerGroupSkip",
            "slidesPerColumn"
        ].forEach(function(param) {
            var paramValue = breakpointOnlyParams[param];
            if (typeof paramValue === "undefined") return;
            if (param === "slidesPerView" && (paramValue === "AUTO" || paramValue === "auto")) {
                breakpointOnlyParams[param] = "auto";
            } else if (param === "slidesPerView") {
                breakpointOnlyParams[param] = parseFloat(paramValue);
            } else {
                breakpointOnlyParams[param] = parseInt(paramValue, 10);
            }
        });
    }
    var breakpointParams = breakpointOnlyParams || swiper.originalParams;
    var wasMultiRow = params.slidesPerColumn > 1;
    var isMultiRow = breakpointParams.slidesPerColumn > 1;
    var wasEnabled = params.enabled;
    if (wasMultiRow && !isMultiRow) {
        $el.removeClass(params.containerModifierClass + "multirow " + params.containerModifierClass + "multirow-column");
        swiper.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
        $el.addClass(params.containerModifierClass + "multirow");
        if (breakpointParams.slidesPerColumnFill === "column") {
            $el.addClass(params.containerModifierClass + "multirow-column");
        }
        swiper.emitContainerClasses();
    }
    var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
    if (directionChanged && initialized) {
        swiper.changeDirection();
    }
    extend2(swiper.params, breakpointParams);
    var isEnabled = swiper.params.enabled;
    extend2(swiper, {
        allowTouchMove: swiper.params.allowTouchMove,
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev
    });
    if (wasEnabled && !isEnabled) {
        swiper.disable();
    } else if (!wasEnabled && isEnabled) {
        swiper.enable();
    }
    swiper.currentBreakpoint = breakpoint;
    swiper.emit("_beforeBreakpoint", breakpointParams);
    if (needsReLoop && initialized) {
        swiper.loopDestroy();
        swiper.loopCreate();
        swiper.updateSlides();
        swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
    }
    swiper.emit("breakpoint", breakpointParams);
}
// node_modules/swiper/esm/components/core/breakpoints/getBreakpoint.js
function getBreakpoint(breakpoints, base, containerEl) {
    if (base === void 0) {
        base = "window";
    }
    if (!breakpoints || base === "container" && !containerEl) return void 0;
    var breakpoint = false;
    var window2 = getWindow();
    var currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
    var points = Object.keys(breakpoints).map(function(point2) {
        if (typeof point2 === "string" && point2.indexOf("@") === 0) {
            var minRatio = parseFloat(point2.substr(1));
            var value2 = currentHeight * minRatio;
            return {
                value: value2,
                point: point2
            };
        }
        return {
            value: point2,
            point: point2
        };
    });
    points.sort(function(a, b) {
        return parseInt(a.value, 10) - parseInt(b.value, 10);
    });
    for(var i2 = 0; i2 < points.length; i2 += 1){
        var _points$i = points[i2], point = _points$i.point, value = _points$i.value;
        if (base === "window") {
            if (window2.matchMedia("(min-width: " + value + "px)").matches) {
                breakpoint = point;
            }
        } else if (value <= containerEl.clientWidth) {
            breakpoint = point;
        }
    }
    return breakpoint || "max";
}
// node_modules/swiper/esm/components/core/breakpoints/index.js
var breakpoints_default = {
    setBreakpoint,
    getBreakpoint
};
// node_modules/swiper/esm/components/core/classes/addClasses.js
function prepareClasses(entries, prefix) {
    var resultClasses = [];
    entries.forEach(function(item) {
        if (typeof item === "object") {
            Object.keys(item).forEach(function(classNames) {
                if (item[classNames]) {
                    resultClasses.push(prefix + classNames);
                }
            });
        } else if (typeof item === "string") {
            resultClasses.push(prefix + item);
        }
    });
    return resultClasses;
}
function addClasses() {
    var swiper = this;
    var classNames = swiper.classNames, params = swiper.params, rtl = swiper.rtl, $el = swiper.$el, device2 = swiper.device, support3 = swiper.support;
    var suffixes = prepareClasses([
        "initialized",
        params.direction,
        {
            "pointer-events": support3.pointerEvents && !support3.touch
        },
        {
            "free-mode": params.freeMode
        },
        {
            "autoheight": params.autoHeight
        },
        {
            "rtl": rtl
        },
        {
            "multirow": params.slidesPerColumn > 1
        },
        {
            "multirow-column": params.slidesPerColumn > 1 && params.slidesPerColumnFill === "column"
        },
        {
            "android": device2.android
        },
        {
            "ios": device2.ios
        },
        {
            "css-mode": params.cssMode
        }
    ], params.containerModifierClass);
    classNames.push.apply(classNames, suffixes);
    $el.addClass([].concat(classNames).join(" "));
    swiper.emitContainerClasses();
}
// node_modules/swiper/esm/components/core/classes/removeClasses.js
function removeClasses() {
    var swiper = this;
    var $el = swiper.$el, classNames = swiper.classNames;
    $el.removeClass(classNames.join(" "));
    swiper.emitContainerClasses();
}
// node_modules/swiper/esm/components/core/classes/index.js
var classes_default = {
    addClasses,
    removeClasses
};
// node_modules/swiper/esm/components/core/images/loadImage.js
function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
    var window2 = getWindow();
    var image;
    function onReady() {
        if (callback) callback();
    }
    var isPicture = dom_default(imageEl).parent("picture")[0];
    if (!isPicture && (!imageEl.complete || !checkForComplete)) {
        if (src) {
            image = new window2.Image();
            image.onload = onReady;
            image.onerror = onReady;
            if (sizes) {
                image.sizes = sizes;
            }
            if (srcset) {
                image.srcset = srcset;
            }
            if (src) {
                image.src = src;
            }
        } else {
            onReady();
        }
    } else {
        onReady();
    }
}
// node_modules/swiper/esm/components/core/images/preloadImages.js
function preloadImages() {
    var swiper = this;
    swiper.imagesToLoad = swiper.$el.find("img");
    function onReady() {
        if (typeof swiper === "undefined" || swiper === null || !swiper || swiper.destroyed) return;
        if (swiper.imagesLoaded !== void 0) swiper.imagesLoaded += 1;
        if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
            if (swiper.params.updateOnImagesReady) swiper.update();
            swiper.emit("imagesReady");
        }
    }
    for(var i2 = 0; i2 < swiper.imagesToLoad.length; i2 += 1){
        var imageEl = swiper.imagesToLoad[i2];
        swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute("src"), imageEl.srcset || imageEl.getAttribute("srcset"), imageEl.sizes || imageEl.getAttribute("sizes"), true, onReady);
    }
}
// node_modules/swiper/esm/components/core/images/index.js
var images_default = {
    loadImage,
    preloadImages
};
// node_modules/swiper/esm/components/core/check-overflow/index.js
function checkOverflow() {
    var swiper = this;
    var params = swiper.params;
    var wasLocked = swiper.isLocked;
    var lastSlidePosition = swiper.slides.length > 0 && params.slidesOffsetBefore + params.spaceBetween * (swiper.slides.length - 1) + swiper.slides[0].offsetWidth * swiper.slides.length;
    if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
        swiper.isLocked = lastSlidePosition <= swiper.size;
    } else {
        swiper.isLocked = swiper.snapGrid.length === 1;
    }
    swiper.allowSlideNext = !swiper.isLocked;
    swiper.allowSlidePrev = !swiper.isLocked;
    if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? "lock" : "unlock");
    if (wasLocked && wasLocked !== swiper.isLocked) {
        swiper.isEnd = false;
        if (swiper.navigation) swiper.navigation.update();
    }
}
var check_overflow_default = {
    checkOverflow
};
// node_modules/swiper/esm/components/core/defaults.js
var defaults_default = {
    init: true,
    direction: "horizontal",
    touchEventsTarget: "container",
    initialSlide: 0,
    speed: 300,
    cssMode: false,
    updateOnWindowResize: true,
    resizeObserver: false,
    nested: false,
    createElements: false,
    enabled: true,
    focusableElements: "input, select, option, textarea, button, video, label",
    // Overrides
    width: null,
    height: null,
    //
    preventInteractionOnTransition: false,
    // ssr
    userAgent: null,
    url: null,
    // To support iOS's swipe-to-go-back gesture (when being used in-app).
    edgeSwipeDetection: false,
    edgeSwipeThreshold: 20,
    // Free mode
    freeMode: false,
    freeModeMomentum: true,
    freeModeMomentumRatio: 1,
    freeModeMomentumBounce: true,
    freeModeMomentumBounceRatio: 1,
    freeModeMomentumVelocityRatio: 1,
    freeModeSticky: false,
    freeModeMinimumVelocity: 0.02,
    // Autoheight
    autoHeight: false,
    // Set wrapper width
    setWrapperSize: false,
    // Virtual Translate
    virtualTranslate: false,
    // Effects
    effect: "slide",
    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
    // Breakpoints
    breakpoints: void 0,
    breakpointsBase: "window",
    // Slides grid
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerColumn: 1,
    slidesPerColumnFill: "column",
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    centeredSlides: false,
    centeredSlidesBounds: false,
    slidesOffsetBefore: 0,
    // in px
    slidesOffsetAfter: 0,
    // in px
    normalizeSlideIndex: true,
    centerInsufficientSlides: false,
    // Disable swiper and hide navigation when container not overflow
    watchOverflow: false,
    // Round length
    roundLengths: false,
    // Touches
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: true,
    shortSwipes: true,
    longSwipes: true,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: true,
    allowTouchMove: true,
    threshold: 0,
    touchMoveStopPropagation: false,
    touchStartPreventDefault: true,
    touchStartForcePreventDefault: false,
    touchReleaseOnEdges: false,
    // Unique Navigation Elements
    uniqueNavElements: true,
    // Resistance
    resistance: true,
    resistanceRatio: 0.85,
    // Progress
    watchSlidesProgress: false,
    watchSlidesVisibility: false,
    // Cursor
    grabCursor: false,
    // Clicks
    preventClicks: true,
    preventClicksPropagation: true,
    slideToClickedSlide: false,
    // Images
    preloadImages: true,
    updateOnImagesReady: true,
    // loop
    loop: false,
    loopAdditionalSlides: 0,
    loopedSlides: null,
    loopFillGroupWithBlank: false,
    loopPreventsSlide: true,
    // Swiping/no swiping
    allowSlidePrev: true,
    allowSlideNext: true,
    swipeHandler: null,
    // '.swipe-handler',
    noSwiping: true,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    // Passive Listeners
    passiveListeners: true,
    // NS
    containerModifierClass: "swiper-container-",
    // NEW
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-invisible-blank",
    slideActiveClass: "swiper-slide-active",
    slideDuplicateActiveClass: "swiper-slide-duplicate-active",
    slideVisibleClass: "swiper-slide-visible",
    slideDuplicateClass: "swiper-slide-duplicate",
    slideNextClass: "swiper-slide-next",
    slideDuplicateNextClass: "swiper-slide-duplicate-next",
    slidePrevClass: "swiper-slide-prev",
    slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
    wrapperClass: "swiper-wrapper",
    // Callbacks
    runCallbacksOnInit: true,
    // Internals
    _emitClasses: false
};
// node_modules/swiper/esm/components/core/core-class.js
function _defineProperties(target, props) {
    for(var i2 = 0; i2 < props.length; i2++){
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
var prototypes = {
    modular: modular_default,
    eventsEmitter: events_emitter_default,
    update: update_default,
    translate: translate_default,
    transition: transition_default,
    slide: slide_default,
    loop: loop_default,
    grabCursor: grab_cursor_default,
    manipulation: manipulation_default,
    events: events_default,
    breakpoints: breakpoints_default,
    checkOverflow: check_overflow_default,
    classes: classes_default,
    images: images_default
};
var extendedDefaults = {};
var Swiper = function() {
    function Swiper3() {
        var el;
        var params;
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
            params = args[0];
        } else {
            el = args[0];
            params = args[1];
        }
        if (!params) params = {};
        params = extend2({}, params);
        if (el && !params.el) params.el = el;
        if (params.el && dom_default(params.el).length > 1) {
            var swipers = [];
            dom_default(params.el).each(function(containerEl) {
                var newParams = extend2({}, params, {
                    el: containerEl
                });
                swipers.push(new Swiper3(newParams));
            });
            return swipers;
        }
        var swiper = this;
        swiper.__swiper__ = true;
        swiper.support = getSupport();
        swiper.device = getDevice({
            userAgent: params.userAgent
        });
        swiper.browser = getBrowser();
        swiper.eventsListeners = {};
        swiper.eventsAnyListeners = [];
        if (typeof swiper.modules === "undefined") {
            swiper.modules = {};
        }
        Object.keys(swiper.modules).forEach(function(moduleName) {
            var module2 = swiper.modules[moduleName];
            if (module2.params) {
                var moduleParamName = Object.keys(module2.params)[0];
                var moduleParams = module2.params[moduleParamName];
                if (typeof moduleParams !== "object" || moduleParams === null) return;
                if ([
                    "navigation",
                    "pagination",
                    "scrollbar"
                ].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
                    params[moduleParamName] = {
                        auto: true
                    };
                }
                if (!(moduleParamName in params && "enabled" in moduleParams)) return;
                if (params[moduleParamName] === true) {
                    params[moduleParamName] = {
                        enabled: true
                    };
                }
                if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
                    params[moduleParamName].enabled = true;
                }
                if (!params[moduleParamName]) params[moduleParamName] = {
                    enabled: false
                };
            }
        });
        var swiperParams = extend2({}, defaults_default);
        swiper.useParams(swiperParams);
        swiper.params = extend2({}, swiperParams, extendedDefaults, params);
        swiper.originalParams = extend2({}, swiper.params);
        swiper.passedParams = extend2({}, params);
        if (swiper.params && swiper.params.on) {
            Object.keys(swiper.params.on).forEach(function(eventName) {
                swiper.on(eventName, swiper.params.on[eventName]);
            });
        }
        if (swiper.params && swiper.params.onAny) {
            swiper.onAny(swiper.params.onAny);
        }
        swiper.$ = dom_default;
        extend2(swiper, {
            enabled: swiper.params.enabled,
            el,
            // Classes
            classNames: [],
            // Slides
            slides: dom_default(),
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            // isDirection
            isHorizontal: function isHorizontal() {
                return swiper.params.direction === "horizontal";
            },
            isVertical: function isVertical() {
                return swiper.params.direction === "vertical";
            },
            // Indexes
            activeIndex: 0,
            realIndex: 0,
            //
            isBeginning: true,
            isEnd: false,
            // Props
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: false,
            // Locks
            allowSlideNext: swiper.params.allowSlideNext,
            allowSlidePrev: swiper.params.allowSlidePrev,
            // Touch Events
            touchEvents: function touchEvents() {
                var touch = [
                    "touchstart",
                    "touchmove",
                    "touchend",
                    "touchcancel"
                ];
                var desktop = [
                    "mousedown",
                    "mousemove",
                    "mouseup"
                ];
                if (swiper.support.pointerEvents) {
                    desktop = [
                        "pointerdown",
                        "pointermove",
                        "pointerup"
                    ];
                }
                swiper.touchEventsTouch = {
                    start: touch[0],
                    move: touch[1],
                    end: touch[2],
                    cancel: touch[3]
                };
                swiper.touchEventsDesktop = {
                    start: desktop[0],
                    move: desktop[1],
                    end: desktop[2]
                };
                return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
            }(),
            touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                // Form elements to match
                focusableElements: swiper.params.focusableElements,
                // Last click time
                lastClickTime: now2(),
                clickTimeout: void 0,
                // Velocities
                velocities: [],
                allowMomentumBounce: void 0,
                isTouchEvent: void 0,
                startMoving: void 0
            },
            // Clicks
            allowClick: true,
            // Touches
            allowTouchMove: swiper.params.allowTouchMove,
            touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0
            },
            // Images
            imagesToLoad: [],
            imagesLoaded: 0
        });
        swiper.useModules();
        swiper.emit("_swiper");
        if (swiper.params.init) {
            swiper.init();
        }
        return swiper;
    }
    var _proto = Swiper3.prototype;
    _proto.enable = function enable4() {
        var swiper = this;
        if (swiper.enabled) return;
        swiper.enabled = true;
        if (swiper.params.grabCursor) {
            swiper.setGrabCursor();
        }
        swiper.emit("enable");
    };
    _proto.disable = function disable4() {
        var swiper = this;
        if (!swiper.enabled) return;
        swiper.enabled = false;
        if (swiper.params.grabCursor) {
            swiper.unsetGrabCursor();
        }
        swiper.emit("disable");
    };
    _proto.setProgress = function setProgress(progress, speed) {
        var swiper = this;
        progress = Math.min(Math.max(progress, 0), 1);
        var min = swiper.minTranslate();
        var max = swiper.maxTranslate();
        var current = (max - min) * progress + min;
        swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
    };
    _proto.emitContainerClasses = function emitContainerClasses() {
        var swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        var classes = swiper.el.className.split(" ").filter(function(className) {
            return className.indexOf("swiper-container") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
        });
        swiper.emit("_containerClasses", classes.join(" "));
    };
    _proto.getSlideClasses = function getSlideClasses(slideEl) {
        var swiper = this;
        return slideEl.className.split(" ").filter(function(className) {
            return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0;
        }).join(" ");
    };
    _proto.emitSlidesClasses = function emitSlidesClasses() {
        var swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        var updates = [];
        swiper.slides.each(function(slideEl) {
            var classNames = swiper.getSlideClasses(slideEl);
            updates.push({
                slideEl,
                classNames
            });
            swiper.emit("_slideClass", slideEl, classNames);
        });
        swiper.emit("_slideClasses", updates);
    };
    _proto.slidesPerViewDynamic = function slidesPerViewDynamic() {
        var swiper = this;
        var params = swiper.params, slides = swiper.slides, slidesGrid = swiper.slidesGrid, swiperSize = swiper.size, activeIndex = swiper.activeIndex;
        var spv = 1;
        if (params.centeredSlides) {
            var slideSize = slides[activeIndex].swiperSlideSize;
            var breakLoop;
            for(var i2 = activeIndex + 1; i2 < slides.length; i2 += 1){
                if (slides[i2] && !breakLoop) {
                    slideSize += slides[i2].swiperSlideSize;
                    spv += 1;
                    if (slideSize > swiperSize) breakLoop = true;
                }
            }
            for(var _i = activeIndex - 1; _i >= 0; _i -= 1){
                if (slides[_i] && !breakLoop) {
                    slideSize += slides[_i].swiperSlideSize;
                    spv += 1;
                    if (slideSize > swiperSize) breakLoop = true;
                }
            }
        } else {
            for(var _i2 = activeIndex + 1; _i2 < slides.length; _i2 += 1){
                if (slidesGrid[_i2] - slidesGrid[activeIndex] < swiperSize) {
                    spv += 1;
                }
            }
        }
        return spv;
    };
    _proto.update = function update8() {
        var swiper = this;
        if (!swiper || swiper.destroyed) return;
        var snapGrid = swiper.snapGrid, params = swiper.params;
        if (params.breakpoints) {
            swiper.setBreakpoint();
        }
        swiper.updateSize();
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();
        function setTranslate17() {
            var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
            var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
            swiper.setTranslate(newTranslate);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
        var translated;
        if (swiper.params.freeMode) {
            setTranslate17();
            if (swiper.params.autoHeight) {
                swiper.updateAutoHeight();
            }
        } else {
            if ((swiper.params.slidesPerView === "auto" || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
                translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
            } else {
                translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
            }
            if (!translated) {
                setTranslate17();
            }
        }
        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
            swiper.checkOverflow();
        }
        swiper.emit("update");
    };
    _proto.changeDirection = function changeDirection(newDirection, needUpdate) {
        if (needUpdate === void 0) {
            needUpdate = true;
        }
        var swiper = this;
        var currentDirection = swiper.params.direction;
        if (!newDirection) {
            newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
        }
        if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
            return swiper;
        }
        swiper.$el.removeClass("" + swiper.params.containerModifierClass + currentDirection).addClass("" + swiper.params.containerModifierClass + newDirection);
        swiper.emitContainerClasses();
        swiper.params.direction = newDirection;
        swiper.slides.each(function(slideEl) {
            if (newDirection === "vertical") {
                slideEl.style.width = "";
            } else {
                slideEl.style.height = "";
            }
        });
        swiper.emit("changeDirection");
        if (needUpdate) swiper.update();
        return swiper;
    };
    _proto.mount = function mount(el) {
        var swiper = this;
        if (swiper.mounted) return true;
        var $el = dom_default(el || swiper.params.el);
        el = $el[0];
        if (!el) {
            return false;
        }
        el.swiper = swiper;
        var getWrapperSelector = function getWrapperSelector2() {
            return "." + (swiper.params.wrapperClass || "").trim().split(" ").join(".");
        };
        var getWrapper = function getWrapper2() {
            if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                var res = dom_default(el.shadowRoot.querySelector(getWrapperSelector()));
                res.children = function(options3) {
                    return $el.children(options3);
                };
                return res;
            }
            return $el.children(getWrapperSelector());
        };
        var $wrapperEl = getWrapper();
        if ($wrapperEl.length === 0 && swiper.params.createElements) {
            var document2 = getDocument();
            var wrapper = document2.createElement("div");
            $wrapperEl = dom_default(wrapper);
            wrapper.className = swiper.params.wrapperClass;
            $el.append(wrapper);
            $el.children("." + swiper.params.slideClass).each(function(slideEl) {
                $wrapperEl.append(slideEl);
            });
        }
        extend2(swiper, {
            $el,
            el,
            $wrapperEl,
            wrapperEl: $wrapperEl[0],
            mounted: true,
            // RTL
            rtl: el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl",
            rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl"),
            wrongRTL: $wrapperEl.css("display") === "-webkit-box"
        });
        return true;
    };
    _proto.init = function init23(el) {
        var swiper = this;
        if (swiper.initialized) return swiper;
        var mounted = swiper.mount(el);
        if (mounted === false) return swiper;
        swiper.emit("beforeInit");
        if (swiper.params.breakpoints) {
            swiper.setBreakpoint();
        }
        swiper.addClasses();
        if (swiper.params.loop) {
            swiper.loopCreate();
        }
        swiper.updateSize();
        swiper.updateSlides();
        if (swiper.params.watchOverflow) {
            swiper.checkOverflow();
        }
        if (swiper.params.grabCursor && swiper.enabled) {
            swiper.setGrabCursor();
        }
        if (swiper.params.preloadImages) {
            swiper.preloadImages();
        }
        if (swiper.params.loop) {
            swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
        } else {
            swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
        }
        swiper.attachEvents();
        swiper.initialized = true;
        swiper.emit("init");
        swiper.emit("afterInit");
        return swiper;
    };
    _proto.destroy = function destroy20(deleteInstance, cleanStyles) {
        if (deleteInstance === void 0) {
            deleteInstance = true;
        }
        if (cleanStyles === void 0) {
            cleanStyles = true;
        }
        var swiper = this;
        var params = swiper.params, $el = swiper.$el, $wrapperEl = swiper.$wrapperEl, slides = swiper.slides;
        if (typeof swiper.params === "undefined" || swiper.destroyed) {
            return null;
        }
        swiper.emit("beforeDestroy");
        swiper.initialized = false;
        swiper.detachEvents();
        if (params.loop) {
            swiper.loopDestroy();
        }
        if (cleanStyles) {
            swiper.removeClasses();
            $el.removeAttr("style");
            $wrapperEl.removeAttr("style");
            if (slides && slides.length) {
                slides.removeClass([
                    params.slideVisibleClass,
                    params.slideActiveClass,
                    params.slideNextClass,
                    params.slidePrevClass
                ].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index");
            }
        }
        swiper.emit("destroy");
        Object.keys(swiper.eventsListeners).forEach(function(eventName) {
            swiper.off(eventName);
        });
        if (deleteInstance !== false) {
            swiper.$el[0].swiper = null;
            deleteProps(swiper);
        }
        swiper.destroyed = true;
        return null;
    };
    Swiper3.extendDefaults = function extendDefaults(newDefaults) {
        extend2(extendedDefaults, newDefaults);
    };
    Swiper3.installModule = function installModule(module2) {
        if (!Swiper3.prototype.modules) Swiper3.prototype.modules = {};
        var name = module2.name || Object.keys(Swiper3.prototype.modules).length + "_" + now2();
        Swiper3.prototype.modules[name] = module2;
    };
    Swiper3.use = function use(module2) {
        if (Array.isArray(module2)) {
            module2.forEach(function(m) {
                return Swiper3.installModule(m);
            });
            return Swiper3;
        }
        Swiper3.installModule(module2);
        return Swiper3;
    };
    _createClass(Swiper3, null, [
        {
            key: "extendedDefaults",
            get: function get2() {
                return extendedDefaults;
            }
        },
        {
            key: "defaults",
            get: function get2() {
                return defaults_default;
            }
        }
    ]);
    return Swiper3;
}();
Object.keys(prototypes).forEach(function(prototypeGroup) {
    Object.keys(prototypes[prototypeGroup]).forEach(function(protoMethod) {
        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
    });
});
Swiper.use([
    resize_default,
    observer_default
]);
var core_class_default = Swiper;
// node_modules/swiper/esm/components/virtual/virtual.js
function _extends3() {
    _extends3 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends3.apply(this, arguments);
}
var Virtual = {
    update: function update(force) {
        var swiper = this;
        var _swiper$params = swiper.params, slidesPerView = _swiper$params.slidesPerView, slidesPerGroup = _swiper$params.slidesPerGroup, centeredSlides = _swiper$params.centeredSlides;
        var _swiper$params$virtua = swiper.params.virtual, addSlidesBefore = _swiper$params$virtua.addSlidesBefore, addSlidesAfter = _swiper$params$virtua.addSlidesAfter;
        var _swiper$virtual = swiper.virtual, previousFrom = _swiper$virtual.from, previousTo = _swiper$virtual.to, slides = _swiper$virtual.slides, previousSlidesGrid = _swiper$virtual.slidesGrid, renderSlide2 = _swiper$virtual.renderSlide, previousOffset = _swiper$virtual.offset;
        swiper.updateActiveIndex();
        var activeIndex = swiper.activeIndex || 0;
        var offsetProp;
        if (swiper.rtlTranslate) offsetProp = "right";
        else offsetProp = swiper.isHorizontal() ? "left" : "top";
        var slidesAfter;
        var slidesBefore;
        if (centeredSlides) {
            slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
            slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
        } else {
            slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
            slidesBefore = slidesPerGroup + addSlidesBefore;
        }
        var from = Math.max((activeIndex || 0) - slidesBefore, 0);
        var to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
        var offset2 = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
        extend2(swiper.virtual, {
            from,
            to,
            offset: offset2,
            slidesGrid: swiper.slidesGrid
        });
        function onRendered() {
            swiper.updateSlides();
            swiper.updateProgress();
            swiper.updateSlidesClasses();
            if (swiper.lazy && swiper.params.lazy.enabled) {
                swiper.lazy.load();
            }
        }
        if (previousFrom === from && previousTo === to && !force) {
            if (swiper.slidesGrid !== previousSlidesGrid && offset2 !== previousOffset) {
                swiper.slides.css(offsetProp, offset2 + "px");
            }
            swiper.updateProgress();
            return;
        }
        if (swiper.params.virtual.renderExternal) {
            swiper.params.virtual.renderExternal.call(swiper, {
                offset: offset2,
                from,
                to,
                slides: function getSlides() {
                    var slidesToRender = [];
                    for(var i3 = from; i3 <= to; i3 += 1){
                        slidesToRender.push(slides[i3]);
                    }
                    return slidesToRender;
                }()
            });
            if (swiper.params.virtual.renderExternalUpdate) {
                onRendered();
            }
            return;
        }
        var prependIndexes = [];
        var appendIndexes = [];
        if (force) {
            swiper.$wrapperEl.find("." + swiper.params.slideClass).remove();
        } else {
            for(var i2 = previousFrom; i2 <= previousTo; i2 += 1){
                if (i2 < from || i2 > to) {
                    swiper.$wrapperEl.find("." + swiper.params.slideClass + '[data-swiper-slide-index="' + i2 + '"]').remove();
                }
            }
        }
        for(var _i = 0; _i < slides.length; _i += 1){
            if (_i >= from && _i <= to) {
                if (typeof previousTo === "undefined" || force) {
                    appendIndexes.push(_i);
                } else {
                    if (_i > previousTo) appendIndexes.push(_i);
                    if (_i < previousFrom) prependIndexes.push(_i);
                }
            }
        }
        appendIndexes.forEach(function(index2) {
            swiper.$wrapperEl.append(renderSlide2(slides[index2], index2));
        });
        prependIndexes.sort(function(a, b) {
            return b - a;
        }).forEach(function(index2) {
            swiper.$wrapperEl.prepend(renderSlide2(slides[index2], index2));
        });
        swiper.$wrapperEl.children(".swiper-slide").css(offsetProp, offset2 + "px");
        onRendered();
    },
    renderSlide: function renderSlide(slide, index2) {
        var swiper = this;
        var params = swiper.params.virtual;
        if (params.cache && swiper.virtual.cache[index2]) {
            return swiper.virtual.cache[index2];
        }
        var $slideEl = params.renderSlide ? dom_default(params.renderSlide.call(swiper, slide, index2)) : dom_default('<div class="' + swiper.params.slideClass + '" data-swiper-slide-index="' + index2 + '">' + slide + "</div>");
        if (!$slideEl.attr("data-swiper-slide-index")) $slideEl.attr("data-swiper-slide-index", index2);
        if (params.cache) swiper.virtual.cache[index2] = $slideEl;
        return $slideEl;
    },
    appendSlide: function appendSlide2(slides) {
        var swiper = this;
        if (typeof slides === "object" && "length" in slides) {
            for(var i2 = 0; i2 < slides.length; i2 += 1){
                if (slides[i2]) swiper.virtual.slides.push(slides[i2]);
            }
        } else {
            swiper.virtual.slides.push(slides);
        }
        swiper.virtual.update(true);
    },
    prependSlide: function prependSlide2(slides) {
        var swiper = this;
        var activeIndex = swiper.activeIndex;
        var newActiveIndex = activeIndex + 1;
        var numberOfNewSlides = 1;
        if (Array.isArray(slides)) {
            for(var i2 = 0; i2 < slides.length; i2 += 1){
                if (slides[i2]) swiper.virtual.slides.unshift(slides[i2]);
            }
            newActiveIndex = activeIndex + slides.length;
            numberOfNewSlides = slides.length;
        } else {
            swiper.virtual.slides.unshift(slides);
        }
        if (swiper.params.virtual.cache) {
            var cache2 = swiper.virtual.cache;
            var newCache = {};
            Object.keys(cache2).forEach(function(cachedIndex) {
                var $cachedEl = cache2[cachedIndex];
                var cachedElIndex = $cachedEl.attr("data-swiper-slide-index");
                if (cachedElIndex) {
                    $cachedEl.attr("data-swiper-slide-index", parseInt(cachedElIndex, 10) + 1);
                }
                newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
            });
            swiper.virtual.cache = newCache;
        }
        swiper.virtual.update(true);
        swiper.slideTo(newActiveIndex, 0);
    },
    removeSlide: function removeSlide2(slidesIndexes) {
        var swiper = this;
        if (typeof slidesIndexes === "undefined" || slidesIndexes === null) return;
        var activeIndex = swiper.activeIndex;
        if (Array.isArray(slidesIndexes)) {
            for(var i2 = slidesIndexes.length - 1; i2 >= 0; i2 -= 1){
                swiper.virtual.slides.splice(slidesIndexes[i2], 1);
                if (swiper.params.virtual.cache) {
                    delete swiper.virtual.cache[slidesIndexes[i2]];
                }
                if (slidesIndexes[i2] < activeIndex) activeIndex -= 1;
                activeIndex = Math.max(activeIndex, 0);
            }
        } else {
            swiper.virtual.slides.splice(slidesIndexes, 1);
            if (swiper.params.virtual.cache) {
                delete swiper.virtual.cache[slidesIndexes];
            }
            if (slidesIndexes < activeIndex) activeIndex -= 1;
            activeIndex = Math.max(activeIndex, 0);
        }
        swiper.virtual.update(true);
        swiper.slideTo(activeIndex, 0);
    },
    removeAllSlides: function removeAllSlides2() {
        var swiper = this;
        swiper.virtual.slides = [];
        if (swiper.params.virtual.cache) {
            swiper.virtual.cache = {};
        }
        swiper.virtual.update(true);
        swiper.slideTo(0, 0);
    }
};
var virtual_default = {
    name: "virtual",
    params: {
        virtual: {
            enabled: false,
            slides: [],
            cache: true,
            renderSlide: null,
            renderExternal: null,
            renderExternalUpdate: true,
            addSlidesBefore: 0,
            addSlidesAfter: 0
        }
    },
    create: function create4() {
        var swiper = this;
        bindModuleMethods(swiper, {
            virtual: _extends3({}, Virtual, {
                slides: swiper.params.virtual.slides,
                cache: {}
            })
        });
    },
    on: {
        beforeInit: function beforeInit(swiper) {
            if (!swiper.params.virtual.enabled) return;
            swiper.classNames.push(swiper.params.containerModifierClass + "virtual");
            var overwriteParams = {
                watchSlidesProgress: true
            };
            extend2(swiper.params, overwriteParams);
            extend2(swiper.originalParams, overwriteParams);
            if (!swiper.params.initialSlide) {
                swiper.virtual.update();
            }
        },
        setTranslate: function setTranslate2(swiper) {
            if (!swiper.params.virtual.enabled) return;
            swiper.virtual.update();
        }
    }
};
// node_modules/swiper/esm/components/keyboard/keyboard.js
function _extends4() {
    _extends4 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends4.apply(this, arguments);
}
var Keyboard = {
    handle: function handle(event2) {
        var swiper = this;
        if (!swiper.enabled) return;
        var window2 = getWindow();
        var document2 = getDocument();
        var rtl = swiper.rtlTranslate;
        var e = event2;
        if (e.originalEvent) e = e.originalEvent;
        var kc = e.keyCode || e.charCode;
        var pageUpDown = swiper.params.keyboard.pageUpDown;
        var isPageUp = pageUpDown && kc === 33;
        var isPageDown = pageUpDown && kc === 34;
        var isArrowLeft = kc === 37;
        var isArrowRight = kc === 39;
        var isArrowUp = kc === 38;
        var isArrowDown = kc === 40;
        if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
            return false;
        }
        if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
            return false;
        }
        if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
            return void 0;
        }
        if (document2.activeElement && document2.activeElement.nodeName && (document2.activeElement.nodeName.toLowerCase() === "input" || document2.activeElement.nodeName.toLowerCase() === "textarea")) {
            return void 0;
        }
        if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
            var inView = false;
            if (swiper.$el.parents("." + swiper.params.slideClass).length > 0 && swiper.$el.parents("." + swiper.params.slideActiveClass).length === 0) {
                return void 0;
            }
            var $el = swiper.$el;
            var swiperWidth = $el[0].clientWidth;
            var swiperHeight = $el[0].clientHeight;
            var windowWidth = window2.innerWidth;
            var windowHeight = window2.innerHeight;
            var swiperOffset = swiper.$el.offset();
            if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
            var swiperCoord = [
                [
                    swiperOffset.left,
                    swiperOffset.top
                ],
                [
                    swiperOffset.left + swiperWidth,
                    swiperOffset.top
                ],
                [
                    swiperOffset.left,
                    swiperOffset.top + swiperHeight
                ],
                [
                    swiperOffset.left + swiperWidth,
                    swiperOffset.top + swiperHeight
                ]
            ];
            for(var i2 = 0; i2 < swiperCoord.length; i2 += 1){
                var point = swiperCoord[i2];
                if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
                    if (point[0] === 0 && point[1] === 0) continue;
                    inView = true;
                }
            }
            if (!inView) return void 0;
        }
        if (swiper.isHorizontal()) {
            if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
                if (e.preventDefault) e.preventDefault();
                else e.returnValue = false;
            }
            if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
            if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
        } else {
            if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
                if (e.preventDefault) e.preventDefault();
                else e.returnValue = false;
            }
            if (isPageDown || isArrowDown) swiper.slideNext();
            if (isPageUp || isArrowUp) swiper.slidePrev();
        }
        swiper.emit("keyPress", kc);
        return void 0;
    },
    enable: function enable() {
        var swiper = this;
        var document2 = getDocument();
        if (swiper.keyboard.enabled) return;
        dom_default(document2).on("keydown", swiper.keyboard.handle);
        swiper.keyboard.enabled = true;
    },
    disable: function disable() {
        var swiper = this;
        var document2 = getDocument();
        if (!swiper.keyboard.enabled) return;
        dom_default(document2).off("keydown", swiper.keyboard.handle);
        swiper.keyboard.enabled = false;
    }
};
var keyboard_default = {
    name: "keyboard",
    params: {
        keyboard: {
            enabled: false,
            onlyInViewport: true,
            pageUpDown: true
        }
    },
    create: function create5() {
        var swiper = this;
        bindModuleMethods(swiper, {
            keyboard: _extends4({
                enabled: false
            }, Keyboard)
        });
    },
    on: {
        init: function init5(swiper) {
            if (swiper.params.keyboard.enabled) {
                swiper.keyboard.enable();
            }
        },
        destroy: function destroy4(swiper) {
            if (swiper.keyboard.enabled) {
                swiper.keyboard.disable();
            }
        }
    }
};
// node_modules/swiper/esm/components/mousewheel/mousewheel.js
function isEventSupported() {
    var document2 = getDocument();
    var eventName = "onwheel";
    var isSupported = eventName in document2;
    if (!isSupported) {
        var element = document2.createElement("div");
        element.setAttribute(eventName, "return;");
        isSupported = typeof element[eventName] === "function";
    }
    if (!isSupported && document2.implementation && document2.implementation.hasFeature && // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    document2.implementation.hasFeature("", "") !== true) {
        isSupported = document2.implementation.hasFeature("Events.wheel", "3.0");
    }
    return isSupported;
}
var Mousewheel = {
    lastScrollTime: now2(),
    lastEventBeforeSnap: void 0,
    recentWheelEvents: [],
    event: function event() {
        var window2 = getWindow();
        if (window2.navigator.userAgent.indexOf("firefox") > -1) return "DOMMouseScroll";
        return isEventSupported() ? "wheel" : "mousewheel";
    },
    normalize: function normalize(e) {
        var PIXEL_STEP = 10;
        var LINE_HEIGHT2 = 40;
        var PAGE_HEIGHT = 800;
        var sX = 0;
        var sY = 0;
        var pX = 0;
        var pY = 0;
        if ("detail" in e) {
            sY = e.detail;
        }
        if ("wheelDelta" in e) {
            sY = -e.wheelDelta / 120;
        }
        if ("wheelDeltaY" in e) {
            sY = -e.wheelDeltaY / 120;
        }
        if ("wheelDeltaX" in e) {
            sX = -e.wheelDeltaX / 120;
        }
        if ("axis" in e && e.axis === e.HORIZONTAL_AXIS) {
            sX = sY;
            sY = 0;
        }
        pX = sX * PIXEL_STEP;
        pY = sY * PIXEL_STEP;
        if ("deltaY" in e) {
            pY = e.deltaY;
        }
        if ("deltaX" in e) {
            pX = e.deltaX;
        }
        if (e.shiftKey && !pX) {
            pX = pY;
            pY = 0;
        }
        if ((pX || pY) && e.deltaMode) {
            if (e.deltaMode === 1) {
                pX *= LINE_HEIGHT2;
                pY *= LINE_HEIGHT2;
            } else {
                pX *= PAGE_HEIGHT;
                pY *= PAGE_HEIGHT;
            }
        }
        if (pX && !sX) {
            sX = pX < 1 ? -1 : 1;
        }
        if (pY && !sY) {
            sY = pY < 1 ? -1 : 1;
        }
        return {
            spinX: sX,
            spinY: sY,
            pixelX: pX,
            pixelY: pY
        };
    },
    handleMouseEnter: function handleMouseEnter() {
        var swiper = this;
        if (!swiper.enabled) return;
        swiper.mouseEntered = true;
    },
    handleMouseLeave: function handleMouseLeave() {
        var swiper = this;
        if (!swiper.enabled) return;
        swiper.mouseEntered = false;
    },
    handle: function handle2(event2) {
        var e = event2;
        var disableParentSwiper = true;
        var swiper = this;
        if (!swiper.enabled) return;
        var params = swiper.params.mousewheel;
        if (swiper.params.cssMode) {
            e.preventDefault();
        }
        var target = swiper.$el;
        if (swiper.params.mousewheel.eventsTarget !== "container") {
            target = dom_default(swiper.params.mousewheel.eventsTarget);
        }
        if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;
        if (e.originalEvent) e = e.originalEvent;
        var delta = 0;
        var rtlFactor = swiper.rtlTranslate ? -1 : 1;
        var data = Mousewheel.normalize(e);
        if (params.forceToAxis) {
            if (swiper.isHorizontal()) {
                if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;
                else return true;
            } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;
            else return true;
        } else {
            delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
        }
        if (delta === 0) return true;
        if (params.invert) delta = -delta;
        var positions = swiper.getTranslate() + delta * params.sensitivity;
        if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
        if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();
        disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
        if (disableParentSwiper && swiper.params.nested) e.stopPropagation();
        if (!swiper.params.freeMode) {
            var newEvent = {
                time: now2(),
                delta: Math.abs(delta),
                direction: Math.sign(delta),
                raw: event2
            };
            var recentWheelEvents = swiper.mousewheel.recentWheelEvents;
            if (recentWheelEvents.length >= 2) {
                recentWheelEvents.shift();
            }
            var prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
            recentWheelEvents.push(newEvent);
            if (prevEvent) {
                if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
                    swiper.mousewheel.animateSlider(newEvent);
                }
            } else {
                swiper.mousewheel.animateSlider(newEvent);
            }
            if (swiper.mousewheel.releaseScroll(newEvent)) {
                return true;
            }
        } else {
            var _newEvent = {
                time: now2(),
                delta: Math.abs(delta),
                direction: Math.sign(delta)
            };
            var lastEventBeforeSnap = swiper.mousewheel.lastEventBeforeSnap;
            var ignoreWheelEvents = lastEventBeforeSnap && _newEvent.time < lastEventBeforeSnap.time + 500 && _newEvent.delta <= lastEventBeforeSnap.delta && _newEvent.direction === lastEventBeforeSnap.direction;
            if (!ignoreWheelEvents) {
                swiper.mousewheel.lastEventBeforeSnap = void 0;
                if (swiper.params.loop) {
                    swiper.loopFix();
                }
                var position = swiper.getTranslate() + delta * params.sensitivity;
                var wasBeginning = swiper.isBeginning;
                var wasEnd = swiper.isEnd;
                if (position >= swiper.minTranslate()) position = swiper.minTranslate();
                if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
                swiper.setTransition(0);
                swiper.setTranslate(position);
                swiper.updateProgress();
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
                if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
                    swiper.updateSlidesClasses();
                }
                if (swiper.params.freeModeSticky) {
                    clearTimeout(swiper.mousewheel.timeout);
                    swiper.mousewheel.timeout = void 0;
                    var _recentWheelEvents = swiper.mousewheel.recentWheelEvents;
                    if (_recentWheelEvents.length >= 15) {
                        _recentWheelEvents.shift();
                    }
                    var _prevEvent = _recentWheelEvents.length ? _recentWheelEvents[_recentWheelEvents.length - 1] : void 0;
                    var firstEvent = _recentWheelEvents[0];
                    _recentWheelEvents.push(_newEvent);
                    if (_prevEvent && (_newEvent.delta > _prevEvent.delta || _newEvent.direction !== _prevEvent.direction)) {
                        _recentWheelEvents.splice(0);
                    } else if (_recentWheelEvents.length >= 15 && _newEvent.time - firstEvent.time < 500 && firstEvent.delta - _newEvent.delta >= 1 && _newEvent.delta <= 6) {
                        var snapToThreshold = delta > 0 ? 0.8 : 0.2;
                        swiper.mousewheel.lastEventBeforeSnap = _newEvent;
                        _recentWheelEvents.splice(0);
                        swiper.mousewheel.timeout = nextTick4(function() {
                            swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);
                        }, 0);
                    }
                    if (!swiper.mousewheel.timeout) {
                        swiper.mousewheel.timeout = nextTick4(function() {
                            var snapToThreshold2 = 0.5;
                            swiper.mousewheel.lastEventBeforeSnap = _newEvent;
                            _recentWheelEvents.splice(0);
                            swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold2);
                        }, 500);
                    }
                }
                if (!ignoreWheelEvents) swiper.emit("scroll", e);
                if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();
                if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
            }
        }
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
        return false;
    },
    animateSlider: function animateSlider(newEvent) {
        var swiper = this;
        var window2 = getWindow();
        if (this.params.mousewheel.thresholdDelta && newEvent.delta < this.params.mousewheel.thresholdDelta) {
            return false;
        }
        if (this.params.mousewheel.thresholdTime && now2() - swiper.mousewheel.lastScrollTime < this.params.mousewheel.thresholdTime) {
            return false;
        }
        if (newEvent.delta >= 6 && now2() - swiper.mousewheel.lastScrollTime < 60) {
            return true;
        }
        if (newEvent.direction < 0) {
            if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
                swiper.slideNext();
                swiper.emit("scroll", newEvent.raw);
            }
        } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
            swiper.slidePrev();
            swiper.emit("scroll", newEvent.raw);
        }
        swiper.mousewheel.lastScrollTime = new window2.Date().getTime();
        return false;
    },
    releaseScroll: function releaseScroll(newEvent) {
        var swiper = this;
        var params = swiper.params.mousewheel;
        if (newEvent.direction < 0) {
            if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
                return true;
            }
        } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
            return true;
        }
        return false;
    },
    enable: function enable2() {
        var swiper = this;
        var event2 = Mousewheel.event();
        if (swiper.params.cssMode) {
            swiper.wrapperEl.removeEventListener(event2, swiper.mousewheel.handle);
            return true;
        }
        if (!event2) return false;
        if (swiper.mousewheel.enabled) return false;
        var target = swiper.$el;
        if (swiper.params.mousewheel.eventsTarget !== "container") {
            target = dom_default(swiper.params.mousewheel.eventsTarget);
        }
        target.on("mouseenter", swiper.mousewheel.handleMouseEnter);
        target.on("mouseleave", swiper.mousewheel.handleMouseLeave);
        target.on(event2, swiper.mousewheel.handle);
        swiper.mousewheel.enabled = true;
        return true;
    },
    disable: function disable2() {
        var swiper = this;
        var event2 = Mousewheel.event();
        if (swiper.params.cssMode) {
            swiper.wrapperEl.addEventListener(event2, swiper.mousewheel.handle);
            return true;
        }
        if (!event2) return false;
        if (!swiper.mousewheel.enabled) return false;
        var target = swiper.$el;
        if (swiper.params.mousewheel.eventsTarget !== "container") {
            target = dom_default(swiper.params.mousewheel.eventsTarget);
        }
        target.off(event2, swiper.mousewheel.handle);
        swiper.mousewheel.enabled = false;
        return true;
    }
};
var mousewheel_default = {
    name: "mousewheel",
    params: {
        mousewheel: {
            enabled: false,
            releaseOnEdges: false,
            invert: false,
            forceToAxis: false,
            sensitivity: 1,
            eventsTarget: "container",
            thresholdDelta: null,
            thresholdTime: null
        }
    },
    create: function create6() {
        var swiper = this;
        bindModuleMethods(swiper, {
            mousewheel: {
                enabled: false,
                lastScrollTime: now2(),
                lastEventBeforeSnap: void 0,
                recentWheelEvents: [],
                enable: Mousewheel.enable,
                disable: Mousewheel.disable,
                handle: Mousewheel.handle,
                handleMouseEnter: Mousewheel.handleMouseEnter,
                handleMouseLeave: Mousewheel.handleMouseLeave,
                animateSlider: Mousewheel.animateSlider,
                releaseScroll: Mousewheel.releaseScroll
            }
        });
    },
    on: {
        init: function init6(swiper) {
            if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
                swiper.mousewheel.disable();
            }
            if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();
        },
        destroy: function destroy5(swiper) {
            if (swiper.params.cssMode) {
                swiper.mousewheel.enable();
            }
            if (swiper.mousewheel.enabled) swiper.mousewheel.disable();
        }
    }
};
// node_modules/swiper/esm/components/navigation/navigation.js
function _extends5() {
    _extends5 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends5.apply(this, arguments);
}
var Navigation = {
    toggleEl: function toggleEl($el, disabled) {
        $el[disabled ? "addClass" : "removeClass"](this.params.navigation.disabledClass);
        if ($el[0] && $el[0].tagName === "BUTTON") $el[0].disabled = disabled;
    },
    update: function update2() {
        var swiper = this;
        var params = swiper.params.navigation;
        var toggleEl2 = swiper.navigation.toggleEl;
        if (swiper.params.loop) return;
        var _swiper$navigation = swiper.navigation, $nextEl = _swiper$navigation.$nextEl, $prevEl = _swiper$navigation.$prevEl;
        if ($prevEl && $prevEl.length > 0) {
            if (swiper.isBeginning) {
                toggleEl2($prevEl, true);
            } else {
                toggleEl2($prevEl, false);
            }
            if (swiper.params.watchOverflow && swiper.enabled) {
                $prevEl[swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
            }
        }
        if ($nextEl && $nextEl.length > 0) {
            if (swiper.isEnd) {
                toggleEl2($nextEl, true);
            } else {
                toggleEl2($nextEl, false);
            }
            if (swiper.params.watchOverflow && swiper.enabled) {
                $nextEl[swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
            }
        }
    },
    onPrevClick: function onPrevClick(e) {
        var swiper = this;
        e.preventDefault();
        if (swiper.isBeginning && !swiper.params.loop) return;
        swiper.slidePrev();
    },
    onNextClick: function onNextClick(e) {
        var swiper = this;
        e.preventDefault();
        if (swiper.isEnd && !swiper.params.loop) return;
        swiper.slideNext();
    },
    init: function init7() {
        var swiper = this;
        var params = swiper.params.navigation;
        swiper.params.navigation = createElementIfNotDefined(swiper.$el, swiper.params.navigation, swiper.params.createElements, {
            nextEl: "swiper-button-next",
            prevEl: "swiper-button-prev"
        });
        if (!(params.nextEl || params.prevEl)) return;
        var $nextEl;
        var $prevEl;
        if (params.nextEl) {
            $nextEl = dom_default(params.nextEl);
            if (swiper.params.uniqueNavElements && typeof params.nextEl === "string" && $nextEl.length > 1 && swiper.$el.find(params.nextEl).length === 1) {
                $nextEl = swiper.$el.find(params.nextEl);
            }
        }
        if (params.prevEl) {
            $prevEl = dom_default(params.prevEl);
            if (swiper.params.uniqueNavElements && typeof params.prevEl === "string" && $prevEl.length > 1 && swiper.$el.find(params.prevEl).length === 1) {
                $prevEl = swiper.$el.find(params.prevEl);
            }
        }
        if ($nextEl && $nextEl.length > 0) {
            $nextEl.on("click", swiper.navigation.onNextClick);
        }
        if ($prevEl && $prevEl.length > 0) {
            $prevEl.on("click", swiper.navigation.onPrevClick);
        }
        extend2(swiper.navigation, {
            $nextEl,
            nextEl: $nextEl && $nextEl[0],
            $prevEl,
            prevEl: $prevEl && $prevEl[0]
        });
        if (!swiper.enabled) {
            if ($nextEl) $nextEl.addClass(params.lockClass);
            if ($prevEl) $prevEl.addClass(params.lockClass);
        }
    },
    destroy: function destroy6() {
        var swiper = this;
        var _swiper$navigation2 = swiper.navigation, $nextEl = _swiper$navigation2.$nextEl, $prevEl = _swiper$navigation2.$prevEl;
        if ($nextEl && $nextEl.length) {
            $nextEl.off("click", swiper.navigation.onNextClick);
            $nextEl.removeClass(swiper.params.navigation.disabledClass);
        }
        if ($prevEl && $prevEl.length) {
            $prevEl.off("click", swiper.navigation.onPrevClick);
            $prevEl.removeClass(swiper.params.navigation.disabledClass);
        }
    }
};
var navigation_default = {
    name: "navigation",
    params: {
        navigation: {
            nextEl: null,
            prevEl: null,
            hideOnClick: false,
            disabledClass: "swiper-button-disabled",
            hiddenClass: "swiper-button-hidden",
            lockClass: "swiper-button-lock"
        }
    },
    create: function create7() {
        var swiper = this;
        bindModuleMethods(swiper, {
            navigation: _extends5({}, Navigation)
        });
    },
    on: {
        init: function init8(swiper) {
            swiper.navigation.init();
            swiper.navigation.update();
        },
        toEdge: function toEdge(swiper) {
            swiper.navigation.update();
        },
        fromEdge: function fromEdge(swiper) {
            swiper.navigation.update();
        },
        destroy: function destroy7(swiper) {
            swiper.navigation.destroy();
        },
        "enable disable": function enableDisable(swiper) {
            var _swiper$navigation3 = swiper.navigation, $nextEl = _swiper$navigation3.$nextEl, $prevEl = _swiper$navigation3.$prevEl;
            if ($nextEl) {
                $nextEl[swiper.enabled ? "removeClass" : "addClass"](swiper.params.navigation.lockClass);
            }
            if ($prevEl) {
                $prevEl[swiper.enabled ? "removeClass" : "addClass"](swiper.params.navigation.lockClass);
            }
        },
        click: function click2(swiper, e) {
            var _swiper$navigation4 = swiper.navigation, $nextEl = _swiper$navigation4.$nextEl, $prevEl = _swiper$navigation4.$prevEl;
            var targetEl = e.target;
            if (swiper.params.navigation.hideOnClick && !dom_default(targetEl).is($prevEl) && !dom_default(targetEl).is($nextEl)) {
                if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
                var isHidden;
                if ($nextEl) {
                    isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
                } else if ($prevEl) {
                    isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
                }
                if (isHidden === true) {
                    swiper.emit("navigationShow");
                } else {
                    swiper.emit("navigationHide");
                }
                if ($nextEl) {
                    $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
                }
                if ($prevEl) {
                    $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
                }
            }
        }
    }
};
// node_modules/swiper/esm/components/pagination/pagination.js
function _extends6() {
    _extends6 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends6.apply(this, arguments);
}
var Pagination = {
    update: function update3() {
        var swiper = this;
        var rtl = swiper.rtl;
        var params = swiper.params.pagination;
        if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
        var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        var $el = swiper.pagination.$el;
        var current;
        var total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
        if (swiper.params.loop) {
            current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
            if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
                current -= slidesLength - swiper.loopedSlides * 2;
            }
            if (current > total - 1) current -= total;
            if (current < 0 && swiper.params.paginationType !== "bullets") current = total + current;
        } else if (typeof swiper.snapIndex !== "undefined") {
            current = swiper.snapIndex;
        } else {
            current = swiper.activeIndex || 0;
        }
        if (params.type === "bullets" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
            var bullets = swiper.pagination.bullets;
            var firstIndex;
            var lastIndex;
            var midIndex;
            if (params.dynamicBullets) {
                swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? "outerWidth" : "outerHeight"](true);
                $el.css(swiper.isHorizontal() ? "width" : "height", swiper.pagination.bulletSize * (params.dynamicMainBullets + 4) + "px");
                if (params.dynamicMainBullets > 1 && swiper.previousIndex !== void 0) {
                    swiper.pagination.dynamicBulletIndex += current - swiper.previousIndex;
                    if (swiper.pagination.dynamicBulletIndex > params.dynamicMainBullets - 1) {
                        swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
                    } else if (swiper.pagination.dynamicBulletIndex < 0) {
                        swiper.pagination.dynamicBulletIndex = 0;
                    }
                }
                firstIndex = current - swiper.pagination.dynamicBulletIndex;
                lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                midIndex = (lastIndex + firstIndex) / 2;
            }
            bullets.removeClass(params.bulletActiveClass + " " + params.bulletActiveClass + "-next " + params.bulletActiveClass + "-next-next " + params.bulletActiveClass + "-prev " + params.bulletActiveClass + "-prev-prev " + params.bulletActiveClass + "-main");
            if ($el.length > 1) {
                bullets.each(function(bullet) {
                    var $bullet2 = dom_default(bullet);
                    var bulletIndex2 = $bullet2.index();
                    if (bulletIndex2 === current) {
                        $bullet2.addClass(params.bulletActiveClass);
                    }
                    if (params.dynamicBullets) {
                        if (bulletIndex2 >= firstIndex && bulletIndex2 <= lastIndex) {
                            $bullet2.addClass(params.bulletActiveClass + "-main");
                        }
                        if (bulletIndex2 === firstIndex) {
                            $bullet2.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
                        }
                        if (bulletIndex2 === lastIndex) {
                            $bullet2.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
                        }
                    }
                });
            } else {
                var $bullet = bullets.eq(current);
                var bulletIndex = $bullet.index();
                $bullet.addClass(params.bulletActiveClass);
                if (params.dynamicBullets) {
                    var $firstDisplayedBullet = bullets.eq(firstIndex);
                    var $lastDisplayedBullet = bullets.eq(lastIndex);
                    for(var i2 = firstIndex; i2 <= lastIndex; i2 += 1){
                        bullets.eq(i2).addClass(params.bulletActiveClass + "-main");
                    }
                    if (swiper.params.loop) {
                        if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
                            for(var _i = params.dynamicMainBullets; _i >= 0; _i -= 1){
                                bullets.eq(bullets.length - _i).addClass(params.bulletActiveClass + "-main");
                            }
                            bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(params.bulletActiveClass + "-prev");
                        } else {
                            $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
                            $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
                        }
                    } else {
                        $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
                        $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
                    }
                }
            }
            if (params.dynamicBullets) {
                var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
                var bulletsOffset = (swiper.pagination.bulletSize * dynamicBulletsLength - swiper.pagination.bulletSize) / 2 - midIndex * swiper.pagination.bulletSize;
                var offsetProp = rtl ? "right" : "left";
                bullets.css(swiper.isHorizontal() ? offsetProp : "top", bulletsOffset + "px");
            }
        }
        if (params.type === "fraction") {
            $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
            $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
        }
        if (params.type === "progressbar") {
            var progressbarDirection;
            if (params.progressbarOpposite) {
                progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal";
            } else {
                progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical";
            }
            var scale = (current + 1) / total;
            var scaleX = 1;
            var scaleY = 1;
            if (progressbarDirection === "horizontal") {
                scaleX = scale;
            } else {
                scaleY = scale;
            }
            $el.find(classesToSelector(params.progressbarFillClass)).transform("translate3d(0,0,0) scaleX(" + scaleX + ") scaleY(" + scaleY + ")").transition(swiper.params.speed);
        }
        if (params.type === "custom" && params.renderCustom) {
            $el.html(params.renderCustom(swiper, current + 1, total));
            swiper.emit("paginationRender", $el[0]);
        } else {
            swiper.emit("paginationUpdate", $el[0]);
        }
        if (swiper.params.watchOverflow && swiper.enabled) {
            $el[swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
        }
    },
    render: function render() {
        var swiper = this;
        var params = swiper.params.pagination;
        if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
        var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        var $el = swiper.pagination.$el;
        var paginationHTML = "";
        if (params.type === "bullets") {
            var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
            if (swiper.params.freeMode && !swiper.params.loop && numberOfBullets > slidesLength) {
                numberOfBullets = slidesLength;
            }
            for(var i2 = 0; i2 < numberOfBullets; i2 += 1){
                if (params.renderBullet) {
                    paginationHTML += params.renderBullet.call(swiper, i2, params.bulletClass);
                } else {
                    paginationHTML += "<" + params.bulletElement + ' class="' + params.bulletClass + '"></' + params.bulletElement + ">";
                }
            }
            $el.html(paginationHTML);
            swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
        }
        if (params.type === "fraction") {
            if (params.renderFraction) {
                paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
            } else {
                paginationHTML = '<span class="' + params.currentClass + '"></span> / ' + ('<span class="' + params.totalClass + '"></span>');
            }
            $el.html(paginationHTML);
        }
        if (params.type === "progressbar") {
            if (params.renderProgressbar) {
                paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
            } else {
                paginationHTML = '<span class="' + params.progressbarFillClass + '"></span>';
            }
            $el.html(paginationHTML);
        }
        if (params.type !== "custom") {
            swiper.emit("paginationRender", swiper.pagination.$el[0]);
        }
    },
    init: function init9() {
        var swiper = this;
        swiper.params.pagination = createElementIfNotDefined(swiper.$el, swiper.params.pagination, swiper.params.createElements, {
            el: "swiper-pagination"
        });
        var params = swiper.params.pagination;
        if (!params.el) return;
        var $el = dom_default(params.el);
        if ($el.length === 0) return;
        if (swiper.params.uniqueNavElements && typeof params.el === "string" && $el.length > 1) {
            $el = swiper.$el.find(params.el);
        }
        if (params.type === "bullets" && params.clickable) {
            $el.addClass(params.clickableClass);
        }
        $el.addClass(params.modifierClass + params.type);
        if (params.type === "bullets" && params.dynamicBullets) {
            $el.addClass("" + params.modifierClass + params.type + "-dynamic");
            swiper.pagination.dynamicBulletIndex = 0;
            if (params.dynamicMainBullets < 1) {
                params.dynamicMainBullets = 1;
            }
        }
        if (params.type === "progressbar" && params.progressbarOpposite) {
            $el.addClass(params.progressbarOppositeClass);
        }
        if (params.clickable) {
            $el.on("click", classesToSelector(params.bulletClass), function onClick2(e) {
                e.preventDefault();
                var index2 = dom_default(this).index() * swiper.params.slidesPerGroup;
                if (swiper.params.loop) index2 += swiper.loopedSlides;
                swiper.slideTo(index2);
            });
        }
        extend2(swiper.pagination, {
            $el,
            el: $el[0]
        });
        if (!swiper.enabled) {
            $el.addClass(params.lockClass);
        }
    },
    destroy: function destroy8() {
        var swiper = this;
        var params = swiper.params.pagination;
        if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
        var $el = swiper.pagination.$el;
        $el.removeClass(params.hiddenClass);
        $el.removeClass(params.modifierClass + params.type);
        if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
        if (params.clickable) {
            $el.off("click", classesToSelector(params.bulletClass));
        }
    }
};
var pagination_default = {
    name: "pagination",
    params: {
        pagination: {
            el: null,
            bulletElement: "span",
            clickable: false,
            hideOnClick: false,
            renderBullet: null,
            renderProgressbar: null,
            renderFraction: null,
            renderCustom: null,
            progressbarOpposite: false,
            type: "bullets",
            // 'bullets' or 'progressbar' or 'fraction' or 'custom'
            dynamicBullets: false,
            dynamicMainBullets: 1,
            formatFractionCurrent: function formatFractionCurrent(number2) {
                return number2;
            },
            formatFractionTotal: function formatFractionTotal(number2) {
                return number2;
            },
            bulletClass: "swiper-pagination-bullet",
            bulletActiveClass: "swiper-pagination-bullet-active",
            modifierClass: "swiper-pagination-",
            // NEW
            currentClass: "swiper-pagination-current",
            totalClass: "swiper-pagination-total",
            hiddenClass: "swiper-pagination-hidden",
            progressbarFillClass: "swiper-pagination-progressbar-fill",
            progressbarOppositeClass: "swiper-pagination-progressbar-opposite",
            clickableClass: "swiper-pagination-clickable",
            // NEW
            lockClass: "swiper-pagination-lock"
        }
    },
    create: function create8() {
        var swiper = this;
        bindModuleMethods(swiper, {
            pagination: _extends6({
                dynamicBulletIndex: 0
            }, Pagination)
        });
    },
    on: {
        init: function init10(swiper) {
            swiper.pagination.init();
            swiper.pagination.render();
            swiper.pagination.update();
        },
        activeIndexChange: function activeIndexChange(swiper) {
            if (swiper.params.loop) {
                swiper.pagination.update();
            } else if (typeof swiper.snapIndex === "undefined") {
                swiper.pagination.update();
            }
        },
        snapIndexChange: function snapIndexChange(swiper) {
            if (!swiper.params.loop) {
                swiper.pagination.update();
            }
        },
        slidesLengthChange: function slidesLengthChange(swiper) {
            if (swiper.params.loop) {
                swiper.pagination.render();
                swiper.pagination.update();
            }
        },
        snapGridLengthChange: function snapGridLengthChange(swiper) {
            if (!swiper.params.loop) {
                swiper.pagination.render();
                swiper.pagination.update();
            }
        },
        destroy: function destroy9(swiper) {
            swiper.pagination.destroy();
        },
        "enable disable": function enableDisable2(swiper) {
            var $el = swiper.pagination.$el;
            if ($el) {
                $el[swiper.enabled ? "removeClass" : "addClass"](swiper.params.pagination.lockClass);
            }
        },
        click: function click3(swiper, e) {
            var targetEl = e.target;
            if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && swiper.pagination.$el.length > 0 && !dom_default(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
                if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
                var isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);
                if (isHidden === true) {
                    swiper.emit("paginationShow");
                } else {
                    swiper.emit("paginationHide");
                }
                swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
            }
        }
    }
};
// node_modules/swiper/esm/components/scrollbar/scrollbar.js
function _extends7() {
    _extends7 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends7.apply(this, arguments);
}
var Scrollbar = {
    setTranslate: function setTranslate3() {
        var swiper = this;
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        var scrollbar = swiper.scrollbar, rtl = swiper.rtlTranslate, progress = swiper.progress;
        var dragSize = scrollbar.dragSize, trackSize = scrollbar.trackSize, $dragEl = scrollbar.$dragEl, $el = scrollbar.$el;
        var params = swiper.params.scrollbar;
        var newSize = dragSize;
        var newPos = (trackSize - dragSize) * progress;
        if (rtl) {
            newPos = -newPos;
            if (newPos > 0) {
                newSize = dragSize - newPos;
                newPos = 0;
            } else if (-newPos + dragSize > trackSize) {
                newSize = trackSize + newPos;
            }
        } else if (newPos < 0) {
            newSize = dragSize + newPos;
            newPos = 0;
        } else if (newPos + dragSize > trackSize) {
            newSize = trackSize - newPos;
        }
        if (swiper.isHorizontal()) {
            $dragEl.transform("translate3d(" + newPos + "px, 0, 0)");
            $dragEl[0].style.width = newSize + "px";
        } else {
            $dragEl.transform("translate3d(0px, " + newPos + "px, 0)");
            $dragEl[0].style.height = newSize + "px";
        }
        if (params.hide) {
            clearTimeout(swiper.scrollbar.timeout);
            $el[0].style.opacity = 1;
            swiper.scrollbar.timeout = setTimeout(function() {
                $el[0].style.opacity = 0;
                $el.transition(400);
            }, 1e3);
        }
    },
    setTransition: function setTransition2(duration) {
        var swiper = this;
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        swiper.scrollbar.$dragEl.transition(duration);
    },
    updateSize: function updateSize2() {
        var swiper = this;
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        var scrollbar = swiper.scrollbar;
        var $dragEl = scrollbar.$dragEl, $el = scrollbar.$el;
        $dragEl[0].style.width = "";
        $dragEl[0].style.height = "";
        var trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
        var divider = swiper.size / swiper.virtualSize;
        var moveDivider = divider * (trackSize / swiper.size);
        var dragSize;
        if (swiper.params.scrollbar.dragSize === "auto") {
            dragSize = trackSize * divider;
        } else {
            dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
        }
        if (swiper.isHorizontal()) {
            $dragEl[0].style.width = dragSize + "px";
        } else {
            $dragEl[0].style.height = dragSize + "px";
        }
        if (divider >= 1) {
            $el[0].style.display = "none";
        } else {
            $el[0].style.display = "";
        }
        if (swiper.params.scrollbar.hide) {
            $el[0].style.opacity = 0;
        }
        extend2(scrollbar, {
            trackSize,
            divider,
            moveDivider,
            dragSize
        });
        if (swiper.params.watchOverflow && swiper.enabled) {
            scrollbar.$el[swiper.isLocked ? "addClass" : "removeClass"](swiper.params.scrollbar.lockClass);
        }
    },
    getPointerPosition: function getPointerPosition(e) {
        var swiper = this;
        if (swiper.isHorizontal()) {
            return e.type === "touchstart" || e.type === "touchmove" ? e.targetTouches[0].clientX : e.clientX;
        }
        return e.type === "touchstart" || e.type === "touchmove" ? e.targetTouches[0].clientY : e.clientY;
    },
    setDragPosition: function setDragPosition(e) {
        var swiper = this;
        var scrollbar = swiper.scrollbar, rtl = swiper.rtlTranslate;
        var $el = scrollbar.$el, dragSize = scrollbar.dragSize, trackSize = scrollbar.trackSize, dragStartPos = scrollbar.dragStartPos;
        var positionRatio;
        positionRatio = (scrollbar.getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? "left" : "top"] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
        positionRatio = Math.max(Math.min(positionRatio, 1), 0);
        if (rtl) {
            positionRatio = 1 - positionRatio;
        }
        var position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
        swiper.updateProgress(position);
        swiper.setTranslate(position);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
    },
    onDragStart: function onDragStart(e) {
        var swiper = this;
        var params = swiper.params.scrollbar;
        var scrollbar = swiper.scrollbar, $wrapperEl = swiper.$wrapperEl;
        var $el = scrollbar.$el, $dragEl = scrollbar.$dragEl;
        swiper.scrollbar.isTouched = true;
        swiper.scrollbar.dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? scrollbar.getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? "left" : "top"] : null;
        e.preventDefault();
        e.stopPropagation();
        $wrapperEl.transition(100);
        $dragEl.transition(100);
        scrollbar.setDragPosition(e);
        clearTimeout(swiper.scrollbar.dragTimeout);
        $el.transition(0);
        if (params.hide) {
            $el.css("opacity", 1);
        }
        if (swiper.params.cssMode) {
            swiper.$wrapperEl.css("scroll-snap-type", "none");
        }
        swiper.emit("scrollbarDragStart", e);
    },
    onDragMove: function onDragMove(e) {
        var swiper = this;
        var scrollbar = swiper.scrollbar, $wrapperEl = swiper.$wrapperEl;
        var $el = scrollbar.$el, $dragEl = scrollbar.$dragEl;
        if (!swiper.scrollbar.isTouched) return;
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
        scrollbar.setDragPosition(e);
        $wrapperEl.transition(0);
        $el.transition(0);
        $dragEl.transition(0);
        swiper.emit("scrollbarDragMove", e);
    },
    onDragEnd: function onDragEnd(e) {
        var swiper = this;
        var params = swiper.params.scrollbar;
        var scrollbar = swiper.scrollbar, $wrapperEl = swiper.$wrapperEl;
        var $el = scrollbar.$el;
        if (!swiper.scrollbar.isTouched) return;
        swiper.scrollbar.isTouched = false;
        if (swiper.params.cssMode) {
            swiper.$wrapperEl.css("scroll-snap-type", "");
            $wrapperEl.transition("");
        }
        if (params.hide) {
            clearTimeout(swiper.scrollbar.dragTimeout);
            swiper.scrollbar.dragTimeout = nextTick4(function() {
                $el.css("opacity", 0);
                $el.transition(400);
            }, 1e3);
        }
        swiper.emit("scrollbarDragEnd", e);
        if (params.snapOnRelease) {
            swiper.slideToClosest();
        }
    },
    enableDraggable: function enableDraggable() {
        var swiper = this;
        if (!swiper.params.scrollbar.el) return;
        var document2 = getDocument();
        var scrollbar = swiper.scrollbar, touchEventsTouch = swiper.touchEventsTouch, touchEventsDesktop = swiper.touchEventsDesktop, params = swiper.params, support3 = swiper.support;
        var $el = scrollbar.$el;
        var target = $el[0];
        var activeListener = support3.passiveListener && params.passiveListeners ? {
            passive: false,
            capture: false
        } : false;
        var passiveListener = support3.passiveListener && params.passiveListeners ? {
            passive: true,
            capture: false
        } : false;
        if (!target) return;
        if (!support3.touch) {
            target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
            document2.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
            document2.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
        } else {
            target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
            target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
            target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
        }
    },
    disableDraggable: function disableDraggable() {
        var swiper = this;
        if (!swiper.params.scrollbar.el) return;
        var document2 = getDocument();
        var scrollbar = swiper.scrollbar, touchEventsTouch = swiper.touchEventsTouch, touchEventsDesktop = swiper.touchEventsDesktop, params = swiper.params, support3 = swiper.support;
        var $el = scrollbar.$el;
        var target = $el[0];
        var activeListener = support3.passiveListener && params.passiveListeners ? {
            passive: false,
            capture: false
        } : false;
        var passiveListener = support3.passiveListener && params.passiveListeners ? {
            passive: true,
            capture: false
        } : false;
        if (!target) return;
        if (!support3.touch) {
            target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
            document2.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
            document2.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
        } else {
            target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
            target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
            target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
        }
    },
    init: function init11() {
        var swiper = this;
        var scrollbar = swiper.scrollbar, $swiperEl = swiper.$el;
        swiper.params.scrollbar = createElementIfNotDefined($swiperEl, swiper.params.scrollbar, swiper.params.createElements, {
            el: "swiper-scrollbar"
        });
        var params = swiper.params.scrollbar;
        if (!params.el) return;
        var $el = dom_default(params.el);
        if (swiper.params.uniqueNavElements && typeof params.el === "string" && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
            $el = $swiperEl.find(params.el);
        }
        var $dragEl = $el.find("." + swiper.params.scrollbar.dragClass);
        if ($dragEl.length === 0) {
            $dragEl = dom_default('<div class="' + swiper.params.scrollbar.dragClass + '"></div>');
            $el.append($dragEl);
        }
        extend2(scrollbar, {
            $el,
            el: $el[0],
            $dragEl,
            dragEl: $dragEl[0]
        });
        if (params.draggable) {
            scrollbar.enableDraggable();
        }
        if ($el) {
            $el[swiper.enabled ? "removeClass" : "addClass"](swiper.params.scrollbar.lockClass);
        }
    },
    destroy: function destroy10() {
        var swiper = this;
        swiper.scrollbar.disableDraggable();
    }
};
var scrollbar_default = {
    name: "scrollbar",
    params: {
        scrollbar: {
            el: null,
            dragSize: "auto",
            hide: false,
            draggable: false,
            snapOnRelease: true,
            lockClass: "swiper-scrollbar-lock",
            dragClass: "swiper-scrollbar-drag"
        }
    },
    create: function create9() {
        var swiper = this;
        bindModuleMethods(swiper, {
            scrollbar: _extends7({
                isTouched: false,
                timeout: null,
                dragTimeout: null
            }, Scrollbar)
        });
    },
    on: {
        init: function init12(swiper) {
            swiper.scrollbar.init();
            swiper.scrollbar.updateSize();
            swiper.scrollbar.setTranslate();
        },
        update: function update4(swiper) {
            swiper.scrollbar.updateSize();
        },
        resize: function resize2(swiper) {
            swiper.scrollbar.updateSize();
        },
        observerUpdate: function observerUpdate(swiper) {
            swiper.scrollbar.updateSize();
        },
        setTranslate: function setTranslate4(swiper) {
            swiper.scrollbar.setTranslate();
        },
        setTransition: function setTransition3(swiper, duration) {
            swiper.scrollbar.setTransition(duration);
        },
        "enable disable": function enableDisable3(swiper) {
            var $el = swiper.scrollbar.$el;
            if ($el) {
                $el[swiper.enabled ? "removeClass" : "addClass"](swiper.params.scrollbar.lockClass);
            }
        },
        destroy: function destroy11(swiper) {
            swiper.scrollbar.destroy();
        }
    }
};
// node_modules/swiper/esm/components/parallax/parallax.js
function _extends8() {
    _extends8 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends8.apply(this, arguments);
}
var Parallax = {
    setTransform: function setTransform3(el, progress) {
        var swiper = this;
        var rtl = swiper.rtl;
        var $el = dom_default(el);
        var rtlFactor = rtl ? -1 : 1;
        var p = $el.attr("data-swiper-parallax") || "0";
        var x = $el.attr("data-swiper-parallax-x");
        var y = $el.attr("data-swiper-parallax-y");
        var scale = $el.attr("data-swiper-parallax-scale");
        var opacity = $el.attr("data-swiper-parallax-opacity");
        if (x || y) {
            x = x || "0";
            y = y || "0";
        } else if (swiper.isHorizontal()) {
            x = p;
            y = "0";
        } else {
            y = p;
            x = "0";
        }
        if (x.indexOf("%") >= 0) {
            x = parseInt(x, 10) * progress * rtlFactor + "%";
        } else {
            x = x * progress * rtlFactor + "px";
        }
        if (y.indexOf("%") >= 0) {
            y = parseInt(y, 10) * progress + "%";
        } else {
            y = y * progress + "px";
        }
        if (typeof opacity !== "undefined" && opacity !== null) {
            var currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
            $el[0].style.opacity = currentOpacity;
        }
        if (typeof scale === "undefined" || scale === null) {
            $el.transform("translate3d(" + x + ", " + y + ", 0px)");
        } else {
            var currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
            $el.transform("translate3d(" + x + ", " + y + ", 0px) scale(" + currentScale + ")");
        }
    },
    setTranslate: function setTranslate5() {
        var swiper = this;
        var $el = swiper.$el, slides = swiper.slides, progress = swiper.progress, snapGrid = swiper.snapGrid;
        $el.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(function(el) {
            swiper.parallax.setTransform(el, progress);
        });
        slides.each(function(slideEl, slideIndex) {
            var slideProgress = slideEl.progress;
            if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== "auto") {
                slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
            }
            slideProgress = Math.min(Math.max(slideProgress, -1), 1);
            dom_default(slideEl).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(function(el) {
                swiper.parallax.setTransform(el, slideProgress);
            });
        });
    },
    setTransition: function setTransition4(duration) {
        if (duration === void 0) {
            duration = this.params.speed;
        }
        var swiper = this;
        var $el = swiper.$el;
        $el.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(function(parallaxEl) {
            var $parallaxEl = dom_default(parallaxEl);
            var parallaxDuration = parseInt($parallaxEl.attr("data-swiper-parallax-duration"), 10) || duration;
            if (duration === 0) parallaxDuration = 0;
            $parallaxEl.transition(parallaxDuration);
        });
    }
};
var parallax_default = {
    name: "parallax",
    params: {
        parallax: {
            enabled: false
        }
    },
    create: function create10() {
        var swiper = this;
        bindModuleMethods(swiper, {
            parallax: _extends8({}, Parallax)
        });
    },
    on: {
        beforeInit: function beforeInit2(swiper) {
            if (!swiper.params.parallax.enabled) return;
            swiper.params.watchSlidesProgress = true;
            swiper.originalParams.watchSlidesProgress = true;
        },
        init: function init13(swiper) {
            if (!swiper.params.parallax.enabled) return;
            swiper.parallax.setTranslate();
        },
        setTranslate: function setTranslate6(swiper) {
            if (!swiper.params.parallax.enabled) return;
            swiper.parallax.setTranslate();
        },
        setTransition: function setTransition5(swiper, duration) {
            if (!swiper.params.parallax.enabled) return;
            swiper.parallax.setTransition(duration);
        }
    }
};
// node_modules/swiper/esm/components/zoom/zoom.js
function _extends9() {
    _extends9 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends9.apply(this, arguments);
}
var Zoom = {
    // Calc Scale From Multi-touches
    getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {
        if (e.targetTouches.length < 2) return 1;
        var x1 = e.targetTouches[0].pageX;
        var y1 = e.targetTouches[0].pageY;
        var x2 = e.targetTouches[1].pageX;
        var y2 = e.targetTouches[1].pageY;
        var distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        return distance;
    },
    // Events
    onGestureStart: function onGestureStart(e) {
        var swiper = this;
        var support3 = swiper.support;
        var params = swiper.params.zoom;
        var zoom = swiper.zoom;
        var gesture = zoom.gesture;
        zoom.fakeGestureTouched = false;
        zoom.fakeGestureMoved = false;
        if (!support3.gestures) {
            if (e.type !== "touchstart" || e.type === "touchstart" && e.targetTouches.length < 2) {
                return;
            }
            zoom.fakeGestureTouched = true;
            gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
        }
        if (!gesture.$slideEl || !gesture.$slideEl.length) {
            gesture.$slideEl = dom_default(e.target).closest("." + swiper.params.slideClass);
            if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
            gesture.$imageEl = gesture.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target");
            gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
            gesture.maxRatio = gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio;
            if (gesture.$imageWrapEl.length === 0) {
                gesture.$imageEl = void 0;
                return;
            }
        }
        if (gesture.$imageEl) {
            gesture.$imageEl.transition(0);
        }
        swiper.zoom.isScaling = true;
    },
    onGestureChange: function onGestureChange(e) {
        var swiper = this;
        var support3 = swiper.support;
        var params = swiper.params.zoom;
        var zoom = swiper.zoom;
        var gesture = zoom.gesture;
        if (!support3.gestures) {
            if (e.type !== "touchmove" || e.type === "touchmove" && e.targetTouches.length < 2) {
                return;
            }
            zoom.fakeGestureMoved = true;
            gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
        }
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
            if (e.type === "gesturechange") zoom.onGestureStart(e);
            return;
        }
        if (support3.gestures) {
            zoom.scale = e.scale * zoom.currentScale;
        } else {
            zoom.scale = gesture.scaleMove / gesture.scaleStart * zoom.currentScale;
        }
        if (zoom.scale > gesture.maxRatio) {
            zoom.scale = gesture.maxRatio - 1 + Math.pow(zoom.scale - gesture.maxRatio + 1, 0.5);
        }
        if (zoom.scale < params.minRatio) {
            zoom.scale = params.minRatio + 1 - Math.pow(params.minRatio - zoom.scale + 1, 0.5);
        }
        gesture.$imageEl.transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
    },
    onGestureEnd: function onGestureEnd(e) {
        var swiper = this;
        var device2 = swiper.device;
        var support3 = swiper.support;
        var params = swiper.params.zoom;
        var zoom = swiper.zoom;
        var gesture = zoom.gesture;
        if (!support3.gestures) {
            if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
                return;
            }
            if (e.type !== "touchend" || e.type === "touchend" && e.changedTouches.length < 2 && !device2.android) {
                return;
            }
            zoom.fakeGestureTouched = false;
            zoom.fakeGestureMoved = false;
        }
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
        gesture.$imageEl.transition(swiper.params.speed).transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
        zoom.currentScale = zoom.scale;
        zoom.isScaling = false;
        if (zoom.scale === 1) gesture.$slideEl = void 0;
    },
    onTouchStart: function onTouchStart2(e) {
        var swiper = this;
        var device2 = swiper.device;
        var zoom = swiper.zoom;
        var gesture = zoom.gesture, image = zoom.image;
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        if (image.isTouched) return;
        if (device2.android && e.cancelable) e.preventDefault();
        image.isTouched = true;
        image.touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
        image.touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    },
    onTouchMove: function onTouchMove2(e) {
        var swiper = this;
        var zoom = swiper.zoom;
        var gesture = zoom.gesture, image = zoom.image, velocity = zoom.velocity;
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        swiper.allowClick = false;
        if (!image.isTouched || !gesture.$slideEl) return;
        if (!image.isMoved) {
            image.width = gesture.$imageEl[0].offsetWidth;
            image.height = gesture.$imageEl[0].offsetHeight;
            image.startX = getTranslate(gesture.$imageWrapEl[0], "x") || 0;
            image.startY = getTranslate(gesture.$imageWrapEl[0], "y") || 0;
            gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
            gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
            gesture.$imageWrapEl.transition(0);
        }
        var scaledWidth = image.width * zoom.scale;
        var scaledHeight = image.height * zoom.scale;
        if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;
        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
        image.maxX = -image.minX;
        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
        image.maxY = -image.minY;
        image.touchesCurrent.x = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
        image.touchesCurrent.y = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
        if (!image.isMoved && !zoom.isScaling) {
            if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
                image.isTouched = false;
                return;
            }
            if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
                image.isTouched = false;
                return;
            }
        }
        if (e.cancelable) {
            e.preventDefault();
        }
        e.stopPropagation();
        image.isMoved = true;
        image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
        image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;
        if (image.currentX < image.minX) {
            image.currentX = image.minX + 1 - Math.pow(image.minX - image.currentX + 1, 0.8);
        }
        if (image.currentX > image.maxX) {
            image.currentX = image.maxX - 1 + Math.pow(image.currentX - image.maxX + 1, 0.8);
        }
        if (image.currentY < image.minY) {
            image.currentY = image.minY + 1 - Math.pow(image.minY - image.currentY + 1, 0.8);
        }
        if (image.currentY > image.maxY) {
            image.currentY = image.maxY - 1 + Math.pow(image.currentY - image.maxY + 1, 0.8);
        }
        if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
        if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
        if (!velocity.prevTime) velocity.prevTime = Date.now();
        velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
        velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
        if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
        if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
        velocity.prevPositionX = image.touchesCurrent.x;
        velocity.prevPositionY = image.touchesCurrent.y;
        velocity.prevTime = Date.now();
        gesture.$imageWrapEl.transform("translate3d(" + image.currentX + "px, " + image.currentY + "px,0)");
    },
    onTouchEnd: function onTouchEnd2() {
        var swiper = this;
        var zoom = swiper.zoom;
        var gesture = zoom.gesture, image = zoom.image, velocity = zoom.velocity;
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        if (!image.isTouched || !image.isMoved) {
            image.isTouched = false;
            image.isMoved = false;
            return;
        }
        image.isTouched = false;
        image.isMoved = false;
        var momentumDurationX = 300;
        var momentumDurationY = 300;
        var momentumDistanceX = velocity.x * momentumDurationX;
        var newPositionX = image.currentX + momentumDistanceX;
        var momentumDistanceY = velocity.y * momentumDurationY;
        var newPositionY = image.currentY + momentumDistanceY;
        if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
        if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
        var momentumDuration = Math.max(momentumDurationX, momentumDurationY);
        image.currentX = newPositionX;
        image.currentY = newPositionY;
        var scaledWidth = image.width * zoom.scale;
        var scaledHeight = image.height * zoom.scale;
        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
        image.maxX = -image.minX;
        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
        image.maxY = -image.minY;
        image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
        image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
        gesture.$imageWrapEl.transition(momentumDuration).transform("translate3d(" + image.currentX + "px, " + image.currentY + "px,0)");
    },
    onTransitionEnd: function onTransitionEnd() {
        var swiper = this;
        var zoom = swiper.zoom;
        var gesture = zoom.gesture;
        if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
            if (gesture.$imageEl) {
                gesture.$imageEl.transform("translate3d(0,0,0) scale(1)");
            }
            if (gesture.$imageWrapEl) {
                gesture.$imageWrapEl.transform("translate3d(0,0,0)");
            }
            zoom.scale = 1;
            zoom.currentScale = 1;
            gesture.$slideEl = void 0;
            gesture.$imageEl = void 0;
            gesture.$imageWrapEl = void 0;
        }
    },
    // Toggle Zoom
    toggle: function toggle(e) {
        var swiper = this;
        var zoom = swiper.zoom;
        if (zoom.scale && zoom.scale !== 1) {
            zoom.out();
        } else {
            zoom.in(e);
        }
    },
    in: function _in(e) {
        var swiper = this;
        var window2 = getWindow();
        var zoom = swiper.zoom;
        var params = swiper.params.zoom;
        var gesture = zoom.gesture, image = zoom.image;
        if (!gesture.$slideEl) {
            if (e && e.target) {
                gesture.$slideEl = dom_default(e.target).closest("." + swiper.params.slideClass);
            }
            if (!gesture.$slideEl) {
                if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
                    gesture.$slideEl = swiper.$wrapperEl.children("." + swiper.params.slideActiveClass);
                } else {
                    gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
                }
            }
            gesture.$imageEl = gesture.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target");
            gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
        }
        if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;
        gesture.$slideEl.addClass("" + params.zoomedSlideClass);
        var touchX;
        var touchY;
        var offsetX;
        var offsetY;
        var diffX;
        var diffY;
        var translateX;
        var translateY;
        var imageWidth;
        var imageHeight;
        var scaledWidth;
        var scaledHeight;
        var translateMinX;
        var translateMinY;
        var translateMaxX;
        var translateMaxY;
        var slideWidth;
        var slideHeight;
        if (typeof image.touchesStart.x === "undefined" && e) {
            touchX = e.type === "touchend" ? e.changedTouches[0].pageX : e.pageX;
            touchY = e.type === "touchend" ? e.changedTouches[0].pageY : e.pageY;
        } else {
            touchX = image.touchesStart.x;
            touchY = image.touchesStart.y;
        }
        zoom.scale = gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio;
        zoom.currentScale = gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio;
        if (e) {
            slideWidth = gesture.$slideEl[0].offsetWidth;
            slideHeight = gesture.$slideEl[0].offsetHeight;
            offsetX = gesture.$slideEl.offset().left + window2.scrollX;
            offsetY = gesture.$slideEl.offset().top + window2.scrollY;
            diffX = offsetX + slideWidth / 2 - touchX;
            diffY = offsetY + slideHeight / 2 - touchY;
            imageWidth = gesture.$imageEl[0].offsetWidth;
            imageHeight = gesture.$imageEl[0].offsetHeight;
            scaledWidth = imageWidth * zoom.scale;
            scaledHeight = imageHeight * zoom.scale;
            translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
            translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
            translateMaxX = -translateMinX;
            translateMaxY = -translateMinY;
            translateX = diffX * zoom.scale;
            translateY = diffY * zoom.scale;
            if (translateX < translateMinX) {
                translateX = translateMinX;
            }
            if (translateX > translateMaxX) {
                translateX = translateMaxX;
            }
            if (translateY < translateMinY) {
                translateY = translateMinY;
            }
            if (translateY > translateMaxY) {
                translateY = translateMaxY;
            }
        } else {
            translateX = 0;
            translateY = 0;
        }
        gesture.$imageWrapEl.transition(300).transform("translate3d(" + translateX + "px, " + translateY + "px,0)");
        gesture.$imageEl.transition(300).transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
    },
    out: function out() {
        var swiper = this;
        var zoom = swiper.zoom;
        var params = swiper.params.zoom;
        var gesture = zoom.gesture;
        if (!gesture.$slideEl) {
            if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
                gesture.$slideEl = swiper.$wrapperEl.children("." + swiper.params.slideActiveClass);
            } else {
                gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
            }
            gesture.$imageEl = gesture.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target");
            gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
        }
        if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;
        zoom.scale = 1;
        zoom.currentScale = 1;
        gesture.$imageWrapEl.transition(300).transform("translate3d(0,0,0)");
        gesture.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)");
        gesture.$slideEl.removeClass("" + params.zoomedSlideClass);
        gesture.$slideEl = void 0;
    },
    toggleGestures: function toggleGestures(method) {
        var swiper = this;
        var zoom = swiper.zoom;
        var selector = zoom.slideSelector, passive = zoom.passiveListener;
        swiper.$wrapperEl[method]("gesturestart", selector, zoom.onGestureStart, passive);
        swiper.$wrapperEl[method]("gesturechange", selector, zoom.onGestureChange, passive);
        swiper.$wrapperEl[method]("gestureend", selector, zoom.onGestureEnd, passive);
    },
    enableGestures: function enableGestures() {
        if (this.zoom.gesturesEnabled) return;
        this.zoom.gesturesEnabled = true;
        this.zoom.toggleGestures("on");
    },
    disableGestures: function disableGestures() {
        if (!this.zoom.gesturesEnabled) return;
        this.zoom.gesturesEnabled = false;
        this.zoom.toggleGestures("off");
    },
    // Attach/Detach Events
    enable: function enable3() {
        var swiper = this;
        var support3 = swiper.support;
        var zoom = swiper.zoom;
        if (zoom.enabled) return;
        zoom.enabled = true;
        var passiveListener = swiper.touchEvents.start === "touchstart" && support3.passiveListener && swiper.params.passiveListeners ? {
            passive: true,
            capture: false
        } : false;
        var activeListenerWithCapture = support3.passiveListener ? {
            passive: false,
            capture: true
        } : true;
        var slideSelector = "." + swiper.params.slideClass;
        swiper.zoom.passiveListener = passiveListener;
        swiper.zoom.slideSelector = slideSelector;
        if (support3.gestures) {
            swiper.$wrapperEl.on(swiper.touchEvents.start, swiper.zoom.enableGestures, passiveListener);
            swiper.$wrapperEl.on(swiper.touchEvents.end, swiper.zoom.disableGestures, passiveListener);
        } else if (swiper.touchEvents.start === "touchstart") {
            swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
            swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
            swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);
            if (swiper.touchEvents.cancel) {
                swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
            }
        }
        swiper.$wrapperEl.on(swiper.touchEvents.move, "." + swiper.params.zoom.containerClass, zoom.onTouchMove, activeListenerWithCapture);
    },
    disable: function disable3() {
        var swiper = this;
        var zoom = swiper.zoom;
        if (!zoom.enabled) return;
        var support3 = swiper.support;
        swiper.zoom.enabled = false;
        var passiveListener = swiper.touchEvents.start === "touchstart" && support3.passiveListener && swiper.params.passiveListeners ? {
            passive: true,
            capture: false
        } : false;
        var activeListenerWithCapture = support3.passiveListener ? {
            passive: false,
            capture: true
        } : true;
        var slideSelector = "." + swiper.params.slideClass;
        if (support3.gestures) {
            swiper.$wrapperEl.off(swiper.touchEvents.start, swiper.zoom.enableGestures, passiveListener);
            swiper.$wrapperEl.off(swiper.touchEvents.end, swiper.zoom.disableGestures, passiveListener);
        } else if (swiper.touchEvents.start === "touchstart") {
            swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
            swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
            swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);
            if (swiper.touchEvents.cancel) {
                swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
            }
        }
        swiper.$wrapperEl.off(swiper.touchEvents.move, "." + swiper.params.zoom.containerClass, zoom.onTouchMove, activeListenerWithCapture);
    }
};
var zoom_default = {
    name: "zoom",
    params: {
        zoom: {
            enabled: false,
            maxRatio: 3,
            minRatio: 1,
            toggle: true,
            containerClass: "swiper-zoom-container",
            zoomedSlideClass: "swiper-slide-zoomed"
        }
    },
    create: function create11() {
        var swiper = this;
        bindModuleMethods(swiper, {
            zoom: _extends9({
                enabled: false,
                scale: 1,
                currentScale: 1,
                isScaling: false,
                gesture: {
                    $slideEl: void 0,
                    slideWidth: void 0,
                    slideHeight: void 0,
                    $imageEl: void 0,
                    $imageWrapEl: void 0,
                    maxRatio: 3
                },
                image: {
                    isTouched: void 0,
                    isMoved: void 0,
                    currentX: void 0,
                    currentY: void 0,
                    minX: void 0,
                    minY: void 0,
                    maxX: void 0,
                    maxY: void 0,
                    width: void 0,
                    height: void 0,
                    startX: void 0,
                    startY: void 0,
                    touchesStart: {},
                    touchesCurrent: {}
                },
                velocity: {
                    x: void 0,
                    y: void 0,
                    prevPositionX: void 0,
                    prevPositionY: void 0,
                    prevTime: void 0
                }
            }, Zoom)
        });
        var scale = 1;
        Object.defineProperty(swiper.zoom, "scale", {
            get: function get2() {
                return scale;
            },
            set: function set3(value) {
                if (scale !== value) {
                    var imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : void 0;
                    var slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : void 0;
                    swiper.emit("zoomChange", value, imageEl, slideEl);
                }
                scale = value;
            }
        });
    },
    on: {
        init: function init14(swiper) {
            if (swiper.params.zoom.enabled) {
                swiper.zoom.enable();
            }
        },
        destroy: function destroy12(swiper) {
            swiper.zoom.disable();
        },
        touchStart: function touchStart(swiper, e) {
            if (!swiper.zoom.enabled) return;
            swiper.zoom.onTouchStart(e);
        },
        touchEnd: function touchEnd(swiper, e) {
            if (!swiper.zoom.enabled) return;
            swiper.zoom.onTouchEnd(e);
        },
        doubleTap: function doubleTap(swiper, e) {
            if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
                swiper.zoom.toggle(e);
            }
        },
        transitionEnd: function transitionEnd3(swiper) {
            if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
                swiper.zoom.onTransitionEnd();
            }
        },
        slideChange: function slideChange(swiper) {
            if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
                swiper.zoom.onTransitionEnd();
            }
        }
    }
};
// node_modules/swiper/esm/components/lazy/lazy.js
function _extends10() {
    _extends10 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends10.apply(this, arguments);
}
var Lazy2 = {
    loadInSlide: function loadInSlide(index2, loadInDuplicate) {
        if (loadInDuplicate === void 0) {
            loadInDuplicate = true;
        }
        var swiper = this;
        var params = swiper.params.lazy;
        if (typeof index2 === "undefined") return;
        if (swiper.slides.length === 0) return;
        var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
        var $slideEl = isVirtual ? swiper.$wrapperEl.children("." + swiper.params.slideClass + '[data-swiper-slide-index="' + index2 + '"]') : swiper.slides.eq(index2);
        var $images = $slideEl.find("." + params.elementClass + ":not(." + params.loadedClass + "):not(." + params.loadingClass + ")");
        if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
            $images.push($slideEl[0]);
        }
        if ($images.length === 0) return;
        $images.each(function(imageEl) {
            var $imageEl = dom_default(imageEl);
            $imageEl.addClass(params.loadingClass);
            var background = $imageEl.attr("data-background");
            var src = $imageEl.attr("data-src");
            var srcset = $imageEl.attr("data-srcset");
            var sizes = $imageEl.attr("data-sizes");
            var $pictureEl = $imageEl.parent("picture");
            swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, function() {
                if (typeof swiper === "undefined" || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) return;
                if (background) {
                    $imageEl.css("background-image", 'url("' + background + '")');
                    $imageEl.removeAttr("data-background");
                } else {
                    if (srcset) {
                        $imageEl.attr("srcset", srcset);
                        $imageEl.removeAttr("data-srcset");
                    }
                    if (sizes) {
                        $imageEl.attr("sizes", sizes);
                        $imageEl.removeAttr("data-sizes");
                    }
                    if ($pictureEl.length) {
                        $pictureEl.children("source").each(function(sourceEl) {
                            var $source = dom_default(sourceEl);
                            if ($source.attr("data-srcset")) {
                                $source.attr("srcset", $source.attr("data-srcset"));
                                $source.removeAttr("data-srcset");
                            }
                        });
                    }
                    if (src) {
                        $imageEl.attr("src", src);
                        $imageEl.removeAttr("data-src");
                    }
                }
                $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
                $slideEl.find("." + params.preloaderClass).remove();
                if (swiper.params.loop && loadInDuplicate) {
                    var slideOriginalIndex = $slideEl.attr("data-swiper-slide-index");
                    if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
                        var originalSlide = swiper.$wrapperEl.children('[data-swiper-slide-index="' + slideOriginalIndex + '"]:not(.' + swiper.params.slideDuplicateClass + ")");
                        swiper.lazy.loadInSlide(originalSlide.index(), false);
                    } else {
                        var duplicatedSlide = swiper.$wrapperEl.children("." + swiper.params.slideDuplicateClass + '[data-swiper-slide-index="' + slideOriginalIndex + '"]');
                        swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
                    }
                }
                swiper.emit("lazyImageReady", $slideEl[0], $imageEl[0]);
                if (swiper.params.autoHeight) {
                    swiper.updateAutoHeight();
                }
            });
            swiper.emit("lazyImageLoad", $slideEl[0], $imageEl[0]);
        });
    },
    load: function load() {
        var swiper = this;
        var $wrapperEl = swiper.$wrapperEl, swiperParams = swiper.params, slides = swiper.slides, activeIndex = swiper.activeIndex;
        var isVirtual = swiper.virtual && swiperParams.virtual.enabled;
        var params = swiperParams.lazy;
        var slidesPerView = swiperParams.slidesPerView;
        if (slidesPerView === "auto") {
            slidesPerView = 0;
        }
        function slideExist(index2) {
            if (isVirtual) {
                if ($wrapperEl.children("." + swiperParams.slideClass + '[data-swiper-slide-index="' + index2 + '"]').length) {
                    return true;
                }
            } else if (slides[index2]) return true;
            return false;
        }
        function slideIndex(slideEl) {
            if (isVirtual) {
                return dom_default(slideEl).attr("data-swiper-slide-index");
            }
            return dom_default(slideEl).index();
        }
        if (!swiper.lazy.initialImageLoaded) swiper.lazy.initialImageLoaded = true;
        if (swiper.params.watchSlidesVisibility) {
            $wrapperEl.children("." + swiperParams.slideVisibleClass).each(function(slideEl) {
                var index2 = isVirtual ? dom_default(slideEl).attr("data-swiper-slide-index") : dom_default(slideEl).index();
                swiper.lazy.loadInSlide(index2);
            });
        } else if (slidesPerView > 1) {
            for(var i2 = activeIndex; i2 < activeIndex + slidesPerView; i2 += 1){
                if (slideExist(i2)) swiper.lazy.loadInSlide(i2);
            }
        } else {
            swiper.lazy.loadInSlide(activeIndex);
        }
        if (params.loadPrevNext) {
            if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
                var amount = params.loadPrevNextAmount;
                var spv = slidesPerView;
                var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
                var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
                for(var _i = activeIndex + slidesPerView; _i < maxIndex; _i += 1){
                    if (slideExist(_i)) swiper.lazy.loadInSlide(_i);
                }
                for(var _i2 = minIndex; _i2 < activeIndex; _i2 += 1){
                    if (slideExist(_i2)) swiper.lazy.loadInSlide(_i2);
                }
            } else {
                var nextSlide = $wrapperEl.children("." + swiperParams.slideNextClass);
                if (nextSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(nextSlide));
                var prevSlide = $wrapperEl.children("." + swiperParams.slidePrevClass);
                if (prevSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(prevSlide));
            }
        }
    },
    checkInViewOnLoad: function checkInViewOnLoad() {
        var window2 = getWindow();
        var swiper = this;
        if (!swiper || swiper.destroyed) return;
        var $scrollElement = swiper.params.lazy.scrollingElement ? dom_default(swiper.params.lazy.scrollingElement) : dom_default(window2);
        var isWindow = $scrollElement[0] === window2;
        var scrollElementWidth = isWindow ? window2.innerWidth : $scrollElement[0].offsetWidth;
        var scrollElementHeight = isWindow ? window2.innerHeight : $scrollElement[0].offsetHeight;
        var swiperOffset = swiper.$el.offset();
        var rtl = swiper.rtlTranslate;
        var inView = false;
        if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
        var swiperCoord = [
            [
                swiperOffset.left,
                swiperOffset.top
            ],
            [
                swiperOffset.left + swiper.width,
                swiperOffset.top
            ],
            [
                swiperOffset.left,
                swiperOffset.top + swiper.height
            ],
            [
                swiperOffset.left + swiper.width,
                swiperOffset.top + swiper.height
            ]
        ];
        for(var i2 = 0; i2 < swiperCoord.length; i2 += 1){
            var point = swiperCoord[i2];
            if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {
                if (point[0] === 0 && point[1] === 0) continue;
                inView = true;
            }
        }
        var passiveListener = swiper.touchEvents.start === "touchstart" && swiper.support.passiveListener && swiper.params.passiveListeners ? {
            passive: true,
            capture: false
        } : false;
        if (inView) {
            swiper.lazy.load();
            $scrollElement.off("scroll", swiper.lazy.checkInViewOnLoad, passiveListener);
        } else if (!swiper.lazy.scrollHandlerAttached) {
            swiper.lazy.scrollHandlerAttached = true;
            $scrollElement.on("scroll", swiper.lazy.checkInViewOnLoad, passiveListener);
        }
    }
};
var lazy_default = {
    name: "lazy",
    params: {
        lazy: {
            checkInView: false,
            enabled: false,
            loadPrevNext: false,
            loadPrevNextAmount: 1,
            loadOnTransitionStart: false,
            scrollingElement: "",
            elementClass: "swiper-lazy",
            loadingClass: "swiper-lazy-loading",
            loadedClass: "swiper-lazy-loaded",
            preloaderClass: "swiper-lazy-preloader"
        }
    },
    create: function create12() {
        var swiper = this;
        bindModuleMethods(swiper, {
            lazy: _extends10({
                initialImageLoaded: false
            }, Lazy2)
        });
    },
    on: {
        beforeInit: function beforeInit3(swiper) {
            if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
                swiper.params.preloadImages = false;
            }
        },
        init: function init15(swiper) {
            if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
                if (swiper.params.lazy.checkInView) {
                    swiper.lazy.checkInViewOnLoad();
                } else {
                    swiper.lazy.load();
                }
            }
        },
        scroll: function scroll2(swiper) {
            if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
                swiper.lazy.load();
            }
        },
        "scrollbarDragMove resize _freeModeNoMomentumRelease": function lazyLoad(swiper) {
            if (swiper.params.lazy.enabled) {
                swiper.lazy.load();
            }
        },
        transitionStart: function transitionStart2(swiper) {
            if (swiper.params.lazy.enabled) {
                if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded) {
                    swiper.lazy.load();
                }
            }
        },
        transitionEnd: function transitionEnd4(swiper) {
            if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
                swiper.lazy.load();
            }
        },
        slideChange: function slideChange2(swiper) {
            var _swiper$params = swiper.params, lazy = _swiper$params.lazy, cssMode = _swiper$params.cssMode, watchSlidesVisibility = _swiper$params.watchSlidesVisibility, watchSlidesProgress = _swiper$params.watchSlidesProgress, touchReleaseOnEdges = _swiper$params.touchReleaseOnEdges, resistanceRatio = _swiper$params.resistanceRatio;
            if (lazy.enabled && (cssMode || (watchSlidesVisibility || watchSlidesProgress) && (touchReleaseOnEdges || resistanceRatio === 0))) {
                swiper.lazy.load();
            }
        }
    }
};
// node_modules/swiper/esm/components/controller/controller.js
function _extends11() {
    _extends11 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends11.apply(this, arguments);
}
var Controller = {
    LinearSpline: function LinearSpline(x, y) {
        var binarySearch = /* @__PURE__ */ function search() {
            var maxIndex;
            var minIndex;
            var guess;
            return function(array2, val) {
                minIndex = -1;
                maxIndex = array2.length;
                while(maxIndex - minIndex > 1){
                    guess = maxIndex + minIndex >> 1;
                    if (array2[guess] <= val) {
                        minIndex = guess;
                    } else {
                        maxIndex = guess;
                    }
                }
                return maxIndex;
            };
        }();
        this.x = x;
        this.y = y;
        this.lastIndex = x.length - 1;
        var i1;
        var i3;
        this.interpolate = function interpolate(x2) {
            if (!x2) return 0;
            i3 = binarySearch(this.x, x2);
            i1 = i3 - 1;
            return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
        };
        return this;
    },
    // xxx: for now i will just save one spline function to to
    getInterpolateFunction: function getInterpolateFunction(c) {
        var swiper = this;
        if (!swiper.controller.spline) {
            swiper.controller.spline = swiper.params.loop ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid) : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
        }
    },
    setTranslate: function setTranslate7(_setTranslate, byController) {
        var swiper = this;
        var controlled = swiper.controller.control;
        var multiplier;
        var controlledTranslate;
        var Swiper3 = swiper.constructor;
        function setControlledTranslate(c) {
            var translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
            if (swiper.params.controller.by === "slide") {
                swiper.controller.getInterpolateFunction(c);
                controlledTranslate = -swiper.controller.spline.interpolate(-translate);
            }
            if (!controlledTranslate || swiper.params.controller.by === "container") {
                multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
                controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
            }
            if (swiper.params.controller.inverse) {
                controlledTranslate = c.maxTranslate() - controlledTranslate;
            }
            c.updateProgress(controlledTranslate);
            c.setTranslate(controlledTranslate, swiper);
            c.updateActiveIndex();
            c.updateSlidesClasses();
        }
        if (Array.isArray(controlled)) {
            for(var i2 = 0; i2 < controlled.length; i2 += 1){
                if (controlled[i2] !== byController && controlled[i2] instanceof Swiper3) {
                    setControlledTranslate(controlled[i2]);
                }
            }
        } else if (controlled instanceof Swiper3 && byController !== controlled) {
            setControlledTranslate(controlled);
        }
    },
    setTransition: function setTransition6(duration, byController) {
        var swiper = this;
        var Swiper3 = swiper.constructor;
        var controlled = swiper.controller.control;
        var i2;
        function setControlledTransition(c) {
            c.setTransition(duration, swiper);
            if (duration !== 0) {
                c.transitionStart();
                if (c.params.autoHeight) {
                    nextTick4(function() {
                        c.updateAutoHeight();
                    });
                }
                c.$wrapperEl.transitionEnd(function() {
                    if (!controlled) return;
                    if (c.params.loop && swiper.params.controller.by === "slide") {
                        c.loopFix();
                    }
                    c.transitionEnd();
                });
            }
        }
        if (Array.isArray(controlled)) {
            for(i2 = 0; i2 < controlled.length; i2 += 1){
                if (controlled[i2] !== byController && controlled[i2] instanceof Swiper3) {
                    setControlledTransition(controlled[i2]);
                }
            }
        } else if (controlled instanceof Swiper3 && byController !== controlled) {
            setControlledTransition(controlled);
        }
    }
};
var controller_default = {
    name: "controller",
    params: {
        controller: {
            control: void 0,
            inverse: false,
            by: "slide"
        }
    },
    create: function create13() {
        var swiper = this;
        bindModuleMethods(swiper, {
            controller: _extends11({
                control: swiper.params.controller.control
            }, Controller)
        });
    },
    on: {
        update: function update5(swiper) {
            if (!swiper.controller.control) return;
            if (swiper.controller.spline) {
                swiper.controller.spline = void 0;
                delete swiper.controller.spline;
            }
        },
        resize: function resize3(swiper) {
            if (!swiper.controller.control) return;
            if (swiper.controller.spline) {
                swiper.controller.spline = void 0;
                delete swiper.controller.spline;
            }
        },
        observerUpdate: function observerUpdate2(swiper) {
            if (!swiper.controller.control) return;
            if (swiper.controller.spline) {
                swiper.controller.spline = void 0;
                delete swiper.controller.spline;
            }
        },
        setTranslate: function setTranslate8(swiper, translate, byController) {
            if (!swiper.controller.control) return;
            swiper.controller.setTranslate(translate, byController);
        },
        setTransition: function setTransition7(swiper, duration, byController) {
            if (!swiper.controller.control) return;
            swiper.controller.setTransition(duration, byController);
        }
    }
};
// node_modules/swiper/esm/components/a11y/a11y.js
function _extends12() {
    _extends12 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends12.apply(this, arguments);
}
var A11y = {
    getRandomNumber: function getRandomNumber(size) {
        if (size === void 0) {
            size = 16;
        }
        var randomChar = function randomChar2() {
            return Math.round(16 * Math.random()).toString(16);
        };
        return "x".repeat(size).replace(/x/g, randomChar);
    },
    makeElFocusable: function makeElFocusable($el) {
        $el.attr("tabIndex", "0");
        return $el;
    },
    makeElNotFocusable: function makeElNotFocusable($el) {
        $el.attr("tabIndex", "-1");
        return $el;
    },
    addElRole: function addElRole($el, role) {
        $el.attr("role", role);
        return $el;
    },
    addElRoleDescription: function addElRoleDescription($el, description) {
        $el.attr("aria-roledescription", description);
        return $el;
    },
    addElControls: function addElControls($el, controls) {
        $el.attr("aria-controls", controls);
        return $el;
    },
    addElLabel: function addElLabel($el, label) {
        $el.attr("aria-label", label);
        return $el;
    },
    addElId: function addElId($el, id) {
        $el.attr("id", id);
        return $el;
    },
    addElLive: function addElLive($el, live) {
        $el.attr("aria-live", live);
        return $el;
    },
    disableEl: function disableEl($el) {
        $el.attr("aria-disabled", true);
        return $el;
    },
    enableEl: function enableEl($el) {
        $el.attr("aria-disabled", false);
        return $el;
    },
    onEnterOrSpaceKey: function onEnterOrSpaceKey(e) {
        if (e.keyCode !== 13 && e.keyCode !== 32) return;
        var swiper = this;
        var params = swiper.params.a11y;
        var $targetEl = dom_default(e.target);
        if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
            if (!(swiper.isEnd && !swiper.params.loop)) {
                swiper.slideNext();
            }
            if (swiper.isEnd) {
                swiper.a11y.notify(params.lastSlideMessage);
            } else {
                swiper.a11y.notify(params.nextSlideMessage);
            }
        }
        if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
            if (!(swiper.isBeginning && !swiper.params.loop)) {
                swiper.slidePrev();
            }
            if (swiper.isBeginning) {
                swiper.a11y.notify(params.firstSlideMessage);
            } else {
                swiper.a11y.notify(params.prevSlideMessage);
            }
        }
        if (swiper.pagination && $targetEl.is(classesToSelector(swiper.params.pagination.bulletClass))) {
            $targetEl[0].click();
        }
    },
    notify: function notify(message) {
        var swiper = this;
        var notification = swiper.a11y.liveRegion;
        if (notification.length === 0) return;
        notification.html("");
        notification.html(message);
    },
    updateNavigation: function updateNavigation() {
        var swiper = this;
        if (swiper.params.loop || !swiper.navigation) return;
        var _swiper$navigation = swiper.navigation, $nextEl = _swiper$navigation.$nextEl, $prevEl = _swiper$navigation.$prevEl;
        if ($prevEl && $prevEl.length > 0) {
            if (swiper.isBeginning) {
                swiper.a11y.disableEl($prevEl);
                swiper.a11y.makeElNotFocusable($prevEl);
            } else {
                swiper.a11y.enableEl($prevEl);
                swiper.a11y.makeElFocusable($prevEl);
            }
        }
        if ($nextEl && $nextEl.length > 0) {
            if (swiper.isEnd) {
                swiper.a11y.disableEl($nextEl);
                swiper.a11y.makeElNotFocusable($nextEl);
            } else {
                swiper.a11y.enableEl($nextEl);
                swiper.a11y.makeElFocusable($nextEl);
            }
        }
    },
    updatePagination: function updatePagination() {
        var swiper = this;
        var params = swiper.params.a11y;
        if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
            swiper.pagination.bullets.each(function(bulletEl) {
                var $bulletEl = dom_default(bulletEl);
                swiper.a11y.makeElFocusable($bulletEl);
                if (!swiper.params.pagination.renderBullet) {
                    swiper.a11y.addElRole($bulletEl, "button");
                    swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
                }
            });
        }
    },
    init: function init16() {
        var swiper = this;
        var params = swiper.params.a11y;
        swiper.$el.append(swiper.a11y.liveRegion);
        var $containerEl = swiper.$el;
        if (params.containerRoleDescriptionMessage) {
            swiper.a11y.addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);
        }
        if (params.containerMessage) {
            swiper.a11y.addElLabel($containerEl, params.containerMessage);
        }
        var $wrapperEl = swiper.$wrapperEl;
        var wrapperId = $wrapperEl.attr("id") || "swiper-wrapper-" + swiper.a11y.getRandomNumber(16);
        var live = swiper.params.autoplay && swiper.params.autoplay.enabled ? "off" : "polite";
        swiper.a11y.addElId($wrapperEl, wrapperId);
        swiper.a11y.addElLive($wrapperEl, live);
        if (params.itemRoleDescriptionMessage) {
            swiper.a11y.addElRoleDescription(dom_default(swiper.slides), params.itemRoleDescriptionMessage);
        }
        swiper.a11y.addElRole(dom_default(swiper.slides), params.slideRole);
        var slidesLength = swiper.params.loop ? swiper.slides.filter(function(el) {
            return !el.classList.contains(swiper.params.slideDuplicateClass);
        }).length : swiper.slides.length;
        swiper.slides.each(function(slideEl, index2) {
            var $slideEl = dom_default(slideEl);
            var slideIndex = swiper.params.loop ? parseInt($slideEl.attr("data-swiper-slide-index"), 10) : index2;
            var ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
            swiper.a11y.addElLabel($slideEl, ariaLabelMessage);
        });
        var $nextEl;
        var $prevEl;
        if (swiper.navigation && swiper.navigation.$nextEl) {
            $nextEl = swiper.navigation.$nextEl;
        }
        if (swiper.navigation && swiper.navigation.$prevEl) {
            $prevEl = swiper.navigation.$prevEl;
        }
        if ($nextEl && $nextEl.length) {
            swiper.a11y.makeElFocusable($nextEl);
            if ($nextEl[0].tagName !== "BUTTON") {
                swiper.a11y.addElRole($nextEl, "button");
                $nextEl.on("keydown", swiper.a11y.onEnterOrSpaceKey);
            }
            swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
            swiper.a11y.addElControls($nextEl, wrapperId);
        }
        if ($prevEl && $prevEl.length) {
            swiper.a11y.makeElFocusable($prevEl);
            if ($prevEl[0].tagName !== "BUTTON") {
                swiper.a11y.addElRole($prevEl, "button");
                $prevEl.on("keydown", swiper.a11y.onEnterOrSpaceKey);
            }
            swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
            swiper.a11y.addElControls($prevEl, wrapperId);
        }
        if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
            swiper.pagination.$el.on("keydown", classesToSelector(swiper.params.pagination.bulletClass), swiper.a11y.onEnterOrSpaceKey);
        }
    },
    destroy: function destroy13() {
        var swiper = this;
        if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) swiper.a11y.liveRegion.remove();
        var $nextEl;
        var $prevEl;
        if (swiper.navigation && swiper.navigation.$nextEl) {
            $nextEl = swiper.navigation.$nextEl;
        }
        if (swiper.navigation && swiper.navigation.$prevEl) {
            $prevEl = swiper.navigation.$prevEl;
        }
        if ($nextEl) {
            $nextEl.off("keydown", swiper.a11y.onEnterOrSpaceKey);
        }
        if ($prevEl) {
            $prevEl.off("keydown", swiper.a11y.onEnterOrSpaceKey);
        }
        if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
            swiper.pagination.$el.off("keydown", classesToSelector(swiper.params.pagination.bulletClass), swiper.a11y.onEnterOrSpaceKey);
        }
    }
};
var a11y_default = {
    name: "a11y",
    params: {
        a11y: {
            enabled: true,
            notificationClass: "swiper-notification",
            prevSlideMessage: "Previous slide",
            nextSlideMessage: "Next slide",
            firstSlideMessage: "This is the first slide",
            lastSlideMessage: "This is the last slide",
            paginationBulletMessage: "Go to slide {{index}}",
            slideLabelMessage: "{{index}} / {{slidesLength}}",
            containerMessage: null,
            containerRoleDescriptionMessage: null,
            itemRoleDescriptionMessage: null,
            slideRole: "group"
        }
    },
    create: function create14() {
        var swiper = this;
        bindModuleMethods(swiper, {
            a11y: _extends12({}, A11y, {
                liveRegion: dom_default('<span class="' + swiper.params.a11y.notificationClass + '" aria-live="assertive" aria-atomic="true"></span>')
            })
        });
    },
    on: {
        afterInit: function afterInit(swiper) {
            if (!swiper.params.a11y.enabled) return;
            swiper.a11y.init();
            swiper.a11y.updateNavigation();
        },
        toEdge: function toEdge2(swiper) {
            if (!swiper.params.a11y.enabled) return;
            swiper.a11y.updateNavigation();
        },
        fromEdge: function fromEdge2(swiper) {
            if (!swiper.params.a11y.enabled) return;
            swiper.a11y.updateNavigation();
        },
        paginationUpdate: function paginationUpdate(swiper) {
            if (!swiper.params.a11y.enabled) return;
            swiper.a11y.updatePagination();
        },
        destroy: function destroy14(swiper) {
            if (!swiper.params.a11y.enabled) return;
            swiper.a11y.destroy();
        }
    }
};
// node_modules/swiper/esm/components/history/history.js
function _extends13() {
    _extends13 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends13.apply(this, arguments);
}
var History = {
    init: function init17() {
        var swiper = this;
        var window2 = getWindow();
        if (!swiper.params.history) return;
        if (!window2.history || !window2.history.pushState) {
            swiper.params.history.enabled = false;
            swiper.params.hashNavigation.enabled = true;
            return;
        }
        var history2 = swiper.history;
        history2.initialized = true;
        history2.paths = History.getPathValues(swiper.params.url);
        if (!history2.paths.key && !history2.paths.value) return;
        history2.scrollToSlide(0, history2.paths.value, swiper.params.runCallbacksOnInit);
        if (!swiper.params.history.replaceState) {
            window2.addEventListener("popstate", swiper.history.setHistoryPopState);
        }
    },
    destroy: function destroy15() {
        var swiper = this;
        var window2 = getWindow();
        if (!swiper.params.history.replaceState) {
            window2.removeEventListener("popstate", swiper.history.setHistoryPopState);
        }
    },
    setHistoryPopState: function setHistoryPopState() {
        var swiper = this;
        swiper.history.paths = History.getPathValues(swiper.params.url);
        swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
    },
    getPathValues: function getPathValues(urlOverride) {
        var window2 = getWindow();
        var location2;
        if (urlOverride) {
            location2 = new URL(urlOverride);
        } else {
            location2 = window2.location;
        }
        var pathArray = location2.pathname.slice(1).split("/").filter(function(part) {
            return part !== "";
        });
        var total = pathArray.length;
        var key = pathArray[total - 2];
        var value = pathArray[total - 1];
        return {
            key,
            value
        };
    },
    setHistory: function setHistory2(key, index2) {
        var swiper = this;
        var window2 = getWindow();
        if (!swiper.history.initialized || !swiper.params.history.enabled) return;
        var location2;
        if (swiper.params.url) {
            location2 = new URL(swiper.params.url);
        } else {
            location2 = window2.location;
        }
        var slide = swiper.slides.eq(index2);
        var value = History.slugify(slide.attr("data-history"));
        if (swiper.params.history.root.length > 0) {
            var root2 = swiper.params.history.root;
            if (root2[root2.length - 1] === "/") root2 = root2.slice(0, root2.length - 1);
            value = root2 + "/" + key + "/" + value;
        } else if (!location2.pathname.includes(key)) {
            value = key + "/" + value;
        }
        var currentState = window2.history.state;
        if (currentState && currentState.value === value) {
            return;
        }
        if (swiper.params.history.replaceState) {
            window2.history.replaceState({
                value
            }, null, value);
        } else {
            window2.history.pushState({
                value
            }, null, value);
        }
    },
    slugify: function slugify(text2) {
        return text2.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
    },
    scrollToSlide: function scrollToSlide(speed, value, runCallbacks) {
        var swiper = this;
        if (value) {
            for(var i2 = 0, length = swiper.slides.length; i2 < length; i2 += 1){
                var slide = swiper.slides.eq(i2);
                var slideHistory = History.slugify(slide.attr("data-history"));
                if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
                    var index2 = slide.index();
                    swiper.slideTo(index2, speed, runCallbacks);
                }
            }
        } else {
            swiper.slideTo(0, speed, runCallbacks);
        }
    }
};
var history_default = {
    name: "history",
    params: {
        history: {
            enabled: false,
            root: "",
            replaceState: false,
            key: "slides"
        }
    },
    create: function create15() {
        var swiper = this;
        bindModuleMethods(swiper, {
            history: _extends13({}, History)
        });
    },
    on: {
        init: function init18(swiper) {
            if (swiper.params.history.enabled) {
                swiper.history.init();
            }
        },
        destroy: function destroy16(swiper) {
            if (swiper.params.history.enabled) {
                swiper.history.destroy();
            }
        },
        "transitionEnd _freeModeNoMomentumRelease": function transitionEnd_freeModeNoMomentumRelease(swiper) {
            if (swiper.history.initialized) {
                swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
            }
        },
        slideChange: function slideChange3(swiper) {
            if (swiper.history.initialized && swiper.params.cssMode) {
                swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
            }
        }
    }
};
// node_modules/swiper/esm/components/hash-navigation/hash-navigation.js
function _extends14() {
    _extends14 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends14.apply(this, arguments);
}
var HashNavigation = {
    onHashChange: function onHashChange() {
        var swiper = this;
        var document2 = getDocument();
        swiper.emit("hashChange");
        var newHash = document2.location.hash.replace("#", "");
        var activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr("data-hash");
        if (newHash !== activeSlideHash) {
            var newIndex = swiper.$wrapperEl.children("." + swiper.params.slideClass + '[data-hash="' + newHash + '"]').index();
            if (typeof newIndex === "undefined") return;
            swiper.slideTo(newIndex);
        }
    },
    setHash: function setHash() {
        var swiper = this;
        var window2 = getWindow();
        var document2 = getDocument();
        if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) return;
        if (swiper.params.hashNavigation.replaceState && window2.history && window2.history.replaceState) {
            window2.history.replaceState(null, null, "#" + swiper.slides.eq(swiper.activeIndex).attr("data-hash") || "");
            swiper.emit("hashSet");
        } else {
            var slide = swiper.slides.eq(swiper.activeIndex);
            var hash = slide.attr("data-hash") || slide.attr("data-history");
            document2.location.hash = hash || "";
            swiper.emit("hashSet");
        }
    },
    init: function init19() {
        var swiper = this;
        var document2 = getDocument();
        var window2 = getWindow();
        if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
        swiper.hashNavigation.initialized = true;
        var hash = document2.location.hash.replace("#", "");
        if (hash) {
            var speed = 0;
            for(var i2 = 0, length = swiper.slides.length; i2 < length; i2 += 1){
                var slide = swiper.slides.eq(i2);
                var slideHash = slide.attr("data-hash") || slide.attr("data-history");
                if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
                    var index2 = slide.index();
                    swiper.slideTo(index2, speed, swiper.params.runCallbacksOnInit, true);
                }
            }
        }
        if (swiper.params.hashNavigation.watchState) {
            dom_default(window2).on("hashchange", swiper.hashNavigation.onHashChange);
        }
    },
    destroy: function destroy17() {
        var swiper = this;
        var window2 = getWindow();
        if (swiper.params.hashNavigation.watchState) {
            dom_default(window2).off("hashchange", swiper.hashNavigation.onHashChange);
        }
    }
};
var hash_navigation_default = {
    name: "hash-navigation",
    params: {
        hashNavigation: {
            enabled: false,
            replaceState: false,
            watchState: false
        }
    },
    create: function create16() {
        var swiper = this;
        bindModuleMethods(swiper, {
            hashNavigation: _extends14({
                initialized: false
            }, HashNavigation)
        });
    },
    on: {
        init: function init20(swiper) {
            if (swiper.params.hashNavigation.enabled) {
                swiper.hashNavigation.init();
            }
        },
        destroy: function destroy18(swiper) {
            if (swiper.params.hashNavigation.enabled) {
                swiper.hashNavigation.destroy();
            }
        },
        "transitionEnd _freeModeNoMomentumRelease": function transitionEnd_freeModeNoMomentumRelease2(swiper) {
            if (swiper.hashNavigation.initialized) {
                swiper.hashNavigation.setHash();
            }
        },
        slideChange: function slideChange4(swiper) {
            if (swiper.hashNavigation.initialized && swiper.params.cssMode) {
                swiper.hashNavigation.setHash();
            }
        }
    }
};
// node_modules/swiper/esm/components/autoplay/autoplay.js
function _extends15() {
    _extends15 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends15.apply(this, arguments);
}
var Autoplay = {
    run: function run() {
        var swiper = this;
        var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
        var delay = swiper.params.autoplay.delay;
        if ($activeSlideEl.attr("data-swiper-autoplay")) {
            delay = $activeSlideEl.attr("data-swiper-autoplay") || swiper.params.autoplay.delay;
        }
        clearTimeout(swiper.autoplay.timeout);
        swiper.autoplay.timeout = nextTick4(function() {
            var autoplayResult;
            if (swiper.params.autoplay.reverseDirection) {
                if (swiper.params.loop) {
                    swiper.loopFix();
                    autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
                    swiper.emit("autoplay");
                } else if (!swiper.isBeginning) {
                    autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
                    swiper.emit("autoplay");
                } else if (!swiper.params.autoplay.stopOnLastSlide) {
                    autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
                    swiper.emit("autoplay");
                } else {
                    swiper.autoplay.stop();
                }
            } else if (swiper.params.loop) {
                swiper.loopFix();
                autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
                swiper.emit("autoplay");
            } else if (!swiper.isEnd) {
                autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
                swiper.emit("autoplay");
            } else if (!swiper.params.autoplay.stopOnLastSlide) {
                autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
                swiper.emit("autoplay");
            } else {
                swiper.autoplay.stop();
            }
            if (swiper.params.cssMode && swiper.autoplay.running) swiper.autoplay.run();
            else if (autoplayResult === false) {
                swiper.autoplay.run();
            }
        }, delay);
    },
    start: function start() {
        var swiper = this;
        if (typeof swiper.autoplay.timeout !== "undefined") return false;
        if (swiper.autoplay.running) return false;
        swiper.autoplay.running = true;
        swiper.emit("autoplayStart");
        swiper.autoplay.run();
        return true;
    },
    stop: function stop() {
        var swiper = this;
        if (!swiper.autoplay.running) return false;
        if (typeof swiper.autoplay.timeout === "undefined") return false;
        if (swiper.autoplay.timeout) {
            clearTimeout(swiper.autoplay.timeout);
            swiper.autoplay.timeout = void 0;
        }
        swiper.autoplay.running = false;
        swiper.emit("autoplayStop");
        return true;
    },
    pause: function pause(speed) {
        var swiper = this;
        if (!swiper.autoplay.running) return;
        if (swiper.autoplay.paused) return;
        if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);
        swiper.autoplay.paused = true;
        if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
            swiper.autoplay.paused = false;
            swiper.autoplay.run();
        } else {
            [
                "transitionend",
                "webkitTransitionEnd"
            ].forEach(function(event2) {
                swiper.$wrapperEl[0].addEventListener(event2, swiper.autoplay.onTransitionEnd);
            });
        }
    },
    onVisibilityChange: function onVisibilityChange() {
        var swiper = this;
        var document2 = getDocument();
        if (document2.visibilityState === "hidden" && swiper.autoplay.running) {
            swiper.autoplay.pause();
        }
        if (document2.visibilityState === "visible" && swiper.autoplay.paused) {
            swiper.autoplay.run();
            swiper.autoplay.paused = false;
        }
    },
    onTransitionEnd: function onTransitionEnd2(e) {
        var swiper = this;
        if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
        if (e.target !== swiper.$wrapperEl[0]) return;
        [
            "transitionend",
            "webkitTransitionEnd"
        ].forEach(function(event2) {
            swiper.$wrapperEl[0].removeEventListener(event2, swiper.autoplay.onTransitionEnd);
        });
        swiper.autoplay.paused = false;
        if (!swiper.autoplay.running) {
            swiper.autoplay.stop();
        } else {
            swiper.autoplay.run();
        }
    },
    onMouseEnter: function onMouseEnter() {
        var swiper = this;
        if (swiper.params.autoplay.disableOnInteraction) {
            swiper.autoplay.stop();
        } else {
            swiper.autoplay.pause();
        }
        [
            "transitionend",
            "webkitTransitionEnd"
        ].forEach(function(event2) {
            swiper.$wrapperEl[0].removeEventListener(event2, swiper.autoplay.onTransitionEnd);
        });
    },
    onMouseLeave: function onMouseLeave() {
        var swiper = this;
        if (swiper.params.autoplay.disableOnInteraction) {
            return;
        }
        swiper.autoplay.paused = false;
        swiper.autoplay.run();
    },
    attachMouseEvents: function attachMouseEvents() {
        var swiper = this;
        if (swiper.params.autoplay.pauseOnMouseEnter) {
            swiper.$el.on("mouseenter", swiper.autoplay.onMouseEnter);
            swiper.$el.on("mouseleave", swiper.autoplay.onMouseLeave);
        }
    },
    detachMouseEvents: function detachMouseEvents() {
        var swiper = this;
        swiper.$el.off("mouseenter", swiper.autoplay.onMouseEnter);
        swiper.$el.off("mouseleave", swiper.autoplay.onMouseLeave);
    }
};
var autoplay_default = {
    name: "autoplay",
    params: {
        autoplay: {
            enabled: false,
            delay: 3e3,
            waitForTransition: true,
            disableOnInteraction: true,
            stopOnLastSlide: false,
            reverseDirection: false,
            pauseOnMouseEnter: false
        }
    },
    create: function create17() {
        var swiper = this;
        bindModuleMethods(swiper, {
            autoplay: _extends15({}, Autoplay, {
                running: false,
                paused: false
            })
        });
    },
    on: {
        init: function init21(swiper) {
            if (swiper.params.autoplay.enabled) {
                swiper.autoplay.start();
                var document2 = getDocument();
                document2.addEventListener("visibilitychange", swiper.autoplay.onVisibilityChange);
                swiper.autoplay.attachMouseEvents();
            }
        },
        beforeTransitionStart: function beforeTransitionStart(swiper, speed, internal) {
            if (swiper.autoplay.running) {
                if (internal || !swiper.params.autoplay.disableOnInteraction) {
                    swiper.autoplay.pause(speed);
                } else {
                    swiper.autoplay.stop();
                }
            }
        },
        sliderFirstMove: function sliderFirstMove(swiper) {
            if (swiper.autoplay.running) {
                if (swiper.params.autoplay.disableOnInteraction) {
                    swiper.autoplay.stop();
                } else {
                    swiper.autoplay.pause();
                }
            }
        },
        touchEnd: function touchEnd2(swiper) {
            if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
                swiper.autoplay.run();
            }
        },
        destroy: function destroy19(swiper) {
            swiper.autoplay.detachMouseEvents();
            if (swiper.autoplay.running) {
                swiper.autoplay.stop();
            }
            var document2 = getDocument();
            document2.removeEventListener("visibilitychange", swiper.autoplay.onVisibilityChange);
        }
    }
};
// node_modules/swiper/esm/components/effect-fade/effect-fade.js
function _extends16() {
    _extends16 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends16.apply(this, arguments);
}
var Fade = {
    setTranslate: function setTranslate9() {
        var swiper = this;
        var slides = swiper.slides;
        for(var i2 = 0; i2 < slides.length; i2 += 1){
            var $slideEl = swiper.slides.eq(i2);
            var offset2 = $slideEl[0].swiperSlideOffset;
            var tx = -offset2;
            if (!swiper.params.virtualTranslate) tx -= swiper.translate;
            var ty = 0;
            if (!swiper.isHorizontal()) {
                ty = tx;
                tx = 0;
            }
            var slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
            $slideEl.css({
                opacity: slideOpacity
            }).transform("translate3d(" + tx + "px, " + ty + "px, 0px)");
        }
    },
    setTransition: function setTransition8(duration) {
        var swiper = this;
        var slides = swiper.slides, $wrapperEl = swiper.$wrapperEl;
        slides.transition(duration);
        if (swiper.params.virtualTranslate && duration !== 0) {
            var eventTriggered = false;
            slides.transitionEnd(function() {
                if (eventTriggered) return;
                if (!swiper || swiper.destroyed) return;
                eventTriggered = true;
                swiper.animating = false;
                var triggerEvents = [
                    "webkitTransitionEnd",
                    "transitionend"
                ];
                for(var i2 = 0; i2 < triggerEvents.length; i2 += 1){
                    $wrapperEl.trigger(triggerEvents[i2]);
                }
            });
        }
    }
};
var effect_fade_default = {
    name: "effect-fade",
    params: {
        fadeEffect: {
            crossFade: false
        }
    },
    create: function create18() {
        var swiper = this;
        bindModuleMethods(swiper, {
            fadeEffect: _extends16({}, Fade)
        });
    },
    on: {
        beforeInit: function beforeInit4(swiper) {
            if (swiper.params.effect !== "fade") return;
            swiper.classNames.push(swiper.params.containerModifierClass + "fade");
            var overwriteParams = {
                slidesPerView: 1,
                slidesPerColumn: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                spaceBetween: 0,
                virtualTranslate: true
            };
            extend2(swiper.params, overwriteParams);
            extend2(swiper.originalParams, overwriteParams);
        },
        setTranslate: function setTranslate10(swiper) {
            if (swiper.params.effect !== "fade") return;
            swiper.fadeEffect.setTranslate();
        },
        setTransition: function setTransition9(swiper, duration) {
            if (swiper.params.effect !== "fade") return;
            swiper.fadeEffect.setTransition(duration);
        }
    }
};
// node_modules/swiper/esm/components/effect-cube/effect-cube.js
function _extends17() {
    _extends17 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends17.apply(this, arguments);
}
var Cube = {
    setTranslate: function setTranslate11() {
        var swiper = this;
        var $el = swiper.$el, $wrapperEl = swiper.$wrapperEl, slides = swiper.slides, swiperWidth = swiper.width, swiperHeight = swiper.height, rtl = swiper.rtlTranslate, swiperSize = swiper.size, browser2 = swiper.browser;
        var params = swiper.params.cubeEffect;
        var isHorizontal = swiper.isHorizontal();
        var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
        var wrapperRotate = 0;
        var $cubeShadowEl;
        if (params.shadow) {
            if (isHorizontal) {
                $cubeShadowEl = $wrapperEl.find(".swiper-cube-shadow");
                if ($cubeShadowEl.length === 0) {
                    $cubeShadowEl = dom_default('<div class="swiper-cube-shadow"></div>');
                    $wrapperEl.append($cubeShadowEl);
                }
                $cubeShadowEl.css({
                    height: swiperWidth + "px"
                });
            } else {
                $cubeShadowEl = $el.find(".swiper-cube-shadow");
                if ($cubeShadowEl.length === 0) {
                    $cubeShadowEl = dom_default('<div class="swiper-cube-shadow"></div>');
                    $el.append($cubeShadowEl);
                }
            }
        }
        for(var i2 = 0; i2 < slides.length; i2 += 1){
            var $slideEl = slides.eq(i2);
            var slideIndex = i2;
            if (isVirtual) {
                slideIndex = parseInt($slideEl.attr("data-swiper-slide-index"), 10);
            }
            var slideAngle = slideIndex * 90;
            var round = Math.floor(slideAngle / 360);
            if (rtl) {
                slideAngle = -slideAngle;
                round = Math.floor(-slideAngle / 360);
            }
            var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
            var tx = 0;
            var ty = 0;
            var tz = 0;
            if (slideIndex % 4 === 0) {
                tx = -round * 4 * swiperSize;
                tz = 0;
            } else if ((slideIndex - 1) % 4 === 0) {
                tx = 0;
                tz = -round * 4 * swiperSize;
            } else if ((slideIndex - 2) % 4 === 0) {
                tx = swiperSize + round * 4 * swiperSize;
                tz = swiperSize;
            } else if ((slideIndex - 3) % 4 === 0) {
                tx = -swiperSize;
                tz = 3 * swiperSize + swiperSize * 4 * round;
            }
            if (rtl) {
                tx = -tx;
            }
            if (!isHorizontal) {
                ty = tx;
                tx = 0;
            }
            var transform2 = "rotateX(" + (isHorizontal ? 0 : -slideAngle) + "deg) rotateY(" + (isHorizontal ? slideAngle : 0) + "deg) translate3d(" + tx + "px, " + ty + "px, " + tz + "px)";
            if (progress <= 1 && progress > -1) {
                wrapperRotate = slideIndex * 90 + progress * 90;
                if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
            }
            $slideEl.transform(transform2);
            if (params.slideShadows) {
                var shadowBefore = isHorizontal ? $slideEl.find(".swiper-slide-shadow-left") : $slideEl.find(".swiper-slide-shadow-top");
                var shadowAfter = isHorizontal ? $slideEl.find(".swiper-slide-shadow-right") : $slideEl.find(".swiper-slide-shadow-bottom");
                if (shadowBefore.length === 0) {
                    shadowBefore = dom_default('<div class="swiper-slide-shadow-' + (isHorizontal ? "left" : "top") + '"></div>');
                    $slideEl.append(shadowBefore);
                }
                if (shadowAfter.length === 0) {
                    shadowAfter = dom_default('<div class="swiper-slide-shadow-' + (isHorizontal ? "right" : "bottom") + '"></div>');
                    $slideEl.append(shadowAfter);
                }
                if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
                if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
            }
        }
        $wrapperEl.css({
            "-webkit-transform-origin": "50% 50% -" + swiperSize / 2 + "px",
            "-moz-transform-origin": "50% 50% -" + swiperSize / 2 + "px",
            "-ms-transform-origin": "50% 50% -" + swiperSize / 2 + "px",
            "transform-origin": "50% 50% -" + swiperSize / 2 + "px"
        });
        if (params.shadow) {
            if (isHorizontal) {
                $cubeShadowEl.transform("translate3d(0px, " + (swiperWidth / 2 + params.shadowOffset) + "px, " + -swiperWidth / 2 + "px) rotateX(90deg) rotateZ(0deg) scale(" + params.shadowScale + ")");
            } else {
                var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
                var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
                var scale1 = params.shadowScale;
                var scale2 = params.shadowScale / multiplier;
                var offset2 = params.shadowOffset;
                $cubeShadowEl.transform("scale3d(" + scale1 + ", 1, " + scale2 + ") translate3d(0px, " + (swiperHeight / 2 + offset2) + "px, " + -swiperHeight / 2 / scale2 + "px) rotateX(-90deg)");
            }
        }
        var zFactor = browser2.isSafari || browser2.isWebView ? -swiperSize / 2 : 0;
        $wrapperEl.transform("translate3d(0px,0," + zFactor + "px) rotateX(" + (swiper.isHorizontal() ? 0 : wrapperRotate) + "deg) rotateY(" + (swiper.isHorizontal() ? -wrapperRotate : 0) + "deg)");
    },
    setTransition: function setTransition10(duration) {
        var swiper = this;
        var $el = swiper.$el, slides = swiper.slides;
        slides.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration);
        if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
            $el.find(".swiper-cube-shadow").transition(duration);
        }
    }
};
var effect_cube_default = {
    name: "effect-cube",
    params: {
        cubeEffect: {
            slideShadows: true,
            shadow: true,
            shadowOffset: 20,
            shadowScale: 0.94
        }
    },
    create: function create19() {
        var swiper = this;
        bindModuleMethods(swiper, {
            cubeEffect: _extends17({}, Cube)
        });
    },
    on: {
        beforeInit: function beforeInit5(swiper) {
            if (swiper.params.effect !== "cube") return;
            swiper.classNames.push(swiper.params.containerModifierClass + "cube");
            swiper.classNames.push(swiper.params.containerModifierClass + "3d");
            var overwriteParams = {
                slidesPerView: 1,
                slidesPerColumn: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                resistanceRatio: 0,
                spaceBetween: 0,
                centeredSlides: false,
                virtualTranslate: true
            };
            extend2(swiper.params, overwriteParams);
            extend2(swiper.originalParams, overwriteParams);
        },
        setTranslate: function setTranslate12(swiper) {
            if (swiper.params.effect !== "cube") return;
            swiper.cubeEffect.setTranslate();
        },
        setTransition: function setTransition11(swiper, duration) {
            if (swiper.params.effect !== "cube") return;
            swiper.cubeEffect.setTransition(duration);
        }
    }
};
// node_modules/swiper/esm/components/effect-flip/effect-flip.js
function _extends18() {
    _extends18 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends18.apply(this, arguments);
}
var Flip = {
    setTranslate: function setTranslate13() {
        var swiper = this;
        var slides = swiper.slides, rtl = swiper.rtlTranslate;
        for(var i2 = 0; i2 < slides.length; i2 += 1){
            var $slideEl = slides.eq(i2);
            var progress = $slideEl[0].progress;
            if (swiper.params.flipEffect.limitRotation) {
                progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
            }
            var offset2 = $slideEl[0].swiperSlideOffset;
            var rotate = -180 * progress;
            var rotateY = rotate;
            var rotateX = 0;
            var tx = -offset2;
            var ty = 0;
            if (!swiper.isHorizontal()) {
                ty = tx;
                tx = 0;
                rotateX = -rotateY;
                rotateY = 0;
            } else if (rtl) {
                rotateY = -rotateY;
            }
            $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
            if (swiper.params.flipEffect.slideShadows) {
                var shadowBefore = swiper.isHorizontal() ? $slideEl.find(".swiper-slide-shadow-left") : $slideEl.find(".swiper-slide-shadow-top");
                var shadowAfter = swiper.isHorizontal() ? $slideEl.find(".swiper-slide-shadow-right") : $slideEl.find(".swiper-slide-shadow-bottom");
                if (shadowBefore.length === 0) {
                    shadowBefore = dom_default('<div class="swiper-slide-shadow-' + (swiper.isHorizontal() ? "left" : "top") + '"></div>');
                    $slideEl.append(shadowBefore);
                }
                if (shadowAfter.length === 0) {
                    shadowAfter = dom_default('<div class="swiper-slide-shadow-' + (swiper.isHorizontal() ? "right" : "bottom") + '"></div>');
                    $slideEl.append(shadowAfter);
                }
                if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
                if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
            }
            $slideEl.transform("translate3d(" + tx + "px, " + ty + "px, 0px) rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)");
        }
    },
    setTransition: function setTransition12(duration) {
        var swiper = this;
        var slides = swiper.slides, activeIndex = swiper.activeIndex, $wrapperEl = swiper.$wrapperEl;
        slides.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration);
        if (swiper.params.virtualTranslate && duration !== 0) {
            var eventTriggered = false;
            slides.eq(activeIndex).transitionEnd(function onTransitionEnd3() {
                if (eventTriggered) return;
                if (!swiper || swiper.destroyed) return;
                eventTriggered = true;
                swiper.animating = false;
                var triggerEvents = [
                    "webkitTransitionEnd",
                    "transitionend"
                ];
                for(var i2 = 0; i2 < triggerEvents.length; i2 += 1){
                    $wrapperEl.trigger(triggerEvents[i2]);
                }
            });
        }
    }
};
var effect_flip_default = {
    name: "effect-flip",
    params: {
        flipEffect: {
            slideShadows: true,
            limitRotation: true
        }
    },
    create: function create20() {
        var swiper = this;
        bindModuleMethods(swiper, {
            flipEffect: _extends18({}, Flip)
        });
    },
    on: {
        beforeInit: function beforeInit6(swiper) {
            if (swiper.params.effect !== "flip") return;
            swiper.classNames.push(swiper.params.containerModifierClass + "flip");
            swiper.classNames.push(swiper.params.containerModifierClass + "3d");
            var overwriteParams = {
                slidesPerView: 1,
                slidesPerColumn: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                spaceBetween: 0,
                virtualTranslate: true
            };
            extend2(swiper.params, overwriteParams);
            extend2(swiper.originalParams, overwriteParams);
        },
        setTranslate: function setTranslate14(swiper) {
            if (swiper.params.effect !== "flip") return;
            swiper.flipEffect.setTranslate();
        },
        setTransition: function setTransition13(swiper, duration) {
            if (swiper.params.effect !== "flip") return;
            swiper.flipEffect.setTransition(duration);
        }
    }
};
// node_modules/swiper/esm/components/effect-coverflow/effect-coverflow.js
function _extends19() {
    _extends19 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends19.apply(this, arguments);
}
var Coverflow = {
    setTranslate: function setTranslate15() {
        var swiper = this;
        var swiperWidth = swiper.width, swiperHeight = swiper.height, slides = swiper.slides, slidesSizesGrid = swiper.slidesSizesGrid;
        var params = swiper.params.coverflowEffect;
        var isHorizontal = swiper.isHorizontal();
        var transform2 = swiper.translate;
        var center = isHorizontal ? -transform2 + swiperWidth / 2 : -transform2 + swiperHeight / 2;
        var rotate = isHorizontal ? params.rotate : -params.rotate;
        var translate = params.depth;
        for(var i2 = 0, length = slides.length; i2 < length; i2 += 1){
            var $slideEl = slides.eq(i2);
            var slideSize = slidesSizesGrid[i2];
            var slideOffset = $slideEl[0].swiperSlideOffset;
            var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * params.modifier;
            var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
            var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
            var translateZ = -translate * Math.abs(offsetMultiplier);
            var stretch = params.stretch;
            if (typeof stretch === "string" && stretch.indexOf("%") !== -1) {
                stretch = parseFloat(params.stretch) / 100 * slideSize;
            }
            var translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
            var translateX = isHorizontal ? stretch * offsetMultiplier : 0;
            var scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);
            if (Math.abs(translateX) < 1e-3) translateX = 0;
            if (Math.abs(translateY) < 1e-3) translateY = 0;
            if (Math.abs(translateZ) < 1e-3) translateZ = 0;
            if (Math.abs(rotateY) < 1e-3) rotateY = 0;
            if (Math.abs(rotateX) < 1e-3) rotateX = 0;
            if (Math.abs(scale) < 1e-3) scale = 0;
            var slideTransform = "translate3d(" + translateX + "px," + translateY + "px," + translateZ + "px)  rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg) scale(" + scale + ")";
            $slideEl.transform(slideTransform);
            $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
            if (params.slideShadows) {
                var $shadowBeforeEl = isHorizontal ? $slideEl.find(".swiper-slide-shadow-left") : $slideEl.find(".swiper-slide-shadow-top");
                var $shadowAfterEl = isHorizontal ? $slideEl.find(".swiper-slide-shadow-right") : $slideEl.find(".swiper-slide-shadow-bottom");
                if ($shadowBeforeEl.length === 0) {
                    $shadowBeforeEl = dom_default('<div class="swiper-slide-shadow-' + (isHorizontal ? "left" : "top") + '"></div>');
                    $slideEl.append($shadowBeforeEl);
                }
                if ($shadowAfterEl.length === 0) {
                    $shadowAfterEl = dom_default('<div class="swiper-slide-shadow-' + (isHorizontal ? "right" : "bottom") + '"></div>');
                    $slideEl.append($shadowAfterEl);
                }
                if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
                if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
            }
        }
    },
    setTransition: function setTransition14(duration) {
        var swiper = this;
        swiper.slides.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration);
    }
};
var effect_coverflow_default = {
    name: "effect-coverflow",
    params: {
        coverflowEffect: {
            rotate: 50,
            stretch: 0,
            depth: 100,
            scale: 1,
            modifier: 1,
            slideShadows: true
        }
    },
    create: function create21() {
        var swiper = this;
        bindModuleMethods(swiper, {
            coverflowEffect: _extends19({}, Coverflow)
        });
    },
    on: {
        beforeInit: function beforeInit7(swiper) {
            if (swiper.params.effect !== "coverflow") return;
            swiper.classNames.push(swiper.params.containerModifierClass + "coverflow");
            swiper.classNames.push(swiper.params.containerModifierClass + "3d");
            swiper.params.watchSlidesProgress = true;
            swiper.originalParams.watchSlidesProgress = true;
        },
        setTranslate: function setTranslate16(swiper) {
            if (swiper.params.effect !== "coverflow") return;
            swiper.coverflowEffect.setTranslate();
        },
        setTransition: function setTransition15(swiper, duration) {
            if (swiper.params.effect !== "coverflow") return;
            swiper.coverflowEffect.setTransition(duration);
        }
    }
};
// node_modules/swiper/esm/components/thumbs/thumbs.js
function _extends20() {
    _extends20 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends20.apply(this, arguments);
}
var Thumbs = {
    init: function init22() {
        var swiper = this;
        var thumbsParams = swiper.params.thumbs;
        if (swiper.thumbs.initialized) return false;
        swiper.thumbs.initialized = true;
        var SwiperClass = swiper.constructor;
        if (thumbsParams.swiper instanceof SwiperClass) {
            swiper.thumbs.swiper = thumbsParams.swiper;
            extend2(swiper.thumbs.swiper.originalParams, {
                watchSlidesProgress: true,
                slideToClickedSlide: false
            });
            extend2(swiper.thumbs.swiper.params, {
                watchSlidesProgress: true,
                slideToClickedSlide: false
            });
        } else if (isObject5(thumbsParams.swiper)) {
            swiper.thumbs.swiper = new SwiperClass(extend2({}, thumbsParams.swiper, {
                watchSlidesVisibility: true,
                watchSlidesProgress: true,
                slideToClickedSlide: false
            }));
            swiper.thumbs.swiperCreated = true;
        }
        swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
        swiper.thumbs.swiper.on("tap", swiper.thumbs.onThumbClick);
        return true;
    },
    onThumbClick: function onThumbClick() {
        var swiper = this;
        var thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper) return;
        var clickedIndex = thumbsSwiper.clickedIndex;
        var clickedSlide = thumbsSwiper.clickedSlide;
        if (clickedSlide && dom_default(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
        if (typeof clickedIndex === "undefined" || clickedIndex === null) return;
        var slideToIndex;
        if (thumbsSwiper.params.loop) {
            slideToIndex = parseInt(dom_default(thumbsSwiper.clickedSlide).attr("data-swiper-slide-index"), 10);
        } else {
            slideToIndex = clickedIndex;
        }
        if (swiper.params.loop) {
            var currentIndex = swiper.activeIndex;
            if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
                swiper.loopFix();
                swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
                currentIndex = swiper.activeIndex;
            }
            var prevIndex = swiper.slides.eq(currentIndex).prevAll('[data-swiper-slide-index="' + slideToIndex + '"]').eq(0).index();
            var nextIndex = swiper.slides.eq(currentIndex).nextAll('[data-swiper-slide-index="' + slideToIndex + '"]').eq(0).index();
            if (typeof prevIndex === "undefined") slideToIndex = nextIndex;
            else if (typeof nextIndex === "undefined") slideToIndex = prevIndex;
            else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;
            else slideToIndex = prevIndex;
        }
        swiper.slideTo(slideToIndex);
    },
    update: function update6(initial) {
        var swiper = this;
        var thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper) return;
        var slidesPerView = thumbsSwiper.params.slidesPerView === "auto" ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
        var autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
        var useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
        if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
            var currentThumbsIndex = thumbsSwiper.activeIndex;
            var newThumbsIndex;
            var direction;
            if (thumbsSwiper.params.loop) {
                if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
                    thumbsSwiper.loopFix();
                    thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
                    currentThumbsIndex = thumbsSwiper.activeIndex;
                }
                var prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll('[data-swiper-slide-index="' + swiper.realIndex + '"]').eq(0).index();
                var nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll('[data-swiper-slide-index="' + swiper.realIndex + '"]').eq(0).index();
                if (typeof prevThumbsIndex === "undefined") {
                    newThumbsIndex = nextThumbsIndex;
                } else if (typeof nextThumbsIndex === "undefined") {
                    newThumbsIndex = prevThumbsIndex;
                } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
                    newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;
                } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
                    newThumbsIndex = nextThumbsIndex;
                } else {
                    newThumbsIndex = prevThumbsIndex;
                }
                direction = swiper.activeIndex > swiper.previousIndex ? "next" : "prev";
            } else {
                newThumbsIndex = swiper.realIndex;
                direction = newThumbsIndex > swiper.previousIndex ? "next" : "prev";
            }
            if (useOffset) {
                newThumbsIndex += direction === "next" ? autoScrollOffset : -1 * autoScrollOffset;
            }
            if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
                if (thumbsSwiper.params.centeredSlides) {
                    if (newThumbsIndex > currentThumbsIndex) {
                        newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
                    } else {
                        newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
                    }
                } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) {}
                thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : void 0);
            }
        }
        var thumbsToActivate = 1;
        var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
        if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
            thumbsToActivate = swiper.params.slidesPerView;
        }
        if (!swiper.params.thumbs.multipleActiveThumbs) {
            thumbsToActivate = 1;
        }
        thumbsToActivate = Math.floor(thumbsToActivate);
        thumbsSwiper.slides.removeClass(thumbActiveClass);
        if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
            for(var i2 = 0; i2 < thumbsToActivate; i2 += 1){
                thumbsSwiper.$wrapperEl.children('[data-swiper-slide-index="' + (swiper.realIndex + i2) + '"]').addClass(thumbActiveClass);
            }
        } else {
            for(var _i = 0; _i < thumbsToActivate; _i += 1){
                thumbsSwiper.slides.eq(swiper.realIndex + _i).addClass(thumbActiveClass);
            }
        }
    }
};
var thumbs_default = {
    name: "thumbs",
    params: {
        thumbs: {
            swiper: null,
            multipleActiveThumbs: true,
            autoScrollOffset: 0,
            slideThumbActiveClass: "swiper-slide-thumb-active",
            thumbsContainerClass: "swiper-container-thumbs"
        }
    },
    create: function create22() {
        var swiper = this;
        bindModuleMethods(swiper, {
            thumbs: _extends20({
                swiper: null,
                initialized: false
            }, Thumbs)
        });
    },
    on: {
        beforeInit: function beforeInit8(swiper) {
            var thumbs = swiper.params.thumbs;
            if (!thumbs || !thumbs.swiper) return;
            swiper.thumbs.init();
            swiper.thumbs.update(true);
        },
        slideChange: function slideChange5(swiper) {
            if (!swiper.thumbs.swiper) return;
            swiper.thumbs.update();
        },
        update: function update7(swiper) {
            if (!swiper.thumbs.swiper) return;
            swiper.thumbs.update();
        },
        resize: function resize4(swiper) {
            if (!swiper.thumbs.swiper) return;
            swiper.thumbs.update();
        },
        observerUpdate: function observerUpdate3(swiper) {
            if (!swiper.thumbs.swiper) return;
            swiper.thumbs.update();
        },
        setTransition: function setTransition16(swiper, duration) {
            var thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper) return;
            thumbsSwiper.setTransition(duration);
        },
        beforeDestroy: function beforeDestroy(swiper) {
            var thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper) return;
            if (swiper.thumbs.swiperCreated && thumbsSwiper) {
                thumbsSwiper.destroy();
            }
        }
    }
};
// node_modules/swiper/swiper-bundle.esm.js
var components2 = [
    virtual_default,
    keyboard_default,
    mousewheel_default,
    navigation_default,
    pagination_default,
    scrollbar_default,
    parallax_default,
    zoom_default,
    lazy_default,
    controller_default,
    a11y_default,
    history_default,
    hash_navigation_default,
    autoplay_default,
    effect_fade_default,
    effect_cube_default,
    effect_flip_default,
    effect_coverflow_default,
    thumbs_default
];
core_class_default.use(components2);
// node_modules/@tarojs/components/dist/components/taro-swiper-core.js
var indexCss17 = "@font-face{font-family:swiper-icons;src:url('data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA') format('woff');font-weight:400;font-style:normal}:root{--swiper-theme-color:#007aff}.swiper-container{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1}.swiper-container-vertical>.swiper-wrapper{-ms-flex-direction:column;flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:-ms-flexbox;display:flex;-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform, -webkit-transform;-webkit-box-sizing:content-box;box-sizing:content-box}.swiper-container-android .swiper-slide,.swiper-wrapper{-webkit-transform:translate3d(0px,0,0);transform:translate3d(0px,0,0)}.swiper-container-multirow>.swiper-wrapper{-ms-flex-wrap:wrap;flex-wrap:wrap}.swiper-container-multirow-column>.swiper-wrapper{-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-direction:column;flex-direction:column}.swiper-container-free-mode>.swiper-wrapper{-webkit-transition-timing-function:ease-out;transition-timing-function:ease-out;margin:0 auto}.swiper-container-pointer-events{-ms-touch-action:pan-y;touch-action:pan-y}.swiper-container-pointer-events.swiper-container-vertical{-ms-touch-action:pan-x;touch-action:pan-x}.swiper-slide{-ms-flex-negative:0;flex-shrink:0;width:100%;height:100%;position:relative;-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform, -webkit-transform}.swiper-slide-invisible-blank{visibility:hidden}.swiper-container-autoheight,.swiper-container-autoheight .swiper-slide{height:auto}.swiper-container-autoheight .swiper-wrapper{-ms-flex-align:start;align-items:flex-start;-webkit-transition-property:height,-webkit-transform;transition-property:height,-webkit-transform;transition-property:transform,height;transition-property:transform,height,-webkit-transform}.swiper-container-3d{-webkit-perspective:1200px;perspective:1200px}.swiper-container-3d .swiper-cube-shadow,.swiper-container-3d .swiper-slide,.swiper-container-3d .swiper-slide-shadow-bottom,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top,.swiper-container-3d .swiper-wrapper{-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.swiper-container-3d .swiper-slide-shadow-bottom,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-container-3d .swiper-slide-shadow-left{background-image:-webkit-gradient(linear,right top, left top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-3d .swiper-slide-shadow-right{background-image:-webkit-gradient(linear,left top, right top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-3d .swiper-slide-shadow-top{background-image:-webkit-gradient(linear,left bottom, left top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-3d .swiper-slide-shadow-bottom{background-image:-webkit-gradient(linear,left top, left bottom,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-container-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-container-css-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:start start}.swiper-container-horizontal.swiper-container-css-mode>.swiper-wrapper{-webkit-scroll-snap-type:x mandatory;-ms-scroll-snap-type:x mandatory;scroll-snap-type:x mandatory}.swiper-container-vertical.swiper-container-css-mode>.swiper-wrapper{-webkit-scroll-snap-type:y mandatory;-ms-scroll-snap-type:y mandatory;scroll-snap-type:y mandatory}@font-face{font-family:swiper-icons;src:url('data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA') format('woff');font-weight:400;font-style:normal}:root{--swiper-theme-color:#007aff}.swiper-container{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1}.swiper-container-vertical>.swiper-wrapper{-ms-flex-direction:column;flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:-ms-flexbox;display:flex;-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform, -webkit-transform;-webkit-box-sizing:content-box;box-sizing:content-box}.swiper-container-android .swiper-slide,.swiper-wrapper{-webkit-transform:translate3d(0px,0,0);transform:translate3d(0px,0,0)}.swiper-container-multirow>.swiper-wrapper{-ms-flex-wrap:wrap;flex-wrap:wrap}.swiper-container-multirow-column>.swiper-wrapper{-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-direction:column;flex-direction:column}.swiper-container-free-mode>.swiper-wrapper{-webkit-transition-timing-function:ease-out;transition-timing-function:ease-out;margin:0 auto}.swiper-container-pointer-events{-ms-touch-action:pan-y;touch-action:pan-y}.swiper-container-pointer-events.swiper-container-vertical{-ms-touch-action:pan-x;touch-action:pan-x}.swiper-slide{-ms-flex-negative:0;flex-shrink:0;width:100%;height:100%;position:relative;-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform, -webkit-transform}.swiper-slide-invisible-blank{visibility:hidden}.swiper-container-autoheight,.swiper-container-autoheight .swiper-slide{height:auto}.swiper-container-autoheight .swiper-wrapper{-ms-flex-align:start;align-items:flex-start;-webkit-transition-property:height,-webkit-transform;transition-property:height,-webkit-transform;transition-property:transform,height;transition-property:transform,height,-webkit-transform}.swiper-container-3d{-webkit-perspective:1200px;perspective:1200px}.swiper-container-3d .swiper-cube-shadow,.swiper-container-3d .swiper-slide,.swiper-container-3d .swiper-slide-shadow-bottom,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top,.swiper-container-3d .swiper-wrapper{-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.swiper-container-3d .swiper-slide-shadow-bottom,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-container-3d .swiper-slide-shadow-left{background-image:-webkit-gradient(linear,right top, left top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-3d .swiper-slide-shadow-right{background-image:-webkit-gradient(linear,left top, right top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-3d .swiper-slide-shadow-top{background-image:-webkit-gradient(linear,left bottom, left top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-3d .swiper-slide-shadow-bottom{background-image:-webkit-gradient(linear,left top, left bottom,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-container-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-container-css-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:start start}.swiper-container-horizontal.swiper-container-css-mode>.swiper-wrapper{-webkit-scroll-snap-type:x mandatory;-ms-scroll-snap-type:x mandatory;scroll-snap-type:x mandatory}.swiper-container-vertical.swiper-container-css-mode>.swiper-wrapper{-webkit-scroll-snap-type:y mandatory;-ms-scroll-snap-type:y mandatory;scroll-snap-type:y mandatory}:root{--swiper-navigation-size:44px}.swiper-button-next,.swiper-button-prev{position:absolute;top:50%;width:calc(var(--swiper-navigation-size)/ 44 * 27);height:var(--swiper-navigation-size);margin-top:calc(0px - (var(--swiper-navigation-size)/ 2));z-index:10;cursor:pointer;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;color:var(--swiper-navigation-color,var(--swiper-theme-color))}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-next:after,.swiper-button-prev:after{font-family:swiper-icons;font-size:var(--swiper-navigation-size);text-transform:none!important;letter-spacing:0;text-transform:none;font-variant:initial;line-height:1}.swiper-button-prev,.swiper-container-rtl .swiper-button-next{left:10px;right:auto}.swiper-button-prev:after,.swiper-container-rtl .swiper-button-next:after{content:'prev'}.swiper-button-next,.swiper-container-rtl .swiper-button-prev{right:10px;left:auto}.swiper-button-next:after,.swiper-container-rtl .swiper-button-prev:after{content:'next'}.swiper-button-next.swiper-button-white,.swiper-button-prev.swiper-button-white{--swiper-navigation-color:#ffffff}.swiper-button-next.swiper-button-black,.swiper-button-prev.swiper-button-black{--swiper-navigation-color:#000000}.swiper-button-lock{display:none}.swiper-pagination{position:absolute;text-align:center;-webkit-transition:.3s opacity;transition:.3s opacity;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-container-horizontal>.swiper-pagination-bullets,.swiper-pagination-custom,.swiper-pagination-fraction{bottom:10px;left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{-webkit-transform:scale(.33);transform:scale(.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{-webkit-transform:scale(1);transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{-webkit-transform:scale(1);transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{-webkit-transform:scale(.66);transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{-webkit-transform:scale(.33);transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{-webkit-transform:scale(.66);transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{-webkit-transform:scale(.33);transform:scale(.33)}.swiper-pagination-bullet{width:8px;height:8px;display:inline-block;border-radius:50%;background:#000;opacity:.2}button.swiper-pagination-bullet{border:none;margin:0;padding:0;-webkit-box-shadow:none;box-shadow:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet-active{opacity:1;background:var(--swiper-pagination-color,var(--swiper-theme-color))}.swiper-container-vertical>.swiper-pagination-bullets{right:10px;top:50%;-webkit-transform:translate3d(0px,-50%,0);transform:translate3d(0px,-50%,0)}.swiper-container-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:6px 0;display:block}.swiper-container-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);width:8px}.swiper-container-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;-webkit-transition:.2s transform,.2s top;transition:.2s transform,.2s top}.swiper-container-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 4px}.swiper-container-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%);white-space:nowrap}.swiper-container-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{-webkit-transition:.2s transform,.2s left;transition:.2s transform,.2s left}.swiper-container-horizontal.swiper-container-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{-webkit-transition:.2s transform,.2s right;transition:.2s transform,.2s right}.swiper-pagination-progressbar{background:rgba(0,0,0,.25);position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color,var(--swiper-theme-color));position:absolute;left:0;top:0;width:100%;height:100%;-webkit-transform:scale(0);transform:scale(0);-webkit-transform-origin:left top;transform-origin:left top}.swiper-container-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{-webkit-transform-origin:right top;transform-origin:right top}.swiper-container-horizontal>.swiper-pagination-progressbar,.swiper-container-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:4px;left:0;top:0}.swiper-container-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-container-vertical>.swiper-pagination-progressbar{width:4px;height:100%;left:0;top:0}.swiper-pagination-white{--swiper-pagination-color:#ffffff}.swiper-pagination-black{--swiper-pagination-color:#000000}.swiper-pagination-lock{display:none}.swiper-scrollbar{border-radius:10px;position:relative;-ms-touch-action:none;background:rgba(0,0,0,.1)}.swiper-container-horizontal>.swiper-scrollbar{position:absolute;left:1%;bottom:3px;z-index:50;height:5px;width:98%}.swiper-container-vertical>.swiper-scrollbar{position:absolute;right:3px;top:1%;z-index:50;width:5px;height:98%}.swiper-scrollbar-drag{height:100%;width:100%;position:relative;background:rgba(0,0,0,.5);border-radius:10px;left:0;top:0}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}.swiper-zoom-container{width:100%;height:100%;display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center;text-align:center}.swiper-zoom-container>canvas,.swiper-zoom-container>img,.swiper-zoom-container>svg{max-width:100%;max-height:100%;-o-object-fit:contain;object-fit:contain}.swiper-slide-zoomed{cursor:move}.swiper-lazy-preloader{width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;-webkit-transform-origin:50%;transform-origin:50%;-webkit-animation:swiper-preloader-spin 1s infinite linear;animation:swiper-preloader-spin 1s infinite linear;-webkit-box-sizing:border-box;box-sizing:border-box;border:4px solid var(--swiper-preloader-color,var(--swiper-theme-color));border-radius:50%;border-top-color:transparent}.swiper-lazy-preloader-white{--swiper-preloader-color:#fff}.swiper-lazy-preloader-black{--swiper-preloader-color:#000}@-webkit-keyframes swiper-preloader-spin{100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes swiper-preloader-spin{100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.swiper-container .swiper-notification{position:absolute;left:0;top:0;pointer-events:none;opacity:0;z-index:-1000}.swiper-container-fade.swiper-container-free-mode .swiper-slide{-webkit-transition-timing-function:ease-out;transition-timing-function:ease-out}.swiper-container-fade .swiper-slide{pointer-events:none;-webkit-transition-property:opacity;transition-property:opacity}.swiper-container-fade .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-fade .swiper-slide-active,.swiper-container-fade .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-cube{overflow:visible}.swiper-container-cube .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;visibility:hidden;-webkit-transform-origin:0 0;transform-origin:0 0;width:100%;height:100%}.swiper-container-cube .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-cube.swiper-container-rtl .swiper-slide{-webkit-transform-origin:100% 0;transform-origin:100% 0}.swiper-container-cube .swiper-slide-active,.swiper-container-cube .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-cube .swiper-slide-active,.swiper-container-cube .swiper-slide-next,.swiper-container-cube .swiper-slide-next+.swiper-slide,.swiper-container-cube .swiper-slide-prev{pointer-events:auto;visibility:visible}.swiper-container-cube .swiper-slide-shadow-bottom,.swiper-container-cube .swiper-slide-shadow-left,.swiper-container-cube .swiper-slide-shadow-right,.swiper-container-cube .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-container-cube .swiper-cube-shadow{position:absolute;left:0;bottom:0px;width:100%;height:100%;opacity:.6;z-index:0}.swiper-container-cube .swiper-cube-shadow:before{content:'';background:#000;position:absolute;left:0;top:0;bottom:0;right:0;-webkit-filter:blur(50px);filter:blur(50px)}.swiper-container-flip{overflow:visible}.swiper-container-flip .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1}.swiper-container-flip .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-flip .swiper-slide-active,.swiper-container-flip .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-flip .swiper-slide-shadow-bottom,.swiper-container-flip .swiper-slide-shadow-left,.swiper-container-flip .swiper-slide-shadow-right,.swiper-container-flip .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}taro-swiper-core{height:150px;display:block}taro-swiper-core .swiper-container{height:100%}taro-swiper-core .swiper-pagination{font-size:0}taro-swiper-core .swiper-pagination.swiper-pagination-bullet{opacity:1}taro-swiper-core .swiper-pagination.swiper-pagination-hidden{display:none}";
var __classPrivateFieldGet4 = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet4 = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _Swiper_id;
var _Swiper_source;
var INSTANCE_ID = 0;
var Swiper2 = proxyCustomElement(class extends H {
    watchCurrent(newVal) {
        if (!this.isWillLoadCalled) return;
        const n = parseInt(newVal, 10);
        if (isNaN(n)) return;
        if (this.circular) {
            if (!this.swiper.isBeginning && !this.swiper.isEnd) {
                this.swiper.slideToLoop(n);
            }
        } else {
            this.swiper.slideTo(n);
        }
    }
    watchAutoplay(newVal) {
        if (!this.isWillLoadCalled || !this.swiper) return;
        const swiperAutoplay = this.swiper.autoplay;
        if (swiperAutoplay) {
            if (swiperAutoplay.running === newVal) return;
            if (newVal) {
                if (this.swiper.params && typeof this.swiper.params.autoplay === "object") {
                    if (this.swiper.params.autoplay.disableOnInteraction === true) {
                        this.swiper.params.autoplay.disableOnInteraction = false;
                    }
                    this.swiper.params.autoplay.delay = this.interval;
                }
                swiperAutoplay.start();
            } else {
                swiperAutoplay.stop();
            }
        }
    }
    watchDuration(newVal) {
        if (!this.isWillLoadCalled) return;
        this.swiper.params.speed = newVal;
    }
    watchInterval(newVal) {
        if (!this.isWillLoadCalled) return;
        if (typeof this.swiper.params.autoplay === "object") {
            this.swiper.params.autoplay.delay = newVal;
        }
    }
    watchSwiperWrapper(newVal) {
        if (!this.isWillLoadCalled) return;
        if (!newVal) return;
        this.el.appendChild = (newChild)=>{
            return newVal.appendChild(newChild);
        };
        this.el.insertBefore = (newChild, refChild)=>{
            return newVal.insertBefore(newChild, refChild);
        };
        this.el.replaceChild = (newChild, oldChild)=>{
            return newVal.replaceChild(newChild, oldChild);
        };
        this.el.removeChild = (oldChild)=>{
            return newVal.removeChild(oldChild);
        };
        this.el.addEventListener("DOMNodeInserted", this.handleSwiperSizeDebounce);
        this.el.addEventListener("DOMNodeRemoved", this.handleSwiperSizeDebounce);
        this.el.addEventListener("MutationObserver", this.handleSwiperSizeDebounce);
    }
    watchCircular() {
        if (this.swiper) {
            this.swiper.destroy();
            this.handleInit();
        }
    }
    watchDisplayMultipleItems() {
        if (this.swiper) {
            this.swiper.destroy();
            this.handleInit();
        }
    }
    componentWillLoad() {
        this.isWillLoadCalled = true;
    }
    componentDidLoad() {
        var _a;
        this.handleInit();
        if (!this.swiper || !this.circular) return;
        const wrapper = (_a = this.swiper.$wrapperEl) === null || _a === void 0 ? void 0 : _a[0];
        this.observer = new MutationObserver(this.handleSwiperLoopListen);
        this.observer.observe(wrapper, {
            childList: true
        });
    }
    componentWillUpdate() {
        var _a, _b;
        if (!this.swiper) return;
        if (this.autoplay && !((_a = this.swiper.autoplay) === null || _a === void 0 ? void 0 : _a.running)) {
            (_b = this.swiper.autoplay) === null || _b === void 0 ? void 0 : _b.start();
        }
        if (this.swiper.$el) {
            this.swiper.update();
        }
    }
    componentDidRender() {
        this.handleSwiperLoop();
    }
    disconnectedCallback() {
        var _a, _b, _c, _d, _e, _f;
        this.el.removeEventListener("DOMNodeInserted", this.handleSwiperSizeDebounce);
        this.el.removeEventListener("DOMNodeRemoved", this.handleSwiperSizeDebounce);
        this.el.removeEventListener("MutationObserver", this.handleSwiperSizeDebounce);
        (_b = (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect) === null || _b === void 0 ? void 0 : _b.call(_a);
        (_d = (_c = this.observerFirst) === null || _c === void 0 ? void 0 : _c.disconnect) === null || _d === void 0 ? void 0 : _d.call(_c);
        (_f = (_e = this.observerLast) === null || _e === void 0 ? void 0 : _e.disconnect) === null || _f === void 0 ? void 0 : _f.call(_e);
    }
    handleInit() {
        const { autoplay, circular, current, displayMultipleItems, duration, interval, vertical } = this;
        const that = this;
        const options3 = {
            pagination: {
                el: `.taro-swiper-${__classPrivateFieldGet4(this, _Swiper_id, "f")} > .swiper-container > .swiper-pagination`
            },
            direction: vertical ? "vertical" : "horizontal",
            loop: circular,
            slidesPerView: displayMultipleItems,
            initialSlide: circular ? current + 1 : current,
            speed: duration,
            observer: true,
            observeParents: true,
            zoom: this.zoom,
            on: {
                slideTo () {
                    that.current = this.realIndex;
                },
                // Note: slideChange 事件在 swiper.slideTo 改写 current 时不触发，因此用 slideChangeTransitionEnd 事件代替
                slideChangeTransitionEnd () {
                    if (circular) {
                        if (this.isBeginning || this.isEnd) {
                            this.slideToLoop(this.realIndex, 0);
                            return;
                        }
                    }
                    that.onChange.emit({
                        current: this.realIndex,
                        source: __classPrivateFieldGet4(that, _Swiper_source, "f")
                    });
                },
                touchEnd: ()=>{
                    __classPrivateFieldSet4(that, _Swiper_source, "touch", "f");
                },
                autoplay () {
                    __classPrivateFieldSet4(that, _Swiper_source, "autoplay", "f");
                },
                transitionEnd () {
                    setTimeout(()=>{
                        __classPrivateFieldSet4(that, _Swiper_source, "", "f");
                    });
                    that.onAnimationFinish.emit({
                        current: this.realIndex,
                        source: __classPrivateFieldGet4(that, _Swiper_source, "f")
                    });
                },
                observerUpdate (_swiper, e) {
                    const target = e.target;
                    const className = target && typeof target.className === "string" ? target.className : "";
                    if (className.includes("taro_page") && target.style.display !== "none") {
                        if (that.autoplay && target.contains(_swiper.$el[0])) {
                            if (that.circular) {
                                _swiper.slideToLoop(this.realIndex, 0);
                            } else {
                                _swiper.slideTo(this.realIndex);
                            }
                        }
                    }
                }
            }
        };
        if (autoplay) {
            options3.autoplay = {
                delay: interval,
                disableOnInteraction: false
            };
        }
        this.swiper = new core_class_default(`.taro-swiper-${__classPrivateFieldGet4(this, _Swiper_id, "f")} > .swiper-container`, options3);
        this.swiperWrapper = this.el.querySelector(`.taro-swiper-${__classPrivateFieldGet4(this, _Swiper_id, "f")} > .swiper-container > .swiper-wrapper`);
    }
    render() {
        const { vertical, indicatorDots, indicatorColor, indicatorActiveColor } = this;
        const hostStyle = {
            overflow: "hidden"
        };
        const style = {
            overflow: "visible"
        };
        if (this.full) {
            hostStyle.height = "100%";
            style.height = "100%";
        }
        const [, previousMargin] = /^(\d+)px/.exec(this.previousMargin) || [];
        const [, nextMargin] = /^(\d+)px/.exec(this.nextMargin) || [];
        const pM = parseInt(previousMargin) || 0;
        const nM = parseInt(nextMargin) || 0;
        if (vertical) {
            style.marginTop = `${pM}px`;
            style.marginBottom = `${nM}px`;
        } else {
            style.marginRight = `${nM}px`;
            style.marginLeft = `${pM}px`;
        }
        return h(Host, {
            class: `taro-swiper-${__classPrivateFieldGet4(this, _Swiper_id, "f")}`,
            style: hostStyle
        }, h("div", {
            class: "swiper-container",
            style
        }, h("style", {
            type: "text/css"
        }, `
              .taro-swiper-${__classPrivateFieldGet4(this, _Swiper_id, "f")} > .swiper-container > .swiper-pagination > .swiper-pagination-bullet { background: ${indicatorColor} }
              .taro-swiper-${__classPrivateFieldGet4(this, _Swiper_id, "f")} > .swiper-container > .swiper-pagination > .swiper-pagination-bullet-active { background: ${indicatorActiveColor} }
            `), h("div", {
            class: "swiper-wrapper"
        }, h("slot", null)), h("div", {
            class: classnames("swiper-pagination", {
                "swiper-pagination-hidden": !indicatorDots,
                "swiper-pagination-bullets": indicatorDots
            })
        })));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "current": [
                "watchCurrent"
            ],
            "autoplay": [
                "watchAutoplay"
            ],
            "duration": [
                "watchDuration"
            ],
            "interval": [
                "watchInterval"
            ],
            "swiperWrapper": [
                "watchSwiperWrapper"
            ],
            "circular": [
                "watchCircular"
            ],
            "displayMultipleItems": [
                "watchDisplayMultipleItems"
            ]
        };
    }
    static get style() {
        return indexCss17;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "change", 7);
        this.onAnimationFinish = createEvent(this, "animationfinish", 7);
        _Swiper_id.set(this, INSTANCE_ID++);
        _Swiper_source.set(this, "");
        this.handleSwiperLoopListen = ()=>{
            var _a, _b, _c;
            ((_a = this.observerFirst) === null || _a === void 0 ? void 0 : _a.disconnect) && this.observerFirst.disconnect();
            ((_b = this.observerLast) === null || _b === void 0 ? void 0 : _b.disconnect) && this.observerLast.disconnect();
            this.observerFirst = new MutationObserver(this.handleSwiperLoopDebounce);
            this.observerLast = new MutationObserver(this.handleSwiperLoopDebounce);
            const wrapper = (_c = this.swiper.$wrapperEl) === null || _c === void 0 ? void 0 : _c[0];
            const list2 = wrapper.querySelectorAll("taro-swiper-item-core:not(.swiper-slide-duplicate)");
            if (list2.length >= 1) {
                this.observerFirst.observe(list2[0], {
                    characterData: true
                });
            } else if (list2.length >= 2) {
                this.observerLast.observe(list2[list2.length - 1], {
                    characterData: true
                });
            }
        };
        this.handleSwiperLoop = ()=>{
            var _a, _b, _c, _d;
            if (!this.swiper || !this.circular) return;
            const swiper = this.swiper;
            const duplicates = ((_a = this.swiperWrapper) === null || _a === void 0 ? void 0 : _a.querySelectorAll(".swiper-slide-duplicate")) || [];
            if (duplicates.length < 2) {
                (_b = swiper.loopDestroy) === null || _b === void 0 ? void 0 : _b.call(swiper);
                (_c = swiper.loopCreate) === null || _c === void 0 ? void 0 : _c.call(swiper);
            } else {
                (_d = swiper.loopFix) === null || _d === void 0 ? void 0 : _d.call(swiper);
            }
        };
        this.handleSwiperLoopDebounce = debounce2(this.handleSwiperLoop, 50);
        this.handleSwiperSizeDebounce = debounce2(()=>{
            if (this.swiper && this.swiper.$wrapperEl && !this.circular) {
                this.swiper.updateSlides();
            }
        }, 50);
        this.swiperWrapper = void 0;
        this.swiper = void 0;
        this.isWillLoadCalled = false;
        this.indicatorDots = false;
        this.indicatorColor = "rgba(0, 0, 0, .3)";
        this.indicatorActiveColor = "#000000";
        this.autoplay = false;
        this.current = 0;
        this.interval = 5e3;
        this.duration = 500;
        this.circular = false;
        this.vertical = false;
        this.previousMargin = "0px";
        this.nextMargin = "0px";
        this.displayMultipleItems = 1;
        this.full = false;
        this.zoom = false;
        this.observer = void 0;
        this.observerFirst = void 0;
        this.observerLast = void 0;
    }
}, [
    4,
    "taro-swiper-core",
    {
        "indicatorDots": [
            4,
            "indicator-dots"
        ],
        "indicatorColor": [
            1,
            "indicator-color"
        ],
        "indicatorActiveColor": [
            1,
            "indicator-active-color"
        ],
        "autoplay": [
            4
        ],
        "current": [
            2
        ],
        "interval": [
            2
        ],
        "duration": [
            2
        ],
        "circular": [
            4
        ],
        "vertical": [
            4
        ],
        "previousMargin": [
            1,
            "previous-margin"
        ],
        "nextMargin": [
            1,
            "next-margin"
        ],
        "displayMultipleItems": [
            2,
            "display-multiple-items"
        ],
        "full": [
            4
        ],
        "zoom": [
            4
        ],
        "swiperWrapper": [
            32
        ],
        "swiper": [
            32
        ],
        "isWillLoadCalled": [
            32
        ],
        "observer": [
            32
        ],
        "observerFirst": [
            32
        ],
        "observerLast": [
            32
        ]
    }
]);
_Swiper_id = /* @__PURE__ */ new WeakMap(), _Swiper_source = /* @__PURE__ */ new WeakMap();
function defineCustomElement$168() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-swiper-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-swiper-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Swiper2);
                }
                break;
        }
    });
}
var defineCustomElement = defineCustomElement$168;
// node_modules/@tarojs/components/dist/components/taro-swiper-item-core.js
var nativeCloneNode = Node.prototype.cloneNode;
var SwiperItem = proxyCustomElement(class extends H {
    handleCloneNode(node, deep) {
        const clonedNode = nativeCloneNode.call(node, false);
        const srcChildNodes = this.handleChildNodes(node);
        if (deep) {
            for(let i2 = 0; i2 < srcChildNodes.length; i2++){
                const srcNode = srcChildNodes[i2];
                if (!srcNode) break;
                let srcDeep = deep;
                if (srcNode.nodeType !== 2 && srcNode.nodeType !== 8) {
                    if (this.deep !== true && !srcNode["s-cr"]) {
                        srcDeep = false;
                    }
                    const childClone = this.handleCloneNode(srcNode, srcDeep);
                    clonedNode.appendChild(childClone);
                }
            }
        }
        return clonedNode;
    }
    handleChildNodes(node) {
        const childNodes = node.childNodes;
        if (node["s-sc"]) {
            const result = [];
            for(let i2 = 0; i2 < childNodes.length; i2++){
                const slot = childNodes[i2]["s-nr"];
                if (slot) {
                    result.push(slot);
                }
            }
            return result;
        }
        return Array.from(childNodes);
    }
    componentDidRender() {
        this.el.cloneNode = (deep = false)=>{
            return this.handleCloneNode(this.el, deep);
        };
    }
    render() {
        return h(Host, {
            class: "swiper-slide",
            "item-id": this.itemId
        });
    }
    get el() {
        return this;
    }
    constructor(){
        super();
        this.__registerHost();
        this.itemId = void 0;
        this.deep = false;
    }
}, [
    0,
    "taro-swiper-item-core",
    {
        "itemId": [
            1,
            "item-id"
        ],
        "deep": [
            4
        ]
    }
]);
function defineCustomElement$169() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-swiper-item-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-swiper-item-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, SwiperItem);
                }
                break;
        }
    });
}
var defineCustomElement2 = defineCustomElement$169;
// node_modules/@tarojs/components/dist/components/taro-switch-core.js
var indexCss18 = '.weui-cell_switch{padding-top:6.5px;padding-bottom:6.5px}.weui-switch{-webkit-appearance:none;-moz-appearance:none;appearance:none}.weui-switch,.weui-switch-cp__box{-webkit-box-sizing:border-box;box-sizing:border-box;background-color:#dfdfdf;border:1px solid #dfdfdf;border-radius:16px;outline:0;width:52px;height:32px;-webkit-transition:background-color .1s,border .1s;transition:background-color .1s,border .1s;position:relative}.weui-switch:before,.weui-switch-cp__box:before{content:" ";background-color:#fdfdfd;border-radius:15px;width:50px;height:30px;-webkit-transition:-webkit-transform .35s cubic-bezier(.45,1,.4,1);transition:-webkit-transform .35s cubic-bezier(.45,1,.4,1);transition:transform .35s cubic-bezier(.45,1,.4,1);transition:transform .35s cubic-bezier(.45,1,.4,1), -webkit-transform .35s cubic-bezier(.45,1,.4,1);position:absolute;top:0;left:0}.weui-switch:after,.weui-switch-cp__box:after{content:" ";background-color:#fff;border-radius:15px;width:30px;height:30px;-webkit-transition:-webkit-transform .35s cubic-bezier(.4,.4,.25,1.35);transition:-webkit-transform .35s cubic-bezier(.4,.4,.25,1.35);transition:transform .35s cubic-bezier(.4,.4,.25,1.35);transition:transform .35s cubic-bezier(.4,.4,.25,1.35), -webkit-transform .35s cubic-bezier(.4,.4,.25,1.35);position:absolute;top:0;left:0;-webkit-box-shadow:0 1px 3px rgba(0,0,0,.4);box-shadow:0 1px 3px rgba(0,0,0,.4)}.weui-switch:checked,.weui-switch-cp__input:checked~.weui-switch-cp__box{background-color:#04be02;border-color:#04be02}.weui-switch:checked:before,.weui-switch-cp__input:checked~.weui-switch-cp__box:before{-webkit-transform:scale(0);transform:scale(0)}.weui-switch:checked:after,.weui-switch-cp__input:checked~.weui-switch-cp__box:after{-webkit-transform:translate(20px);transform:translate(20px)}.weui-switch-cp__input{position:absolute;left:-9999px}.weui-switch-cp__box{display:block}taro-switch-core{width:52px;height:32px;display:inline-block}taro-switch-core .weui-switch{width:100%;height:100%;display:block}';
var Switch = proxyCustomElement(class extends H {
    function(newValue) {
        if (!this.isWillLoadCalled) return;
        if (this.inputRef.checked !== newValue) {
            this.inputRef.checked = newValue;
        }
    }
    componentWillLoad() {
        this.isWillLoadCalled = true;
    }
    componentDidLoad() {
        Object.defineProperty(this.el, "value", {
            get: ()=>this.checked,
            configurable: true
        });
    }
    render() {
        const { type, color, checked, name, disabled, nativeProps } = this;
        const style = checked ? {
            borderColor: color || "04BE02",
            backgroundColor: color || "04BE02"
        } : {};
        return h("input", Object.assign({
            ref: (input)=>{
                this.inputRef = input;
            },
            type: "checkbox",
            class: `weui-${type}`,
            style,
            checked,
            name,
            disabled,
            onChange: this.switchChange
        }, nativeProps));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "checked": [
                "function"
            ]
        };
    }
    static get style() {
        return indexCss18;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "change", 7);
        this.switchChange = (e)=>{
            e.stopPropagation();
            const value = e.target.checked;
            this.checked = value;
            this.onChange.emit({
                value
            });
        };
        this.type = "switch";
        this.checked = false;
        this.color = "#04BE02";
        this.name = void 0;
        this.disabled = false;
        this.nativeProps = {};
        this.isWillLoadCalled = false;
    }
}, [
    0,
    "taro-switch-core",
    {
        "type": [
            1
        ],
        "checked": [
            1028
        ],
        "color": [
            1
        ],
        "name": [
            1
        ],
        "disabled": [
            4
        ],
        "nativeProps": [
            16
        ],
        "isWillLoadCalled": [
            32
        ]
    }
]);
function defineCustomElement$170() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-switch-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-switch-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Switch);
                }
                break;
        }
    });
}
var defineCustomElement72 = defineCustomElement$170;
// node_modules/@tarojs/components/dist/components/taro-tab-item-core.js
var TabItem = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("TabItem", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-tab-item-core"
]);
function defineCustomElement$171() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-tab-item-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-tab-item-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, TabItem);
                }
                break;
        }
    });
}
var defineCustomElement73 = defineCustomElement$171;
// node_modules/resolve-pathname/esm/resolve-pathname.js
function isAbsolute(pathname) {
    return pathname.charAt(0) === "/";
}
function spliceOne(list2, index2) {
    for(var i2 = index2, k = i2 + 1, n = list2.length; k < n; i2 += 1, k += 1){
        list2[i2] = list2[k];
    }
    list2.pop();
}
function resolvePathname(to, from) {
    if (from === void 0) from = "";
    var toParts = to && to.split("/") || [];
    var fromParts = from && from.split("/") || [];
    var isToAbs = to && isAbsolute(to);
    var isFromAbs = from && isAbsolute(from);
    var mustEndAbs = isToAbs || isFromAbs;
    if (to && isAbsolute(to)) {
        fromParts = toParts;
    } else if (toParts.length) {
        fromParts.pop();
        fromParts = fromParts.concat(toParts);
    }
    if (!fromParts.length) return "/";
    var hasTrailingSlash;
    if (fromParts.length) {
        var last = fromParts[fromParts.length - 1];
        hasTrailingSlash = last === "." || last === ".." || last === "";
    } else {
        hasTrailingSlash = false;
    }
    var up = 0;
    for(var i2 = fromParts.length; i2 >= 0; i2--){
        var part = fromParts[i2];
        if (part === ".") {
            spliceOne(fromParts, i2);
        } else if (part === "..") {
            spliceOne(fromParts, i2);
            up++;
        } else if (up) {
            spliceOne(fromParts, i2);
            up--;
        }
    }
    if (!mustEndAbs) for(; up--; up)fromParts.unshift("..");
    if (mustEndAbs && fromParts[0] !== "" && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift("");
    var result = fromParts.join("/");
    if (hasTrailingSlash && result.substr(-1) !== "/") result += "/";
    return result;
}
var resolve_pathname_default = resolvePathname;
// node_modules/@tarojs/components/dist/components/taro-tabbar.js
var splitUrl = (_url)=>{
    let url = _url || "";
    let pos;
    const res = {
        path: null,
        query: null,
        fragment: null
    };
    pos = url.indexOf("#");
    if (pos > -1) {
        res.fragment = url.substring(pos + 1);
        url = url.substring(0, pos);
    }
    pos = url.indexOf("?");
    if (pos > -1) {
        res.query = url.substring(pos + 1);
        url = url.substring(0, pos);
    }
    res.path = url;
    return res;
};
var TabbarItem = ({ index: index2, isSelected = false, textColor, iconPath, badgeText, showRedDot = false, pagePath, text: text2, onSelect })=>{
    const className = classnames("weui-tabbar__item", {
        "weui-bar__item_on": isSelected
    });
    const badgeStyle = {
        position: "absolute",
        top: "-2px",
        right: "-13px"
    };
    const dotStyle = {
        position: "absolute",
        top: "0",
        right: "-6px"
    };
    function onClick2() {
        const page = taro.getCurrentPages().shift();
        if (typeof (page === null || page === void 0 ? void 0 : page.onTabItemTap) === "function" && isVisible(this)) {
            page.onTabItemTap({
                index: index2,
                pagePath,
                text: text2
            });
        }
        onSelect(index2);
    }
    return h("a", {
        key: index2,
        href: "javascript:;",
        class: className,
        onClick: onClick2
    }, h("span", {
        style: {
            display: "inline-block",
            position: "relative"
        }
    }, h("img", {
        src: iconPath,
        alt: "",
        class: "weui-tabbar__icon"
    }), !!badgeText && h("span", {
        class: "weui-badge taro-tabbar-badge",
        style: badgeStyle
    }, badgeText), showRedDot && h("span", {
        class: "weui-badge weui-badge_dot",
        style: dotStyle
    })), h("p", {
        class: "weui-tabbar__label",
        style: {
            color: textColor
        }
    }, text2));
};
var indexCss19 = '.weui-tabbar{z-index:500;background-color:#f7f7fa;width:100%;display:-ms-flexbox;display:flex;position:absolute;bottom:0}.weui-tabbar:before{content:" ";color:#c0bfc4;-webkit-transform-origin:0 0;transform-origin:0 0;border-top:1px solid #c0bfc4;height:1px;position:absolute;top:0;left:0;right:0;-webkit-transform:scaleY(.5);transform:scaleY(.5)}.weui-tabbar__item{padding:5px 0;padding-bottom:constant(safe-area-inset-bottom);padding-bottom:env(safe-area-inset-bottom);color:#999;text-align:center;-webkit-tap-highlight-color:transparent;-ms-flex:1;flex:1;font-size:0;display:block}.weui-tabbar__item.weui-bar__item_on .weui-tabbar__icon,.weui-tabbar__item.weui-bar__item_on .weui-tabbar__icon>i,.weui-tabbar__item.weui-bar__item_on .weui-tabbar__label{color:#09bb07}.weui-tabbar__icon{width:27px;height:27px;display:inline-block}.weui-tabbar__icon img{width:100%;height:100%}i.weui-tabbar__icon,.weui-tabbar__icon>i{color:#999;font-size:24px}.weui-tabbar__label{text-align:center;color:#999;font-size:10px;line-height:1.8}.weui-badge{color:#fff;text-align:center;vertical-align:middle;background-color:#f43530;border-radius:18px;min-width:8px;padding:.15em .4em;font-size:12px;line-height:1.2;display:inline-block}.weui-badge_dot{min-width:0;padding:.4em}html,body{height:100%}:root{--taro-tabbar-height:$weuiTabBarHeight}#app{height:100%}.taro-tabbar__border-white:before{border-top-color:#fff!important}.taro-tabbar__container{-ms-flex-direction:column;flex-direction:column;height:100%;display:-ms-flexbox;display:flex;overflow:hidden}.taro-tabbar__panel{-webkit-overflow-scrolling:auto;-ms-flex:1;flex:1;position:relative;overflow:auto}.taro-tabbar__tabbar{height:var(--taro-tabbar-height);width:100%;-webkit-transition:bottom .2s,top .2s;transition:bottom .2s,top .2s;position:relative}.taro-tabbar__tabbar-top{top:0}.taro-tabbar__tabbar-bottom{margin-bottom:constant(safe-area-inset-bottom);margin-bottom:env(safe-area-inset-bottom);bottom:0}.taro-tabbar__tabbar-hide{display:none}.taro-tabbar__tabbar-slideout{-ms-flex:0 0;flex:0 0;top:-52px}.taro-tabbar__panel+.taro-tabbar__tabbar-slideout{top:auto;bottom:-52px}';
var STATUS_SHOW = 0;
var STATUS_HIDE = 1;
var STATUS_SLIDEOUT = 2;
var basicTabBarClassName = "taro-tabbar__tabbar";
var hideTabBarClassName = "taro-tabbar__tabbar-hide";
var hideTabBarWithAnimationClassName = "taro-tabbar__tabbar-slideout";
var Tabbar = proxyCustomElement(class extends H {
    componentWillLoad() {
        var _a, _b;
        const list2 = ((_a = this.conf) === null || _a === void 0 ? void 0 : _a.list) || [];
        const customRoutes = ((_b = this.conf) === null || _b === void 0 ? void 0 : _b.customRoutes) || {};
        if (Object.prototype.toString.call(list2) !== "[object Array]" || list2.length < 2 || list2.length > 5) {
            throw new Error("tabBar \u914D\u7F6E\u9519\u8BEF");
        }
        this.homePage = addLeadingSlash(this.conf.homePage);
        for(let key in customRoutes){
            const path = customRoutes[key];
            key = addLeadingSlash(key);
            if (typeof path === "string") {
                this.customRoutes.push([
                    key,
                    addLeadingSlash(path)
                ]);
            } else if ((path === null || path === void 0 ? void 0 : path.length) > 0) {
                this.customRoutes.push(...path.map((p)=>[
                        key,
                        addLeadingSlash(p)
                    ]));
            }
        }
        list2.forEach((item)=>{
            if (item.pagePath.indexOf("/") !== 0) {
                item.pagePath = "/" + item.pagePath;
            }
        });
        this.list = list2;
        this.borderStyle = this.conf.borderStyle;
        this.backgroundColor = this.conf.backgroundColor;
        this.color = this.conf.color;
        this.selectedColor = this.conf.selectedColor;
    }
    getCurrentUrl() {
        const routePath = getCurrentPage(this.conf.mode, this.conf.basename);
        return decodeURI(routePath === "/" ? this.homePage : routePath);
    }
    bindEvent() {
        taro.eventCenter.on("__taroRouterChange", this.routerChangeHandler);
        taro.eventCenter.on("__taroSwitchTab", this.switchTabHandler);
        taro.eventCenter.on("__taroSetTabBarBadge", this.setTabBarBadgeHandler);
        taro.eventCenter.on("__taroRemoveTabBarBadge", this.removeTabBarBadgeHandler);
        taro.eventCenter.on("__taroShowTabBarRedDotHandler", this.showTabBarRedDotHandler);
        taro.eventCenter.on("__taroHideTabBarRedDotHandler", this.hideTabBarRedDotHandler);
        taro.eventCenter.on("__taroShowTabBar", this.showTabBarHandler);
        taro.eventCenter.on("__taroHideTabBar", this.hideTabBarHandler);
        taro.eventCenter.on("__taroSetTabBarStyle", this.setTabBarStyleHandler);
        taro.eventCenter.on("__taroSetTabBarItem", this.setTabBarItemHandler);
    }
    removeEvent() {
        taro.eventCenter.off("__taroRouterChange", this.routerChangeHandler);
        taro.eventCenter.off("__taroSwitchTab", this.switchTabHandler);
        taro.eventCenter.off("__taroSetTabBarBadge", this.setTabBarBadgeHandler);
        taro.eventCenter.off("__taroRemoveTabBarBadge", this.removeTabBarBadgeHandler);
        taro.eventCenter.off("__taroShowTabBarRedDotHandler", this.showTabBarRedDotHandler);
        taro.eventCenter.off("__taroHideTabBarRedDotHandler", this.hideTabBarRedDotHandler);
        taro.eventCenter.off("__taroShowTabBar", this.showTabBarHandler);
        taro.eventCenter.off("__taroHideTabBar", this.hideTabBarHandler);
        taro.eventCenter.off("__taroSetTabBarStyle", this.setTabBarStyleHandler);
        taro.eventCenter.off("__taroSetTabBarItem", this.setTabBarItemHandler);
    }
    componentDidLoad() {
        this.tabbarPos = this.tabbar.nextElementSibling ? "top" : "bottom";
        this.bindEvent();
        this.routerChangeHandler();
    }
    disconnectedCallback() {
        this.removeEvent();
    }
    render() {
        const { tabbarPos = "bottom" } = this;
        const status2 = this.status;
        const containerCls = classnames("weui-tabbar", {
            [`taro-tabbar__border-${this.borderStyle || "black"}`]: true
        });
        const shouldHideTabBar = this.selectedIndex === -1 || status2 === STATUS_HIDE;
        const shouldSlideout = status2 === STATUS_SLIDEOUT;
        return h(Host, {
            class: classnames(basicTabBarClassName, `${basicTabBarClassName}-${tabbarPos}`, {
                [hideTabBarClassName]: shouldHideTabBar,
                [hideTabBarWithAnimationClassName]: shouldSlideout
            })
        }, h("div", {
            class: containerCls,
            style: {
                backgroundColor: this.backgroundColor || "",
                height: "inherit"
            }
        }, this.list.map((item, index2)=>{
            const isSelected = this.selectedIndex === index2;
            let textColor;
            let iconPath;
            if (isSelected) {
                textColor = this.selectedColor || "";
                iconPath = item.selectedIconPath;
            } else {
                textColor = this.color || "";
                iconPath = item.iconPath;
            }
            return h(TabbarItem, {
                index: index2,
                onSelect: this.switchTab.bind(this),
                isSelected,
                textColor,
                iconPath,
                pagePath: item.pagePath,
                text: item.text,
                badgeText: item.badgeText,
                showRedDot: item.showRedDot
            });
        })));
    }
    get tabbar() {
        return this;
    }
    static get style() {
        return indexCss19;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onLongPress = createEvent(this, "longpress", 7);
        this.homePage = "";
        this.customRoutes = [];
        this.tabbarPos = "bottom";
        this.getOriginUrl = (url)=>{
            const customRoute = this.customRoutes.filter(([, customUrl])=>{
                const pathA = splitUrl(customUrl).path;
                const pathB = splitUrl(url).path;
                return pathA === pathB;
            });
            return stripSuffix(customRoute.length ? customRoute[0][0] : url, ".html");
        };
        this.getSelectedIndex = (url)=>{
            let foundIndex = -1;
            this.list.forEach(({ pagePath }, idx)=>{
                const pathA = splitUrl(url).path;
                const pathB = splitUrl(pagePath).path;
                if (pathA === pathB) {
                    foundIndex = idx;
                }
            });
            return foundIndex;
        };
        this.switchTab = (index2)=>{
            this.selectedIndex = index2;
            taro.switchTab({
                url: this.list[index2].pagePath
            });
        };
        this.switchTabHandler = ({ url, successHandler, errorHandler })=>{
            const currentUrl = this.getOriginUrl(this.getCurrentUrl() || this.homePage);
            const nextTab = resolve_pathname_default(url, currentUrl);
            const foundIndex = this.getSelectedIndex(nextTab);
            if (foundIndex > -1) {
                this.switchTab(foundIndex);
                successHandler({
                    errMsg: "switchTab:ok"
                });
            } else {
                errorHandler({
                    errMsg: `switchTab:fail page "${nextTab}" is not found`
                });
            }
        };
        this.routerChangeHandler = (options3)=>{
            var _a;
            const to = (_a = options3 === null || options3 === void 0 ? void 0 : options3.toLocation) === null || _a === void 0 ? void 0 : _a.path;
            let currentPage;
            if (typeof to === "string") {
                const routerBasename = this.conf.basename || "/";
                currentPage = stripBasename(addLeadingSlash(to || this.homePage), routerBasename) || "/";
            } else {
                currentPage = this.getCurrentUrl();
            }
            this.selectedIndex = this.getSelectedIndex(this.getOriginUrl(currentPage));
        };
        this.setTabBarBadgeHandler = ({ index: index2, text: text2, successHandler, errorHandler })=>{
            const list2 = [
                ...this.list
            ];
            if (index2 in list2) {
                list2[index2].showRedDot = false;
                list2[index2].badgeText = text2;
                successHandler({
                    errMsg: "setTabBarBadge:ok"
                });
            } else {
                errorHandler({
                    errMsg: "setTabBarBadge:fail tabbar item not found"
                });
            }
            this.list = list2;
        };
        this.removeTabBarBadgeHandler = ({ index: index2, successHandler, errorHandler })=>{
            const list2 = [
                ...this.list
            ];
            if (index2 in list2) {
                list2[index2].badgeText = null;
                list2[index2].badgeText = null;
                successHandler({
                    errMsg: "removeTabBarBadge:ok"
                });
            } else {
                errorHandler({
                    errMsg: "removeTabBarBadge:fail tabbar item not found"
                });
            }
            this.list = list2;
        };
        this.showTabBarRedDotHandler = ({ index: index2, successHandler, errorHandler })=>{
            const list2 = [
                ...this.list
            ];
            if (index2 in list2) {
                list2[index2].badgeText = null;
                list2[index2].showRedDot = true;
                successHandler({
                    errMsg: "showTabBarRedDot:ok"
                });
            } else {
                errorHandler({
                    errMsg: "showTabBarRedDot:fail tabbar item not found"
                });
            }
            this.list = list2;
        };
        this.hideTabBarRedDotHandler = ({ index: index2, successHandler, errorHandler })=>{
            const list2 = [
                ...this.list
            ];
            if (index2 in list2) {
                list2[index2].showRedDot = false;
                successHandler({
                    errMsg: "hideTabBarRedDot:ok"
                });
            } else {
                errorHandler({
                    errMsg: "hideTabBarRedDot:fail tabbar item not found"
                });
            }
            this.list = list2;
        };
        this.showTabBarHandler = ({ successHandler })=>{
            this.status = STATUS_SHOW;
            successHandler({
                errMsg: "showTabBar:ok"
            });
        };
        this.hideTabBarHandler = ({ animation, successHandler })=>{
            this.status = animation ? STATUS_SLIDEOUT : STATUS_HIDE;
            successHandler({
                errMsg: "hideTabBar:ok"
            });
        };
        this.setTabBarStyleHandler = ({ color, selectedColor, backgroundColor, borderStyle, successHandler })=>{
            if (backgroundColor) this.backgroundColor = backgroundColor;
            if (borderStyle) this.borderStyle = borderStyle;
            if (color) this.color = color;
            if (selectedColor) this.selectedColor = selectedColor;
            successHandler({
                errMsg: "setTabBarStyle:ok"
            });
        };
        this.setTabBarItemHandler = ({ index: index2, iconPath, selectedIconPath, text: text2, successHandler, errorHandler })=>{
            const list2 = [
                ...this.list
            ];
            if (index2 in list2) {
                if (iconPath) list2[index2].iconPath = iconPath;
                if (selectedIconPath) list2[index2].selectedIconPath = selectedIconPath;
                if (text2) list2[index2].text = text2;
                successHandler({
                    errMsg: "setTabBarItem:ok"
                });
            } else {
                errorHandler({
                    errMsg: "setTabBarItem:fail tabbar item not found"
                });
            }
            this.list = list2;
        };
        this.conf = void 0;
        this.list = void 0;
        this.borderStyle = void 0;
        this.backgroundColor = void 0;
        this.color = void 0;
        this.selectedColor = void 0;
        this.selectedIndex = -1;
        this.status = STATUS_SHOW;
    }
}, [
    0,
    "taro-tabbar",
    {
        "conf": [
            16
        ],
        "list": [
            32
        ],
        "borderStyle": [
            32
        ],
        "backgroundColor": [
            32
        ],
        "color": [
            32
        ],
        "selectedColor": [
            32
        ],
        "selectedIndex": [
            32
        ],
        "status": [
            32
        ]
    }
]);
function defineCustomElement$172() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-tabbar"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-tabbar":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Tabbar);
                }
                break;
        }
    });
}
var defineCustomElement74 = defineCustomElement$172;
// node_modules/@tarojs/components/dist/components/taro-tabs-core.js
var Tabs = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Tabs", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-tabs-core"
]);
function defineCustomElement$173() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-tabs-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-tabs-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Tabs);
                }
                break;
        }
    });
}
var defineCustomElement75 = defineCustomElement$173;
// node_modules/@tarojs/components/dist/components/taro-text-core.js
var indexCss20 = "taro-text-core{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:inline}taro-text-core[selectable=true],taro-text-core[user-select=true]{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;display:inline-block}taro-text-core[space]{white-space:pre-wrap}taro-text-core[space=ensp]{word-spacing:.5em}taro-text-core[space=nbsp]{word-spacing:1em}taro-text-core[number-of-lines]{--line-clamp:2;word-wrap:break-word;text-overflow:ellipsis;-webkit-line-clamp:var(--line-clamp);-webkit-box-orient:vertical;display:-webkit-box;overflow:hidden}";
var Text = proxyCustomElement(class extends H {
    render() {
        const style = {};
        if (typeof this.numberOfLines === "number") {
            style["--line-clamp"] = this.numberOfLines;
        }
        return h(Host, {
            style
        }, h("slot", null));
    }
    static get style() {
        return indexCss20;
    }
    constructor(){
        super();
        this.__registerHost();
        this.selectable = false;
        this.userSelect = false;
        this.space = void 0;
        this.numberOfLines = void 0;
    }
}, [
    4,
    "taro-text-core",
    {
        "selectable": [
            1028
        ],
        "userSelect": [
            1028,
            "user-select"
        ],
        "space": [
            1025
        ],
        "numberOfLines": [
            2,
            "number-of-lines"
        ]
    }
]);
function defineCustomElement$174() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-text-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-text-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Text);
                }
                break;
        }
    });
}
var defineCustomElement76 = defineCustomElement$174;
// node_modules/@tarojs/components/dist/components/taro-textarea-core.js
var indexCss21 = "taro-textarea-core{width:300px;display:block}taro-textarea-core .auto-height{height:auto}.taro-textarea{height:inherit;-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:auto;border:0;width:100%;line-height:1.5;display:block;position:relative}.taro-textarea:focus{outline:none}";
function fixControlledValue2(value) {
    return value !== null && value !== void 0 ? value : "";
}
var Textarea = proxyCustomElement(class extends H {
    watchAutoFocus(newValue, oldValue) {
        var _a;
        if (!oldValue && newValue) {
            (_a = this.textareaRef) === null || _a === void 0 ? void 0 : _a.focus();
        }
    }
    watchValue(newValue) {
        const value = fixControlledValue2(newValue);
        if (this.textareaRef.value !== value) {
            this.textareaRef.value = value;
        }
    }
    focus() {
        var _this = this;
        return _async_to_generator(function*() {
            _this.textareaRef.focus();
        })();
    }
    render() {
        const { value, placeholder, disabled, maxlength, autoFocus, autoHeight, name, nativeProps, handleInput, handleFocus, handleBlur, handleChange } = this;
        const otherProps = {};
        if (autoHeight) {
            otherProps.rows = this.line;
        }
        return h("textarea", Object.assign({
            ref: (input)=>{
                if (input) {
                    this.textareaRef = input;
                    if (autoFocus && input) input.focus();
                }
            },
            class: `taro-textarea ${autoHeight ? "auto-height" : ""}`,
            value: fixControlledValue2(value),
            placeholder,
            name,
            disabled,
            maxlength,
            autofocus: autoFocus,
            onInput: handleInput,
            onFocus: handleFocus,
            onBlur: handleBlur,
            onChange: handleChange,
            onKeyDown: this.handleKeyDown
        }, nativeProps, otherProps));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "autoFocus": [
                "watchAutoFocus"
            ],
            "value": [
                "watchValue"
            ]
        };
    }
    static get style() {
        return indexCss21;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onInput = createEvent(this, "input", 7);
        this.onFocus = createEvent(this, "focus", 7);
        this.onBlur = createEvent(this, "blur", 7);
        this.onConfirm = createEvent(this, "confirm", 7);
        this.onChange = createEvent(this, "change", 7);
        this.onLineChange = createEvent(this, "linechange", 7);
        this.onKeyDown = createEvent(this, "keydown", 7);
        this.handleInput = (e)=>{
            e.stopPropagation();
            this.handleLineChange();
            const value = e.target.value || "";
            this.value = value;
            this.onInput.emit({
                value,
                cursor: value.length
            });
        };
        this.handleFocus = (e)=>{
            e.stopPropagation();
            this.onFocus.emit({
                value: e.target.value
            });
        };
        this.handleBlur = (e)=>{
            e.stopPropagation();
            this.onBlur.emit({
                value: e.target.value
            });
        };
        this.handleChange = (e)=>{
            e.stopPropagation();
            this.onChange.emit({
                value: e.target.value
            });
        };
        this.handleLineChange = ()=>{
            const line = this.getNumberOfLines();
            if (line !== this.line) {
                this.line = line;
                this.onLineChange.emit({
                    height: this.textareaRef.clientHeight,
                    lineCount: this.line
                });
            }
        };
        this.handleKeyDown = (e)=>{
            e.stopPropagation();
            const { value } = e.target;
            const keyCode = e.keyCode || e.code;
            this.onKeyDown.emit({
                value,
                cursor: value.length,
                keyCode
            });
            keyCode === 13 && this.onConfirm.emit({
                value
            });
        };
        this.calculateContentHeight = (ta, scanAmount)=>{
            let origHeight = ta.style.height, height = ta.offsetHeight, scrollHeight = ta.scrollHeight, overflow = ta.style.overflow, originMinHeight = ta.style.minHeight || null;
            if (height >= scrollHeight) {
                ta.style.minHeight = 0;
                ta.style.height = height + scanAmount + "px";
                ta.style.overflow = "hidden";
                if (scrollHeight < ta.scrollHeight) {
                    while(ta.offsetHeight >= ta.scrollHeight){
                        ta.style.height = (height -= scanAmount) + "px";
                    }
                    while(ta.offsetHeight < ta.scrollHeight){
                        ta.style.height = height++ + "px";
                    }
                    ta.style.height = origHeight;
                    ta.style.overflow = overflow;
                    ta.style.minHeight = originMinHeight;
                    return height;
                }
            } else {
                return scrollHeight;
            }
        };
        this.getNumberOfLines = ()=>{
            const ta = this.textareaRef, style = window.getComputedStyle ? window.getComputedStyle(ta) : ta.style, taLineHeight = parseInt(style.lineHeight, 10), taHeight = this.calculateContentHeight(ta, taLineHeight), numberOfLines = Math.floor(taHeight / taLineHeight);
            return numberOfLines;
        };
        this.value = "";
        this.placeholder = void 0;
        this.disabled = false;
        this.maxlength = 140;
        this.autoFocus = false;
        this.autoHeight = false;
        this.name = void 0;
        this.nativeProps = {};
        this.line = 1;
    }
}, [
    0,
    "taro-textarea-core",
    {
        "value": [
            1025
        ],
        "placeholder": [
            1
        ],
        "disabled": [
            4
        ],
        "maxlength": [
            2
        ],
        "autoFocus": [
            4,
            "focus"
        ],
        "autoHeight": [
            4,
            "auto-height"
        ],
        "name": [
            1
        ],
        "nativeProps": [
            16
        ],
        "line": [
            32
        ],
        "focus": [
            64
        ]
    }
]);
function defineCustomElement$175() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-textarea-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-textarea-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Textarea);
                }
                break;
        }
    });
}
var defineCustomElement77 = defineCustomElement$175;
// node_modules/@tarojs/components/dist/components/video-control.js
var formatTime = (time)=>{
    if (!time) return "";
    const sec = Math.round(time % 60);
    const min = Math.round((time - sec) / 60);
    return `${min < 10 ? `0${min}` : min}:${sec < 10 ? `0${sec}` : sec}`;
};
var calcDist = (x, y)=>{
    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
};
var normalizeNumber = (number2)=>{
    return Math.max(-1, Math.min(number2, 1));
};
var scene = "default";
var screenFn = function() {
    let val;
    const fnMap = [
        [
            "requestFullscreen",
            "exitFullscreen",
            "fullscreenElement",
            "fullscreenEnabled",
            "fullscreenchange",
            "fullscreenerror"
        ],
        // New WebKit
        [
            "webkitRequestFullscreen",
            "webkitExitFullscreen",
            "webkitFullscreenElement",
            "webkitFullscreenEnabled",
            "webkitfullscreenchange",
            "webkitfullscreenerror"
        ],
        // Old WebKit
        [
            "webkitRequestFullScreen",
            "webkitCancelFullScreen",
            "webkitCurrentFullScreenElement",
            "webkitCancelFullScreen",
            "webkitfullscreenchange",
            "webkitfullscreenerror"
        ],
        [
            "mozRequestFullScreen",
            "mozCancelFullScreen",
            "mozFullScreenElement",
            "mozFullScreenEnabled",
            "mozfullscreenchange",
            "mozfullscreenerror"
        ],
        [
            "msRequestFullscreen",
            "msExitFullscreen",
            "msFullscreenElement",
            "msFullscreenEnabled",
            "MSFullscreenChange",
            "MSFullscreenError"
        ]
    ];
    var defaultIOSMap = [
        "webkitEnterFullscreen",
        "webkitExitFullscreen",
        "webkitCurrentFullScreenElement",
        "webkitSupportsFullscreen",
        "fullscreenchange",
        "fullscreenerror"
    ];
    let i2 = 0;
    const l = fnMap.length;
    const ret = {};
    for(; i2 < l; i2++){
        val = fnMap[i2];
        if (val && val[1] in document) {
            for(i2 = 0; i2 < val.length; i2++){
                ret[fnMap[0][i2]] = val[i2];
            }
            return ret;
        }
    }
    if (!ret[fnMap[0][0]]) {
        scene = "iOS";
        for(i2 = 0; i2 < defaultIOSMap.length; i2++){
            ret[fnMap[0][i2]] = defaultIOSMap[i2];
        }
    }
    return ret;
}();
var isHls = (url)=>/\.(m3u8)($|\?)/i.test(url);
var VideoControl = proxyCustomElement(class extends H {
    onDocumentTouchMove(e) {
        if (!this.isDraggingProgressBall) return;
        const touchX = e.touches[0].pageX;
        this.percentage = this.calcPercentage(touchX);
        this.setProgressBall(this.percentage);
        this.setCurrentTime(this.percentage * this.duration);
    }
    onDocumentTouchEnd() {
        if (!this.isDraggingProgressBall) return;
        this.isDraggingProgressBall = false;
        this.seekFunc(this.percentage * this.duration);
        this.toggleVisibility(true);
    }
    setProgressBall(percentage) {
        var _this = this;
        return _async_to_generator(function*() {
            if (_this.progressBallRef) {
                _this.progressBallRef.style.left = `${percentage * 100}%`;
            }
        })();
    }
    toggleVisibility(nextVisible) {
        var _this = this;
        return _async_to_generator(function*() {
            const visible = nextVisible === void 0 ? !_this.visible : nextVisible;
            if (visible) {
                _this.hideControlsTimer && clearTimeout(_this.hideControlsTimer);
                if (_this.isPlaying) {
                    _this.hideControlsTimer = setTimeout(()=>{
                        _this.toggleVisibility(false);
                    }, 2e3);
                }
                _this.el.style.visibility = "visible";
            } else {
                _this.el.style.visibility = "hidden";
            }
            _this.visible = !!visible;
        })();
    }
    getIsDraggingProgressBall() {
        var _this = this;
        return _async_to_generator(function*() {
            return _this.isDraggingProgressBall;
        })();
    }
    setCurrentTime(time) {
        var _this = this;
        return _async_to_generator(function*() {
            _this.currentTimeRef.innerHTML = formatTime(time);
        })();
    }
    render() {
        const { controls, currentTime, duration, isPlaying, pauseFunc, playFunc, showPlayBtn, showProgress } = this;
        const formattedDuration = formatTime(duration);
        let playBtn;
        if (!showPlayBtn) {
            playBtn = null;
        } else if (isPlaying) {
            playBtn = h("div", {
                class: "taro-video-control-button taro-video-control-button-pause",
                onClick: pauseFunc
            });
        } else {
            playBtn = h("div", {
                class: "taro-video-control-button taro-video-control-button-play",
                onClick: playFunc
            });
        }
        return h(Host, {
            class: "taro-video-bar taro-video-bar-full"
        }, controls && h("div", {
            class: "taro-video-controls"
        }, playBtn, showProgress && h("div", {
            class: "taro-video-current-time",
            ref: (dom)=>this.currentTimeRef = dom
        }, formatTime(currentTime)), showProgress && h("div", {
            class: "taro-video-progress-container",
            onClick: this.onClickProgress
        }, h("div", {
            class: "taro-video-progress",
            ref: (ref)=>{
                if (!ref) return;
                const rect = ref.getBoundingClientRect();
                this.progressDimensions.left = rect.left;
                this.progressDimensions.width = rect.width;
            }
        }, h("div", {
            class: "taro-video-progress-buffered",
            style: {
                width: "100%"
            }
        }), h("div", {
            class: "taro-video-ball",
            ref: (dom)=>this.progressBallRef = dom,
            onTouchStart: this.onDragProgressBallStart,
            style: {
                left: `${formattedDuration ? this.currentTime / duration * 100 : 0}%`
            }
        }, h("div", {
            class: "taro-video-inner"
        })))), showProgress && h("div", {
            class: "taro-video-duration"
        }, formattedDuration)), h("slot", null));
    }
    get el() {
        return this;
    }
    constructor(){
        super();
        this.__registerHost();
        this.visible = false;
        this.isDraggingProgressBall = false;
        this.percentage = 0;
        this.progressDimensions = {
            left: 0,
            width: 0
        };
        this.calcPercentage = (pageX)=>{
            let pos = pageX - this.progressDimensions.left;
            pos = Math.max(pos, 0);
            pos = Math.min(pos, this.progressDimensions.width);
            return pos / this.progressDimensions.width;
        };
        this.onDragProgressBallStart = ()=>{
            this.isDraggingProgressBall = true;
            this.hideControlsTimer && clearTimeout(this.hideControlsTimer);
        };
        this.onClickProgress = (e)=>{
            e.stopPropagation();
            const percentage = this.calcPercentage(e.pageX);
            this.seekFunc(percentage * this.duration);
            this.toggleVisibility(true);
        };
        this.controls = void 0;
        this.currentTime = void 0;
        this.duration = void 0;
        this.isPlaying = void 0;
        this.pauseFunc = void 0;
        this.playFunc = void 0;
        this.seekFunc = void 0;
        this.showPlayBtn = void 0;
        this.showProgress = void 0;
    }
}, [
    4,
    "taro-video-control",
    {
        "controls": [
            4
        ],
        "currentTime": [
            2,
            "current-time"
        ],
        "duration": [
            2
        ],
        "isPlaying": [
            4,
            "is-playing"
        ],
        "pauseFunc": [
            16
        ],
        "playFunc": [
            16
        ],
        "seekFunc": [
            16
        ],
        "showPlayBtn": [
            4,
            "show-play-btn"
        ],
        "showProgress": [
            4,
            "show-progress"
        ],
        "setProgressBall": [
            64
        ],
        "toggleVisibility": [
            64
        ],
        "getIsDraggingProgressBall": [
            64
        ],
        "setCurrentTime": [
            64
        ]
    },
    [
        [
            5,
            "touchmove",
            "onDocumentTouchMove"
        ],
        [
            5,
            "touchend",
            "onDocumentTouchEnd"
        ],
        [
            5,
            "touchcancel",
            "onDocumentTouchEnd"
        ]
    ]
]);
function defineCustomElement78() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-video-control"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-video-control":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, VideoControl);
                }
                break;
        }
    });
}
// node_modules/@tarojs/components/dist/components/taro-video-control.js
var defineCustomElement79 = defineCustomElement78;
// node_modules/@tarojs/components/dist/components/video-danmu.js
var VideoDanmu = proxyCustomElement(class extends H {
    ensureProperties(danmu) {
        const clonedDanmu = Object.assign({}, danmu);
        if (!("time" in danmu)) {
            clonedDanmu.time = this.currentTime;
        }
        clonedDanmu.key = Math.random();
        clonedDanmu.bottom = `${Math.random() * 90 + 5}%`;
        return clonedDanmu;
    }
    sendDanmu(danmuList = []) {
        var _this = this;
        return _async_to_generator(function*() {
            if (Array.isArray(danmuList)) {
                _this.list = [
                    ..._this.list,
                    ...danmuList.map((danmu)=>_this.ensureProperties(danmu))
                ];
            } else {
                const danmu = danmuList;
                _this.list = [
                    ..._this.list,
                    Object.assign({}, _this.ensureProperties(danmu))
                ];
            }
        })();
    }
    tick(currentTime) {
        var _this = this;
        return _async_to_generator(function*() {
            _this.currentTime = currentTime;
            if (!_this.enable) return;
            const danmuList = _this.list;
            const newDanmuList = danmuList.filter(({ time })=>{
                return currentTime - time < 4 && currentTime > time;
            });
            let shouldUpdate = false;
            const oldDanmuList = _this.danmuList;
            if (newDanmuList.length !== oldDanmuList.length) {
                shouldUpdate = true;
            } else {
                shouldUpdate = newDanmuList.some(({ key })=>{
                    return oldDanmuList.every((danmu)=>{
                        return key !== danmu.key;
                    });
                });
            }
            if (shouldUpdate) {
                _this.danmuList = newDanmuList;
            }
        })();
    }
    componentDidUpdate() {
        requestAnimationFrame(()=>{
            setTimeout(()=>{
                const danmuElList = this.danmuElList.splice(0);
                danmuElList.forEach((danmu)=>{
                    danmu.style.left = "0";
                    danmu.style.webkitTransform = "translateX(-100%)";
                    danmu.style.transform = "translateX(-100%)";
                });
            });
        });
    }
    render() {
        if (!this.enable) return "";
        return h(Host, {
            class: "taro-video-danmu"
        }, this.danmuList.map(({ text: text2, color, bottom, key })=>h("p", {
                class: "taro-video-danmu-item",
                key,
                style: {
                    color,
                    bottom
                },
                ref: (ref)=>{
                    if (ref) {
                        this.danmuElList.push(ref);
                    }
                }
            }, text2)));
    }
    constructor(){
        super();
        this.__registerHost();
        this.list = [];
        this.danmuElList = [];
        this.currentTime = 0;
        this.enable = false;
        this.danmuList = [];
    }
}, [
    0,
    "taro-video-danmu",
    {
        "enable": [
            4
        ],
        "danmuList": [
            32
        ],
        "sendDanmu": [
            64
        ],
        "tick": [
            64
        ]
    }
]);
function defineCustomElement80() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-video-danmu"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-video-danmu":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, VideoDanmu);
                }
                break;
        }
    });
}
// node_modules/@tarojs/components/dist/components/taro-video-core.js
var indexCss22 = '.taro-video{width:100%;height:225px;line-height:0;display:inline-block;position:relative;overflow:hidden}.taro-video[hidden]{display:none}.taro-video-container{-o-object-position:inherit;object-position:inherit;background-color:#000;width:100%;height:100%;display:inline-block;position:absolute;top:0;left:0}.taro-video-container.taro-video-type-fullscreen{z-index:999;position:fixed;inset:0}.taro-video-container.taro-video-type-fullscreen.taro-video-type-rotate-left{-webkit-transform:translate(-50%,-50%)rotate(-90deg);transform:translate(-50%,-50%)rotate(-90deg)}.taro-video-container.taro-video-type-fullscreen.taro-video-type-rotate-right{-webkit-transform:translate(-50%,-50%)rotate(90deg);transform:translate(-50%,-50%)rotate(90deg)}.taro-video-video{-o-object-position:inherit;object-position:inherit;width:100%;height:100%;display:block}.taro-video-cover{z-index:1;background-color:rgba(1,1,1,.5);-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center;width:100%;display:-ms-flexbox;display:flex;position:absolute;top:0;bottom:0;left:0}.taro-video-cover-play-button{background-position:50%;background-repeat:no-repeat;background-size:50%;width:40px;height:40px}.taro-video-cover-duration{color:#fff;margin-top:10px;font-size:16px;line-height:1}.taro-video-bar{visibility:hidden;z-index:1;background-color:rgba(0,0,0,.5);-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:44px;padding:0 10px;display:-ms-flexbox;display:flex;position:absolute;bottom:0;right:0;overflow:hidden}.taro-video-bar.taro-video-bar-full{left:0}.taro-video-controls{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;margin:0 8.5px;display:-ms-flexbox;display:flex}.taro-video-control-button{-webkit-box-sizing:content-box;box-sizing:content-box;width:13px;height:15px;margin-left:-8.5px;padding:14.5px 12.5px}.taro-video-control-button:after{content:"";background-position:50%;background-repeat:no-repeat;background-size:100%;width:100%;height:100%;display:block}.taro-video-control-button.taro-video-control-button-play:after,.taro-video-cover-play-button{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAeCAYAAAAy2w7YAAAAAXNSR0IArs4c6QAAAWhJREFUSA1j+P///0cgBoHjQGzCQCsAtgJB/AMy5wCxGNXtQ9iBwvoA5BUCMQvVLEQxHpNzDSjkRhXLMM3GKrIeKKpEkYVYjcUu+AMo3ALE3GRZiN1MvKKPgbIRJFuG10j8koeA0gZEW4jfLIKyf4EqpgOxMEELCRpFnIJ3QGU5QMyM00LizCFa1SWgSkeslhFtBGkKVwGVy6FYSJp+klR/A6quB2JOkIWMIK0oNlOf8xBoZDE9LAI7nYn6HsBq4l96WHQEaLUpAyiOaASeAM2NgvuPBpaACt82IEYtfKls0UagecpwXyAzqGTRdaA57sjmYrAptAjUsCkGYlYMg9EFyLQI1IiZB8Ti6Obh5JNh0QmgHlOcBuKSIMGi50C18UDMiMssvOJEWPQLqKYbiHnxGkRIkoBF24DyaoTMIEoeh0W3geI+RBlArCI0iz4D+RVAzEasfqLVAQ19AcSg5LoYiKWI1kiiQgCMBLnEEcfDSgAAAABJRU5ErkJggg==)}.taro-video-control-button.taro-video-control-button-pause:after{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAgCAYAAAAffCjxAAAAAXNSR0IArs4c6QAAAFlJREFUSA3tksEKACAIQ7X//5zq98wOgQayum8QaGweHhMzG/6OujzKAymn+0LMqivu1XznWmX8/echTIyMyAgTwA72iIwwAexgj8gIE8CO3aMRbDPMaEy5BRGaKcZv8YxRAAAAAElFTkSuQmCC)}.taro-video-current-time,.taro-video-duration{color:#cbcbcb;height:14.5px;margin-top:15px;margin-bottom:14.5px;font-size:12px;line-height:14.5px}.taro-video-progress-container{-webkit-box-flex:2;-ms-flex-positive:2;flex-grow:2;position:relative}.taro-video-progress{background-color:rgba(255,255,255,.4);height:2px;margin:21px 12px;position:relative}.taro-video-progress-buffered{background-color:rgba(255,255,255,.8);width:0;height:100%;-webkit-transition:width .1s;transition:width .1s;position:absolute;top:0;left:0}.taro-video-ball{-webkit-box-sizing:content-box;box-sizing:content-box;width:16px;height:16px;margin-left:-22px;padding:14px;position:absolute;top:-21px;left:0}.taro-video-inner{background-color:#fff;border-radius:50%;width:100%;height:100%}.taro-video-danmu-button{color:#fff;white-space:nowrap;border:1px solid #fff;border-radius:5px;margin:0 8.5px;padding:2px 10px;font-size:13px;line-height:1}.taro-video-danmu-button.taro-video-danmu-button-active{color:#48c23d;border-color:#48c23d}.taro-video-fullscreen,.taro-video-mute{-webkit-box-sizing:content-box;box-sizing:content-box;background-position:50%;background-repeat:no-repeat;background-size:50%;width:17px;height:17px;padding:8.5px}.taro-video-fullscreen{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAhUlEQVRYR+2WSwrAMAhEnZO3PfmULLooGEFTiIXJ2s/kRY2wzQeb85sE9CRA8jSzY1YfAFzhJBnU1AVgxH2dSiArCnD9QgGzRNnOech48SRABHoSyFb5in3PSbhyo6yvCPQkEM3u7BsPe/0FIvBfAh/vhKmVbO9SWun1qk/PSVi9TcVPBG6R1YIhgWwNpQAAAABJRU5ErkJggg==)}.taro-video-fullscreen.taro-video-type-fullscreen{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+2Xu0pDURBF1/ZLxNcHKNiIlfhA7C0UBSEE8RNEBNFPUEQEEbGxFiSSSrCwEHsf5E/ccsSUuWfUhKQ40947+y42Z8+ZK/pcinzf9hhwD1xJ2q/qsb0JHAOzkl5y+lGAGnCWICQtZgAS6DxQk3TeLYA6cAo0JSXxjmW7CcwBdUkJurKiDhSA4kBvHbA9CqwBQx2O7BSw8ssU3ALPFRF4knT3nQLbr8B4LjLBOdAAFgJaLUkjbYC9n+zm+i4kXWbmwCqwnRMCHiXthuZAQOzPrxSA4kBxYDAcsH0EzATCfCLpJjOINoCtgFZabg7bk7AFDAeaGpKWgitZTu5N0kQbYBmYrujo9mX0CVxL+gidAdu9vY5zXhWA4sAgOND3X7NJ4AHYCaxkB8B62gslvecSFpoDOZH/PP8Cnt7hIaM5xCEAAAAASUVORK5CYII=)}.taro-video-mute{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAGAGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDAgNzkuMTYwNDUxLCAyMDE3LzA1LzA2LTAxOjA4OjIxICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMTktMDQtMTFUMTA6MTg6MjArMDg6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDE5LTA0LTExVDEwOjIyOjIyKzA4OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDE5LTA0LTExVDEwOjIyOjIyKzA4OjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9InNSR0IgSUVDNjE5NjYtMi4xIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjk3YmE4Yjg0LTFhNTYtNGM1MS04NDVkLTNiZmYyMGI0ZDc0ZiIgeG1wTU06RG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjg1NGQ3MjlkLWUwNjctZjU0OC1hMTlhLTBlZjQ4OGRkYjJiOSIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjA1ODY3ZDFlLWQ3NGEtNDgyNC04MDU3LTYzYmRmMTdjODk5ZSI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MDU4NjdkMWUtZDc0YS00ODI0LTgwNTctNjNiZGYxN2M4OTllIiBzdEV2dDp3aGVuPSIyMDE5LTA0LTExVDEwOjE4OjIwKzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoTWFjaW50b3NoKSIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6OTdiYThiODQtMWE1Ni00YzUxLTg0NWQtM2JmZjIwYjRkNzRmIiBzdEV2dDp3aGVuPSIyMDE5LTA0LTExVDEwOjIyOjIyKzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoTWFjaW50b3NoKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz459+FoAAABqElEQVRYhc2XPWsVQRSGnxPjF4oGRfxoRQKGWCU2Ft7CykrQWosEyf/If0hhIPgHDEmbNJZqCFxiQEgTUGxsBUVEHgvnyrjZZJO92V1fGIaZnTPvszPszNlQ6VIjnbr/DwCoDLMNak/dUVfUK0f2rQugnlcX/FevWgFQH6gf3autRgHUC+piiXHzAOmtPx9gXgug8itQx9SXwDpw47AGKXZWvXvQmNFCwE3gCXA2dY0Az4GrRzHONA9cU/vAbERsllEOyh31e8USV2mrMPdG9uyn+rDom2/BHHCm5puWKiKmgdtAnz+rvaxO5mNygEvHaZ5BfADuARvAaWBpP4DGFBHfgBngFzClTrUKkCDeA+9S837rAEnbqb7VFcCpVJ/oCmCw959aB1AfAROpudYqgDoOLKRmPyLelAF8bcD4pPoMeAtcB34AT4uDBqXXwFG8XXUU/72MIuK1OgE8Bs6l7mEvo8up7lN1Ge0n9aK6VHMFZvJTr9S3CiALaCQhqZOSvegMIAvu2UVSWpigLC1fbQ0gm6in7qpfLCQbhwGIYcyPQ53/G3YO8BtUtd35bvKcVwAAAABJRU5ErkJggg==)}.taro-video-mute.taro-video-type-mute{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAgCAYAAAB3j6rJAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGAGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDAgNzkuMTYwNDUxLCAyMDE3LzA1LzA2LTAxOjA4OjIxICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMTktMDQtMTFUMTA6MTk6MDMrMDg6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDE5LTA0LTExVDEwOjIyOjMzKzA4OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDE5LTA0LTExVDEwOjIyOjMzKzA4OjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9InNSR0IgSUVDNjE5NjYtMi4xIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjAzYjJmNjE2LTZmZTUtNDJjNC1iNTgwLTczNzZjZjI2NzdmNSIgeG1wTU06RG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjYzZjQ2NTYzLWE0ZjktOGQ0Mi1hM2FhLTY3ODJhNDBhYWNjMSIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjIyYWNjMWFlLTg4ZmMtNDBlZi1iMWM1LTNmODgwY2QzYWI2MiI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MjJhY2MxYWUtODhmYy00MGVmLWIxYzUtM2Y4ODBjZDNhYjYyIiBzdEV2dDp3aGVuPSIyMDE5LTA0LTExVDEwOjE5OjAzKzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoTWFjaW50b3NoKSIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MDNiMmY2MTYtNmZlNS00MmM0LWI1ODAtNzM3NmNmMjY3N2Y1IiBzdEV2dDp3aGVuPSIyMDE5LTA0LTExVDEwOjIyOjMzKzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoTWFjaW50b3NoKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5PmxYVAAACLklEQVRYhc2XP2sVQRRHz40hKoqaQgVBCy1EozFlGiVFxMLGh4piYWEh+hkEP4YKAVFEEFTyughaCH6DqIVpAhYWEgIxoJE8cywyi5tNHu/tJmvyg2WZO3dmzt47/zZUtoJ6Nhsg09YDiYhKDzACTAFNYH9lEpUq80TdrT5wpV5n/ZV9KoGoo+pXV2uyKkipOaLuUceAt8DhUvQd1FsCYhR4ChzaSIBMHSOi7lOfsByFWiCgEBH1GHAF2JlMPcBt4GC3HUYEaj9wF3gVEVPtfNVTwAXgWX7CDKq/1piAZTSZBmim8qJ6sQ3EgDqb/L7kU3MH2NHtl3dQX3r3Ak21UYAYAj4A/cl0JB+RF+uMRj4iQ+p8zt7KYFLdXKHuRi0gacBhV6a6pd5bA6KRNagFJPU9qv5u47toLmW1HnoR8Q5oAK1CVQu4FBHj/wUkaXsb+4pzpVaQFPqXrN7Be4Fx9VztIOr1BLEtmX4A94E/qdwHTKjDWYM6lu81dSlnn3V570BtuLxaMs2rZ/IgYxsBovaoPwsQA4VoFWEm8ql5DiysNyURsQTMpOIMcDYiPhd8xoGr/FtNC2G6FKXD6ihwGdiVHMoeeh8jYlA9ANwE3kTEp3bO6vE03qOONzR1r/q4RGrquaFFxFxE3ALOA9+6jExpdb180y55AhirhaRTatq0GXEzL8+ZIuI9cBJ4WKiartJf9nWV/mty7UfUafW7erpqRGI9EBuprffvu9n6C1KOmsqwI5A1AAAAAElFTkSuQmCC)}.taro-video-danmu{width:100%;margin-top:14px;margin-bottom:44px;font-size:14px;line-height:14px;position:absolute;top:0;bottom:0;left:0;overflow:visible}.taro-video-danmu-item{color:#fff;white-space:nowrap;line-height:1;-webkit-transition-property:left,-webkit-transform;transition-property:left,-webkit-transform;transition-property:left,transform;transition-property:left,transform,-webkit-transform;-webkit-transition-duration:3s;transition-duration:3s;-webkit-transition-timing-function:linear;transition-timing-function:linear;position:absolute;left:100%;-webkit-transform:translate(0);transform:translate(0)}.taro-video-toast{visibility:hidden;pointer-events:none;color:#000;background-color:rgba(255,255,255,.8);border-radius:5px;display:block;position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.taro-video-toast.taro-video-toast-volume{width:100px;height:100px;display:block}.taro-video-toast-volume .taro-video-toast-title{text-align:center;width:100%;margin-top:10px;font-size:12px;line-height:16px;display:block}.taro-video-toast-volume .taro-video-toast-icon{fill:#000;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAFhklEQVR4Xu2aeaxfQxTHP1VBES0NIQitWtpaaxeCUkQtaYVa0tiClAq1ExIiQTVppaWxt8RWSa2tWkJQRGgtQaSIpUKEpG0ssbbk28yV2+mZO/e9e3vvu/e98897mZnfzPl+75mZs0wvurn06ub46SGgxwLqZaA3sB/wO/A+8G/V6tS5BU4BJgJbO9DvAMOB36okoQ4CNgAeBEYbQK8Bbm4zAdsBc4EdAyA/APZoKwHHAA8DG2UA/AnYrG0ErAVcD1yXA9gfQJ8c40obsqbPgH7AY8CROTVuFQFD3X7fJid4DWsNAWOAGZ0w58YTsDZwKzChA189PbTRBGwKzAYO6iT4srbAMHfTfAksjulS1iG4JzAH2Dy2YKS/qAVcCdzi1vgZOBZ4PWvNGAG6wgYCW0IwctzNmf06BcEXtYABwOeA4otEfgEOdnGGqV6IAAUopwM6zDYuAVjeKYpYwCjgCWOhH513+b2lhE+Avrj89NPyalzyuCIE6EN9BfQ1dHoPOAD40+9LE6D/5aoqSqtLsgiQC60DTiHzfGCFoaSsQAexZdlTgEuyCDgLuK8u5G7dEAHyKN8CBrtxLwDHAX8Z+l4N3GS0L3db4aN0X5opmc+2XZQAfb2LPd2eciG1lUSRJZ9qYHkZONwiYAjwSc3gs24BXWWWfzEVuMjQez13HljX8v7A28lvEgsInaBVcxLaAvr6sgJLtBWeNTrOB+4w2p8DRvoEnAPcXTVaY70QAbrbXwIONX7zBSAL/tvrk1+iviTllnRry2irr/QSEws4D7izCxMg1XQLLAQGGXpeCkw22kOWI49RMUujCJC+uwAfGtfcImAng4AtAMsBeg04pIkESOfbgQsMsNoGnxrtSrfv7rXrSlwXWN6kLZBgEBiB8iWUUZZPIN/AF1nMoiYSICDfAlt5iB4CxhpAzwXuMtqPBuY1lYB5wFEeqFeAwwyguvIUqvuiQO/xphJwP3Cmhyh0EKrOoGDIF7n+M5pKwEwXrqdBCaQSM77Ig7SSIicDs5pKwIvACA+pzFwZIF9OlKm36QyQV7jEqDDJk5VD58uFgGIGX1Se+6yJFqAKsqI6X84GdDb4Mh0Y5zUqjFYFakUTCXja5QLSmBQHbAL8ahAgT1AeYVreSKLLphGwF/CuAfLJQLldGSTFD75c5d4mNCoWyAqG9gYWGED1AOMKo12ZbiWA/idA++deY2DVTZ0Jh5UJPsFQtD/wDaAHGWl5EzgwaUi2gK4UXS11S0cTIjrMFBtYQdAk4DID0BnAAz4B6wNLgTKKG0VIDBHwqitwpOcW+OOB540FdeipNKbUWFrUtn06o5xOij4KyDuqU0IE3Obl/rLA63pTzm9XA8jKACjdniZAaSKFmUpB1yUhAlTsUEpMh913wEkuTe7rKTzPAHqO44vpKPkFhH3cWWBVV6ogJVYZUgz/tXtIYelzI3Ct0fExIGx6j7iKWBUUveyYBehv1RIjIEsfqziq8Xp4pSBJOYTVJFQcVY3wCFeKUjVGyYfQWB00+5bEVBECrNS+qsOKBpVHNCVWHs+LS7H5PV5pOu9v0+OKEOAXR39w1e1C7wM6AkJ1eLmkRcrpRQiQrqobXO5S3vL3/4kBKMsCknV0k+iasVLUMV3UX5SAPGtED8EOT+L9YENnCasUIXNO2goChFWHqAIRyxXN4qI1BCQg9dJESYq8LnbrCBAR8t50Lig6i0krCRBoVWhVlt45wkBrCRBuRZyPuAguxIPe9lXqhpd9DcZMXOvdkPF0Xu/8dohNUmZ/1QQkuitXr+d4fryuFx3jywQYm6suAqSX8vLTXKJDt4QqO6rtLYspXWZ/nQQkOJTAUJZGIav19q9MvKvN1RUIWKMAY5P3EBBjqO393d4C/gMVHwRQlpx21QAAAABJRU5ErkJggg==);background-position:50%;background-repeat:no-repeat;background-size:50%;width:50%;height:50%;margin-left:25%;display:block}.taro-video-toast-volume .taro-video-toast-value{width:80px;height:5px;margin-top:5px;margin-left:10px}.taro-video-toast-volume .taro-video-toast-value>.taro-video-toast-value-content{overflow:hidden}.taro-video-toast-volume-grids{width:80px;height:5px}.taro-video-toast-volume-grids-item{float:left;background-color:#000;width:7.1px;height:5px}.taro-video-toast-volume-grids-item:not(:first-child){margin-left:1px}.taro-video-toast.taro-video-toast-progress{color:#fff;background-color:rgba(0,0,0,.8);padding:6px;font-size:14px;line-height:18px}';
var Video = proxyCustomElement(class extends H {
    componentWillLoad() {
        this._enableDanmu = this.enableDanmu;
    }
    componentDidLoad() {
        var _a, _b;
        this.init();
        if (this.initialTime) {
            this.videoRef.currentTime = this.initialTime;
        }
        (_b = (_a = this.danmuRef).sendDanmu) === null || _b === void 0 ? void 0 : _b.call(_a, this.danmuList);
        if (document.addEventListener) {
            document.addEventListener(screenFn.fullscreenchange, this.handleFullScreenChange);
        }
        if (this.videoRef && scene === "iOS") {
            this.videoRef.addEventListener("webkitendfullscreen", this.handleFullScreenChange);
        }
    }
    componentDidRender() {}
    disconnectedCallback() {
        if (document.removeEventListener) {
            document.removeEventListener(screenFn.fullscreenchange, this.handleFullScreenChange);
        }
        if (this.videoRef && scene === "iOS") {
            this.videoRef.removeEventListener("webkitendfullscreen", this.handleFullScreenChange);
        }
    }
    watchEnableDanmu(newVal) {
        this._enableDanmu = newVal;
    }
    watchSrc() {
        this.init();
    }
    onDocumentTouchMove(e) {
        var _this = this;
        return _async_to_generator(function*() {
            if (_this.lastTouchScreenX === void 0 || _this.lastTouchScreenY === void 0) return;
            if (yield _this.controlsRef.getIsDraggingProgressBall()) return;
            const gestureObj = _this.analyzeGesture(e);
            if (gestureObj.type === "adjustVolume") {
                _this.toastVolumeRef.style.visibility = "visible";
                const nextVolume = Math.max(Math.min(_this.lastVolume - gestureObj.dataY, 1), 0);
                _this.videoRef.volume = nextVolume;
                _this.toastVolumeBarRef.style.width = `${nextVolume * 100}%`;
            } else if (gestureObj.type === "adjustProgress") {
                _this.isDraggingProgress = true;
                _this.nextPercentage = Math.max(Math.min(_this.lastPercentage + (gestureObj.dataX || 0), 1), 0);
                if (_this.controls && _this.showProgress) {
                    _this.controlsRef.setProgressBall(_this.nextPercentage);
                    _this.controlsRef.toggleVisibility(true);
                }
                const duration = _this.duration || _this._duration;
                _this.toastProgressTitleRef.innerHTML = `${formatTime(_this.nextPercentage * duration)} / ${formatTime(duration)}`;
                _this.toastProgressRef.style.visibility = "visible";
            }
        })();
    }
    onDocumentTouchEnd() {
        var _a;
        if (this.gestureType === "adjustVolume") {
            this.toastVolumeRef.style.visibility = "hidden";
        } else if (this.gestureType === "adjustProgress") {
            this.toastProgressRef.style.visibility = "hidden";
        }
        if (this.isDraggingProgress) {
            this.isDraggingProgress = false;
            this.seek(this.nextPercentage * ((_a = this.duration) !== null && _a !== void 0 ? _a : this._duration));
        }
        this.gestureType = "none";
        this.lastTouchScreenX = void 0;
        this.lastTouchScreenY = void 0;
    }
    getHlsObject() {
        var _this = this;
        return _async_to_generator(function*() {
            return _this.hls;
        })();
    }
    /** 播放视频 */ play() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._play();
        })();
    }
    /** 暂停视频 */ pause() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._pause();
        })();
    }
    /** 停止视频 */ stop() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._stop();
        })();
    }
    /** 跳转到指定位置 */ seek(position) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._seek(position);
        })();
    }
    /** 进入全屏。若有自定义内容需在全屏时展示，需将内容节点放置到 video 节点内。 */ requestFullScreen() {
        var _this = this;
        return _async_to_generator(function*() {
            _this.toggleFullScreen(true);
        })();
    }
    /** 退出全屏 */ exitFullScreen() {
        var _this = this;
        return _async_to_generator(function*() {
            _this.toggleFullScreen(false);
        })();
    }
    render() {
        const { controls, autoplay, loop, muted, poster, objectFit, isFirst, isMute, isFullScreen, showCenterPlayBtn, isPlaying, _enableDanmu, showMuteBtn, danmuBtn, showFullscreenBtn, nativeProps } = this;
        const duration = this.duration || this._duration;
        const durationTime = formatTime(duration);
        return h(Host, {
            class: classnames("taro-video-container", {
                "taro-video-type-fullscreen": isFullScreen
            }),
            onTouchStart: this.onTouchStartContainer,
            onClick: this.onClickContainer
        }, h("video", Object.assign({
            class: "taro-video-video",
            style: {
                "object-fit": objectFit
            },
            ref: (dom)=>{
                if (dom) {
                    this.videoRef = dom;
                }
            },
            autoplay,
            loop,
            muted,
            poster: controls ? poster : void 0,
            playsinline: true,
            "webkit-playsinline": true,
            onPlay: this.handlePlay,
            onPause: this.handlePause,
            onEnded: this.handleEnded,
            onTimeUpdate: this.handleTimeUpdate,
            onError: this.handleError,
            onDurationChange: this.handleDurationChange,
            onProgress: this.handleProgress,
            onLoadedMetaData: this.handleLoadedMetaData
        }, nativeProps), "\u6682\u65F6\u4E0D\u652F\u6301\u64AD\u653E\u8BE5\u89C6\u9891"), h("taro-video-danmu", {
            ref: (dom)=>{
                if (dom) {
                    this.danmuRef = dom;
                }
            },
            enable: _enableDanmu
        }), isFirst && showCenterPlayBtn && !isPlaying && h("div", {
            class: "taro-video-cover"
        }, h("div", {
            class: "taro-video-cover-play-button",
            onClick: ()=>this.play()
        }), h("p", {
            class: "taro-video-cover-duration"
        }, durationTime)), h("taro-video-control", {
            ref: (dom)=>{
                if (dom) {
                    this.controlsRef = dom;
                }
            },
            controls,
            currentTime: this.currentTime,
            duration,
            isPlaying: this.isPlaying,
            pauseFunc: this._pause,
            playFunc: this._play,
            seekFunc: this._seek,
            showPlayBtn: this.showPlayBtn,
            showProgress: this.showProgress
        }, showMuteBtn && h("div", {
            class: classnames("taro-video-mute", {
                "taro-video-type-mute": isMute
            }),
            onClick: this.toggleMute
        }), danmuBtn && h("div", {
            class: classnames("taro-video-danmu-button", {
                "taro-video-danmu-button-active": _enableDanmu
            }),
            onClick: this.toggleDanmu
        }, "\u5F39\u5E55"), showFullscreenBtn && h("div", {
            class: classnames("taro-video-fullscreen", {
                "taro-video-type-fullscreen": isFullScreen
            }),
            onClick: this.onClickFullScreenBtn
        })), h("div", {
            class: "taro-video-toast taro-video-toast-volume",
            ref: (dom)=>{
                if (dom) {
                    this.toastVolumeRef = dom;
                }
            }
        }, h("div", {
            class: "taro-video-toast-title"
        }, "\u97F3\u91CF"), h("div", {
            class: "taro-video-toast-icon"
        }), h("div", {
            class: "taro-video-toast-value"
        }, h("div", {
            class: "taro-video-toast-value-content",
            ref: (dom)=>{
                if (dom) {
                    this.toastVolumeBarRef = dom;
                }
            }
        }, h("div", {
            class: "taro-video-toast-volume-grids"
        }, Array(10).fill(1).map(()=>h("div", {
                class: "taro-video-toast-volume-grids-item"
            })))))), h("div", {
            class: "taro-video-toast taro-video-toast-progress",
            ref: (dom)=>{
                if (dom) {
                    this.toastProgressRef = dom;
                }
            }
        }, h("div", {
            class: "taro-video-toast-title",
            ref: (dom)=>{
                if (dom) {
                    this.toastProgressTitleRef = dom;
                }
            }
        })));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "enableDanmu": [
                "watchEnableDanmu"
            ],
            "src": [
                "watchSrc"
            ]
        };
    }
    static get style() {
        return indexCss22;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onPlay = createEvent(this, "play", 7);
        this.onPause = createEvent(this, "pause", 7);
        this.onEnded = createEvent(this, "ended", 7);
        this.onTimeUpdate = createEvent(this, "timeupdate", 7);
        this.onError = createEvent(this, "error", 7);
        this.onFullScreenChange = createEvent(this, "fullscreenchange", 7);
        this.onProgress = createEvent(this, "progress", 7);
        this.onLoadedMetaData = createEvent(this, "loadedmetadata", 7);
        this.currentTime = 0;
        this.isDraggingProgress = false;
        this.gestureType = "none";
        this.analyzeGesture = (e)=>{
            var _a;
            const obj = {
                type: "none"
            };
            const nowX = e.touches[0].screenX;
            const nowY = e.touches[0].screenY;
            const distX = nowX - this.lastTouchScreenX;
            const distY = nowY - this.lastTouchScreenY;
            const enableVslideGesture = this.isFullScreen ? this.vslideGestureInFullscreen : this.vslideGesture;
            if (this.gestureType === "none") {
                const dist = calcDist(distX, distY);
                if (dist < 10) return obj;
                if (Math.abs(distY) >= Math.abs(distX)) {
                    if (enableVslideGesture) {
                        this.gestureType = "adjustVolume";
                        this.lastVolume = this.videoRef.volume;
                    } else {
                        return obj;
                    }
                } else if (Math.abs(distY) < Math.abs(distX)) {
                    if (this.enableProgressGesture) {
                        this.gestureType = "adjustProgress";
                        this.lastPercentage = this.currentTime / ((_a = this.duration) !== null && _a !== void 0 ? _a : this._duration);
                    } else {
                        return obj;
                    }
                }
            }
            obj.type = this.gestureType;
            obj.dataX = normalizeNumber(distX / 200);
            obj.dataY = normalizeNumber(distY / 200);
            return obj;
        };
        this.loadNativePlayer = ()=>{
            var _a, _b;
            if (this.videoRef) {
                this.videoRef.src = this.src;
                (_b = (_a = this.videoRef).load) === null || _b === void 0 ? void 0 : _b.call(_a);
            }
        };
        this.init = ()=>{
            const { src, videoRef } = this;
            if (isHls(src)) {
                import(/* webpackExports: ["default"] */ "./hls-LPGUFH6I.js").then((e)=>{
                    const Hls = e.default;
                    this.HLS = Hls;
                    if (Hls.isSupported()) {
                        if (this.hls) {
                            this.hls.destroy();
                        }
                        this.hls = new Hls();
                        this.hls.loadSource(src);
                        this.hls.attachMedia(videoRef);
                        this.hls.on(Hls.Events.MANIFEST_PARSED, ()=>{
                            this.autoplay && this.play();
                        });
                        this.hls.on(Hls.Events.ERROR, (_, data)=>{
                            this.handleError(data);
                        });
                    } else if (videoRef.canPlayType("application/vnd.apple.mpegurl")) {
                        this.loadNativePlayer();
                    } else {
                        console.error("\u8BE5\u6D4F\u89C8\u5668\u4E0D\u652F\u6301 HLS \u64AD\u653E");
                    }
                });
            } else {
                this.loadNativePlayer();
            }
        };
        this.handlePlay = ()=>{
            this.isPlaying = true;
            this.isFirst = false;
            this.controlsRef.toggleVisibility(true);
            this.onPlay.emit();
        };
        this.handlePause = ()=>{
            this.isPlaying = false;
            this.controlsRef.toggleVisibility(true);
            this.onPause.emit();
        };
        this.handleEnded = ()=>{
            this.isFirst = true;
            this.pause();
            this.controlsRef.toggleVisibility();
            this.onEnded.emit();
        };
        var _this = this;
        this.handleTimeUpdate = throttle2(function() {
            var _ref = _async_to_generator(function*(e) {
                var _a, _b;
                _this.currentTime = _this.videoRef.currentTime;
                const duration = _this.duration || _this._duration;
                const isControlDragging = yield _this.controlsRef.getIsDraggingProgressBall();
                if (_this.controls && _this.showProgress) {
                    if (!isControlDragging && !_this.isDraggingProgress) {
                        _this.controlsRef.setProgressBall(_this.currentTime / duration);
                        _this.controlsRef.setCurrentTime(_this.currentTime);
                    }
                }
                _this.danmuRef.tick(_this.currentTime);
                _this.onTimeUpdate.emit({
                    duration: (_a = e.target) === null || _a === void 0 ? void 0 : _a.duration,
                    currentTime: (_b = e.target) === null || _b === void 0 ? void 0 : _b.currentTime
                });
                if (_this.duration) {
                    if (_this.currentTime >= _this.duration) {
                        _this.seek(0);
                        _this.handleEnded();
                    }
                }
            });
            return function(e) {
                return _ref.apply(this, arguments);
            };
        }(), 250);
        this.handleError = (e)=>{
            var _a, _b;
            if (this.hls) {
                switch(e.type){
                    case this.HLS.ErrorTypes.NETWORK_ERROR:
                        this.onError.emit({
                            errMsg: e.response
                        });
                        this.hls.startLoad();
                        break;
                    case this.HLS.ErrorTypes.MEDIA_ERROR:
                        this.onError.emit({
                            errMsg: e.reason || "\u5A92\u4F53\u9519\u8BEF,\u8BF7\u91CD\u8BD5"
                        });
                        this.hls.recoverMediaError();
                        break;
                }
            } else {
                this.onError.emit({
                    errMsg: (_b = (_a = e.target) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.message
                });
            }
        };
        this.handleDurationChange = ()=>{
            this._duration = this.videoRef.duration;
        };
        this.handleProgress = ()=>{
            this.onProgress.emit();
        };
        this.handleLoadedMetaData = (e)=>{
            const target = e.target;
            this.onLoadedMetaData.emit({
                width: target.videoWidth,
                height: target.videoHeight,
                duration: target.duration
            });
        };
        this._play = ()=>this.videoRef.play();
        this._pause = ()=>this.videoRef.pause();
        this._stop = ()=>{
            this.videoRef.pause();
            this._seek(0);
        };
        this._seek = (position)=>{
            this.videoRef.currentTime = position;
        };
        this.onTouchStartContainer = (e)=>{
            this.lastTouchScreenX = e.touches[0].screenX;
            this.lastTouchScreenY = e.touches[0].screenY;
        };
        this.onClickContainer = ()=>{
            if (this.enablePlayGesture) {
                const now3 = Date.now();
                if (now3 - this.lastClickedTime < 300) {
                    this.isPlaying ? this.pause() : this.play();
                }
                this.lastClickedTime = now3;
            }
            this.controlsRef.toggleVisibility();
        };
        this.onClickFullScreenBtn = (e)=>{
            e.stopPropagation();
            this.toggleFullScreen();
        };
        this.handleFullScreenChange = (e)=>{
            const timestamp2 = /* @__PURE__ */ new Date().getTime();
            if (!e.detail && this.isFullScreen && !document[screenFn.fullscreenElement] && timestamp2 - this.fullScreenTimestamp > 100) {
                this.toggleFullScreen(false, true);
            }
        };
        this.toggleFullScreen = (isFullScreen = !this.isFullScreen, fromBrowser = false)=>{
            this.isFullScreen = isFullScreen;
            this.controlsRef.toggleVisibility(true);
            this.fullScreenTimestamp = /* @__PURE__ */ new Date().getTime();
            this.onFullScreenChange.emit({
                fullScreen: this.isFullScreen,
                direction: "vertical"
            });
            if (this.isFullScreen && !document[screenFn.fullscreenElement]) {
                setTimeout(()=>{
                    this.videoRef[screenFn.requestFullscreen]({
                        navigationUI: "auto"
                    });
                }, 0);
            } else if (!fromBrowser) {
                document[screenFn.exitFullscreen]();
            }
        };
        this.toggleMute = (e)=>{
            e.stopPropagation();
            this.videoRef.muted = !this.isMute;
            this.controlsRef.toggleVisibility(true);
            this.isMute = !this.isMute;
        };
        this.toggleDanmu = (e)=>{
            e.stopPropagation();
            this.controlsRef.toggleVisibility(true);
            this._enableDanmu = !this._enableDanmu;
        };
        this.src = void 0;
        this.duration = void 0;
        this.controls = true;
        this.autoplay = false;
        this.loop = false;
        this.muted = false;
        this.initialTime = 0;
        this.poster = void 0;
        this.objectFit = "contain";
        this.showProgress = true;
        this.showFullscreenBtn = true;
        this.showPlayBtn = true;
        this.showCenterPlayBtn = true;
        this.showMuteBtn = false;
        this.danmuList = void 0;
        this.danmuBtn = false;
        this.enableDanmu = false;
        this.enablePlayGesture = false;
        this.enableProgressGesture = true;
        this.vslideGesture = false;
        this.vslideGestureInFullscreen = true;
        this.nativeProps = {};
        this._duration = void 0;
        this._enableDanmu = false;
        this.isPlaying = false;
        this.isFirst = true;
        this.isFullScreen = false;
        this.fullScreenTimestamp = /* @__PURE__ */ new Date().getTime();
        this.isMute = false;
    }
}, [
    0,
    "taro-video-core",
    {
        "src": [
            1
        ],
        "duration": [
            2
        ],
        "controls": [
            4
        ],
        "autoplay": [
            4
        ],
        "loop": [
            4
        ],
        "muted": [
            4
        ],
        "initialTime": [
            2,
            "initial-time"
        ],
        "poster": [
            1
        ],
        "objectFit": [
            1,
            "object-fit"
        ],
        "showProgress": [
            4,
            "show-progress"
        ],
        "showFullscreenBtn": [
            4,
            "show-fullscreen-btn"
        ],
        "showPlayBtn": [
            4,
            "show-play-btn"
        ],
        "showCenterPlayBtn": [
            4,
            "show-center-play-btn"
        ],
        "showMuteBtn": [
            4,
            "show-mute-btn"
        ],
        "danmuList": [
            16
        ],
        "danmuBtn": [
            4,
            "danmu-btn"
        ],
        "enableDanmu": [
            4,
            "enable-danmu"
        ],
        "enablePlayGesture": [
            4,
            "enable-play-gesture"
        ],
        "enableProgressGesture": [
            4,
            "enable-progress-gesture"
        ],
        "vslideGesture": [
            4,
            "vslide-gesture"
        ],
        "vslideGestureInFullscreen": [
            4,
            "vslide-gesture-in-fullscreen"
        ],
        "nativeProps": [
            16
        ],
        "_duration": [
            32
        ],
        "_enableDanmu": [
            32
        ],
        "isPlaying": [
            32
        ],
        "isFirst": [
            32
        ],
        "isFullScreen": [
            32
        ],
        "fullScreenTimestamp": [
            32
        ],
        "isMute": [
            32
        ],
        "getHlsObject": [
            64
        ],
        "play": [
            64
        ],
        "pause": [
            64
        ],
        "stop": [
            64
        ],
        "seek": [
            64
        ],
        "requestFullScreen": [
            64
        ],
        "exitFullScreen": [
            64
        ]
    },
    [
        [
            5,
            "touchmove",
            "onDocumentTouchMove"
        ],
        [
            5,
            "touchend",
            "onDocumentTouchEnd"
        ],
        [
            5,
            "touchcancel",
            "onDocumentTouchEnd"
        ]
    ]
]);
function defineCustomElement$176() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-video-core",
        "taro-video-control",
        "taro-video-danmu"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-video-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Video);
                }
                break;
            case "taro-video-control":
                if (!customElements.get(tagName)) {
                    defineCustomElement78();
                }
                break;
            case "taro-video-danmu":
                if (!customElements.get(tagName)) {
                    defineCustomElement80();
                }
                break;
        }
    });
}
var defineCustomElement81 = defineCustomElement$176;
// node_modules/@tarojs/components/dist/components/taro-video-danmu.js
var defineCustomElement82 = defineCustomElement80;
// node_modules/@tarojs/components/dist/components/taro-view-core.js
var indexCss23 = "body,html{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent}taro-view-core{display:block}";
var View = proxyCustomElement(class extends H {
    onTouchStart() {
        if (this.hoverClass) {
            this.touch = true;
            setTimeout(()=>{
                if (this.touch) {
                    this.hover = true;
                }
            }, this.hoverStartTime);
        }
        this.timeoutEvent = setTimeout(()=>{
            this.onLongPress.emit();
        }, 350);
        this.startTime = Date.now();
    }
    onTouchMove() {
        clearTimeout(this.timeoutEvent);
    }
    onTouchEnd() {
        const spanTime = Date.now() - this.startTime;
        if (spanTime < 350) {
            clearTimeout(this.timeoutEvent);
        }
        if (this.hoverClass) {
            this.touch = false;
            setTimeout(()=>{
                if (!this.touch) {
                    this.hover = false;
                }
            }, this.hoverStayTime);
        }
    }
    componentDidRender() {
        handleStencilNodes(this.el);
    }
    render() {
        const cls = classnames({
            [`${this.hoverClass}`]: this.hover
        });
        let attr2 = {};
        if (!!this.animation) {
            attr2["animation"] = this.animation;
            attr2["data-animation"] = this.animation;
        }
        return h(Host, Object.assign({
            class: cls
        }, attr2), h("slot", null));
    }
    get el() {
        return this;
    }
    static get style() {
        return indexCss23;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onLongPress = createEvent(this, "longpress", 7);
        this.startTime = 0;
        this.animation = void 0;
        this.hoverClass = void 0;
        this.hoverStartTime = 50;
        this.hoverStayTime = 400;
        this.hover = false;
        this.touch = false;
    }
}, [
    4,
    "taro-view-core",
    {
        "animation": [
            1
        ],
        "hoverClass": [
            1,
            "hover-class"
        ],
        "hoverStartTime": [
            2,
            "hover-start-time"
        ],
        "hoverStayTime": [
            2,
            "hover-stay-time"
        ],
        "hover": [
            32
        ],
        "touch": [
            32
        ]
    },
    [
        [
            1,
            "touchstart",
            "onTouchStart"
        ],
        [
            1,
            "touchmove",
            "onTouchMove"
        ],
        [
            1,
            "touchend",
            "onTouchEnd"
        ]
    ]
]);
function defineCustomElement$177() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-view-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-view-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, View);
                }
                break;
        }
    });
}
var defineCustomElement83 = defineCustomElement$177;
// node_modules/@tarojs/components/dist/components/taro-voip-room-core.js
var VoipRoom = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("VoipRoom", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-voip-room-core"
]);
function defineCustomElement$178() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-voip-room-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-voip-room-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, VoipRoom);
                }
                break;
        }
    });
}
var defineCustomElement84 = defineCustomElement$178;
// node_modules/@tarojs/components/dist/components/taro-web-view-core.js
var indexCss24 = "iframe{border:none}.taro-webview{z-index:999;width:100%;height:100%;position:fixed;top:0;bottom:0}";
var WebView = proxyCustomElement(class extends H {
    render() {
        const { src, onLoad, onError: onError2 } = this;
        return h("iframe", {
            class: "taro-webview",
            onLoad: (e)=>{
                e.stopPropagation();
                onLoad.emit({
                    src
                });
            },
            onError: (e)=>{
                e.stopPropagation();
                onError2.emit({
                    src
                });
            },
            src
        });
    }
    static get style() {
        return indexCss24;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onLoad = createEvent(this, "load", 7);
        this.onError = createEvent(this, "error", 7);
        this.src = void 0;
    }
}, [
    0,
    "taro-web-view-core",
    {
        "src": [
            1
        ]
    }
]);
function defineCustomElement$179() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components3 = [
        "taro-web-view-core"
    ];
    components3.forEach((tagName)=>{
        switch(tagName){
            case "taro-web-view-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, WebView);
                }
                break;
        }
    });
}
var defineCustomElement85 = defineCustomElement$179;
// node_modules/@tarojs/router/dist/tabbar.js
function initTabbar(config, history2) {
    if (config.tabBar == null) {
        return;
    }
    defineCustomElement74();
    const tabbar = document.createElement("taro-tabbar");
    const homePage = config.entryPagePath || (config.pages ? config.pages[0] : "");
    tabbar.conf = config.tabBar;
    tabbar.conf.homePage = history2.location.pathname === "/" ? homePage : history2.location.pathname;
    const routerConfig = config.router;
    tabbar.conf.mode = routerConfig && routerConfig.mode ? routerConfig.mode : "hash";
    if (routerConfig.customRoutes) {
        tabbar.conf.custom = true;
        tabbar.conf.customRoutes = routerConfig.customRoutes;
    } else {
        tabbar.conf.custom = false;
        tabbar.conf.customRoutes = {};
    }
    if (typeof routerConfig.basename !== "undefined") {
        tabbar.conf.basename = routerConfig.basename;
    }
    const container2 = document.getElementById("container");
    container2 === null || container2 === void 0 ? void 0 : container2.appendChild(tabbar);
    initTabBarApis(config);
}
// node_modules/@tarojs/router/dist/index.js
function handleAppMount(config, _, appId = config.appId || "app") {
    let app = document.getElementById(appId);
    let isPosition = true;
    if (!app) {
        app = document.createElement("div");
        app.id = appId;
        isPosition = false;
    }
    const appWrapper = (app === null || app === void 0 ? void 0 : app.parentNode) || (app === null || app === void 0 ? void 0 : app.parentElement) || document.body;
    app.classList.add("taro_router");
    if (!isPosition) appWrapper.appendChild(app);
}
function handleAppMountWithTabbar(config, history2, appId = config.appId || "app") {
    let app = document.getElementById(appId);
    let isPosition = true;
    if (!app) {
        app = document.createElement("div");
        app.id = appId;
        isPosition = false;
    }
    const appWrapper = (app === null || app === void 0 ? void 0 : app.parentNode) || (app === null || app === void 0 ? void 0 : app.parentElement) || document.body;
    app.classList.add("taro_router");
    const container2 = document.createElement("div");
    container2.classList.add("taro-tabbar__container");
    container2.id = "container";
    const panel = document.createElement("div");
    panel.classList.add("taro-tabbar__panel");
    panel.appendChild(app.cloneNode(true));
    container2.appendChild(panel);
    if (!isPosition) {
        appWrapper.appendChild(container2);
    } else {
        appWrapper.replaceChild(container2, app);
    }
    initTabbar(config, history2);
}
export { _extends, createBrowserHistory, createHashHistory, history, setHistory, createMpaHistory, setHistoryMode, prependBasename, routesAlias, navigateTo, redirectTo, navigateBack, switchTab, reLaunch, getCurrentPages, isWeixin, isDingTalk, setTitle, createMultiRouter, createRouter, handleAppMount, handleAppMountWithTabbar, createRewardedVideoAd, createInterstitialAd, stopFaceDetect, initFaceDetect, faceDetect, getInferenceEnvInfo, createInferenceSession, isVKSupport, createVKSession, getOpenUserInfo, tradePay, getUserCryptoManager, setEnableDebug, getRealtimeLogManager, getLogManager, reportPerformance, getPerformance, preloadWebview, preloadSkylineView, preloadAssets, openSystemBluetoothSetting, openAppAuthorizeSetting, getWindowInfo, getSystemSetting, getDeviceInfo, getAppBaseInfo, getAppAuthorizeSetting, getSystemInfoSync, getSystemInfoAsync, getSystemInfo, getSkylineInfoSync, getSkylineInfo, getRendererUserAgent, updateWeChatApp, getUpdateManager, onUnhandledRejection, onThemeChange, onPageNotFound, onLazyLoadError, onError, onAudioInterruptionEnd, onAudioInterruptionBegin, onAppShow, onAppHide, offUnhandledRejection, offThemeChange, offPageNotFound, offLazyLoadError, offError, offAudioInterruptionEnd, offAudioInterruptionBegin, offAppShow, offAppHide, getLaunchOptionsSync, getEnterOptionsSync, env, arrayBufferToBase64, base64ToArrayBuffer, createCanvasContext, canvasToTempFilePath, canvasPutImageData, canvasGetImageData, createOffscreenCanvas, cloud, reportMonitor, reportAnalytics, reportEvent, getExptInfoSync, stopAccelerometer, startAccelerometer, onAccelerometerChange, offAccelerometerChange, checkIsOpenAccessibility, getBatteryInfoSync, getBatteryInfo, stopBluetoothDevicesDiscovery, startBluetoothDevicesDiscovery, openBluetoothAdapter, onBluetoothDeviceFound, onBluetoothAdapterStateChange, offBluetoothDeviceFound, offBluetoothAdapterStateChange, makeBluetoothPair, isBluetoothDevicePaired, getConnectedBluetoothDevices, getBluetoothDevices, getBluetoothAdapterState, closeBluetoothAdapter, writeBLECharacteristicValue, setBLEMTU, readBLECharacteristicValue, onBLEMTUChange, onBLEConnectionStateChange, onBLECharacteristicValueChange, offBLEMTUChange, offBLEConnectionStateChange, offBLECharacteristicValueChange, notifyBLECharacteristicValueChange, getBLEMTU, getBLEDeviceServices, getBLEDeviceRSSI, getBLEDeviceCharacteristics, createBLEConnection, closeBLEConnection, onBLEPeripheralConnectionStateChanged, offBLEPeripheralConnectionStateChanged, createBLEPeripheralServer, addPhoneRepeatCalendar, addPhoneCalendar, setBackgroundFetchToken, onBackgroundFetchData, getBackgroundFetchToken, getBackgroundFetchData, createCacheManager, setStorageSync, setStorage, revokeBufferURL, removeStorageSync, removeStorage, getStorageSync, getStorageInfoSync, getStorageInfo, getStorage, createBufferURL, clearStorageSync, clearStorage, batchSetStorageSync, batchSetStorage, batchGetStorageSync, batchGetStorage, setClipboardData, getClipboardData, stopCompass, startCompass, onCompassChange, offCompassChange, chooseContact, addPhoneContact, getRandomValues, stopGyroscope, startGyroscope, onGyroscopeChange, offGyroscopeChange, stopBeaconDiscovery, startBeaconDiscovery, onBeaconUpdate, onBeaconServiceChange, offBeaconUpdate, offBeaconServiceChange, getBeacons, onKeyboardHeightChange, offKeyboardHeightChange, hideKeyboard, getSelectedTextRange, onMemoryWarning, offMemoryWarning, stopDeviceMotionListening, startDeviceMotionListening, onDeviceMotionChange, offDeviceMotionChange, getNetworkType, onNetworkWeakChange, onNetworkStatusChange, offNetworkWeakChange, offNetworkStatusChange, getLocalIPAddress, stopHCE, startHCE, sendHCEMessage, onHCEMessage, offHCEMessage, getNFCAdapter, getHCEState, makePhoneCall, scanCode, setVisualEffectOnCapture, setScreenBrightness, setKeepScreenOn, onUserCaptureScreen, offUserCaptureScreen, getScreenBrightness, onScreenRecordingStateChanged, offScreenRecordingStateChanged, getScreenRecordingState, sendSms, vibrateShort, vibrateLong, stopWifi, startWifi, setWifiList, onWifiConnectedWithPartialInfo, onWifiConnected, onGetWifiList, offWifiConnectedWithPartialInfo, offWifiConnected, offGetWifiList, getWifiList, getConnectedWifi, connectWifi, getExtConfigSync, getExtConfig, saveFileToDisk, saveFile, removeSavedFile, openDocument, getSavedFileList, getSavedFileInfo, getFileSystemManager, getFileInfo, getApp2 as getApp, getCurrentInstance2 as getCurrentInstance, getLocation, chooseLocation, stopLocationUpdate, startLocationUpdateBackground, startLocationUpdate, openLocation, onLocationChangeError, onLocationChange, offLocationChangeError, offLocationChange, choosePoi, getFuzzyLocation, stopVoice, setInnerAudioOption, playVoice, pauseVoice, getAvailableAudioSources, createWebAudioContext, createMediaAudioPlayer, createInnerAudioContext, createAudioContext, stopBackgroundAudio, seekBackgroundAudio, playBackgroundAudio, pauseBackgroundAudio, onBackgroundAudioStop, onBackgroundAudioPlay, onBackgroundAudioPause, getBackgroundAudioPlayerState, getBackgroundAudioManager, createCameraContext, saveImageToPhotosAlbum, getImageInfo, previewImage, createAnimation, setBackgroundTextStyle, setBackgroundColor, nextTick3 as nextTick, loadFontFace, showToast, hideToast, showLoading, hideLoading, showModal, showActionSheet, enableAlertBeforeUnload, disableAlertBeforeUnload, getMenuButtonBoundingClientRect, showNavigationBarLoading, setNavigationBarTitle, setNavigationBarColor, hideNavigationBarLoading, hideHomeButton, startPullDownRefresh, stopPullDownRefresh, pageScrollTo, setTopBarText, initTabBarApis, showTabBarRedDot, showTabBar, setTabBarStyle, setTabBarItem, setTabBarBadge, removeTabBarBadge, hideTabBarRedDot, hideTabBar, setWindowSize, onWindowResize, offWindowResize, checkIsPictureInPictureActive, chooseMedia, chooseImage, previewMedia, compressImage, chooseMessageFile, editImage, cropImage, createLivePusherContext, createLivePlayerContext, createMapContext, createMediaRecorder, stopRecord, startRecord, getRecorderManager, saveVideoToPhotosAlbum, getVideoInfo, chooseVideo, openVideoEditor, createVideoContext, compressVideo, createVideoDecoder, createMediaContainer, updateVoIPChatMuteConfig, subscribeVoIPVideoMembers, setEnable1v1Chat, onVoIPVideoMembersChanged, onVoIPChatStateChanged, onVoIPChatSpeakersChanged, onVoIPChatMembersChanged, onVoIPChatInterrupted, offVoIPChatSpeakersChanged, offVoIPVideoMembersChanged, offVoIPChatStateChanged, offVoIPChatMembersChanged, offVoIPChatInterrupted, joinVoIPChat, join1v1Chat, exitVoIPChat, openEmbeddedMiniProgram, navigateToMiniProgram, navigateBackMiniProgram, exitMiniProgram, openBusinessView, downloadFile, stopLocalServiceDiscovery, startLocalServiceDiscovery, onLocalServiceResolveFail, onLocalServiceLost, onLocalServiceFound, onLocalServiceDiscoveryStop, offLocalServiceResolveFail, offLocalServiceLost, offLocalServiceFound, offLocalServiceDiscoveryStop, request, addInterceptor, cleanInterceptors, createTCPSocket, createUDPSocket, uploadFile, sendSocketMessage, onSocketOpen, onSocketMessage, onSocketError, onSocketClose, connectSocket, closeSocket, getAccountInfoSync, chooseAddress, authorizeForMiniProgram, authorize, openCard, addCard, reserveChannelsLive, openChannelsUserProfile, openChannelsLive, openChannelsEvent, openChannelsActivity, getChannelsShareKey, getChannelsLiveNoticeInfo, getChannelsLiveInfo, openCustomerServiceChat, requestDeviceVoIP, getDeviceVoIPList, checkIsSupportFacialRecognition, startFacialRecognitionVerify, startFacialRecognitionVerifyAndUploadVideo, faceVerifyForPay, addVideoToFavorites, addFileToFavorites, getGroupEnterInfo, chooseInvoiceTitle, chooseInvoice, chooseLicensePlate, pluginLogin, login, checkSession, checkIsAddedToMyMiniProgram, requirePrivacyAuthorize, openPrivacyContract, onNeedPrivacyAuthorization, getPrivacySetting, showRedPackage, openSetting, getSetting, startSoterAuthentication, checkIsSupportSoterAuthentication, checkIsSoterEnrolledInDevice, requestSubscribeMessage, requestSubscribeDeviceMessage, getUserProfile, getUserInfo, shareToWeRun, getWeRunData, requestPayment, requestPluginPayment, requestOrderPayment, openQzonePublish, getQQRunData, setOfficialDress, setCustomDress, updateQQApp, addRecentColorSign, getGuildInfo, applyAddToMyApps, isAddedToMyApps, updateShareMenu, showShareMenu, showShareImageMenu, shareVideoMessage, shareFileMessage, onCopyUrl, offCopyUrl, hideShareMenu, getShareInfo, authPrivateMessage, setPageInfo, ocrIdCard, ocrBankCard, ocrDrivingLicense, ocrVehicleLicense, textReview, textToAudio, imageAudit, advancedGeneralIdentify, objectDetectIdentify, carClassify, dishClassify, logoClassify, animalClassify, plantClassify, getSwanId, requestPolymerPayment, navigateToSmartGameProgram, navigateToSmartProgram, navigateBackSmartProgram, preloadSubPackage, createWorker, NodesRef, createSelectorQuery, createIntersectionObserver, createMediaQueryObserver, Behavior2 as Behavior, getEnv2 as getEnv, ENV_TYPE2 as ENV_TYPE, Link3 as Link, interceptors2 as interceptors, interceptorify2 as interceptorify, Current2 as Current, options2 as options, eventCenter2 as eventCenter, Events2 as Events, preload, taro, requirePlugin, initPxTransform, pxTransform, canIUseWebp, getAppInfo, canIUse, defineCustomElement3 as defineCustomElement, defineCustomElement4 as defineCustomElement2, defineCustomElement5 as defineCustomElement3, defineCustomElement6 as defineCustomElement4, defineCustomElement7 as defineCustomElement5, defineCustomElement8 as defineCustomElement6, defineCustomElement9 as defineCustomElement7, defineCustomElement10 as defineCustomElement8, defineCustomElement11 as defineCustomElement9, defineCustomElement12 as defineCustomElement10, defineCustomElement13 as defineCustomElement11, defineCustomElement14 as defineCustomElement12, defineCustomElement15 as defineCustomElement13, defineCustomElement16 as defineCustomElement14, defineCustomElement17 as defineCustomElement15, defineCustomElement18 as defineCustomElement16, defineCustomElement19 as defineCustomElement17, defineCustomElement20 as defineCustomElement18, defineCustomElement21 as defineCustomElement19, defineCustomElement22 as defineCustomElement20, defineCustomElement23 as defineCustomElement21, defineCustomElement24 as defineCustomElement22, defineCustomElement25 as defineCustomElement23, defineCustomElement26 as defineCustomElement24, defineCustomElement27 as defineCustomElement25, defineCustomElement28 as defineCustomElement26, defineCustomElement29 as defineCustomElement27, defineCustomElement30 as defineCustomElement28, defineCustomElement31 as defineCustomElement29, defineCustomElement32 as defineCustomElement30, defineCustomElement33 as defineCustomElement31, defineCustomElement34 as defineCustomElement32, defineCustomElement35 as defineCustomElement33, defineCustomElement36 as defineCustomElement34, defineCustomElement37 as defineCustomElement35, defineCustomElement38 as defineCustomElement36, defineCustomElement39 as defineCustomElement37, defineCustomElement40 as defineCustomElement38, defineCustomElement41 as defineCustomElement39, defineCustomElement42 as defineCustomElement40, defineCustomElement43 as defineCustomElement41, defineCustomElement44 as defineCustomElement42, defineCustomElement45 as defineCustomElement43, defineCustomElement46 as defineCustomElement44, defineCustomElement47 as defineCustomElement45, defineCustomElement48 as defineCustomElement46, defineCustomElement49 as defineCustomElement47, defineCustomElement50 as defineCustomElement48, defineCustomElement51 as defineCustomElement49, defineCustomElement53 as defineCustomElement50, defineCustomElement54 as defineCustomElement51, defineCustomElement55 as defineCustomElement52, defineCustomElement56 as defineCustomElement53, defineCustomElement57 as defineCustomElement54, defineCustomElement58 as defineCustomElement55, defineCustomElement59 as defineCustomElement56, defineCustomElement60 as defineCustomElement57, defineCustomElement61 as defineCustomElement58, defineCustomElement62 as defineCustomElement59, defineCustomElement63 as defineCustomElement60, defineCustomElement64 as defineCustomElement61, defineCustomElement65 as defineCustomElement62, defineCustomElement66 as defineCustomElement63, defineCustomElement67 as defineCustomElement64, defineCustomElement68 as defineCustomElement65, defineCustomElement69 as defineCustomElement66, defineCustomElement70 as defineCustomElement67, defineCustomElement71 as defineCustomElement68, defineCustomElement as defineCustomElement69, defineCustomElement2 as defineCustomElement70, defineCustomElement72 as defineCustomElement71, defineCustomElement73 as defineCustomElement72, defineCustomElement74 as defineCustomElement73, defineCustomElement75 as defineCustomElement74, defineCustomElement76 as defineCustomElement75, defineCustomElement77 as defineCustomElement76, defineCustomElement79 as defineCustomElement77, defineCustomElement81 as defineCustomElement78, defineCustomElement82 as defineCustomElement79, defineCustomElement83 as defineCustomElement80, defineCustomElement84 as defineCustomElement81, defineCustomElement85 as defineCustomElement82 }; /*! Bundled license information:

platform/platform.js:
  (*!
   * Platform.js v1.3.6
   * Copyright 2014-2020 Benjamin Tan
   * Copyright 2011-2013 John-David Dalton
   * Available under MIT license
   *)

universal-router/module.js:
  (*! Universal Router | MIT License | https://www.kriasoft.com/universal-router/ *)

@stencil/core/internal/client/index.js:
  (*!__STENCIL_STATIC_IMPORT_SWITCH__*)

jsonp-retry/dist/jsonp.esm.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

@tarojs/components/dist/components/index2.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)
*/ 
