"use strict";
(self["webpackJsonp"] = self["webpackJsonp"] || []).push([["vendors-node_modules_taro_h5_prebundle_chunk-OJQNUBSF_js-node_modules_taro_h5_prebundle_chunk-9a748d"],{

/***/ "./node_modules/.taro/h5/prebundle/chunk-OJQNUBSF.js":
/*!***********************************************************!*\
  !*** ./node_modules/.taro/h5/prebundle/chunk-OJQNUBSF.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "A": function() { return /* binding */ A; },
/* harmony export */   "APP": function() { return /* binding */ APP; },
/* harmony export */   "BEHAVIORS": function() { return /* binding */ BEHAVIORS; },
/* harmony export */   "BODY": function() { return /* binding */ BODY; },
/* harmony export */   "CATCHMOVE": function() { return /* binding */ CATCHMOVE; },
/* harmony export */   "CATCH_VIEW": function() { return /* binding */ CATCH_VIEW; },
/* harmony export */   "CHANGE": function() { return /* binding */ CHANGE; },
/* harmony export */   "CLASS": function() { return /* binding */ CLASS; },
/* harmony export */   "COMMENT": function() { return /* binding */ COMMENT; },
/* harmony export */   "COMPILE_MODE": function() { return /* binding */ COMPILE_MODE; },
/* harmony export */   "CONFIRM": function() { return /* binding */ CONFIRM; },
/* harmony export */   "CONTAINER": function() { return /* binding */ CONTAINER; },
/* harmony export */   "CONTEXT_ACTIONS": function() { return /* binding */ CONTEXT_ACTIONS; },
/* harmony export */   "CURRENT_TARGET": function() { return /* binding */ CURRENT_TARGET; },
/* harmony export */   "CUSTOM_WRAPPER": function() { return /* binding */ CUSTOM_WRAPPER; },
/* harmony export */   "Current": function() { return /* binding */ Current; },
/* harmony export */   "DATASET": function() { return /* binding */ DATASET; },
/* harmony export */   "DATE": function() { return /* binding */ DATE; },
/* harmony export */   "DOCUMENT_ELEMENT_NAME": function() { return /* binding */ DOCUMENT_ELEMENT_NAME; },
/* harmony export */   "DOCUMENT_FRAGMENT": function() { return /* binding */ DOCUMENT_FRAGMENT; },
/* harmony export */   "EMPTY_OBJ": function() { return /* binding */ EMPTY_OBJ; },
/* harmony export */   "EVENT_CALLBACK_RESULT": function() { return /* binding */ EVENT_CALLBACK_RESULT; },
/* harmony export */   "EXTERNAL_CLASSES": function() { return /* binding */ EXTERNAL_CLASSES; },
/* harmony export */   "Events": function() { return /* binding */ Events; },
/* harmony export */   "FOCUS": function() { return /* binding */ FOCUS; },
/* harmony export */   "FormElement": function() { return /* binding */ FormElement; },
/* harmony export */   "HEAD": function() { return /* binding */ HEAD; },
/* harmony export */   "HOOKS_APP_ID": function() { return /* binding */ HOOKS_APP_ID; },
/* harmony export */   "HTML": function() { return /* binding */ HTML; },
/* harmony export */   "History": function() { return /* binding */ History; },
/* harmony export */   "ID": function() { return /* binding */ ID; },
/* harmony export */   "INPUT": function() { return /* binding */ INPUT; },
/* harmony export */   "KEY_CODE": function() { return /* binding */ KEY_CODE; },
/* harmony export */   "Location": function() { return /* binding */ Location; },
/* harmony export */   "MutationObserver$1": function() { return /* binding */ MutationObserver$1; },
/* harmony export */   "OBJECT": function() { return /* binding */ OBJECT; },
/* harmony export */   "ON_HIDE": function() { return /* binding */ ON_HIDE; },
/* harmony export */   "ON_LOAD": function() { return /* binding */ ON_LOAD; },
/* harmony export */   "ON_READY": function() { return /* binding */ ON_READY; },
/* harmony export */   "ON_SHOW": function() { return /* binding */ ON_SHOW; },
/* harmony export */   "OPTIONS": function() { return /* binding */ OPTIONS; },
/* harmony export */   "PAGE_INIT": function() { return /* binding */ PAGE_INIT; },
/* harmony export */   "PROPERTY_THRESHOLD": function() { return /* binding */ PROPERTY_THRESHOLD; },
/* harmony export */   "PROPS": function() { return /* binding */ PROPS; },
/* harmony export */   "PURE_VIEW": function() { return /* binding */ PURE_VIEW; },
/* harmony export */   "ROOT_STR": function() { return /* binding */ ROOT_STR; },
/* harmony export */   "SET_DATA": function() { return /* binding */ SET_DATA; },
/* harmony export */   "SET_TIMEOUT": function() { return /* binding */ SET_TIMEOUT; },
/* harmony export */   "STATIC_VIEW": function() { return /* binding */ STATIC_VIEW; },
/* harmony export */   "STYLE": function() { return /* binding */ STYLE; },
/* harmony export */   "SVGElement": function() { return /* binding */ SVGElement; },
/* harmony export */   "Style": function() { return /* binding */ Style; },
/* harmony export */   "TARGET": function() { return /* binding */ TARGET; },
/* harmony export */   "TARO_RUNTIME": function() { return /* binding */ TARO_RUNTIME; },
/* harmony export */   "TIME_STAMP": function() { return /* binding */ TIME_STAMP; },
/* harmony export */   "TOUCHMOVE": function() { return /* binding */ TOUCHMOVE; },
/* harmony export */   "TYPE": function() { return /* binding */ TYPE; },
/* harmony export */   "TaroElement": function() { return /* binding */ TaroElement; },
/* harmony export */   "TaroEvent": function() { return /* binding */ TaroEvent; },
/* harmony export */   "TaroNode": function() { return /* binding */ TaroNode; },
/* harmony export */   "TaroRootElement": function() { return /* binding */ TaroRootElement; },
/* harmony export */   "TaroText": function() { return /* binding */ TaroText; },
/* harmony export */   "UID": function() { return /* binding */ UID; },
/* harmony export */   "URL": function() { return /* binding */ URL; },
/* harmony export */   "URLSearchParams": function() { return /* binding */ URLSearchParams; },
/* harmony export */   "VALUE": function() { return /* binding */ VALUE; },
/* harmony export */   "VIEW": function() { return /* binding */ VIEW; },
/* harmony export */   "__awaiter": function() { return /* binding */ __awaiter; },
/* harmony export */   "__rest": function() { return /* binding */ __rest; },
/* harmony export */   "_caf": function() { return /* binding */ _caf; },
/* harmony export */   "_raf": function() { return /* binding */ _raf; },
/* harmony export */   "addLeadingSlash": function() { return /* binding */ addLeadingSlash; },
/* harmony export */   "createComponentConfig": function() { return /* binding */ createComponentConfig; },
/* harmony export */   "createEvent": function() { return /* binding */ createEvent; },
/* harmony export */   "createPageConfig": function() { return /* binding */ createPageConfig; },
/* harmony export */   "createRecursiveComponentConfig": function() { return /* binding */ createRecursiveComponentConfig; },
/* harmony export */   "document$1": function() { return /* binding */ document$1; },
/* harmony export */   "ensure": function() { return /* binding */ ensure; },
/* harmony export */   "env": function() { return /* binding */ env; },
/* harmony export */   "eventCenter": function() { return /* binding */ eventCenter; },
/* harmony export */   "eventHandler": function() { return /* binding */ eventHandler; },
/* harmony export */   "eventSource": function() { return /* binding */ eventSource; },
/* harmony export */   "getComputedStyle": function() { return /* binding */ getComputedStyle; },
/* harmony export */   "getCurrentInstance": function() { return /* binding */ getCurrentInstance; },
/* harmony export */   "getCurrentPage": function() { return /* binding */ getCurrentPage; },
/* harmony export */   "getHomePage": function() { return /* binding */ getHomePage; },
/* harmony export */   "getOnHideEventKey": function() { return /* binding */ getOnHideEventKey; },
/* harmony export */   "getOnReadyEventKey": function() { return /* binding */ getOnReadyEventKey; },
/* harmony export */   "getOnShowEventKey": function() { return /* binding */ getOnShowEventKey; },
/* harmony export */   "getPageInstance": function() { return /* binding */ getPageInstance; },
/* harmony export */   "getPath": function() { return /* binding */ getPath; },
/* harmony export */   "handlePolyfill": function() { return /* binding */ handlePolyfill; },
/* harmony export */   "hasBasename": function() { return /* binding */ hasBasename; },
/* harmony export */   "history": function() { return /* binding */ history; },
/* harmony export */   "hooks": function() { return /* binding */ hooks; },
/* harmony export */   "hydrate": function() { return /* binding */ hydrate; },
/* harmony export */   "incrementId": function() { return /* binding */ incrementId; },
/* harmony export */   "injectPageInstance": function() { return /* binding */ injectPageInstance; },
/* harmony export */   "isArray": function() { return /* binding */ isArray; },
/* harmony export */   "isFunction": function() { return /* binding */ isFunction; },
/* harmony export */   "isHasExtractProp": function() { return /* binding */ isHasExtractProp; },
/* harmony export */   "isObject": function() { return /* binding */ isObject; },
/* harmony export */   "isUndefined": function() { return /* binding */ isUndefined; },
/* harmony export */   "location": function() { return /* binding */ location; },
/* harmony export */   "nav": function() { return /* binding */ nav; },
/* harmony export */   "nextTick": function() { return /* binding */ nextTick; },
/* harmony export */   "now": function() { return /* binding */ now; },
/* harmony export */   "options": function() { return /* binding */ options; },
/* harmony export */   "parseUrl": function() { return /* binding */ parseUrl; },
/* harmony export */   "removePageInstance": function() { return /* binding */ removePageInstance; },
/* harmony export */   "safeExecute": function() { return /* binding */ safeExecute; },
/* harmony export */   "stringify": function() { return /* binding */ stringify; },
/* harmony export */   "stripBasename": function() { return /* binding */ stripBasename; },
/* harmony export */   "stripSuffix": function() { return /* binding */ stripSuffix; },
/* harmony export */   "stripTrailing": function() { return /* binding */ stripTrailing; },
/* harmony export */   "toKebabCase": function() { return /* binding */ toKebabCase; },
/* harmony export */   "window$1": function() { return /* binding */ window$1; }
/* harmony export */ });
// node_modules/@tarojs/shared/dist/shared.esm.js
var DEFAULT_EMPTY_ARRAY = "[]";
var NO_DEFAULT_VALUE = "";
var DEFAULT_TRUE = "!0";
var DEFAULT_FALSE = "!1";
var touchEvents = {
    bindTouchStart: NO_DEFAULT_VALUE,
    bindTouchMove: NO_DEFAULT_VALUE,
    bindTouchEnd: NO_DEFAULT_VALUE,
    bindTouchCancel: NO_DEFAULT_VALUE,
    bindLongTap: NO_DEFAULT_VALUE
};
var animation = {
    animation: NO_DEFAULT_VALUE,
    bindAnimationStart: NO_DEFAULT_VALUE,
    bindAnimationIteration: NO_DEFAULT_VALUE,
    bindAnimationEnd: NO_DEFAULT_VALUE,
    bindTransitionEnd: NO_DEFAULT_VALUE
};
function singleQuote(s) {
    return `'${s}'`;
}
var View = Object.assign(Object.assign({
    "hover-class": singleQuote("none"),
    "hover-stop-propagation": DEFAULT_FALSE,
    "hover-start-time": "50",
    "hover-stay-time": "400"
}, touchEvents), animation);
var Icon = {
    type: NO_DEFAULT_VALUE,
    size: "23",
    color: NO_DEFAULT_VALUE
};
var MapComp = Object.assign({
    longitude: NO_DEFAULT_VALUE,
    latitude: NO_DEFAULT_VALUE,
    scale: "16",
    markers: DEFAULT_EMPTY_ARRAY,
    covers: NO_DEFAULT_VALUE,
    polyline: DEFAULT_EMPTY_ARRAY,
    circles: DEFAULT_EMPTY_ARRAY,
    controls: DEFAULT_EMPTY_ARRAY,
    "include-points": DEFAULT_EMPTY_ARRAY,
    "show-location": NO_DEFAULT_VALUE,
    "layer-style": "1",
    bindMarkerTap: NO_DEFAULT_VALUE,
    bindControlTap: NO_DEFAULT_VALUE,
    bindCalloutTap: NO_DEFAULT_VALUE,
    bindUpdated: NO_DEFAULT_VALUE
}, touchEvents);
var Progress = {
    percent: NO_DEFAULT_VALUE,
    "stroke-width": "6",
    color: singleQuote("#09BB07"),
    activeColor: singleQuote("#09BB07"),
    backgroundColor: singleQuote("#EBEBEB"),
    active: DEFAULT_FALSE,
    "active-mode": singleQuote("backwards"),
    "show-info": DEFAULT_FALSE
};
var RichText = {
    nodes: DEFAULT_EMPTY_ARRAY
};
var Text = {
    selectable: DEFAULT_FALSE,
    space: NO_DEFAULT_VALUE,
    decode: DEFAULT_FALSE
};
var Button = Object.assign({
    size: singleQuote("default"),
    type: NO_DEFAULT_VALUE,
    plain: DEFAULT_FALSE,
    disabled: NO_DEFAULT_VALUE,
    loading: DEFAULT_FALSE,
    "form-type": NO_DEFAULT_VALUE,
    "open-type": NO_DEFAULT_VALUE,
    "hover-class": singleQuote("button-hover"),
    "hover-stop-propagation": DEFAULT_FALSE,
    "hover-start-time": "20",
    "hover-stay-time": "70",
    name: NO_DEFAULT_VALUE,
    bindagreeprivacyauthorization: NO_DEFAULT_VALUE
}, touchEvents);
var Checkbox = {
    value: NO_DEFAULT_VALUE,
    disabled: NO_DEFAULT_VALUE,
    checked: DEFAULT_FALSE,
    color: singleQuote("#09BB07"),
    name: NO_DEFAULT_VALUE
};
var CheckboxGroup = {
    bindChange: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var Form = {
    "report-submit": DEFAULT_FALSE,
    bindSubmit: NO_DEFAULT_VALUE,
    bindReset: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var Input = {
    value: NO_DEFAULT_VALUE,
    type: singleQuote(NO_DEFAULT_VALUE),
    password: DEFAULT_FALSE,
    placeholder: NO_DEFAULT_VALUE,
    "placeholder-style": NO_DEFAULT_VALUE,
    "placeholder-class": singleQuote("input-placeholder"),
    disabled: NO_DEFAULT_VALUE,
    maxlength: "140",
    "cursor-spacing": "0",
    focus: DEFAULT_FALSE,
    "confirm-type": singleQuote("done"),
    "confirm-hold": DEFAULT_FALSE,
    cursor: "-1",
    "selection-start": "-1",
    "selection-end": "-1",
    bindInput: NO_DEFAULT_VALUE,
    bindFocus: NO_DEFAULT_VALUE,
    bindBlur: NO_DEFAULT_VALUE,
    bindConfirm: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var Label = {
    for: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var Picker = {
    mode: singleQuote("selector"),
    disabled: NO_DEFAULT_VALUE,
    range: NO_DEFAULT_VALUE,
    "range-key": NO_DEFAULT_VALUE,
    value: NO_DEFAULT_VALUE,
    start: NO_DEFAULT_VALUE,
    end: NO_DEFAULT_VALUE,
    fields: singleQuote("day"),
    "custom-item": NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE,
    bindCancel: NO_DEFAULT_VALUE,
    bindChange: NO_DEFAULT_VALUE,
    bindColumnChange: NO_DEFAULT_VALUE
};
var PickerView = {
    value: NO_DEFAULT_VALUE,
    "indicator-style": NO_DEFAULT_VALUE,
    "indicator-class": NO_DEFAULT_VALUE,
    "mask-style": NO_DEFAULT_VALUE,
    "mask-class": NO_DEFAULT_VALUE,
    bindChange: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var PickerViewColumn = {
    name: NO_DEFAULT_VALUE
};
var Radio = {
    value: NO_DEFAULT_VALUE,
    checked: DEFAULT_FALSE,
    disabled: NO_DEFAULT_VALUE,
    color: singleQuote("#09BB07"),
    name: NO_DEFAULT_VALUE
};
var RadioGroup = {
    bindChange: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var Slider = {
    min: "0",
    max: "100",
    step: "1",
    disabled: NO_DEFAULT_VALUE,
    value: "0",
    activeColor: singleQuote("#1aad19"),
    backgroundColor: singleQuote("#e9e9e9"),
    "block-size": "28",
    "block-color": singleQuote("#ffffff"),
    "show-value": DEFAULT_FALSE,
    bindChange: NO_DEFAULT_VALUE,
    bindChanging: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var Switch = {
    checked: DEFAULT_FALSE,
    disabled: NO_DEFAULT_VALUE,
    type: singleQuote("switch"),
    color: singleQuote("#04BE02"),
    bindChange: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var Textarea = {
    value: NO_DEFAULT_VALUE,
    placeholder: NO_DEFAULT_VALUE,
    "placeholder-style": NO_DEFAULT_VALUE,
    "placeholder-class": singleQuote("textarea-placeholder"),
    disabled: NO_DEFAULT_VALUE,
    maxlength: "140",
    "auto-focus": DEFAULT_FALSE,
    focus: DEFAULT_FALSE,
    "auto-height": DEFAULT_FALSE,
    fixed: DEFAULT_FALSE,
    "cursor-spacing": "0",
    cursor: "-1",
    "selection-start": "-1",
    "selection-end": "-1",
    bindFocus: NO_DEFAULT_VALUE,
    bindBlur: NO_DEFAULT_VALUE,
    bindLineChange: NO_DEFAULT_VALUE,
    bindInput: NO_DEFAULT_VALUE,
    bindConfirm: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var CoverImage = {
    src: NO_DEFAULT_VALUE,
    bindLoad: "eh",
    bindError: "eh"
};
var CoverView = Object.assign({
    "scroll-top": DEFAULT_FALSE
}, touchEvents);
var MovableArea = {
    "scale-area": DEFAULT_FALSE
};
var MovableView = Object.assign(Object.assign({
    direction: "none",
    inertia: DEFAULT_FALSE,
    "out-of-bounds": DEFAULT_FALSE,
    x: NO_DEFAULT_VALUE,
    y: NO_DEFAULT_VALUE,
    damping: "20",
    friction: "2",
    disabled: NO_DEFAULT_VALUE,
    scale: DEFAULT_FALSE,
    "scale-min": "0.5",
    "scale-max": "10",
    "scale-value": "1",
    bindChange: NO_DEFAULT_VALUE,
    bindScale: NO_DEFAULT_VALUE,
    bindHTouchMove: NO_DEFAULT_VALUE,
    bindVTouchMove: NO_DEFAULT_VALUE,
    width: singleQuote("10px"),
    height: singleQuote("10px")
}, touchEvents), animation);
var ScrollView = Object.assign(Object.assign({
    "scroll-x": DEFAULT_FALSE,
    "scroll-y": DEFAULT_FALSE,
    "upper-threshold": "50",
    "lower-threshold": "50",
    "scroll-top": NO_DEFAULT_VALUE,
    "scroll-left": NO_DEFAULT_VALUE,
    "scroll-into-view": NO_DEFAULT_VALUE,
    "scroll-with-animation": DEFAULT_FALSE,
    "enable-back-to-top": DEFAULT_FALSE,
    bindScrollToUpper: NO_DEFAULT_VALUE,
    bindScrollToLower: NO_DEFAULT_VALUE,
    bindScroll: NO_DEFAULT_VALUE
}, touchEvents), animation);
var Swiper = Object.assign({
    "indicator-dots": DEFAULT_FALSE,
    "indicator-color": singleQuote("rgba(0, 0, 0, .3)"),
    "indicator-active-color": singleQuote("#000000"),
    autoplay: DEFAULT_FALSE,
    current: "0",
    interval: "5000",
    duration: "500",
    circular: DEFAULT_FALSE,
    vertical: DEFAULT_FALSE,
    "previous-margin": singleQuote("0px"),
    "next-margin": singleQuote("0px"),
    "display-multiple-items": "1",
    bindChange: NO_DEFAULT_VALUE,
    bindTransition: NO_DEFAULT_VALUE,
    bindAnimationFinish: NO_DEFAULT_VALUE
}, touchEvents);
var SwiperItem = {
    "item-id": NO_DEFAULT_VALUE
};
var Navigator = {
    url: NO_DEFAULT_VALUE,
    "open-type": singleQuote("navigate"),
    delta: "1",
    "hover-class": singleQuote("navigator-hover"),
    "hover-stop-propagation": DEFAULT_FALSE,
    "hover-start-time": "50",
    "hover-stay-time": "600",
    bindSuccess: NO_DEFAULT_VALUE,
    bindFail: NO_DEFAULT_VALUE,
    bindComplete: NO_DEFAULT_VALUE
};
var Audio = {
    id: NO_DEFAULT_VALUE,
    src: NO_DEFAULT_VALUE,
    loop: DEFAULT_FALSE,
    controls: DEFAULT_FALSE,
    poster: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE,
    author: NO_DEFAULT_VALUE,
    bindError: NO_DEFAULT_VALUE,
    bindPlay: NO_DEFAULT_VALUE,
    bindPause: NO_DEFAULT_VALUE,
    bindTimeUpdate: NO_DEFAULT_VALUE,
    bindEnded: NO_DEFAULT_VALUE
};
var Camera = {
    "device-position": singleQuote("back"),
    flash: singleQuote("auto"),
    bindStop: NO_DEFAULT_VALUE,
    bindError: NO_DEFAULT_VALUE
};
var Image = Object.assign({
    src: NO_DEFAULT_VALUE,
    mode: singleQuote("scaleToFill"),
    "lazy-load": DEFAULT_FALSE,
    bindError: NO_DEFAULT_VALUE,
    bindLoad: NO_DEFAULT_VALUE
}, touchEvents);
var LivePlayer = Object.assign({
    src: NO_DEFAULT_VALUE,
    autoplay: DEFAULT_FALSE,
    muted: DEFAULT_FALSE,
    orientation: singleQuote("vertical"),
    "object-fit": singleQuote("contain"),
    "background-mute": DEFAULT_FALSE,
    "min-cache": "1",
    "max-cache": "3",
    bindStateChange: NO_DEFAULT_VALUE,
    bindFullScreenChange: NO_DEFAULT_VALUE,
    bindNetStatus: NO_DEFAULT_VALUE
}, animation);
var Video = Object.assign({
    src: NO_DEFAULT_VALUE,
    duration: NO_DEFAULT_VALUE,
    controls: DEFAULT_TRUE,
    "danmu-list": NO_DEFAULT_VALUE,
    "danmu-btn": NO_DEFAULT_VALUE,
    "enable-danmu": NO_DEFAULT_VALUE,
    autoplay: DEFAULT_FALSE,
    loop: DEFAULT_FALSE,
    muted: DEFAULT_FALSE,
    "initial-time": "0",
    "page-gesture": DEFAULT_FALSE,
    direction: NO_DEFAULT_VALUE,
    "show-progress": DEFAULT_TRUE,
    "show-fullscreen-btn": DEFAULT_TRUE,
    "show-play-btn": DEFAULT_TRUE,
    "show-center-play-btn": DEFAULT_TRUE,
    "enable-progress-gesture": DEFAULT_TRUE,
    "object-fit": singleQuote("contain"),
    poster: NO_DEFAULT_VALUE,
    "show-mute-btn": DEFAULT_FALSE,
    bindPlay: NO_DEFAULT_VALUE,
    bindPause: NO_DEFAULT_VALUE,
    bindEnded: NO_DEFAULT_VALUE,
    bindTimeUpdate: NO_DEFAULT_VALUE,
    bindFullScreenChange: NO_DEFAULT_VALUE,
    bindWaiting: NO_DEFAULT_VALUE,
    bindError: NO_DEFAULT_VALUE
}, animation);
var Canvas = Object.assign({
    "canvas-id": NO_DEFAULT_VALUE,
    "disable-scroll": DEFAULT_FALSE,
    bindError: NO_DEFAULT_VALUE
}, touchEvents);
var Ad = {
    "unit-id": NO_DEFAULT_VALUE,
    "ad-intervals": NO_DEFAULT_VALUE,
    bindLoad: NO_DEFAULT_VALUE,
    bindError: NO_DEFAULT_VALUE,
    bindClose: NO_DEFAULT_VALUE
};
var WebView = {
    src: NO_DEFAULT_VALUE,
    bindMessage: NO_DEFAULT_VALUE,
    bindLoad: NO_DEFAULT_VALUE,
    bindError: NO_DEFAULT_VALUE
};
var Block = {};
var SlotView = {
    name: NO_DEFAULT_VALUE
};
var Slot = {
    name: NO_DEFAULT_VALUE
};
var NativeSlot = {
    name: NO_DEFAULT_VALUE
};
var internalComponents = {
    View,
    Icon,
    Progress,
    RichText,
    Text,
    Button,
    Checkbox,
    CheckboxGroup,
    Form,
    Input,
    Label,
    Picker,
    PickerView,
    PickerViewColumn,
    Radio,
    RadioGroup,
    Slider,
    Switch,
    CoverImage,
    Textarea,
    CoverView,
    MovableArea,
    MovableView,
    ScrollView,
    Swiper,
    SwiperItem,
    Navigator,
    Audio,
    Camera,
    Image,
    LivePlayer,
    Video,
    Canvas,
    Ad,
    WebView,
    Block,
    Map: MapComp,
    Slot,
    SlotView,
    NativeSlot
};
var PLATFORM_TYPE;
(function(PLATFORM_TYPE2) {
    PLATFORM_TYPE2["MINI"] = "mini";
    PLATFORM_TYPE2["WEB"] = "web";
    PLATFORM_TYPE2["RN"] = "rn";
    PLATFORM_TYPE2["HARMONY"] = "harmony";
    PLATFORM_TYPE2["QUICK"] = "quickapp";
})(PLATFORM_TYPE || (PLATFORM_TYPE = {}));
var PLATFORM_CONFIG_MAP = {
    h5: {
        type: PLATFORM_TYPE.WEB
    },
    harmony: {
        type: PLATFORM_TYPE.HARMONY
    },
    mini: {
        type: PLATFORM_TYPE.MINI
    },
    rn: {
        type: PLATFORM_TYPE.RN
    },
    quickapp: {
        type: PLATFORM_TYPE.QUICK
    }
};
var Events = class _Events {
    on(eventName, callback, context) {
        let event, tail, _eventName;
        if (!callback) {
            return this;
        }
        if (typeof eventName === "symbol") {
            _eventName = [
                eventName
            ];
        } else {
            _eventName = eventName.split(_Events.eventSplitter);
        }
        this.callbacks || (this.callbacks = {});
        const calls = this.callbacks;
        while(event = _eventName.shift()){
            const list = calls[event];
            const node = list ? list.tail : {};
            node.next = tail = {};
            node.context = context;
            node.callback = callback;
            calls[event] = {
                tail,
                next: list ? list.next : node
            };
        }
        return this;
    }
    once(events, callback, context) {
        const wrapper = (...args)=>{
            callback.apply(this, args);
            this.off(events, wrapper, context);
        };
        this.on(events, wrapper, context);
        return this;
    }
    off(events, callback, context) {
        let event, calls, _events;
        if (!(calls = this.callbacks)) {
            return this;
        }
        if (!(events || callback || context)) {
            delete this.callbacks;
            return this;
        }
        if (typeof events === "symbol") {
            _events = [
                events
            ];
        } else {
            _events = events ? events.split(_Events.eventSplitter) : Object.keys(calls);
        }
        while(event = _events.shift()){
            let node = calls[event];
            delete calls[event];
            if (!node || !(callback || context)) {
                continue;
            }
            const tail = node.tail;
            while((node = node.next) !== tail){
                const cb = node.callback;
                const ctx = node.context;
                if (callback && cb !== callback || context && ctx !== context) {
                    this.on(event, cb, ctx);
                }
            }
        }
        return this;
    }
    trigger(events, ...args) {
        let event, node, calls, _events;
        if (!(calls = this.callbacks)) {
            return this;
        }
        if (typeof events === "symbol") {
            _events = [
                events
            ];
        } else {
            _events = events.split(_Events.eventSplitter);
        }
        while(event = _events.shift()){
            if (node = calls[event]) {
                const tail = node.tail;
                while((node = node.next) !== tail){
                    node.callback.apply(node.context || this, args);
                }
            }
        }
        return this;
    }
    constructor(opts){
        var _a1;
        this.callbacks = (_a1 = opts === null || opts === void 0 ? void 0 : opts.callbacks) !== null && _a1 !== void 0 ? _a1 : {};
    }
};
Events.eventSplitter = ",";
function isString(o) {
    return typeof o === "string";
}
function isUndefined(o) {
    return typeof o === "undefined";
}
function isNull(o) {
    return o === null;
}
function isObject(o) {
    return o !== null && typeof o === "object";
}
function isFunction(o) {
    return typeof o === "function";
}
function isNumber(o) {
    return typeof o === "number";
}
var isArray = Array.isArray;
var HOOK_TYPE;
(function(HOOK_TYPE2) {
    HOOK_TYPE2[HOOK_TYPE2["SINGLE"] = 0] = "SINGLE";
    HOOK_TYPE2[HOOK_TYPE2["MULTI"] = 1] = "MULTI";
    HOOK_TYPE2[HOOK_TYPE2["WATERFALL"] = 2] = "WATERFALL";
})(HOOK_TYPE || (HOOK_TYPE = {}));
var defaultMiniLifecycle = {
    app: [
        "onLaunch",
        "onShow",
        "onHide"
    ],
    page: [
        "onLoad",
        "onUnload",
        "onReady",
        "onShow",
        "onHide",
        [
            "onPullDownRefresh",
            "onReachBottom",
            "onPageScroll",
            "onResize",
            "defer:onTabItemTap",
            "onTitleClick",
            "onOptionMenuClick",
            "onPopMenuClick",
            "onPullIntercept",
            "onAddToFavorites"
        ],
        [
            "onShareAppMessage",
            "onShareTimeline"
        ]
    ],
    component: [
        "attached",
        "detached"
    ]
};
function TaroHook(type, initial) {
    return {
        type,
        initial: initial || null
    };
}
var TaroHooks = class extends Events {
    tapOneOrMany(hookName, callback) {
        const list = isFunction(callback) ? [
            callback
        ] : callback;
        list.forEach((cb)=>this.on(hookName, cb));
    }
    tap(hookName, callback) {
        const hooks2 = this.hooks;
        const { type, initial } = hooks2[hookName];
        if (type === HOOK_TYPE.SINGLE) {
            this.off(hookName);
            this.on(hookName, isFunction(callback) ? callback : callback[callback.length - 1]);
        } else {
            initial && this.off(hookName, initial);
            this.tapOneOrMany(hookName, callback);
        }
    }
    call(hookName, ...rest) {
        var _a1;
        const hook = this.hooks[hookName];
        if (!hook) return;
        const { type } = hook;
        const calls = this.callbacks;
        if (!calls) return;
        const list = calls[hookName];
        if (list) {
            const tail = list.tail;
            let node = list.next;
            let args = rest;
            let res;
            while(node !== tail){
                res = (_a1 = node.callback) === null || _a1 === void 0 ? void 0 : _a1.apply(node.context || this, args);
                if (type === HOOK_TYPE.WATERFALL) {
                    const params = [
                        res
                    ];
                    args = params;
                }
                node = node.next;
            }
            return res;
        }
    }
    isExist(hookName) {
        var _a1;
        return Boolean((_a1 = this.callbacks) === null || _a1 === void 0 ? void 0 : _a1[hookName]);
    }
    constructor(hooks2, opts){
        super(opts);
        this.hooks = hooks2;
        for(const hookName in hooks2){
            const { initial } = hooks2[hookName];
            if (isFunction(initial)) {
                this.on(hookName, initial);
            }
        }
    }
};
var hooks = new TaroHooks({
    getMiniLifecycle: TaroHook(HOOK_TYPE.SINGLE, (defaultConfig)=>defaultConfig),
    getMiniLifecycleImpl: TaroHook(HOOK_TYPE.SINGLE, function() {
        return this.call("getMiniLifecycle", defaultMiniLifecycle);
    }),
    getLifecycle: TaroHook(HOOK_TYPE.SINGLE, (instance, lifecycle)=>instance[lifecycle]),
    modifyRecursiveComponentConfig: TaroHook(HOOK_TYPE.SINGLE, (defaultConfig)=>defaultConfig),
    getPathIndex: TaroHook(HOOK_TYPE.SINGLE, (indexOfNode)=>`[${indexOfNode}]`),
    getEventCenter: TaroHook(HOOK_TYPE.SINGLE, (Events2)=>new Events2()),
    isBubbleEvents: TaroHook(HOOK_TYPE.SINGLE, (eventName)=>{
        const BUBBLE_EVENTS = /* @__PURE__ */ new Set([
            "touchstart",
            "touchmove",
            "touchcancel",
            "touchend",
            "touchforcechange",
            "tap",
            "longpress",
            "longtap",
            "transitionend",
            "animationstart",
            "animationiteration",
            "animationend"
        ]);
        return BUBBLE_EVENTS.has(eventName);
    }),
    getSpecialNodes: TaroHook(HOOK_TYPE.SINGLE, ()=>[
            "view",
            "text",
            "image"
        ]),
    onRemoveAttribute: TaroHook(HOOK_TYPE.SINGLE),
    batchedEventUpdates: TaroHook(HOOK_TYPE.SINGLE),
    mergePageInstance: TaroHook(HOOK_TYPE.SINGLE),
    modifyPageObject: TaroHook(HOOK_TYPE.SINGLE),
    createPullDownComponent: TaroHook(HOOK_TYPE.SINGLE),
    getDOMNode: TaroHook(HOOK_TYPE.SINGLE),
    modifyHydrateData: TaroHook(HOOK_TYPE.SINGLE),
    transferHydrateData: TaroHook(HOOK_TYPE.SINGLE),
    modifySetAttrPayload: TaroHook(HOOK_TYPE.SINGLE),
    modifyRmAttrPayload: TaroHook(HOOK_TYPE.SINGLE),
    onAddEvent: TaroHook(HOOK_TYPE.SINGLE),
    proxyToRaw: TaroHook(HOOK_TYPE.SINGLE, function(proxyObj) {
        return proxyObj;
    }),
    modifyMpEvent: TaroHook(HOOK_TYPE.MULTI),
    modifyMpEventImpl: TaroHook(HOOK_TYPE.SINGLE, function(e) {
        try {
            this.call("modifyMpEvent", e);
        } catch (error) {
            console.warn("[Taro modifyMpEvent hook Error]: " + (error === null || error === void 0 ? void 0 : error.message));
        }
    }),
    injectNewStyleProperties: TaroHook(HOOK_TYPE.SINGLE),
    modifyTaroEvent: TaroHook(HOOK_TYPE.MULTI),
    dispatchTaroEvent: TaroHook(HOOK_TYPE.SINGLE, (e, node)=>{
        node.dispatchEvent(e);
    }),
    dispatchTaroEventFinish: TaroHook(HOOK_TYPE.MULTI),
    modifyTaroEventReturn: TaroHook(HOOK_TYPE.SINGLE, ()=>void 0),
    modifyDispatchEvent: TaroHook(HOOK_TYPE.MULTI),
    initNativeApi: TaroHook(HOOK_TYPE.MULTI),
    patchElement: TaroHook(HOOK_TYPE.MULTI),
    modifyAddEventListener: TaroHook(HOOK_TYPE.SINGLE),
    modifyRemoveEventListener: TaroHook(HOOK_TYPE.SINGLE)
});
var EMPTY_OBJ = {};
var noop = (..._)=>{};
function toDashed(s) {
    return s.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}
function toCamelCase(s) {
    let camel = "";
    let nextCap = false;
    for(let i = 0; i < s.length; i++){
        if (s[i] !== "-") {
            camel += nextCap ? s[i].toUpperCase() : s[i];
            nextCap = false;
        } else {
            nextCap = true;
        }
    }
    return camel;
}
var toKebabCase = function(string) {
    return string.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
};
function ensure(condition, msg2) {
    if (!condition) {
        if (true) {
            const reportIssue = "\n\u5982\u6709\u7591\u95EE\uFF0C\u8BF7\u63D0\u4EA4 issue \u81F3\uFF1Ahttps://github.com/nervjs/taro/issues";
            throw new Error(msg2 + reportIssue);
        } else {}
    }
}
function warn(condition, msg2) {
    if (true) {
        if (condition) {
            console.warn(`[taro warn] ${msg2}`);
        }
    }
}
var _loadTime = /* @__PURE__ */ new Date().getTime().toString();
function getComponentsAlias(origin) {
    const mapping = {};
    const viewAttrs = origin.View;
    const extraList = {
        "#text": {},
        StaticView: viewAttrs,
        StaticImage: origin.Image,
        StaticText: origin.Text,
        PureView: viewAttrs,
        CatchView: viewAttrs
    };
    origin = Object.assign(Object.assign({}, origin), extraList);
    Object.keys(origin).sort((a, b)=>{
        const reg = /^(Static|Pure|Catch)*(View|Image|Text)$/;
        const isACommonly = reg.test(a);
        const isBCommonly = reg.test(b);
        if (isACommonly && isBCommonly) {
            return a > b ? 1 : -1;
        } else if (isACommonly) {
            return -1;
        } else if (isBCommonly) {
            return 1;
        } else {
            return a >= b ? 1 : -1;
        }
    }).forEach((key, num)=>{
        const obj = {
            _num: String(num)
        };
        Object.keys(origin[key]).filter((attr)=>!/^bind/.test(attr) && ![
                "focus",
                "blur"
            ].includes(attr)).sort().forEach((attr, index)=>{
            obj[toCamelCase(attr)] = "p" + index;
        });
        mapping[toDashed(key)] = obj;
    });
    return mapping;
}
var Shortcuts;
(function(Shortcuts2) {
    Shortcuts2["Container"] = "container";
    Shortcuts2["Childnodes"] = "cn";
    Shortcuts2["Text"] = "v";
    Shortcuts2["NodeType"] = "nt";
    Shortcuts2["NodeName"] = "nn";
    Shortcuts2["Style"] = "st";
    Shortcuts2["Class"] = "cl";
    Shortcuts2["Src"] = "src";
})(Shortcuts || (Shortcuts = {}));
// node_modules/tslib/tslib.es6.mjs
function __rest(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
// node_modules/@tarojs/runtime/dist/runtime.esm.js
var PROPERTY_THRESHOLD = 2046;
var TARO_RUNTIME = "Taro runtime";
var HOOKS_APP_ID = "taro-app";
var SET_DATA = "\u5C0F\u7A0B\u5E8F setData";
var PAGE_INIT = "\u9875\u9762\u521D\u59CB\u5316";
var ROOT_STR = "root";
var HTML = "html";
var HEAD = "head";
var BODY = "body";
var APP = "app";
var CONTAINER = "container";
var DOCUMENT_ELEMENT_NAME = "#document";
var DOCUMENT_FRAGMENT = "document-fragment";
var ID = "id";
var UID = "uid";
var CLASS = "class";
var STYLE = "style";
var FOCUS = "focus";
var VIEW = "view";
var STATIC_VIEW = "static-view";
var PURE_VIEW = "pure-view";
var PROPS = "props";
var DATASET = "dataset";
var OBJECT = "object";
var VALUE = "value";
var INPUT = "input";
var CHANGE = "change";
var CUSTOM_WRAPPER = "custom-wrapper";
var TARGET = "target";
var CURRENT_TARGET = "currentTarget";
var TYPE = "type";
var CONFIRM = "confirm";
var TIME_STAMP = "timeStamp";
var KEY_CODE = "keyCode";
var TOUCHMOVE = "touchmove";
var DATE = "Date";
var SET_TIMEOUT = "setTimeout";
var COMPILE_MODE = "compileMode";
var CATCHMOVE = "catchMove";
var CATCH_VIEW = "catch-view";
var COMMENT = "comment";
var ON_LOAD = "onLoad";
var ON_READY = "onReady";
var ON_SHOW = "onShow";
var ON_HIDE = "onHide";
var OPTIONS = "options";
var EXTERNAL_CLASSES = "externalClasses";
var EVENT_CALLBACK_RESULT = "e_result";
var BEHAVIORS = "behaviors";
var A = "a";
var CONTEXT_ACTIONS;
(function(CONTEXT_ACTIONS2) {
    CONTEXT_ACTIONS2["INIT"] = "0";
    CONTEXT_ACTIONS2["RESTORE"] = "1";
    CONTEXT_ACTIONS2["RECOVER"] = "2";
    CONTEXT_ACTIONS2["DESTORY"] = "3";
})(CONTEXT_ACTIONS || (CONTEXT_ACTIONS = {}));
var observers = [];
var MutationObserverImpl = class {
    /**
   * Configures the MutationObserver
   * to begin receiving notifications
   * through its callback function
   * when DOM changes matching the given options occur.
   *
   * Options matching is to be implemented.
   */ observe(target, options2) {
        this.disconnect();
        this.target = target;
        this.options = options2 || {};
        observers.push(this);
    }
    /**
   * Stop the MutationObserver instance
   * from receiving further notifications
   * until and unless observe() is called again.
   */ disconnect() {
        this.target = null;
        const index = observers.indexOf(this);
        if (index >= 0) {
            observers.splice(index, 1);
        }
    }
    /**
   * Removes all pending notifications
   * from the MutationObserver's notification queue
   * and returns them in a new Array of MutationRecord objects.
   */ takeRecords() {
        return this.records.splice(0, this.records.length);
    }
    constructor(callback){
        this.records = [];
        this.callback = callback;
    }
};
var sidMatches = (observerTarget, target)=>{
    return !!observerTarget && observerTarget.sid === (target === null || target === void 0 ? void 0 : target.sid);
};
var isConcerned = (record, options2)=>{
    const { characterData, characterDataOldValue, attributes, attributeOldValue, childList } = options2;
    switch(record.type){
        case "characterData":
            if (characterData) {
                if (!characterDataOldValue) record.oldValue = null;
                return true;
            }
            return false;
        case "attributes":
            if (attributes) {
                if (!attributeOldValue) record.oldValue = null;
                return true;
            }
            return false;
        case "childList":
            if (childList) {
                return true;
            }
            return false;
    }
};
var pendingMuatations = false;
function logMutation(observer, record) {
    observer.records.push(record);
    if (!pendingMuatations) {
        pendingMuatations = true;
        Promise.resolve().then(()=>{
            pendingMuatations = false;
            observers.forEach((observer2)=>{
                return observer2.callback(observer2.takeRecords());
            });
        });
    }
}
function recordMutation(record) {
    observers.forEach((observer)=>{
        const { options: options2 } = observer;
        for(let t = record.target; t; t = t.parentNode){
            if (sidMatches(observer.target, t) && isConcerned(record, options2)) {
                logMutation(observer, record);
                break;
            }
            if (!options2.subtree) break;
        }
    });
}
var MutationObserver$1 = class MutationObserver2 {
    observe(...args) {
        this.core.observe(...args);
    }
    disconnect() {
        this.core.disconnect();
    }
    takeRecords() {
        return this.core.takeRecords();
    }
    static record(record) {
        recordMutation(record);
    }
    constructor(callback){
        if (ENABLE_MUTATION_OBSERVER) {
            this.core = new MutationObserverImpl(callback);
        } else {
            if (true) {
                console.warn("[Taro Warning] \u82E5\u8981\u4F7F\u7528 MutationObserver\uFF0C\u8BF7\u5728 Taro \u7F16\u8BD1\u914D\u7F6E\u4E2D\u8BBE\u7F6E 'mini.runtime.enableMutationObserver: true'");
            }
            this.core = {
                observe: noop,
                disconnect: noop,
                takeRecords: noop
            };
        }
    }
};
function throttle(fn, threshold = 250, scope) {
    let lastTime2 = 0;
    let deferTimer;
    return function(...args) {
        const context = scope || this;
        const now2 = Date.now();
        if (now2 - lastTime2 > threshold) {
            fn.apply(this, args);
            lastTime2 = now2;
        } else {
            clearTimeout(deferTimer);
            deferTimer = setTimeout(()=>{
                lastTime2 = now2;
                fn.apply(context, args);
            }, threshold);
        }
    };
}
var incrementId = ()=>{
    const chatCodes = [];
    for(let i = 65; i <= 90; i++){
        chatCodes.push(i);
    }
    for(let i = 97; i <= 122; i++){
        chatCodes.push(i);
    }
    const chatCodesLen = chatCodes.length - 1;
    const list = [
        0,
        0
    ];
    return ()=>{
        const target = list.map((item)=>chatCodes[item]);
        const res = String.fromCharCode(...target);
        let tailIdx = list.length - 1;
        list[tailIdx]++;
        while(list[tailIdx] > chatCodesLen){
            list[tailIdx] = 0;
            tailIdx = tailIdx - 1;
            if (tailIdx < 0) {
                list.push(0);
                break;
            }
            list[tailIdx]++;
        }
        return res;
    };
};
function isElement(node) {
    return node.nodeType === 1;
}
function isText(node) {
    return node.nodeType === 3;
}
function isComment(node) {
    return node.nodeName === COMMENT;
}
function isHasExtractProp(el) {
    const res = Object.keys(el.props).find((prop)=>{
        return !(/^(class|style|id)$/.test(prop) || prop.startsWith("data-"));
    });
    return Boolean(res);
}
function isParentBinded(node, type) {
    var _a1;
    while(node = (node === null || node === void 0 ? void 0 : node.parentElement) || null){
        if (!node || node.nodeName === ROOT_STR || node.nodeName === "root-portal") {
            return false;
        } else if ((_a1 = node.__handlers[type]) === null || _a1 === void 0 ? void 0 : _a1.length) {
            return true;
        }
    }
    return false;
}
function shortcutAttr(key) {
    switch(key){
        case STYLE:
            return "st";
        case ID:
            return UID;
        case CLASS:
            return "cl";
        default:
            return key;
    }
}
var customWrapperCache = /* @__PURE__ */ new Map();
function extend(ctor, methodName, options2) {
    if (isFunction(options2)) {
        options2 = {
            value: options2
        };
    }
    Object.defineProperty(ctor.prototype, methodName, Object.assign({
        configurable: true,
        enumerable: true
    }, options2));
}
var componentsAlias$1;
function getComponentsAlias2() {
    if (!componentsAlias$1) {
        componentsAlias$1 = getComponentsAlias(internalComponents);
    }
    return componentsAlias$1;
}
var ClassList = class {
    get value() {
        return this.toString();
    }
    get length() {
        return this.tokenList.length;
    }
    add() {
        let index = 0;
        let updated = false;
        const tokens = arguments;
        const length = tokens.length;
        const tokenList = this.tokenList;
        do {
            const token = tokens[index];
            if (this.checkTokenIsValid(token) && !~tokenList.indexOf(token)) {
                tokenList.push(token);
                updated = true;
            }
        }while (++index < length)
        if (updated) {
            this._update();
        }
    }
    remove() {
        let i = 0;
        let updated = false;
        const tokens = arguments;
        const length = tokens.length;
        const tokenList = this.tokenList;
        do {
            const token = tokens[i] + "";
            if (!this.checkTokenIsValid(token)) continue;
            const index = tokenList.indexOf(token);
            if (~tokenList.indexOf(token)) {
                tokenList.splice(index, 1);
                updated = true;
            }
        }while (++i < length)
        if (updated) {
            this._update();
        }
    }
    contains(token) {
        if (!this.checkTokenIsValid(token)) return false;
        return !!~this.tokenList.indexOf(token);
    }
    toggle(token, force) {
        const result = this.contains(token);
        const method = result ? force !== true && "remove" : force !== false && "add";
        if (method) {
            this[method](token);
        }
        if (force === true || force === false) {
            return force;
        } else {
            return !result;
        }
    }
    replace(token, replacement_token) {
        if (!this.checkTokenIsValid(token) || !this.checkTokenIsValid(replacement_token)) return;
        const index = this.tokenList.indexOf(token);
        if (~index) {
            this.tokenList.splice(index, 1, replacement_token);
            this._update();
        }
    }
    toString() {
        return this.tokenList.filter((v)=>v !== "").join(" ");
    }
    checkTokenIsValid(token) {
        if (token === "" || /\s/.test(token)) return false;
        return true;
    }
    _update() {
        this.el.className = this.value;
    }
    constructor(className, el){
        this.tokenList = [];
        this.el = el;
        className.trim().split(/\s+/).forEach((token)=>this.tokenList.push(token));
    }
};
var EventSource = class extends Map {
    removeNode(child) {
        const { sid, uid } = child;
        this.delete(sid);
        if (uid !== sid && uid) this.delete(uid);
    }
    removeNodeTree(child) {
        this.removeNode(child);
        const { childNodes } = child;
        childNodes.forEach((node)=>this.removeNodeTree(node));
    }
};
var eventSource = new EventSource();
var env = {
    window:  true ? window : 0,
    document:  true ? document : 0
};
var SPECIAL_NODES;
var componentsAlias;
function hydrate(node) {
    var _a1;
    componentsAlias || (componentsAlias = getComponentsAlias2());
    SPECIAL_NODES || (SPECIAL_NODES = hooks.call("getSpecialNodes"));
    const nodeName = node.nodeName;
    if (isText(node)) {
        return {
            sid: node.sid,
            ["v"]: node.nodeValue,
            ["nn"]: ((_a1 = componentsAlias[nodeName]) === null || _a1 === void 0 ? void 0 : _a1._num) || "8"
        };
    }
    const data = {
        ["nn"]: nodeName,
        sid: node.sid
    };
    if (node.uid !== node.sid) {
        data.uid = node.uid;
    }
    if (!node.isAnyEventBinded() && SPECIAL_NODES.indexOf(nodeName) > -1) {
        data["nn"] = `static-${nodeName}`;
        if (nodeName === VIEW && !isHasExtractProp(node)) {
            data["nn"] = PURE_VIEW;
        }
    }
    const { props } = node;
    for(const prop in props){
        const propInCamelCase = toCamelCase(prop);
        if (!prop.startsWith("data-") && // 在 node.dataset 的数据
        prop !== CLASS && prop !== STYLE && prop !== ID && propInCamelCase !== CATCHMOVE && propInCamelCase !== COMPILE_MODE) {
            data[propInCamelCase] = props[prop];
        }
        if (nodeName === VIEW && propInCamelCase === CATCHMOVE && props[prop] !== false) {
            data["nn"] = CATCH_VIEW;
        }
        if (propInCamelCase === COMPILE_MODE) {
            data["nn"] = props[prop];
        }
    }
    data["cn"] = node.childNodes.filter((node2)=>!isComment(node2)).map(hydrate);
    if (node.className !== "") {
        data["cl"] = node.className;
    }
    const cssText = node.cssText;
    if (cssText !== "" && nodeName !== "swiper-item") {
        data["st"] = cssText;
    }
    hooks.call("modifyHydrateData", data, node);
    const nn = data["nn"];
    const componentAlias = componentsAlias[nn];
    if (componentAlias) {
        data["nn"] = componentAlias._num;
        for(const prop in data){
            if (prop in componentAlias) {
                data[componentAlias[prop]] = data[prop];
                delete data[prop];
            }
        }
    }
    const resData = hooks.call("transferHydrateData", data, node, componentAlias);
    return resData || data;
}
var TaroEventTarget = class {
    addEventListener(type, handler, options2) {
        type = type.toLowerCase();
        hooks.call("onAddEvent", type, handler, options2, this);
        if (type === "regionchange") {
            this.addEventListener("begin", handler, options2);
            this.addEventListener("end", handler, options2);
            return;
        }
        let isCapture = Boolean(options2);
        let isOnce = false;
        if (isObject(options2)) {
            isCapture = Boolean(options2.capture);
            isOnce = Boolean(options2.once);
        }
        if (isOnce) {
            const wrapper = function() {
                handler.apply(this, arguments);
                this.removeEventListener(type, wrapper);
            };
            this.addEventListener(type, wrapper, Object.assign(Object.assign({}, options2), {
                once: false
            }));
            return;
        }
        warn(isCapture, "Taro \u6682\u672A\u5B9E\u73B0 event \u7684 capture \u7279\u6027\u3002");
        const oldHandler = handler;
        handler = function() {
            return oldHandler.apply(this, arguments);
        };
        handler.oldHandler = oldHandler;
        const handlers = this.__handlers[type];
        if (isArray(handlers)) {
            handlers.push(handler);
        } else {
            this.__handlers[type] = [
                handler
            ];
        }
    }
    removeEventListener(type, handler) {
        type = type.toLowerCase();
        if (type === "regionchange") {
            this.removeEventListener("begin", handler);
            this.removeEventListener("end", handler);
            return;
        }
        if (!handler) {
            return;
        }
        const handlers = this.__handlers[type];
        if (!isArray(handlers)) {
            return;
        }
        const index = handlers.findIndex((item)=>{
            if (item === handler || item.oldHandler === handler) return true;
        });
        warn(index === -1, `\u4E8B\u4EF6: '${type}' \u6CA1\u6709\u6CE8\u518C\u5728 DOM \u4E2D\uFF0C\u56E0\u6B64\u4E0D\u4F1A\u88AB\u79FB\u9664\u3002`);
        handlers.splice(index, 1);
    }
    isAnyEventBinded() {
        const handlers = this.__handlers;
        const isAnyEventBinded = Object.keys(handlers).find((key)=>handlers[key].length);
        return Boolean(isAnyEventBinded);
    }
    constructor(){
        this.__handlers = {};
    }
};
var CHILDNODES = "cn";
var nodeId = incrementId();
var TaroNode = class _TaroNode extends TaroEventTarget {
    updateChildNodes(isClean) {
        const cleanChildNodes = ()=>[];
        const rerenderChildNodes = ()=>{
            const childNodes = this.childNodes.filter((node)=>!isComment(node));
            return childNodes.map(hydrate);
        };
        this.enqueueUpdate({
            path: `${this._path}.${CHILDNODES}`,
            value: isClean ? cleanChildNodes : rerenderChildNodes
        });
    }
    updateSingleChild(index) {
        this.childNodes.forEach((child, childIndex)=>{
            if (isComment(child)) return;
            if (index && childIndex < index) return;
            this.enqueueUpdate({
                path: child._path,
                value: this.hydrate(child)
            });
        });
    }
    get _root() {
        var _a1;
        return ((_a1 = this.parentNode) === null || _a1 === void 0 ? void 0 : _a1._root) || null;
    }
    findIndex(refChild) {
        const index = this.childNodes.indexOf(refChild);
        ensure(index !== -1, "The node to be replaced is not a child of this node.");
        return index;
    }
    get _path() {
        const parentNode = this.parentNode;
        if (parentNode) {
            const list = parentNode.childNodes.filter((node)=>!isComment(node));
            const indexOfNode = list.indexOf(this);
            const index = hooks.call("getPathIndex", indexOfNode);
            return `${parentNode._path}.${CHILDNODES}.${index}`;
        }
        return "";
    }
    get nextSibling() {
        const parentNode = this.parentNode;
        return (parentNode === null || parentNode === void 0 ? void 0 : parentNode.childNodes[parentNode.findIndex(this) + 1]) || null;
    }
    get previousSibling() {
        const parentNode = this.parentNode;
        return (parentNode === null || parentNode === void 0 ? void 0 : parentNode.childNodes[parentNode.findIndex(this) - 1]) || null;
    }
    get parentElement() {
        const parentNode = this.parentNode;
        if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.nodeType) === 1) {
            return parentNode;
        }
        return null;
    }
    get firstChild() {
        return this.childNodes[0] || null;
    }
    get lastChild() {
        const childNodes = this.childNodes;
        return childNodes[childNodes.length - 1] || null;
    }
    /**
   * @textContent 目前只能置空子元素
   * @TODO 等待完整 innerHTML 实现
   */ // eslint-disable-next-line accessor-pairs
    set textContent(text) {
        const removedNodes = this.childNodes.slice();
        const addedNodes = [];
        while(this.firstChild){
            this.removeChild(this.firstChild, {
                doUpdate: false
            });
        }
        if (text === "") {
            this.updateChildNodes(true);
        } else {
            const newText = env.document.createTextNode(text);
            addedNodes.push(newText);
            this.appendChild(newText);
            this.updateChildNodes();
        }
        MutationObserver$1.record({
            type: "childList",
            target: this,
            removedNodes,
            addedNodes
        });
    }
    /**
   * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/insertBefore
   * @scenario
   * [A,B,C]
   *   1. insert D before C, D has no parent
   *   2. insert D before C, D has the same parent of C
   *   3. insert D before C, D has the different parent of C
   */ insertBefore(newChild, refChild, isReplace) {
        if (newChild.nodeName === DOCUMENT_FRAGMENT) {
            newChild.childNodes.reduceRight((previousValue, currentValue)=>{
                this.insertBefore(currentValue, previousValue);
                return currentValue;
            }, refChild);
            return newChild;
        }
        newChild.remove({
            cleanRef: false
        });
        let index = 0;
        newChild.parentNode = this;
        if (refChild) {
            index = this.findIndex(refChild);
            this.childNodes.splice(index, 0, newChild);
        } else {
            this.childNodes.push(newChild);
        }
        const childNodesLength = this.childNodes.length;
        if (this._root) {
            if (!refChild) {
                const isOnlyChild = childNodesLength === 1;
                if (isOnlyChild) {
                    this.updateChildNodes();
                } else {
                    this.enqueueUpdate({
                        path: newChild._path,
                        value: this.hydrate(newChild)
                    });
                }
            } else if (isReplace) {
                this.enqueueUpdate({
                    path: newChild._path,
                    value: this.hydrate(newChild)
                });
            } else {
                const mark = childNodesLength * 2 / 3;
                if (mark > index) {
                    this.updateChildNodes();
                } else {
                    this.updateSingleChild(index);
                }
            }
        }
        MutationObserver$1.record({
            type: "childList",
            target: this,
            addedNodes: [
                newChild
            ],
            removedNodes: isReplace ? [
                refChild
            ] : [],
            nextSibling: isReplace ? refChild.nextSibling : refChild || null,
            previousSibling: newChild.previousSibling
        });
        return newChild;
    }
    /**
   * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild
   * @scenario
   * [A,B,C]
   *   1. append C, C has no parent
   *   2. append C, C has the same parent of B
   *   3. append C, C has the different parent of B
   */ appendChild(newChild) {
        return this.insertBefore(newChild);
    }
    /**
   * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/replaceChild
   * @scenario
   * [A,B,C]
   *   1. replace B with C, C has no parent
   *   2. replace B with C, C has no parent, C has the same parent of B
   *   3. replace B with C, C has no parent, C has the different parent of B
   */ replaceChild(newChild, oldChild) {
        if (oldChild.parentNode !== this) return;
        this.insertBefore(newChild, oldChild, true);
        oldChild.remove({
            doUpdate: false
        });
        return oldChild;
    }
    /**
   * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/removeChild
   * @scenario
   * [A,B,C]
   *   1. remove A or B
   *   2. remove C
   */ removeChild(child, options2 = {}) {
        const { cleanRef, doUpdate } = options2;
        if (cleanRef !== false && doUpdate !== false) {
            MutationObserver$1.record({
                type: "childList",
                target: this,
                removedNodes: [
                    child
                ],
                nextSibling: child.nextSibling,
                previousSibling: child.previousSibling
            });
        }
        const index = this.findIndex(child);
        this.childNodes.splice(index, 1);
        child.parentNode = null;
        if (cleanRef !== false) {
            eventSource.removeNodeTree(child);
        }
        if (this._root && doUpdate !== false) {
            this.updateChildNodes();
        }
        return child;
    }
    remove(options2) {
        var _a1;
        (_a1 = this.parentNode) === null || _a1 === void 0 ? void 0 : _a1.removeChild(this, options2);
    }
    hasChildNodes() {
        return this.childNodes.length > 0;
    }
    enqueueUpdate(payload) {
        var _a1;
        (_a1 = this._root) === null || _a1 === void 0 ? void 0 : _a1.enqueueUpdate(payload);
    }
    get ownerDocument() {
        return env.document;
    }
    static extend(methodName, options2) {
        extend(_TaroNode, methodName, options2);
    }
    constructor(){
        super();
        this.parentNode = null;
        this.childNodes = [];
        this.hydrate = (node)=>()=>hydrate(node);
        this.uid = "_" + nodeId();
        this.sid = this.uid;
        eventSource.set(this.sid, this);
    }
};
var WEBKIT = "webkit";
var styleProperties = [
    "all",
    "appearance",
    "blockOverflow",
    "blockSize",
    "bottom",
    "clear",
    "contain",
    "content",
    "continue",
    "cursor",
    "direction",
    "display",
    "filter",
    "float",
    "gap",
    "height",
    "inset",
    "isolation",
    "left",
    "letterSpacing",
    "lightingColor",
    "markerSide",
    "mixBlendMode",
    "opacity",
    "order",
    "position",
    "quotes",
    "resize",
    "right",
    "rowGap",
    "tabSize",
    "tableLayout",
    "top",
    "userSelect",
    "verticalAlign",
    "visibility",
    "voiceFamily",
    "volume",
    "whiteSpace",
    "widows",
    "width",
    "zIndex",
    "pointerEvents",
    "aspectRatio"
];
function combine(prefix, list, excludeSelf) {
    !excludeSelf && styleProperties.push(prefix);
    list.forEach((item)=>{
        styleProperties.push(prefix + item);
        if (prefix === WEBKIT) {
            styleProperties.push("Webkit" + item);
        }
    });
}
var color = "Color";
var style = "Style";
var width = "Width";
var image = "Image";
var size = "Size";
var color_style_width = [
    color,
    style,
    width
];
var fitlength_fitwidth_image = [
    "FitLength",
    "FitWidth",
    image
];
var fitlength_fitwidth_image_radius = [
    ...fitlength_fitwidth_image,
    "Radius"
];
var color_style_width_fitlength_fitwidth_image = [
    ...color_style_width,
    ...fitlength_fitwidth_image
];
var endRadius_startRadius = [
    "EndRadius",
    "StartRadius"
];
var bottom_left_right_top = [
    "Bottom",
    "Left",
    "Right",
    "Top"
];
var end_start = [
    "End",
    "Start"
];
var content_items_self = [
    "Content",
    "Items",
    "Self"
];
var blockSize_height_inlineSize_width = [
    "BlockSize",
    "Height",
    "InlineSize",
    width
];
var after_before = [
    "After",
    "Before"
];
combine("borderBlock", color_style_width);
combine("borderBlockEnd", color_style_width);
combine("borderBlockStart", color_style_width);
combine("outline", [
    ...color_style_width,
    "Offset"
]);
combine("border", [
    ...color_style_width,
    "Boundary",
    "Break",
    "Collapse",
    "Radius",
    "Spacing"
]);
combine("borderFit", [
    "Length",
    width
]);
combine("borderInline", color_style_width);
combine("borderInlineEnd", color_style_width);
combine("borderInlineStart", color_style_width);
combine("borderLeft", color_style_width_fitlength_fitwidth_image);
combine("borderRight", color_style_width_fitlength_fitwidth_image);
combine("borderTop", color_style_width_fitlength_fitwidth_image);
combine("borderBottom", color_style_width_fitlength_fitwidth_image);
combine("textDecoration", [
    color,
    style,
    "Line"
]);
combine("textEmphasis", [
    color,
    style,
    "Position"
]);
combine("scrollMargin", bottom_left_right_top);
combine("scrollPadding", bottom_left_right_top);
combine("padding", bottom_left_right_top);
combine("margin", [
    ...bottom_left_right_top,
    "Trim"
]);
combine("scrollMarginBlock", end_start);
combine("scrollMarginInline", end_start);
combine("scrollPaddingBlock", end_start);
combine("scrollPaddingInline", end_start);
combine("gridColumn", end_start);
combine("gridRow", end_start);
combine("insetBlock", end_start);
combine("insetInline", end_start);
combine("marginBlock", end_start);
combine("marginInline", end_start);
combine("paddingBlock", end_start);
combine("paddingInline", end_start);
combine("pause", after_before);
combine("cue", after_before);
combine("mask", [
    "Clip",
    "Composite",
    image,
    "Mode",
    "Origin",
    "Position",
    "Repeat",
    size,
    "Type"
]);
combine("borderImage", [
    "Outset",
    "Repeat",
    "Slice",
    "Source",
    "Transform",
    width
]);
combine("maskBorder", [
    "Mode",
    "Outset",
    "Repeat",
    "Slice",
    "Source",
    width
]);
combine("font", [
    "Family",
    "FeatureSettings",
    "Kerning",
    "LanguageOverride",
    "MaxSize",
    "MinSize",
    "OpticalSizing",
    "Palette",
    size,
    "SizeAdjust",
    "Stretch",
    style,
    "Weight",
    "VariationSettings"
]);
combine("transform", [
    "Box",
    "Origin",
    style
]);
combine("background", [
    color,
    image,
    "Attachment",
    "BlendMode",
    "Clip",
    "Origin",
    "Position",
    "Repeat",
    size
]);
combine("listStyle", [
    image,
    "Position",
    "Type"
]);
combine("scrollSnap", [
    "Align",
    "Stop",
    "Type"
]);
combine("grid", [
    "Area",
    "AutoColumns",
    "AutoFlow",
    "AutoRows"
]);
combine("gridTemplate", [
    "Areas",
    "Columns",
    "Rows"
]);
combine("overflow", [
    "Block",
    "Inline",
    "Wrap",
    "X",
    "Y"
]);
combine("transition", [
    "Delay",
    "Duration",
    "Property",
    "TimingFunction"
]);
combine("color", [
    "Adjust",
    "InterpolationFilters",
    "Scheme"
]);
combine("textAlign", [
    "All",
    "Last"
]);
combine("page", [
    "BreakAfter",
    "BreakBefore",
    "BreakInside"
]);
combine("animation", [
    "Delay",
    "Direction",
    "Duration",
    "FillMode",
    "IterationCount",
    "Name",
    "PlayState",
    "TimingFunction"
]);
combine("flex", [
    "Basis",
    "Direction",
    "Flow",
    "Grow",
    "Shrink",
    "Wrap"
]);
combine("offset", [
    ...after_before,
    ...end_start,
    "Anchor",
    "Distance",
    "Path",
    "Position",
    "Rotate"
]);
combine("perspective", [
    "Origin"
]);
combine("clip", [
    "Path",
    "Rule"
]);
combine("flow", [
    "From",
    "Into"
]);
combine("align", [
    "Content",
    "Items",
    "Self"
], true);
combine("alignment", [
    "Adjust",
    "Baseline"
], true);
combine("borderStart", endRadius_startRadius, true);
combine("borderEnd", endRadius_startRadius, true);
combine("borderCorner", [
    "Fit",
    image,
    "ImageTransform"
], true);
combine("borderTopLeft", fitlength_fitwidth_image_radius, true);
combine("borderTopRight", fitlength_fitwidth_image_radius, true);
combine("borderBottomLeft", fitlength_fitwidth_image_radius, true);
combine("borderBottomRight", fitlength_fitwidth_image_radius, true);
combine("column", [
    "s",
    "Count",
    "Fill",
    "Gap",
    "Rule",
    "RuleColor",
    "RuleStyle",
    "RuleWidth",
    "Span",
    width
], true);
combine("break", [
    ...after_before,
    "Inside"
], true);
combine("wrap", [
    ...after_before,
    "Flow",
    "Inside",
    "Through"
], true);
combine("justify", content_items_self, true);
combine("place", content_items_self, true);
combine("max", [
    ...blockSize_height_inlineSize_width,
    "Lines"
], true);
combine("min", blockSize_height_inlineSize_width, true);
combine("line", [
    "Break",
    "Clamp",
    "Grid",
    "Height",
    "Padding",
    "Snap"
], true);
combine("inline", [
    "BoxAlign",
    size,
    "Sizing"
], true);
combine("text", [
    "CombineUpright",
    "GroupAlign",
    "Height",
    "Indent",
    "Justify",
    "Orientation",
    "Overflow",
    "Shadow",
    "SpaceCollapse",
    "SpaceTrim",
    "Spacing",
    "Transform",
    "UnderlinePosition",
    "Wrap"
], true);
combine("shape", [
    "ImageThreshold",
    "Inside",
    "Margin",
    "Outside"
], true);
combine("word", [
    "Break",
    "Spacing",
    "Wrap"
], true);
combine("object", [
    "Fit",
    "Position"
], true);
combine("box", [
    "DecorationBreak",
    "Shadow",
    "Sizing",
    "Snap"
], true);
combine(WEBKIT, [
    "LineClamp",
    "BoxOrient",
    "TextFillColor",
    "TextStroke",
    "TextStrokeColor",
    "TextStrokeWidth"
], true);
function recordCss(obj) {
    MutationObserver$1.record({
        type: "attributes",
        target: obj._element,
        attributeName: "style",
        oldValue: obj.cssText
    });
}
function enqueueUpdate(obj) {
    const element = obj._element;
    if (element._root) {
        element.enqueueUpdate({
            path: `${element._path}.${"st"}`,
            value: obj.cssText
        });
    }
}
function setStyle(newVal, styleKey) {
    warn(isString(newVal) && newVal.length > PROPERTY_THRESHOLD, `Style \u5C5E\u6027 ${styleKey} \u7684\u503C\u6570\u636E\u91CF\u8FC7\u5927\uFF0C\u53EF\u80FD\u4F1A\u5F71\u54CD\u6E32\u67D3\u6027\u80FD\uFF0C\u8003\u8651\u4F7F\u7528 CSS \u7C7B\u6216\u5176\u5B83\u65B9\u6848\u66FF\u4EE3\u3002`);
    const old = this[styleKey];
    if (old === newVal) return;
    !this._pending && recordCss(this);
    if (isNull(newVal) || isUndefined(newVal) || newVal === "") {
        this._usedStyleProp.delete(styleKey);
        delete this._value[styleKey];
    } else {
        this._usedStyleProp.add(styleKey);
        this._value[styleKey] = newVal;
    }
    !this._pending && enqueueUpdate(this);
}
function initStyle(ctor, styleProperties2) {
    const properties = {};
    for(let i = 0; i < styleProperties2.length; i++){
        const styleKey = styleProperties2[i];
        if (ctor[styleKey]) return;
        properties[styleKey] = {
            get () {
                const val = this._value[styleKey];
                return isNull(val) || isUndefined(val) ? "" : val;
            },
            set (newVal) {
                setStyle.call(this, newVal, styleKey);
            }
        };
    }
    Object.defineProperties(ctor.prototype, properties);
}
function isCssVariable(propertyName) {
    return /^--/.test(propertyName);
}
var Style = class {
    setCssVariables(styleKey) {
        this.hasOwnProperty(styleKey) || Object.defineProperty(this, styleKey, {
            enumerable: true,
            configurable: true,
            get: ()=>{
                return this._value[styleKey] || "";
            },
            set: (newVal)=>{
                setStyle.call(this, newVal, styleKey);
            }
        });
    }
    get cssText() {
        if (!this._usedStyleProp.size) return "";
        const texts = [];
        this._usedStyleProp.forEach((key)=>{
            const val = this[key];
            if (isNull(val) || isUndefined(val)) return;
            let styleName = isCssVariable(key) ? key : toDashed(key);
            if (styleName.indexOf("webkit") === 0 || styleName.indexOf("Webkit") === 0) {
                styleName = `-${styleName}`;
            }
            texts.push(`${styleName}: ${val};`);
        });
        return texts.join(" ");
    }
    set cssText(str) {
        this._pending = true;
        recordCss(this);
        this._usedStyleProp.forEach((prop)=>{
            this.removeProperty(prop);
        });
        if (str === "" || isUndefined(str) || isNull(str)) {
            this._pending = false;
            enqueueUpdate(this);
            return;
        }
        const rules = str.split(";");
        for(let i = 0; i < rules.length; i++){
            const rule = rules[i].trim();
            if (rule === "") {
                continue;
            }
            const [propName, ...valList] = rule.split(":");
            const val = valList.join(":");
            if (isUndefined(val)) {
                continue;
            }
            this.setProperty(propName.trim(), val.trim());
        }
        this._pending = false;
        enqueueUpdate(this);
    }
    setProperty(propertyName, value) {
        if (propertyName[0] === "-") {
            this.setCssVariables(propertyName);
        } else {
            propertyName = toCamelCase(propertyName);
        }
        if (isNull(value) || isUndefined(value)) {
            this.removeProperty(propertyName);
        } else {
            this[propertyName] = value;
        }
    }
    removeProperty(propertyName) {
        propertyName = toCamelCase(propertyName);
        if (!this._usedStyleProp.has(propertyName)) {
            return "";
        }
        const value = this[propertyName];
        this[propertyName] = void 0;
        return value;
    }
    getPropertyValue(propertyName) {
        propertyName = toCamelCase(propertyName);
        const value = this[propertyName];
        if (!value) {
            return "";
        }
        return value;
    }
    constructor(element){
        this._element = element;
        this._usedStyleProp = /* @__PURE__ */ new Set();
        this._value = {};
    }
};
initStyle(Style, styleProperties);
hooks.tap("injectNewStyleProperties", (newStyleProperties)=>{
    if (isArray(newStyleProperties)) {
        initStyle(Style, newStyleProperties);
    } else {
        if (typeof newStyleProperties !== "string") return;
        initStyle(Style, [
            newStyleProperties
        ]);
    }
});
function returnTrue() {
    return true;
}
function treeToArray(root, predict) {
    const array = [];
    const filter = predict !== null && predict !== void 0 ? predict : returnTrue;
    let object = root;
    while(object){
        if (object.nodeType === 1 && filter(object)) {
            array.push(object);
        }
        object = following(object, root);
    }
    return array;
}
function following(el, root) {
    const firstChild = el.firstChild;
    const isElmentTypeValid = el.nodeType === 1 || el.nodeType === 9;
    if (firstChild && isElmentTypeValid) {
        return firstChild;
    }
    let current = el;
    do {
        if (current === root) {
            return null;
        }
        const nextSibling = current.nextSibling;
        if (nextSibling) {
            return nextSibling;
        }
        current = current.parentElement;
    }while (current)
    return null;
}
var TaroElement = class _TaroElement extends TaroNode {
    _stopPropagation(event) {
        let target = this;
        while(target = target.parentNode){
            const listeners = target.__handlers[event.type];
            if (!isArray(listeners)) {
                continue;
            }
            for(let i = listeners.length; i--;){
                const l = listeners[i];
                l._stop = true;
            }
        }
    }
    get id() {
        return this.getAttribute(ID);
    }
    set id(val) {
        this.setAttribute(ID, val);
    }
    get className() {
        return this.getAttribute(CLASS) || "";
    }
    set className(val) {
        this.setAttribute(CLASS, val);
    }
    get cssText() {
        return this.getAttribute(STYLE) || "";
    }
    get classList() {
        return new ClassList(this.className, this);
    }
    get children() {
        return this.childNodes.filter(isElement);
    }
    get attributes() {
        const props = this.props;
        const propKeys = Object.keys(props);
        const style2 = this.style.cssText;
        const attrs = propKeys.map((key)=>({
                name: key,
                value: props[key]
            }));
        return attrs.concat(style2 ? {
            name: STYLE,
            value: style2
        } : []);
    }
    get textContent() {
        let text = "";
        const childNodes = this.childNodes;
        for(let i = 0; i < childNodes.length; i++){
            text += childNodes[i].textContent;
        }
        return text;
    }
    set textContent(text) {
        super.textContent = text;
    }
    hasAttribute(qualifiedName) {
        return !isUndefined(this.props[qualifiedName]);
    }
    hasAttributes() {
        return this.attributes.length > 0;
    }
    get focus() {
        return function() {
            this.setAttribute(FOCUS, true);
        };
    }
    // 兼容 Vue3，详情请见：https://github.com/NervJS/taro/issues/10579
    set focus(value) {
        this.setAttribute(FOCUS, value);
    }
    blur() {
        this.setAttribute(FOCUS, false);
    }
    setAttribute(qualifiedName, value) {
        warn(isString(value) && value.length > PROPERTY_THRESHOLD, `\u5143\u7D20 ${this.nodeName} \u7684 ${qualifiedName} \u5C5E\u6027\u503C\u6570\u636E\u91CF\u8FC7\u5927\uFF0C\u53EF\u80FD\u4F1A\u5F71\u54CD\u6E32\u67D3\u6027\u80FD\u3002\u8003\u8651\u964D\u4F4E\u56FE\u7247\u8F6C\u4E3A base64 \u7684\u9608\u503C\u6216\u5728 CSS \u4E2D\u4F7F\u7528 base64\u3002`);
        const isPureView = this.nodeName === VIEW && !isHasExtractProp(this) && !this.isAnyEventBinded();
        if (qualifiedName !== STYLE) {
            MutationObserver$1.record({
                target: this,
                type: "attributes",
                attributeName: qualifiedName,
                oldValue: this.getAttribute(qualifiedName)
            });
        }
        switch(qualifiedName){
            case STYLE:
                this.style.cssText = value;
                break;
            case ID:
                if (this.uid !== this.sid) {
                    eventSource.delete(this.uid);
                }
                value = String(value);
                this.props[qualifiedName] = this.uid = value;
                eventSource.set(value, this);
                break;
            default:
                this.props[qualifiedName] = value;
                if (qualifiedName.startsWith("data-")) {
                    if (this.dataset === EMPTY_OBJ) {
                        this.dataset = /* @__PURE__ */ Object.create(null);
                    }
                    this.dataset[toCamelCase(qualifiedName.replace(/^data-/, ""))] = value;
                }
                break;
        }
        if (!this._root) return;
        const componentsAlias2 = getComponentsAlias2();
        const _alias = componentsAlias2[this.nodeName];
        const viewAlias = componentsAlias2[VIEW]._num;
        const staticViewAlias = componentsAlias2[STATIC_VIEW]._num;
        const catchViewAlias = componentsAlias2[CATCH_VIEW]._num;
        const _path = this._path;
        qualifiedName = shortcutAttr(qualifiedName);
        const qualifiedNameInCamelCase = toCamelCase(qualifiedName);
        const payload = {
            path: `${_path}.${qualifiedNameInCamelCase}`,
            value: isFunction(value) ? ()=>value : value
        };
        hooks.call("modifySetAttrPayload", this, qualifiedName, payload, componentsAlias2);
        if (_alias) {
            const qualifiedNameAlias = _alias[qualifiedNameInCamelCase] || qualifiedName;
            payload.path = `${_path}.${toCamelCase(qualifiedNameAlias)}`;
        }
        this.enqueueUpdate(payload);
        if (this.nodeName === VIEW) {
            if (qualifiedNameInCamelCase === CATCHMOVE) {
                this.enqueueUpdate({
                    path: `${_path}.${"nn"}`,
                    value: value ? catchViewAlias : this.isAnyEventBinded() ? viewAlias : staticViewAlias
                });
            } else if (isPureView && isHasExtractProp(this)) {
                this.enqueueUpdate({
                    path: `${_path}.${"nn"}`,
                    value: staticViewAlias
                });
            }
        }
    }
    removeAttribute(qualifiedName) {
        const isStaticView = this.nodeName === VIEW && isHasExtractProp(this) && !this.isAnyEventBinded();
        MutationObserver$1.record({
            target: this,
            type: "attributes",
            attributeName: qualifiedName,
            oldValue: this.getAttribute(qualifiedName)
        });
        if (qualifiedName === STYLE) {
            this.style.cssText = "";
        } else {
            const isInterrupt = hooks.call("onRemoveAttribute", this, qualifiedName);
            if (isInterrupt) {
                return;
            }
            if (!this.props.hasOwnProperty(qualifiedName)) {
                return;
            }
            delete this.props[qualifiedName];
        }
        if (!this._root) return;
        const componentsAlias2 = getComponentsAlias2();
        const _alias = componentsAlias2[this.nodeName];
        const viewAlias = componentsAlias2[VIEW]._num;
        const staticViewAlias = componentsAlias2[STATIC_VIEW]._num;
        const pureViewAlias = componentsAlias2[PURE_VIEW]._num;
        const _path = this._path;
        qualifiedName = shortcutAttr(qualifiedName);
        const qualifiedNameInCamelCase = toCamelCase(qualifiedName);
        const payload = {
            path: `${_path}.${qualifiedNameInCamelCase}`,
            value: ""
        };
        hooks.call("modifyRmAttrPayload", this, qualifiedName, payload, componentsAlias2);
        if (_alias) {
            const qualifiedNameAlias = _alias[qualifiedNameInCamelCase] || qualifiedName;
            payload.path = `${_path}.${toCamelCase(qualifiedNameAlias)}`;
        }
        this.enqueueUpdate(payload);
        if (this.nodeName === VIEW) {
            if (qualifiedNameInCamelCase === CATCHMOVE) {
                this.enqueueUpdate({
                    path: `${_path}.${"nn"}`,
                    value: this.isAnyEventBinded() ? viewAlias : isHasExtractProp(this) ? staticViewAlias : pureViewAlias
                });
            } else if (isStaticView && !isHasExtractProp(this)) {
                this.enqueueUpdate({
                    path: `${_path}.${"nn"}`,
                    value: pureViewAlias
                });
            }
        }
    }
    getAttribute(qualifiedName) {
        const attr = qualifiedName === STYLE ? this.style.cssText : this.props[qualifiedName];
        return attr !== null && attr !== void 0 ? attr : "";
    }
    getElementsByTagName(tagName) {
        return treeToArray(this, (el)=>{
            return el.nodeName === tagName || tagName === "*" && this !== el;
        });
    }
    getElementsByClassName(className) {
        const classNames = className.trim().split(/\s+/);
        return treeToArray(this, (el)=>{
            const classList = el.classList;
            return classNames.every((c)=>classList.contains(c));
        });
    }
    dispatchEvent(event) {
        const cancelable = event.cancelable;
        const listeners = this.__handlers[event.type];
        if (!isArray(listeners)) {
            return false;
        }
        for(let i = listeners.length; i--;){
            const listener = listeners[i];
            let result;
            if (listener._stop) {
                listener._stop = false;
            } else {
                hooks.call("modifyDispatchEvent", event, this);
                result = listener.call(this, event);
            }
            if ((result === false || event._end) && cancelable) {
                event.defaultPrevented = true;
            }
            if (!isUndefined(result) && event.mpEvent) {
                const res = hooks.call("modifyTaroEventReturn", this, event, result);
                if (res) {
                    event.mpEvent[EVENT_CALLBACK_RESULT] = result;
                }
            }
            if (event._end && event._stop) {
                break;
            }
        }
        if (event._stop) {
            this._stopPropagation(event);
        } else {
            event._stop = true;
        }
        return listeners != null;
    }
    addEventListener(type, handler, options2) {
        const name = this.nodeName;
        const SPECIAL_NODES2 = hooks.call("getSpecialNodes");
        let sideEffect = true;
        if (isObject(options2) && options2.sideEffect === false) {
            sideEffect = false;
            delete options2.sideEffect;
        }
        hooks.call("modifyAddEventListener", this, sideEffect, getComponentsAlias2);
        if (sideEffect !== false && !this.isAnyEventBinded() && SPECIAL_NODES2.indexOf(name) > -1) {
            const componentsAlias2 = getComponentsAlias2();
            const alias = componentsAlias2[name]._num;
            this.enqueueUpdate({
                path: `${this._path}.${"nn"}`,
                value: alias
            });
        }
        super.addEventListener(type, handler, options2);
    }
    removeEventListener(type, handler, sideEffect = true) {
        super.removeEventListener(type, handler);
        const name = this.nodeName;
        const SPECIAL_NODES2 = hooks.call("getSpecialNodes");
        hooks.call("modifyRemoveEventListener", this, sideEffect, getComponentsAlias2);
        if (sideEffect !== false && !this.isAnyEventBinded() && SPECIAL_NODES2.indexOf(name) > -1) {
            const componentsAlias2 = getComponentsAlias2();
            const value = isHasExtractProp(this) ? `static-${name}` : `pure-${name}`;
            const valueAlias = componentsAlias2[value]._num;
            this.enqueueUpdate({
                path: `${this._path}.${"nn"}`,
                value: valueAlias
            });
        }
    }
    static extend(methodName, options2) {
        extend(_TaroElement, methodName, options2);
    }
    constructor(){
        super();
        this.props = {};
        this.dataset = EMPTY_OBJ;
        this.nodeType = 1;
        this.style = new Style(this);
        hooks.call("patchElement", this);
    }
};
var options = {
    prerender: true,
    debug: false
};
function makeMap(str, expectsLowerCase) {
    const map = /* @__PURE__ */ Object.create(null);
    const list = str.split(",");
    for(let i = 0; i < list.length; i++){
        map[list[i]] = true;
    }
    return expectsLowerCase ? (val)=>!!map[val.toLowerCase()] : (val)=>!!map[val];
}
var internalCompsList = Object.keys(internalComponents).map((i)=>i.toLowerCase()).join(",");
var isMiniElements = makeMap(internalCompsList, true);
var isInlineElements = makeMap("a,i,abbr,iframe,select,acronym,slot,small,span,bdi,kbd,strong,big,map,sub,sup,br,mark,mark,meter,template,canvas,textarea,cite,object,time,code,output,u,data,picture,tt,datalist,var,dfn,del,q,em,s,embed,samp,b", true);
var isBlockElements = makeMap("address,fieldset,li,article,figcaption,main,aside,figure,nav,blockquote,footer,ol,details,form,p,dialog,h1,h2,h3,h4,h5,h6,pre,dd,header,section,div,hgroup,table,dl,hr,ul,dt", true);
options.html = {
    skipElements: /* @__PURE__ */ new Set([
        "style",
        "script"
    ]),
    voidElements: /* @__PURE__ */ new Set([
        "!doctype",
        "area",
        "base",
        "br",
        "col",
        "command",
        "embed",
        "hr",
        "img",
        "input",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
    ]),
    closingElements: /* @__PURE__ */ new Set([
        "html",
        "head",
        "body",
        "p",
        "dt",
        "dd",
        "li",
        "option",
        "thead",
        "th",
        "tbody",
        "tr",
        "td",
        "tfoot",
        "colgroup"
    ]),
    renderHTMLTag: false
};
if (false) {}
var TaroEvent = class {
    stopPropagation() {
        this._stop = true;
    }
    stopImmediatePropagation() {
        this._end = this._stop = true;
    }
    preventDefault() {
        this.defaultPrevented = true;
    }
    get target() {
        var _a1, _b, _c, _d;
        const cacheTarget = this.cacheTarget;
        if (!cacheTarget) {
            const target = Object.create(((_a1 = this.mpEvent) === null || _a1 === void 0 ? void 0 : _a1.target) || null);
            const element = env.document.getElementById(((_b = target.targetDataset) === null || _b === void 0 ? void 0 : _b.sid) || ((_c = target.dataset) === null || _c === void 0 ? void 0 : _c.sid) || target.id || null);
            target.dataset = element !== null ? element.dataset : EMPTY_OBJ;
            for(const key in (_d = this.mpEvent) === null || _d === void 0 ? void 0 : _d.detail){
                target[key] = this.mpEvent.detail[key];
            }
            this.cacheTarget = target;
            return target;
        } else {
            return cacheTarget;
        }
    }
    get currentTarget() {
        var _a1, _b, _c, _d, _e, _f, _g, _h;
        const cacheCurrentTarget = this.cacheCurrentTarget;
        if (!cacheCurrentTarget) {
            const doc = env.document;
            const currentTarget = Object.create(((_a1 = this.mpEvent) === null || _a1 === void 0 ? void 0 : _a1.currentTarget) || null);
            const element = doc.getElementById(((_b = currentTarget.dataset) === null || _b === void 0 ? void 0 : _b.sid) || currentTarget.id || null);
            const targetElement = doc.getElementById(((_e = (_d = (_c = this.mpEvent) === null || _c === void 0 ? void 0 : _c.target) === null || _d === void 0 ? void 0 : _d.dataset) === null || _e === void 0 ? void 0 : _e.sid) || ((_g = (_f = this.mpEvent) === null || _f === void 0 ? void 0 : _f.target) === null || _g === void 0 ? void 0 : _g.id) || null);
            if (element === null || element && element === targetElement) {
                this.cacheCurrentTarget = this.target;
                return this.target;
            }
            currentTarget.dataset = element.dataset;
            for(const key in (_h = this.mpEvent) === null || _h === void 0 ? void 0 : _h.detail){
                currentTarget[key] = this.mpEvent.detail[key];
            }
            this.cacheCurrentTarget = currentTarget;
            return currentTarget;
        } else {
            return cacheCurrentTarget;
        }
    }
    constructor(type, opts, event){
        this._stop = false;
        this._end = false;
        this.defaultPrevented = false;
        this.button = 0;
        this.timeStamp = Date.now();
        this.type = type.toLowerCase();
        this.mpEvent = event;
        this.bubbles = Boolean(opts && opts.bubbles);
        this.cancelable = Boolean(opts && opts.cancelable);
    }
};
function createEvent(event, node) {
    if (typeof event === "string") {
        return new TaroEvent(event, {
            bubbles: true,
            cancelable: true
        });
    }
    const domEv = new TaroEvent(event.type, {
        bubbles: true,
        cancelable: true
    }, event);
    for(const key in event){
        if (key === CURRENT_TARGET || key === TARGET || key === TYPE || key === TIME_STAMP) {
            continue;
        } else {
            domEv[key] = event[key];
        }
    }
    if (domEv.type === CONFIRM && (node === null || node === void 0 ? void 0 : node.nodeName) === INPUT) {
        domEv[KEY_CODE] = 13;
    }
    return domEv;
}
var eventsBatch = {};
function getEventCBResult(event) {
    const result = event[EVENT_CALLBACK_RESULT];
    if (!isUndefined(result)) {
        delete event[EVENT_CALLBACK_RESULT];
    }
    return result;
}
function eventHandler(event) {
    var _a1, _b;
    event.type === void 0 && Object.defineProperty(event, "type", {
        value: event._type
    });
    event.detail === void 0 && Object.defineProperty(event, "detail", {
        value: event._detail || Object.assign({}, event)
    });
    event.currentTarget = event.currentTarget || event.target || Object.assign({}, event);
    hooks.call("modifyMpEventImpl", event);
    const currentTarget = event.currentTarget;
    const id = ((_a1 = currentTarget.dataset) === null || _a1 === void 0 ? void 0 : _a1.sid) || currentTarget.id || ((_b = event.detail) === null || _b === void 0 ? void 0 : _b.id) || "";
    const node = env.document.getElementById(id);
    if (node) {
        const dispatch = ()=>{
            const e = createEvent(event, node);
            hooks.call("modifyTaroEvent", e, node);
            hooks.call("dispatchTaroEvent", e, node);
            hooks.call("dispatchTaroEventFinish", e, node);
        };
        if (hooks.isExist("batchedEventUpdates")) {
            const type = event.type;
            if (!hooks.call("isBubbleEvents", type) || !isParentBinded(node, type) || type === TOUCHMOVE && !!node.props.catchMove) {
                hooks.call("batchedEventUpdates", ()=>{
                    if (eventsBatch[type]) {
                        eventsBatch[type].forEach((fn)=>fn());
                        delete eventsBatch[type];
                    }
                    dispatch();
                });
                return getEventCBResult(event);
            } else {
                (eventsBatch[type] || (eventsBatch[type] = [])).push(dispatch);
            }
        } else {
            dispatch();
            return getEventCBResult(event);
        }
    }
}
var FormElement = class extends TaroElement {
    get type() {
        var _a1;
        return (_a1 = this.props[TYPE]) !== null && _a1 !== void 0 ? _a1 : "";
    }
    set type(val) {
        this.setAttribute(TYPE, val);
    }
    get value() {
        const val = this.props[VALUE];
        return val == null ? "" : val;
    }
    set value(val) {
        this.setAttribute(VALUE, val);
    }
    dispatchEvent(event) {
        if (event.mpEvent) {
            const val = event.mpEvent.detail.value;
            if (event.type === CHANGE) {
                this.props.value = val;
            } else if (event.type === INPUT) {
                this.value = val;
            }
        }
        return super.dispatchEvent(event);
    }
};
var Performance = class {
    start(id) {
        if (!options.debug) {
            return;
        }
        this.recorder.set(id, Date.now());
    }
    stop(id) {
        if (!options.debug) {
            return;
        }
        const now2 = Date.now();
        const prev = this.recorder.get(id);
        this.recorder.delete(id);
        const time = now2 - prev;
        console.log(`${id} \u65F6\u957F\uFF1A ${time}ms`);
    }
    constructor(){
        this.recorder = /* @__PURE__ */ new Map();
    }
};
var perf = new Performance();
function findCustomWrapper(root, dataPathArr) {
    const list = dataPathArr.slice(1);
    let currentData = root;
    let customWrapper;
    let splitedPath = "";
    list.some((item, i)=>{
        const key = item.replace(/^\[(.+)\]$/, "$1").replace(/\bcn\b/g, "childNodes");
        currentData = currentData[key];
        if (isArray(currentData)) {
            currentData = currentData.filter((el)=>!isComment(el));
        }
        if (isUndefined(currentData)) return true;
        if (currentData.nodeName === CUSTOM_WRAPPER) {
            const res = customWrapperCache.get(currentData.sid);
            if (res) {
                customWrapper = res;
                splitedPath = dataPathArr.slice(i + 2).join(".");
            }
        }
    });
    if (customWrapper) {
        return {
            customWrapper,
            splitedPath
        };
    }
}
var TaroRootElement = class extends TaroElement {
    get _path() {
        return ROOT_STR;
    }
    get _root() {
        return this;
    }
    enqueueUpdate(payload) {
        this.updatePayloads.push(payload);
        if (!this.pendingUpdate && this.ctx) {
            this.performUpdate();
        }
    }
    performUpdate(initRender = false, prerender) {
        this.pendingUpdate = true;
        const ctx = hooks.call("proxyToRaw", this.ctx);
        setTimeout(()=>{
            const setDataMark = `${SET_DATA} \u5F00\u59CB\u65F6\u95F4\u6233 ${Date.now()}`;
            perf.start(setDataMark);
            const data = /* @__PURE__ */ Object.create(null);
            const resetPaths = new Set(initRender ? [
                "root.cn.[0]",
                "root.cn[0]"
            ] : []);
            while(this.updatePayloads.length > 0){
                const { path, value } = this.updatePayloads.shift();
                if (path.endsWith("cn")) {
                    resetPaths.add(path);
                }
                data[path] = value;
            }
            for(const path in data){
                resetPaths.forEach((p)=>{
                    if (path.includes(p) && path !== p) {
                        delete data[path];
                    }
                });
                const value = data[path];
                if (isFunction(value)) {
                    data[path] = value();
                }
            }
            if (isFunction(prerender)) return prerender(data);
            this.pendingUpdate = false;
            let normalUpdate = {};
            const customWrapperMap = /* @__PURE__ */ new Map();
            if (initRender) {
                normalUpdate = data;
            } else {
                for(const p in data){
                    const dataPathArr = p.split(".");
                    const found = findCustomWrapper(this, dataPathArr);
                    if (found) {
                        const { customWrapper, splitedPath } = found;
                        customWrapperMap.set(customWrapper, Object.assign(Object.assign({}, customWrapperMap.get(customWrapper) || {}), {
                            [`i.${splitedPath}`]: data[p]
                        }));
                    } else {
                        normalUpdate[p] = data[p];
                    }
                }
            }
            const customWrapperCount = customWrapperMap.size;
            const isNeedNormalUpdate = Object.keys(normalUpdate).length > 0;
            const updateArrLen = customWrapperCount + (isNeedNormalUpdate ? 1 : 0);
            let executeTime = 0;
            const cb = ()=>{
                if (++executeTime === updateArrLen) {
                    perf.stop(setDataMark);
                    this.flushUpdateCallback();
                    initRender && perf.stop(PAGE_INIT);
                }
            };
            if (customWrapperCount) {
                customWrapperMap.forEach((data2, ctx2)=>{
                    if (options.debug) {
                        console.log("custom wrapper setData: ", data2);
                    }
                    ctx2.setData(data2, cb);
                });
            }
            if (isNeedNormalUpdate) {
                if (options.debug) {
                    console.log("page setData:", normalUpdate);
                }
                ctx.setData(normalUpdate, cb);
            }
        }, 0);
    }
    enqueueUpdateCallback(cb, ctx) {
        this.updateCallbacks.push(()=>{
            ctx ? cb.call(ctx) : cb();
        });
    }
    flushUpdateCallback() {
        const updateCallbacks = this.updateCallbacks;
        if (!updateCallbacks.length) return;
        const copies = updateCallbacks.slice(0);
        this.updateCallbacks.length = 0;
        for(let i = 0; i < copies.length; i++){
            copies[i]();
        }
    }
    constructor(){
        super();
        this.updatePayloads = [];
        this.updateCallbacks = [];
        this.pendingUpdate = false;
        this.ctx = null;
        this.nodeName = ROOT_STR;
        this.tagName = ROOT_STR.toUpperCase();
    }
};
var TaroText = class extends TaroNode {
    set textContent(text) {
        MutationObserver$1.record({
            target: this,
            type: "characterData",
            oldValue: this._value
        });
        this._value = text;
        this.enqueueUpdate({
            path: `${this._path}.${"v"}`,
            value: text
        });
    }
    get textContent() {
        return this._value;
    }
    set nodeValue(text) {
        this.textContent = text;
    }
    get nodeValue() {
        return this._value;
    }
    set data(text) {
        this.textContent = text;
    }
    get data() {
        return this._value;
    }
    constructor(value){
        super();
        this.nodeType = 3;
        this.nodeName = "#text";
        this._value = value;
    }
};
var URLSearchParams =  true ? env.window.URLSearchParams : (0);
var _TaroURL_hash;
var _TaroURL_hostname;
var _TaroURL_pathname;
var _TaroURL_port;
var _TaroURL_protocol;
var _TaroURL_search;
_TaroURL_hash = /* @__PURE__ */ new WeakMap(), _TaroURL_hostname = /* @__PURE__ */ new WeakMap(), _TaroURL_pathname = /* @__PURE__ */ new WeakMap(), _TaroURL_port = /* @__PURE__ */ new WeakMap(), _TaroURL_protocol = /* @__PURE__ */ new WeakMap(), _TaroURL_search = /* @__PURE__ */ new WeakMap();
var URL =  true ? env.window.URL : 0;
function parseUrl(url = "") {
    const result = {
        href: "",
        origin: "",
        protocol: "",
        hostname: "",
        host: "",
        port: "",
        pathname: "",
        search: "",
        hash: ""
    };
    if (!url || !isString(url)) return result;
    url = url.trim();
    const PATTERN = /^(([^:/?#]+):)?\/\/(([^/?#]+):(.+)@)?([^/?#:]*)(:(\d+))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    const matches = url.match(PATTERN);
    if (!matches) return result;
    result.protocol = matches[1] || "https:";
    result.hostname = matches[6] || "taro.com";
    result.port = matches[8] || "";
    result.pathname = matches[9] || "/";
    result.search = matches[10] || "";
    result.hash = matches[12] || "";
    result.href = url;
    result.origin = result.protocol + "//" + result.hostname;
    result.host = result.hostname + (result.port ? `:${result.port}` : "");
    return result;
}
var document$1 =  true ? env.document : 0;
var getComputedStyle =  true ? env.window.getComputedStyle : 0;
var eventCenter = hooks.call("getEventCenter", Events);
var RuntimeCache = class {
    has(identifier) {
        return this.cache.has(identifier);
    }
    set(identifier, ctx) {
        if (identifier && ctx) {
            this.cache.set(identifier, ctx);
        }
    }
    get(identifier) {
        if (this.has(identifier)) return this.cache.get(identifier);
    }
    delete(identifier) {
        this.cache.delete(identifier);
    }
    constructor(name){
        this.cache = /* @__PURE__ */ new Map();
        this.name = name;
    }
};
var _TaroHistory_instances;
var _TaroHistory_location;
var _TaroHistory_stack;
var _TaroHistory_cur;
var _TaroHistory_window;
var _TaroHistory_reset;
var cache$1 = new RuntimeCache("history");
_TaroHistory_location = /* @__PURE__ */ new WeakMap(), _TaroHistory_stack = /* @__PURE__ */ new WeakMap(), _TaroHistory_cur = /* @__PURE__ */ new WeakMap(), _TaroHistory_window = /* @__PURE__ */ new WeakMap(), _TaroHistory_instances = /* @__PURE__ */ new WeakSet(), _TaroHistory_reset = function _TaroHistory_reset2(href = "") {
    __classPrivateFieldSet(this, _TaroHistory_stack, [
        {
            state: null,
            title: "",
            url: href || __classPrivateFieldGet(this, _TaroHistory_location, "f").href
        }
    ], "f");
    __classPrivateFieldSet(this, _TaroHistory_cur, 0, "f");
};
var History =  true ? env.window.History : 0;
var Current = {
    app: null,
    router: null,
    page: null
};
var getCurrentInstance = ()=>Current;
var _TaroLocation_instances;
var _TaroLocation_url;
var _TaroLocation_noCheckUrl;
var _TaroLocation_window;
var _TaroLocation_reset;
var _TaroLocation_getPreValue;
var _TaroLocation_rollBack;
var _TaroLocation_recordHistory;
var _TaroLocation_checkUrlChange;
var INIT_URL = "https://taro.com";
var cache = new RuntimeCache("location");
_TaroLocation_url = /* @__PURE__ */ new WeakMap(), _TaroLocation_noCheckUrl = /* @__PURE__ */ new WeakMap(), _TaroLocation_window = /* @__PURE__ */ new WeakMap(), _TaroLocation_instances = /* @__PURE__ */ new WeakSet(), _TaroLocation_reset = function _TaroLocation_reset2() {
    const Current2 = getCurrentInstance();
    const router = Current2.router;
    if (router) {
        const { path, params } = router;
        const searchArr = Object.keys(params).map((key)=>{
            return `${key}=${params[key]}`;
        });
        const searchStr = searchArr.length > 0 ? "?" + searchArr.join("&") : "";
        const url = `${INIT_URL}${path.startsWith("/") ? path : "/" + path}${searchStr}`;
        __classPrivateFieldSet(this, _TaroLocation_url, new URL(url), "f");
        this.trigger("__reset_history__", this.href);
    }
}, _TaroLocation_getPreValue = function _TaroLocation_getPreValue2() {
    return __classPrivateFieldGet(this, _TaroLocation_url, "f")._toRaw();
}, _TaroLocation_rollBack = function _TaroLocation_rollBack2(href) {
    __classPrivateFieldGet(this, _TaroLocation_url, "f").href = href;
}, _TaroLocation_recordHistory = function _TaroLocation_recordHistory2() {
    this.trigger("__record_history__", this.href);
}, _TaroLocation_checkUrlChange = function _TaroLocation_checkUrlChange2(preValue) {
    if (__classPrivateFieldGet(this, _TaroLocation_noCheckUrl, "f")) {
        return false;
    }
    const { protocol, hostname, port, pathname, search, hash } = __classPrivateFieldGet(this, _TaroLocation_url, "f")._toRaw();
    if (protocol !== preValue.protocol || hostname !== preValue.hostname || port !== preValue.port) {
        __classPrivateFieldGet(this, _TaroLocation_instances, "m", _TaroLocation_rollBack).call(this, preValue.href);
        return false;
    }
    if (pathname !== preValue.pathname) {
        return true;
    }
    if (search !== preValue.search) {
        return true;
    }
    if (hash !== preValue.hash) {
        __classPrivateFieldGet(this, _TaroLocation_window, "f").trigger("hashchange");
        return true;
    }
    __classPrivateFieldGet(this, _TaroLocation_instances, "m", _TaroLocation_rollBack).call(this, preValue.href);
    return false;
};
var Location =  true ? env.window.Location : 0;
var machine = "Macintosh";
var arch = "Intel Mac OS X 10_14_5";
var engine = "AppleWebKit/534.36 (KHTML, like Gecko) NodeJS/v4.1.0 Chrome/76.0.3809.132 Safari/534.36";
var msg = "(" + machine + "; " + arch + ") " + engine;
var nav =  true ? env.window.navigator : 0;
var now;
(function() {
    let loadTime;
    if (typeof performance !== "undefined" && performance !== null && performance.now) {
        now = ()=>performance.now();
    } else if (Date.now) {
        loadTime = Date.now();
        now = ()=>Date.now() - loadTime;
    } else {
        loadTime = /* @__PURE__ */ new Date().getTime();
        now = ()=>/* @__PURE__ */ new Date().getTime() - loadTime;
    }
})();
var lastTime = 0;
var _raf = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame !== null ? requestAnimationFrame : function(callback) {
    const _now = now();
    const nextTime = Math.max(lastTime + 16, _now);
    return setTimeout(function() {
        callback(lastTime = nextTime);
    }, nextTime - _now);
};
var _caf = typeof cancelAnimationFrame !== "undefined" && cancelAnimationFrame !== null ? cancelAnimationFrame : function(seed) {
    clearTimeout(seed);
};
var window$1 =  true ? env.window : 0;
var location = window$1.location;
var history = window$1.history;
var SVGElement = class extends TaroElement {
};
var addLeadingSlash = (url = "")=>url.charAt(0) === "/" ? url : "/" + url;
var hasBasename = (path = "", prefix = "")=>new RegExp("^" + prefix + "(\\/|\\?|#|$)", "i").test(path) || path === prefix;
var stripBasename = (path = "", prefix = "")=>hasBasename(path, prefix) ? path.substring(prefix.length) : path;
var stripTrailing = (str = "")=>str.replace(/[?#][\s\S]*$/, "");
var stripSuffix = (path = "", suffix = "")=>path.includes(suffix) ? path.substring(0, path.length - suffix.length) : path;
var getHomePage = (path = "", basename = "", customRoutes = {}, entryPagePath = "")=>{
    var _a1;
    const routePath = addLeadingSlash(stripBasename(path, basename));
    const alias = ((_a1 = Object.entries(customRoutes).find(([key])=>key === routePath)) === null || _a1 === void 0 ? void 0 : _a1[1]) || routePath;
    return entryPagePath || (typeof alias === "string" ? alias : alias[0]) || basename;
};
var getCurrentPage = (routerMode = "hash", basename = "/")=>{
    const pagePath = routerMode === "hash" ? location.hash.slice(1).split("?")[0] : location.pathname;
    return addLeadingSlash(stripBasename(pagePath, basename));
};
var instances = /* @__PURE__ */ new Map();
var pageId = incrementId();
function injectPageInstance(inst, id) {
    hooks.call("mergePageInstance", instances.get(id), inst);
    instances.set(id, inst);
}
function getPageInstance(id) {
    return instances.get(id);
}
function removePageInstance(id) {
    instances.delete(id);
}
function safeExecute(path, lifecycle, ...args) {
    const instance = instances.get(path);
    if (instance == null) {
        return;
    }
    const func = hooks.call("getLifecycle", instance, lifecycle);
    if (isArray(func)) {
        const res = func.map((fn)=>fn.apply(instance, args));
        return res[0];
    }
    if (!isFunction(func)) {
        return;
    }
    return func.apply(instance, args);
}
function stringify(obj) {
    if (obj == null) {
        return "";
    }
    const path = Object.keys(obj).map((key)=>{
        return key + "=" + obj[key];
    }).join("&");
    return path === "" ? path : "?" + path;
}
function getPath(id, options2) {
    const idx = id.indexOf("?");
    if (true) {
        return `${idx > -1 ? id.substring(0, idx) : id}${stringify((options2 === null || options2 === void 0 ? void 0 : options2.stamp) ? {
            stamp: options2.stamp
        } : {})}`;
    } else {}
}
function getOnReadyEventKey(path) {
    return path + "." + ON_READY;
}
function getOnShowEventKey(path) {
    return path + "." + ON_SHOW;
}
function getOnHideEventKey(path) {
    return path + "." + ON_HIDE;
}
function createPageConfig(component, pageName, data, pageConfig) {
    const id = pageName !== null && pageName !== void 0 ? pageName : `taro_page_${pageId()}`;
    const [ONLOAD, ONUNLOAD, ONREADY, ONSHOW, ONHIDE, LIFECYCLES, SIDE_EFFECT_LIFECYCLES] = hooks.call("getMiniLifecycleImpl").page;
    let pageElement = null;
    let unmounting = false;
    let prepareMountList = [];
    function setCurrentRouter(page) {
        const router =  true ? page.$taroPath : 0;
        Current.router = {
            params: page.$taroParams,
            path: addLeadingSlash(router),
            $taroPath: page.$taroPath,
            onReady: getOnReadyEventKey(id),
            onShow: getOnShowEventKey(id),
            onHide: getOnHideEventKey(id)
        };
        if (!isUndefined(page.exitState)) {
            Current.router.exitState = page.exitState;
        }
    }
    let loadResolver;
    let hasLoaded;
    const config = {
        [ONLOAD] (options2 = {}, cb) {
            hasLoaded = new Promise((resolve)=>{
                loadResolver = resolve;
            });
            perf.start(PAGE_INIT);
            Current.page = this;
            this.config = pageConfig || {};
            const uniqueOptions = Object.assign({}, options2, {
                $taroTimestamp: Date.now()
            });
            const $taroPath = this.$taroPath = getPath(id, uniqueOptions);
            if (true) {
                config.path = $taroPath;
            }
            if (this.$taroParams == null) {
                this.$taroParams = uniqueOptions;
            }
            setCurrentRouter(this);
            if (false) {}
            const mount = ()=>{
                Current.app.mount(component, $taroPath, ()=>{
                    pageElement = env.document.getElementById($taroPath);
                    ensure(pageElement !== null, "\u6CA1\u6709\u627E\u5230\u9875\u9762\u5B9E\u4F8B\u3002");
                    safeExecute($taroPath, ON_LOAD, this.$taroParams);
                    loadResolver();
                    if (false) {} else {
                        isFunction(cb) && cb();
                    }
                });
            };
            if (unmounting) {
                prepareMountList.push(mount);
            } else {
                mount();
            }
        },
        [ONUNLOAD] () {
            const $taroPath = this.$taroPath;
            if (false) {}
            safeExecute($taroPath, ONUNLOAD);
            unmounting = true;
            Current.app.unmount($taroPath, ()=>{
                unmounting = false;
                instances.delete($taroPath);
                if (pageElement) {
                    pageElement.ctx = null;
                    pageElement = null;
                }
                if (prepareMountList.length) {
                    prepareMountList.forEach((fn)=>fn());
                    prepareMountList = [];
                }
            });
        },
        [ONREADY] () {
            hasLoaded.then(()=>{
                safeExecute(this.$taroPath, ON_READY);
                _raf(()=>eventCenter.trigger(getOnReadyEventKey(id)));
                this.onReady.called = true;
            });
        },
        [ONSHOW] (options2 = {}) {
            hasLoaded.then(()=>{
                Current.page = this;
                setCurrentRouter(this);
                if (false) {}
                safeExecute(this.$taroPath, ON_SHOW, options2);
                _raf(()=>eventCenter.trigger(getOnShowEventKey(id)));
            });
        },
        [ONHIDE] () {
            if (false) {}
            if (Current.page === this) {
                Current.page = null;
                Current.router = null;
            }
            safeExecute(this.$taroPath, ON_HIDE);
            eventCenter.trigger(getOnHideEventKey(id));
        }
    };
    LIFECYCLES.forEach((lifecycle)=>{
        let isDefer = false;
        lifecycle = lifecycle.replace(/^defer:/, ()=>{
            isDefer = true;
            return "";
        });
        config[lifecycle] = function() {
            const exec = ()=>safeExecute(this.$taroPath, lifecycle, ...arguments);
            if (isDefer) {
                hasLoaded.then(exec);
            } else {
                return exec();
            }
        };
    });
    SIDE_EFFECT_LIFECYCLES.forEach((lifecycle)=>{
        var _a1;
        if (component[lifecycle] || ((_a1 = component.prototype) === null || _a1 === void 0 ? void 0 : _a1[lifecycle]) || component[lifecycle.replace(/^on/, "enable")] || (pageConfig === null || pageConfig === void 0 ? void 0 : pageConfig[lifecycle.replace(/^on/, "enable")])) {
            config[lifecycle] = function(...args) {
                var _a2;
                const target = (_a2 = args[0]) === null || _a2 === void 0 ? void 0 : _a2.target;
                if (target === null || target === void 0 ? void 0 : target.id) {
                    const id2 = target.id;
                    const element = env.document.getElementById(id2);
                    if (element) {
                        target.dataset = element.dataset;
                    }
                }
                return safeExecute(this.$taroPath, lifecycle, ...args);
            };
        }
    });
    config.eh = eventHandler;
    if (!isUndefined(data)) {
        config.data = data;
    }
    hooks.call("modifyPageObject", config);
    return config;
}
function createComponentConfig(component, componentName, data) {
    const id = componentName !== null && componentName !== void 0 ? componentName : `taro_component_${pageId()}`;
    let componentElement = null;
    const [ATTACHED, DETACHED] = hooks.call("getMiniLifecycleImpl").component;
    const config = {
        [ATTACHED] () {
            var _a1;
            perf.start(PAGE_INIT);
            this.pageIdCache = ((_a1 = this.getPageId) === null || _a1 === void 0 ? void 0 : _a1.call(this)) || pageId();
            const path = getPath(id, {
                id: this.pageIdCache
            });
            Current.app.mount(component, path, ()=>{
                componentElement = env.document.getElementById(path);
                ensure(componentElement !== null, "\u6CA1\u6709\u627E\u5230\u7EC4\u4EF6\u5B9E\u4F8B\u3002");
                this.$taroInstances = instances.get(path);
                safeExecute(path, ON_LOAD);
                if (false) {}
            });
        },
        [DETACHED] () {
            const path = getPath(id, {
                id: this.pageIdCache
            });
            Current.app.unmount(path, ()=>{
                instances.delete(path);
                if (componentElement) {
                    componentElement.ctx = null;
                }
            });
        },
        methods: {
            eh: eventHandler
        }
    };
    if (!isUndefined(data)) {
        config.data = data;
    }
    [
        OPTIONS,
        EXTERNAL_CLASSES,
        BEHAVIORS
    ].forEach((key)=>{
        var _a1;
        config[key] = (_a1 = component[key]) !== null && _a1 !== void 0 ? _a1 : EMPTY_OBJ;
    });
    return config;
}
function createRecursiveComponentConfig(componentName) {
    const isCustomWrapper = componentName === CUSTOM_WRAPPER;
    const [ATTACHED, DETACHED] = hooks.call("getMiniLifecycleImpl").component;
    const lifeCycles = isCustomWrapper ? {
        [ATTACHED] () {
            var _a1, _b;
            const componentId = ((_a1 = this.data.i) === null || _a1 === void 0 ? void 0 : _a1.sid) || ((_b = this.props.i) === null || _b === void 0 ? void 0 : _b.sid);
            if (isString(componentId)) {
                customWrapperCache.set(componentId, this);
                const el = env.document.getElementById(componentId);
                if (el) {
                    el.ctx = this;
                }
            }
        },
        [DETACHED] () {
            var _a1, _b;
            const componentId = ((_a1 = this.data.i) === null || _a1 === void 0 ? void 0 : _a1.sid) || ((_b = this.props.i) === null || _b === void 0 ? void 0 : _b.sid);
            if (isString(componentId)) {
                customWrapperCache.delete(componentId);
                const el = env.document.getElementById(componentId);
                if (el) {
                    el.ctx = null;
                }
            }
        }
    } : EMPTY_OBJ;
    return hooks.call("modifyRecursiveComponentConfig", Object.assign({
        properties: {
            i: {
                type: Object,
                value: {
                    ["nn"]: getComponentsAlias(internalComponents)[VIEW]._num
                }
            },
            l: {
                type: String,
                value: ""
            }
        },
        options: {
            addGlobalClass: true,
            virtualHost: !isCustomWrapper
        },
        methods: {
            eh: eventHandler
        }
    }, lifeCycles), {
        isCustomWrapper
    });
}
var TIMEOUT = 100;
var nextTick = (cb, ctx)=>{
    const beginTime = Date.now();
    const router = Current.router;
    const timerFunc = ()=>{
        setTimeout(function() {
            ctx ? cb.call(ctx) : cb();
        }, 1);
    };
    if (router === null) return timerFunc();
    const path = router.$taroPath;
    function next() {
        var _a1, _b, _c;
        const pageElement = env.document.getElementById(path);
        if (pageElement === null || pageElement === void 0 ? void 0 : pageElement.pendingUpdate) {
            if (true) {
                (_c = (_b = (_a1 = pageElement.firstChild) === null || _a1 === void 0 ? void 0 : _a1["componentOnReady"]) === null || _b === void 0 ? void 0 : _b.call(_a1).then(()=>{
                    timerFunc();
                })) !== null && _c !== void 0 ? _c : timerFunc();
            } else {}
        } else if (Date.now() - beginTime > TIMEOUT) {
            timerFunc();
        } else {
            setTimeout(()=>next(), 20);
        }
    }
    next();
};
function handleArrayFindPolyfill() {
    if (!isFunction(Array.prototype.find)) {
        Object.defineProperty(Array.prototype, "find", {
            value (predicate) {
                if (this == null) {
                    throw new TypeError('"this" is null or not defined');
                }
                const o = Object(this);
                const len = o.length >>> 0;
                if (!isFunction(predicate)) {
                    throw new TypeError("predicate must be a function");
                }
                const thisArg = arguments[1];
                let k = 0;
                while(k < len){
                    const kValue = o[k];
                    if (predicate.call(thisArg, kValue, k, o)) {
                        return kValue;
                    }
                    k++;
                }
                return void 0;
            }
        });
    }
}
function handleArrayIncludesPolyfill() {
    if (!isFunction(Array.prototype.includes)) {
        Object.defineProperty(Array.prototype, "includes", {
            value (searchElement, fromIndex) {
                if (this == null) {
                    throw new TypeError('"this" is null or not defined');
                }
                const o = Object(this);
                const len = o.length >>> 0;
                if (len === 0) {
                    return false;
                }
                const n = fromIndex | 0;
                let k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
                while(k < len){
                    if (o[k] === searchElement) {
                        return true;
                    }
                    k++;
                }
                return false;
            }
        });
    }
}
function handleIntersectionObserverPolyfill() {
    if ("IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype) {
        if (!("isIntersecting" in window.IntersectionObserverEntry.prototype)) {
            Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", {
                get: function() {
                    return this.intersectionRatio > 0;
                }
            });
        }
    } else {
        handleIntersectionObserverObjectPolyfill();
    }
}
function handleIntersectionObserverObjectPolyfill() {
    const document2 = window.document;
    function IntersectionObserverEntry(entry) {
        this.time = entry.time;
        this.target = entry.target;
        this.rootBounds = entry.rootBounds;
        this.boundingClientRect = entry.boundingClientRect;
        this.intersectionRect = entry.intersectionRect || getEmptyRect();
        this.isIntersecting = !!entry.intersectionRect;
        const targetRect = this.boundingClientRect;
        const targetArea = targetRect.width * targetRect.height;
        const intersectionRect = this.intersectionRect;
        const intersectionArea = intersectionRect.width * intersectionRect.height;
        if (targetArea) {
            this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));
        } else {
            this.intersectionRatio = this.isIntersecting ? 1 : 0;
        }
    }
    function IntersectionObserver(callback, options2 = {}) {
        if (!isFunction(callback)) {
            throw new Error("callback must be a function");
        }
        if (options2.root && options2.root.nodeType != 1) {
            throw new Error("root must be an Element");
        }
        this._checkForIntersections = throttle(this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);
        this._callback = callback;
        this._observationTargets = [];
        this._queuedEntries = [];
        this._rootMarginValues = this._parseRootMargin(options2.rootMargin);
        this.thresholds = this._initThresholds(options2.threshold);
        this.root = options2.root || null;
        this.rootMargin = this._rootMarginValues.map(function(margin) {
            return margin.value + margin.unit;
        }).join(" ");
    }
    IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;
    IntersectionObserver.prototype.POLL_INTERVAL = null;
    IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;
    IntersectionObserver.prototype.observe = function(target) {
        const isTargetAlreadyObserved = this._observationTargets.some(function(item) {
            return item.element == target;
        });
        if (isTargetAlreadyObserved) return;
        if (!(target && target.nodeType == 1)) {
            throw new Error("target must be an Element");
        }
        this._registerInstance();
        this._observationTargets.push({
            element: target,
            entry: null
        });
        this._monitorIntersections();
        this._checkForIntersections();
    };
    IntersectionObserver.prototype.unobserve = function(target) {
        this._observationTargets = this._observationTargets.filter(function(item) {
            return item.element != target;
        });
        if (!this._observationTargets.length) {
            this._unmonitorIntersections();
            this._unregisterInstance();
        }
    };
    IntersectionObserver.prototype.disconnect = function() {
        this._observationTargets = [];
        this._unmonitorIntersections();
        this._unregisterInstance();
    };
    IntersectionObserver.prototype.takeRecords = function() {
        const records = this._queuedEntries.slice();
        this._queuedEntries = [];
        return records;
    };
    IntersectionObserver.prototype._initThresholds = function(opt_threshold) {
        let threshold = opt_threshold || [
            0
        ];
        if (!Array.isArray(threshold)) threshold = [
            threshold
        ];
        return threshold.sort().filter(function(t, i, a) {
            if (!isNumber(t) || isNaN(t) || t < 0 || t > 1) {
                throw new Error("threshold must be a number between 0 and 1 inclusively");
            }
            return t !== a[i - 1];
        });
    };
    IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
        const marginString = opt_rootMargin || "0px";
        const margins = marginString.split(/\s+/).map(function(margin) {
            const parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
            if (!parts) {
                throw new Error("rootMargin must be specified in pixels or percent");
            }
            return {
                value: parseFloat(parts[1]),
                unit: parts[2]
            };
        });
        margins[1] = margins[1] || margins[0];
        margins[2] = margins[2] || margins[0];
        margins[3] = margins[3] || margins[1];
        return margins;
    };
    IntersectionObserver.prototype._monitorIntersections = function() {
        if (!this._monitoringIntersections) {
            this._monitoringIntersections = true;
            if (this.POLL_INTERVAL) {
                this._monitoringInterval = setInterval(this._checkForIntersections, this.POLL_INTERVAL);
            } else {
                addEvent(window, "resize", this._checkForIntersections, true);
                addEvent(document2, "scroll", this._checkForIntersections, true);
                if (this.USE_MUTATION_OBSERVER && "MutationObserver" in window) {
                    this._domObserver = new MutationObserver(this._checkForIntersections);
                    this._domObserver.observe(document2, {
                        attributes: true,
                        childList: true,
                        characterData: true,
                        subtree: true
                    });
                }
            }
        }
    };
    IntersectionObserver.prototype._unmonitorIntersections = function() {
        if (this._monitoringIntersections) {
            this._monitoringIntersections = false;
            clearInterval(this._monitoringInterval);
            this._monitoringInterval = null;
            removeEvent(window, "resize", this._checkForIntersections, true);
            removeEvent(document2, "scroll", this._checkForIntersections, true);
            if (this._domObserver) {
                this._domObserver.disconnect();
                this._domObserver = null;
            }
        }
    };
    IntersectionObserver.prototype._checkForIntersections = function() {
        const rootIsInDom = this._rootIsInDom();
        const rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();
        this._observationTargets.forEach(function(item) {
            const target = item.element;
            const targetRect = getBoundingClientRect(target);
            const rootContainsTarget = this._rootContainsTarget(target);
            const oldEntry = item.entry;
            const intersectionRect = rootIsInDom && rootContainsTarget && this._computeTargetAndRootIntersection(target, rootRect);
            const newEntry = item.entry = new IntersectionObserverEntry({
                time: now2(),
                target,
                boundingClientRect: targetRect,
                rootBounds: rootRect,
                intersectionRect,
                intersectionRatio: -1,
                isIntersecting: false
            });
            if (!oldEntry) {
                this._queuedEntries.push(newEntry);
            } else if (rootIsInDom && rootContainsTarget) {
                if (this._hasCrossedThreshold(oldEntry, newEntry)) {
                    this._queuedEntries.push(newEntry);
                }
            } else {
                if (oldEntry && oldEntry.isIntersecting) {
                    this._queuedEntries.push(newEntry);
                }
            }
        }, this);
        if (this._queuedEntries.length) {
            this._callback(this.takeRecords(), this);
        }
    };
    IntersectionObserver.prototype._computeTargetAndRootIntersection = function(target, rootRect) {
        if (window.getComputedStyle(target).display === "none") return;
        const targetRect = getBoundingClientRect(target);
        let intersectionRect = targetRect;
        let parent = getParentNode(target);
        let atRoot = false;
        while(!atRoot){
            let parentRect = null;
            const parentComputedStyle = parent.nodeType == 1 ? window.getComputedStyle(parent) : {};
            if (parentComputedStyle.display === "none") return;
            if (parent == this.root || parent == document2) {
                atRoot = true;
                parentRect = rootRect;
            } else {
                if (parent != document2.body && parent != document2.documentElement && parentComputedStyle.overflow != "visible") {
                    parentRect = getBoundingClientRect(parent);
                }
            }
            if (parentRect) {
                intersectionRect = computeRectIntersection(parentRect, intersectionRect);
                if (!intersectionRect) break;
            }
            parent = getParentNode(parent);
        }
        return intersectionRect;
    };
    IntersectionObserver.prototype._getRootRect = function() {
        let rootRect;
        if (this.root) {
            rootRect = getBoundingClientRect(this.root);
        } else {
            const html = document2.documentElement;
            const body = document2.body;
            rootRect = {
                top: 0,
                left: 0,
                right: html.clientWidth || body.clientWidth,
                width: html.clientWidth || body.clientWidth,
                bottom: html.clientHeight || body.clientHeight,
                height: html.clientHeight || body.clientHeight
            };
        }
        return this._expandRectByRootMargin(rootRect);
    };
    IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {
        const margins = this._rootMarginValues.map(function(margin, i) {
            return margin.unit === "px" ? margin.value : margin.value * (i % 2 ? rect.width : rect.height) / 100;
        });
        const newRect = {
            top: rect.top - margins[0],
            right: rect.right + margins[1],
            bottom: rect.bottom + margins[2],
            left: rect.left - margins[3]
        };
        newRect.width = newRect.right - newRect.left;
        newRect.height = newRect.bottom - newRect.top;
        return newRect;
    };
    IntersectionObserver.prototype._hasCrossedThreshold = function(oldEntry, newEntry) {
        const oldRatio = oldEntry && oldEntry.isIntersecting ? oldEntry.intersectionRatio || 0 : -1;
        const newRatio = newEntry.isIntersecting ? newEntry.intersectionRatio || 0 : -1;
        if (oldRatio === newRatio) return;
        for(let i = 0; i < this.thresholds.length; i++){
            const threshold = this.thresholds[i];
            if (threshold == oldRatio || threshold == newRatio || threshold < oldRatio !== threshold < newRatio) {
                return true;
            }
        }
    };
    IntersectionObserver.prototype._rootIsInDom = function() {
        return !this.root || containsDeep(document2, this.root);
    };
    IntersectionObserver.prototype._rootContainsTarget = function(target) {
        return containsDeep(this.root || document2, target);
    };
    IntersectionObserver.prototype._registerInstance = function() {};
    IntersectionObserver.prototype._unregisterInstance = function() {};
    function now2() {
        return window.performance && performance.now && performance.now();
    }
    function addEvent(node, event, fn, opt_useCapture) {
        if (isFunction(node.addEventListener)) {
            node.addEventListener(event, fn, opt_useCapture || false);
        } else if (isFunction(node.attachEvent)) {
            node.attachEvent("on" + event, fn);
        }
    }
    function removeEvent(node, event, fn, opt_useCapture) {
        if (isFunction(node.removeEventListener)) {
            node.removeEventListener(event, fn, opt_useCapture || false);
        } else if (isFunction(node.detatchEvent)) {
            node.detatchEvent("on" + event, fn);
        }
    }
    function computeRectIntersection(rect1, rect2) {
        const top = Math.max(rect1.top, rect2.top);
        const bottom = Math.min(rect1.bottom, rect2.bottom);
        const left = Math.max(rect1.left, rect2.left);
        const right = Math.min(rect1.right, rect2.right);
        const width2 = right - left;
        const height = bottom - top;
        return width2 >= 0 && height >= 0 && {
            top,
            bottom,
            left,
            right,
            width: width2,
            height
        };
    }
    function getBoundingClientRect(el) {
        let rect;
        try {
            rect = el.getBoundingClientRect();
        } catch (err) {}
        if (!rect) return getEmptyRect();
        if (!(rect.width && rect.height)) {
            rect = {
                top: rect.top,
                right: rect.right,
                bottom: rect.bottom,
                left: rect.left,
                width: rect.right - rect.left,
                height: rect.bottom - rect.top
            };
        }
        return rect;
    }
    function getEmptyRect() {
        return {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            width: 0,
            height: 0
        };
    }
    function containsDeep(parent, child) {
        let node = child;
        while(node){
            if (node == parent) return true;
            node = getParentNode(node);
        }
        return false;
    }
    function getParentNode(node) {
        const parent = node.parentNode;
        if (parent && parent.nodeType == 11 && parent.host) {
            return parent.host;
        }
        if (parent && parent.assignedSlot) {
            return parent.assignedSlot.parentNode;
        }
        return parent;
    }
    window.IntersectionObserver = IntersectionObserver;
    window.IntersectionObserverEntry = IntersectionObserverEntry;
}
function handleObjectAssignPolyfill() {
    if (!isFunction(Object.assign)) {
        Object.assign = function(target) {
            if (target == null) {
                throw new TypeError("Cannot convert undefined or null to object");
            }
            const to = Object(target);
            for(let index = 1; index < arguments.length; index++){
                const nextSource = arguments[index];
                if (nextSource != null) {
                    for(const nextKey in nextSource){
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
            return to;
        };
    }
}
function handleObjectEntriesPolyfill() {
    if (!isFunction(Object.entries)) {
        Object.entries = function(obj) {
            if (obj == null) {
                throw new TypeError("Cannot convert undefined or null to object");
            }
            const to = [];
            if (obj != null) {
                for(const key in obj){
                    if (Object.prototype.hasOwnProperty.call(obj, key)) {
                        to.push([
                            key,
                            obj[key]
                        ]);
                    }
                }
            }
            return to;
        };
    }
}
function handleObjectDefinePropertyPolyfill() {
    if (!isFunction(Object.defineProperties)) {
        Object.defineProperties = function(obj, properties) {
            function convertToDescriptor(desc) {
                function hasProperty(obj2, prop) {
                    return Object.prototype.hasOwnProperty.call(obj2, prop);
                }
                if (!isObject(desc)) {
                    throw new TypeError("bad desc");
                }
                const d = {};
                if (hasProperty(desc, "enumerable")) d.enumerable = !!desc.enumerable;
                if (hasProperty(desc, "configurable")) {
                    d.configurable = !!desc.configurable;
                }
                if (hasProperty(desc, "value")) d.value = desc.value;
                if (hasProperty(desc, "writable")) d.writable = !!desc.writable;
                if (hasProperty(desc, "get")) {
                    const g = desc.get;
                    if (!isFunction(g) && !isUndefined(g)) {
                        throw new TypeError("bad get");
                    }
                    d.get = g;
                }
                if (hasProperty(desc, "set")) {
                    const s = desc.set;
                    if (!isFunction(s) && !isUndefined(s)) {
                        throw new TypeError("bad set");
                    }
                    d.set = s;
                }
                if (("get" in d || "set" in d) && ("value" in d || "writable" in d)) {
                    throw new TypeError("identity-confused descriptor");
                }
                return d;
            }
            if (!isObject(obj)) throw new TypeError("bad obj");
            properties = Object(properties);
            const keys = Object.keys(properties);
            const descs = [];
            for(let i = 0; i < keys.length; i++){
                descs.push([
                    keys[i],
                    convertToDescriptor(properties[keys[i]])
                ]);
            }
            for(let i = 0; i < descs.length; i++){
                Object.defineProperty(obj, descs[i][0], descs[i][1]);
            }
            return obj;
        };
    }
}
function handlePolyfill() {
    if (true) {
        handleObjectAssignPolyfill();
    }
    if (true) {
        handleObjectEntriesPolyfill();
    }
    if (true) {
        handleObjectDefinePropertyPolyfill();
    }
    if (true) {
        handleArrayFindPolyfill();
    }
    if (true) {
        handleArrayIncludesPolyfill();
    }
    if (isObject(window)) {
        if (true) {
            handleIntersectionObserverPolyfill();
        }
    }
}
if (false) {}



/***/ }),

/***/ "./node_modules/.taro/h5/prebundle/chunk-UG6XUGBP.js":
/*!***********************************************************!*\
  !*** ./node_modules/.taro/h5/prebundle/chunk-UG6XUGBP.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__commonJS": function() { return /* binding */ __commonJS; },
/* harmony export */   "__esm": function() { return /* binding */ __esm; },
/* harmony export */   "__export": function() { return /* binding */ __export; },
/* harmony export */   "__glob": function() { return /* binding */ __glob; },
/* harmony export */   "__toCommonJS": function() { return /* binding */ __toCommonJS; },
/* harmony export */   "__toESM": function() { return /* binding */ __toESM; }
/* harmony export */ });
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __glob = (map)=>(path)=>{
        var fn = map[path];
        if (fn) return fn();
        throw new Error("Module not found in bundle: " + path);
    };
var __esm = (fn, res)=>function __init() {
        return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
    };
var __commonJS = (cb, mod)=>function __require() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
            exports: {}
        }).exports, mod), mod.exports;
    };
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);



/***/ })

}]);