import * as React from "react";
import { useMemo, useRef, Children } from "react";
import { useUncontrolled } from "@taroify/hooks/index.js";
import Picker from "../picker/index.js";
import { isElementOf } from "../utils/validate/index.js";
import { useMemoizedFn } from "../hooks/index.js";
import { formatDataForCascade } from "./area-picker.shared.js";
import AreaPickerColumns from "./area-picker-columns.js";
const defaultAreaList = {};
function AreaPicker({ areaList: areaListProp, depth: depthProp, children: childrenProps, value: valueProp, defaultValue, onChange: onChangeProp, onConfirm: onConfirmProp, onCancel: onCancelProp, ...restProps }) {
    const hasChange = useRef(false);
    const { value, setValue } = useUncontrolled({
        value: valueProp,
        defaultValue,
    });
    const [areaList, columnsNum] = useMemo(() => {
        let __areaList__ = areaListProp || defaultAreaList;
        Children.forEach(childrenProps, (child) => {
            if (isElementOf(child, AreaPickerColumns)) {
                __areaList__ = child.props.children;
            }
        });
        return [__areaList__, depthProp || 3];
    }, [childrenProps, areaListProp, depthProp]);
    const [origin, provinceMap, cityMap] = useMemo(() => formatDataForCascade({
        areaList,
        columnsNum,
    }), [areaList, columnsNum]);
    const columns = useMemo(() => {
        const ret = [origin];
        let parent = origin;
        for (let i = 0; i < columnsNum - 1; i++) {
            let selected;
            if (value?.[i]) {
                selected = parent.find((item) => item.value === value?.[i]);
            }
            else {
                selected = parent[0];
            }
            parent = selected?.children || [];
            ret.push(parent);
        }
        return ret;
    }, [origin, value]);
    const handleChange = useMemoizedFn((val, option, column) => {
        const valCache = Array.isArray(val) && val.length ? val : [val];
        const idx = valCache.findIndex((item) => item === option.value);
        let newVal = [];
        if (idx === 0) {
            newVal = [valCache[0]];
            if (columnsNum > 1) {
                const province = provinceMap.get(option.value.slice(0, 2));
                const city = province?.children?.[0];
                newVal.push(city?.value);
                if (columnsNum > 2) {
                    newVal.push(city?.children?.[0]?.value);
                }
            }
        }
        else if (idx === 1) {
            const city = cityMap.get(option.value.slice(0, 4));
            newVal = [valCache[0], city?.value];
            if (columnsNum > 2) {
                newVal.push(city?.children?.[0]?.value);
            }
        }
        else if (idx === 2) {
            newVal = [value?.[0], value?.[1], option.value];
        }
        hasChange.current = true;
        setValue(newVal);
        onChangeProp?.(newVal, option, column);
    });
    const genValOption = (valueParam) => {
        const val = (hasChange.current ? value : valueParam) || [];
        const province = provinceMap.get(val[0]?.slice(0, 2)) || {};
        const option = [province];
        if (columnsNum > 1) {
            const { children, ...city } = cityMap.get(val[1]?.slice(0, 4)) || {};
            option.push(city);
            if (columnsNum > 2) {
                const country = children?.find((item) => item.value === val[2]);
                option.push(country || {});
            }
        }
        return [val, option];
    };
    const handleConfirm = useMemoizedFn((valueParam) => {
        if (onConfirmProp) {
            const [val, option] = genValOption(valueParam);
            onConfirmProp(val, option);
        }
    });
    const handleCancel = useMemoizedFn((valueParam) => {
        if (onCancelProp) {
            const [val, option] = genValOption(valueParam);
            onCancelProp(val, option);
        }
    });
    return (React.createElement(Picker, { ...restProps, children: childrenProps, columns: columns, value: value, defaultValue: defaultValue, onChange: handleChange, onConfirm: handleConfirm, onCancel: handleCancel }));
}
export default AreaPicker;
