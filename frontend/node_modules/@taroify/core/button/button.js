import { cloneIconElement, isIconElement } from "@taroify/icons/utils/index.js";
import { View } from "@tarojs/components";
import classNames from "classnames";
import _isBoolean from "lodash/isBoolean";
import _size from "lodash/size";
import _map from "lodash/map";
import _isPlainObject from "lodash/isPlainObject";
import * as React from "react";
import { cloneElement, useContext, useMemo } from "react";
import ButtonBase from "../button-base/index.js";
import Loading from "../loading/index.js";
import { prefixClassname } from "../styles/index.js";
import Children from "../utils/children.js";
import { isElementOf, isObjectElement } from "../utils/validate/index.js";
import ButtonContent from "./button-content.js";
import ButtonGroupContext from "./button-group.context.js";
import ButtonContext from "./button.context.js";
function useButtonLoading(loading) {
    return useMemo(() => {
        if (_isBoolean(loading) && loading) {
            return (React.createElement(Loading, { className: classNames(prefixClassname("button__loading"), prefixClassname("button__loading--right")) }));
        }
        if (isObjectElement(loading)) {
            const { className, ...restProps } = loading;
            return (React.createElement(Loading, { className: classNames(prefixClassname("button__loading"), prefixClassname("button__loading--right"), className), ...restProps }));
        }
        if (isElementOf(loading, Loading)) {
            return cloneElement(loading, {
                className: classNames(prefixClassname("button__loading"), prefixClassname("button__loading--right")),
            });
        }
        return loading;
    }, [loading]);
}
function appendButtonIconClassname(icon, className) {
    return isIconElement(icon) ? cloneIconElement(icon, { className }) : icon;
}
function useButtonChildren(options) {
    const { loading, icon: iconProp, children, iconPosition } = options;
    if (isElementOf(children, ButtonContent)) {
        return children;
    }
    const childrenArray = Children.toArray(children);
    const lastIndex = _size(childrenArray) - 1;
    const icon = appendButtonIconClassname(iconProp, prefixClassname(iconPosition === "left" ? "button__icon--right" : "button__icon--left"));
    return (React.createElement(ButtonContent, null,
        loading,
        iconPosition === "left" && icon,
        _map(childrenArray, (child, index) => {
            if (isIconElement(child) && index === 0) {
                return appendButtonIconClassname(child, prefixClassname("button__icon--right"));
            }
            if (isIconElement(child) && index === lastIndex) {
                return appendButtonIconClassname(child, prefixClassname("button__icon--left"));
            }
            return (React.createElement(View, { key: index, className: prefixClassname("button__text") }, child));
        }),
        iconPosition === "right" && icon));
}
function useButtonPropertyValue(value1, value2, defaultValue) {
    return useMemo(() => {
        if (value1) {
            return value1;
        }
        if (value2) {
            return value2;
        }
        return defaultValue;
    }, [defaultValue, value1, value2]);
}
export default function Button(props) {
    const { className, style, variant: variantProp, shape: shapeProp, size: sizeProp, color: colorProp, formType = "button", block, hairline: hairlineProp, disabled: disabledProp, loading: loadingProp, icon, iconPosition = "left", children: childrenProp, onClick, ...restProps } = props;
    const { variant: variantCtx, shape: shapeCtx, size: sizeCtx, color: colorCtx, hairline: hairlineCtx, disabled: disabledCtx, } = useContext(ButtonGroupContext);
    const { onClick: onCtxClick } = useContext(ButtonContext);
    const variant = useButtonPropertyValue(variantProp, variantCtx, "contained");
    const shape = useButtonPropertyValue(shapeProp, shapeCtx);
    const size = useButtonPropertyValue(sizeProp, sizeCtx, "medium");
    const color = useButtonPropertyValue(colorProp, colorCtx, "default");
    const hairline = useButtonPropertyValue(hairlineProp, hairlineCtx);
    const disabled = useButtonPropertyValue(disabledProp, disabledCtx);
    const loading = useButtonLoading(loadingProp);
    const children = useButtonChildren({ children: childrenProp, loading, icon, iconPosition });
    return (React.createElement(View, { className: classNames(prefixClassname("button"), {
            [prefixClassname("button--text")]: variant === "text",
            [prefixClassname("button--contained")]: variant === "contained",
            [prefixClassname("button--outlined")]: variant === "outlined",
            [prefixClassname(`button--${color}`)]: color,
            [prefixClassname("button--round")]: shape === "round",
            [prefixClassname("button--square")]: shape === "square",
            [prefixClassname("button--mini")]: size === "mini",
            [prefixClassname("button--small")]: size === "small",
            [prefixClassname("button--medium")]: size === "medium",
            [prefixClassname("button--large")]: size === "large",
            [prefixClassname("button--hairline")]: hairline,
            [prefixClassname("hairline--surround")]: hairline,
            [prefixClassname("button--disabled")]: disabled,
            [prefixClassname("button--loading")]: loading,
            [prefixClassname("button--block")]: block,
        }, className), style: style, onClick: (e) => {
            if (!disabled && !loading) {
                onClick?.(e);
                onCtxClick?.(e, props);
            }
        } },
        children,
        React.createElement(ButtonBase, { className: prefixClassname("button__button"), formType: formType === "submit" ? "submit" : formType === "reset" ? "reset" : undefined, disabled: disabled || !!loading, loading: false, ...restProps })));
}
export function createButton(children, props) {
    if (_isPlainObject(children)) {
        return React.createElement(Button, { ...children, ...props });
    }
    return React.createElement(Button, { children: children, ...props });
}
