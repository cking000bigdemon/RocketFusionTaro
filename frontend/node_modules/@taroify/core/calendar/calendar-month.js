import { View } from "@tarojs/components";
import _some from "lodash/some";
import _map from "lodash/map";
import * as React from "react";
import { forwardRef, useCallback, useContext, useImperativeHandle, useMemo, useRef, } from "react";
import { prefixClassname } from "../styles/index.js";
import { getRect } from "../utils/dom/rect.js";
import { useHeight } from "../hooks/index.js";
import CalendarDay from "./calendar-day.js";
import CalendarContext from "./calendar.context.js";
import { compareDate, createNextDay, createPreviousDay, genMonthId, getEndDayOfMonth, } from "./calendar.shared.js";
function CalendarMonthWatermark(props) {
    const { children } = props;
    return React.createElement(View, { className: prefixClassname("calendar__month-watermark"), children: children });
}
function getBottom(type, dayType) {
    if (type === "range") {
        if (dayType === "start") {
            return "开始";
        }
        if (dayType === "end") {
            return "结束";
        }
        if (dayType === "active") {
            return "开始/结束";
        }
    }
}
const CalendarMonth = forwardRef((props, ref) => {
    const { value: monthValue = new Date(), watermark, showMonthTitle } = props;
    const { type, firstDayOfWeek, min, max, value: currentValue, formatter, } = useContext(CalendarContext);
    const monthRef = useRef();
    const height = useHeight(monthRef);
    const month = useMemo(() => monthValue.getMonth() + 1, [monthValue]);
    const id = useMemo(() => genMonthId(monthValue), [monthValue]);
    const title = useMemo(() => `${monthValue.getFullYear()}年${monthValue.getMonth() + 1}月`, [monthValue]);
    const offset = useMemo(() => {
        const realDay = monthValue.getDay();
        if (firstDayOfWeek) {
            return (realDay + 7 - firstDayOfWeek) % 7;
        }
        return realDay;
    }, [firstDayOfWeek, monthValue]);
    const totalDay = useMemo(() => getEndDayOfMonth(monthValue.getFullYear(), monthValue.getMonth() + 1), [monthValue]);
    const getMultipleDayType = useCallback((day) => {
        const isActive = (date) => _some(currentValue, (item) => compareDate(item, date) === 0);
        if (isActive(day)) {
            const prevDay = createPreviousDay(day);
            const nextDay = createNextDay(day);
            const prevActive = isActive(prevDay);
            const nextActive = isActive(nextDay);
            if (prevActive && nextActive) {
                return "middle";
            }
            if (prevActive) {
                return "end";
            }
            if (nextActive) {
                return "start";
            }
            return "active";
        }
        return "";
    }, [currentValue]);
    const getRangeDayType = useCallback((day) => {
        const [startDay, endDay] = currentValue;
        if (!startDay) {
            return "";
        }
        const compareToStart = compareDate(day, startDay);
        if (!endDay) {
            return compareToStart === 0 ? "start" : "";
        }
        const compareToEnd = compareDate(day, endDay);
        if (compareToStart === 0 && compareToEnd === 0) {
            return "active";
        }
        if (compareToStart === 0) {
            return "start";
        }
        if (compareToEnd === 0) {
            return "end";
        }
        if (compareToStart > 0 && compareToEnd < 0) {
            return "middle";
        }
        return "";
    }, [currentValue]);
    const getDayType = useCallback((dayValue) => {
        if (compareDate(dayValue, min) < 0 || compareDate(dayValue, max) > 0) {
            return "disabled";
        }
        if (Array.isArray(currentValue)) {
            if (type === "multiple") {
                return getMultipleDayType(dayValue);
            }
            if (type === "range") {
                return getRangeDayType(dayValue);
            }
        }
        else if (type === "single") {
            return compareDate(dayValue, currentValue) === 0 ? "active" : "";
        }
        return "";
    }, [currentValue, getMultipleDayType, getRangeDayType, max, min, type]);
    const days = useMemo(() => {
        const days = [];
        const year = monthValue?.getFullYear();
        const month = monthValue?.getMonth();
        for (let dayValue = 1; dayValue <= totalDay; dayValue++) {
            const dateValue = new Date(year, month, dayValue);
            const dayType = getDayType(dateValue);
            const oldDay = {
                value: dateValue,
                type: dayType,
                bottom: getBottom(type, dayType),
                children: dayValue,
            };
            const newDay = formatter ? formatter(oldDay) : oldDay;
            days.push(newDay);
        }
        return days;
    }, [monthValue, totalDay, getDayType, type, formatter]);
    const disabledDays = useMemo(() => days.filter((day) => day.type === "disabled"), [days]);
    const getRectTop = useCallback(() => {
        return getRect(monthRef).then(({ top }) => top);
    }, []);
    useImperativeHandle(ref, () => ({
        getRectTop,
        disabledDays,
        getHeight: () => height,
        getValue: () => monthValue,
    }), [disabledDays, getRectTop, monthValue, height]);
    const content = useMemo(() => _map(days, (day, index) => (React.createElement(CalendarDay, { key: `${day.value}-${index}`, className: day.className, style: { marginLeft: index === 0 ? `${(100 * offset) / 7}%` : "" }, value: day.value, type: day.type, top: day.top, bottom: day.bottom, children: day.children }))), [days, offset]);
    return (React.createElement(View, { id: id, ref: monthRef, className: prefixClassname("calendar__month") },
        showMonthTitle && (React.createElement(View, { className: prefixClassname("calendar__month-title"), children: title })),
        React.createElement(View, { className: prefixClassname("calendar__days") },
            watermark && React.createElement(CalendarMonthWatermark, { children: month }),
            content)));
});
export default CalendarMonth;
