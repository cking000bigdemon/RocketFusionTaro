import { useUncontrolled } from "@taroify/hooks/index.js";
import { ScrollView, View } from "@tarojs/components";
import { nextTick, getEnv } from "@tarojs/taro";
import classNames from "classnames";
import _filter from "lodash/filter";
import _size from "lodash/size";
import _isDate from "lodash/isDate";
import _map from "lodash/map";
import * as React from "react";
import { Children, isValidElement, useEffect, useMemo, useRef, useState, } from "react";
import Popup from "../popup/index.js";
import { prefixClassname } from "../styles/index.js";
import { getRect } from "../utils/dom/rect.js";
import { getScrollTop } from "../utils/dom/scroll.js";
import { useRefs } from "../utils/state.js";
import raf from "../utils/raf.js";
import { useMemoizedFn } from "../hooks/index.js";
import CalendarFooter from "./calendar-footer.js";
import CalendarButton from "./calendar-button.js";
import CalendarHeader from "./calendar-header.js";
import CalendarMonth from "./calendar-month.js";
import CalendarContext from "./calendar.context.js";
import { compareDate, compareYearMonth, createNextDay, createPreviousDay, createToday, MAX_DATE, MIN_DATE, genMonthId, } from "./calendar.shared.js";
function defaultSubtitleRender(date) {
    return `${date.getFullYear()}年${date.getMonth() + 1}月`;
}
function defaultFormatter(day) {
    return day;
}
function Calendar(props) {
    const { className, style, title = "日期选择", subtitle = defaultSubtitleRender, showSubtitle = true, type = "single", poppable = false, showPopup = false, popupPlacement = "bottom", popupRounded = true, popupCloseIcon = true, showConfirm = true, confirmText = "确认", confirmDisabledText = "确认", defaultValue: defaultValueProp, value: valueProp, min: minValue = MIN_DATE, max: maxValue = MAX_DATE, firstDayOfWeek, readonly = false, watermark = true, formatter = defaultFormatter, children: childrenProp, onChange: onChangeProp, onConfirm, onClose, } = props;
    const scrollToDateLoadingRef = useRef(false);
    const Wrapper = useMemo(() => (poppable ? Popup : ({ children }) => React.createElement(React.Fragment, null, children)), [poppable]);
    const defaultValue = useMemo(() => getInitialDate(defaultValueProp), []);
    const { value, setValue } = useUncontrolled({
        defaultValue,
        value: valueProp,
        onChange: onChangeProp,
    });
    const renderFooter = () => {
        let _footer = null;
        Children.forEach(childrenProp, (child) => {
            if (isValidElement(child)) {
                const element = child;
                const { type: elementType } = element;
                if (elementType === CalendarFooter) {
                    _footer = element;
                }
            }
        });
        if (!_footer && showConfirm) {
            _footer = (React.createElement(CalendarFooter, null,
                React.createElement(CalendarButton, { type: "confirm", confirmText: confirmText, confirmDisabledText: confirmDisabledText })));
        }
        return _footer;
    };
    const scrollViewRef = useRef();
    const scrollViewHeightRef = useRef(0);
    const hasConfirmRef = useRef(false);
    const [currentMonth, setCurrentMonth] = useState();
    const changeValueRef = useRef();
    const [scrollIntoView, setScrollIntoView] = useState("");
    const { getRef: getMonthRef, getRefs: getMonthRefs, setRefs: setMonthRefs, clearRefs: clearMonthRefs, } = useRefs();
    const dayOffset = useMemo(() => (firstDayOfWeek ? +firstDayOfWeek % 7 : 0), [firstDayOfWeek]);
    const months = useMemo(() => {
        const months = [];
        const cursor = new Date(minValue);
        cursor.setDate(1);
        do {
            months.push(new Date(cursor));
            cursor.setMonth(cursor.getMonth() + 1);
        } while (compareYearMonth(cursor, maxValue) !== 1);
        return months;
    }, [maxValue, minValue]);
    function limitDateRange(date, minDate = minValue, maxDate = maxValue) {
        if (compareDate(date, minDate) === -1) {
            return minDate;
        }
        if (compareDate(date, maxDate) === 1) {
            return maxDate;
        }
        return date;
    }
    function getInitialDate(defaultDate) {
        if (defaultDate === null) {
            return defaultDate;
        }
        const now = createToday();
        let defaultDateCache = defaultDate;
        if (type === "range") {
            if (!Array.isArray(defaultDateCache)) {
                defaultDateCache = [];
            }
            const start = limitDateRange(defaultDateCache[0] || now, minValue, createPreviousDay(maxValue));
            const end = limitDateRange(defaultDateCache[1] || now, createNextDay(minValue));
            return [start, end];
        }
        if (type === "multiple") {
            if (Array.isArray(defaultDateCache)) {
                return defaultDateCache.map((date) => limitDateRange(date));
            }
            return [limitDateRange(now)];
        }
        if (!defaultDateCache || Array.isArray(defaultDateCache)) {
            defaultDateCache = now;
        }
        return limitDateRange(defaultDateCache);
    }
    function getDisabledDate(disabledDays, startDay, date) {
        return disabledDays.find((day) => compareDate(startDay, day.value) === -1 && compareDate(day.value, date) === -1)?.value;
    }
    function getDisabledDays() {
        return getMonthRefs().reduce((arr, ref) => {
            arr.push(...(ref.current?.disabledDays ?? []));
            return arr;
        }, []);
    }
    function change(dateValue, complete) {
        changeValueRef.current = dateValue;
        setValue?.(dateValue);
        if (complete && !hasConfirmRef.current) {
            onConfirm?.(dateValue);
        }
    }
    function onDayClick(day) {
        const { value: date } = day;
        if (readonly || !date) {
            return;
        }
        if (type === "range") {
            const disabledDays = getDisabledDays();
            if (!value) {
                change([date]);
                return;
            }
            const [startDay, endDay] = value;
            if (startDay && !endDay) {
                const compareToStart = compareDate(date, startDay);
                if (compareToStart === 1) {
                    const disabledDay = getDisabledDate(disabledDays, startDay, date);
                    if (disabledDay) {
                        change([startDay, createPreviousDay(disabledDay)]);
                    }
                    else {
                        change([startDay, date], true);
                    }
                }
                else if (compareToStart === -1) {
                    change([date]);
                }
                else {
                    change([date, date], true);
                }
            }
            else {
                change([date]);
            }
        }
        else if (type === "multiple") {
            if (!value) {
                change([date]);
                return;
            }
            const dates = value;
            const newDates = _filter(dates, (dateItem) => compareDate(dateItem, date) !== 0);
            if (_size(newDates) !== _size(dates)) {
                change(newDates);
            }
            else {
                change([...dates, date]);
            }
        }
        else {
            change(date, true);
        }
    }
    async function onScroll() {
        if (scrollToDateLoadingRef.current) {
            return;
        }
        const top = await getScrollTop(scrollViewRef);
        const bottom = top + scrollViewHeightRef.current;
        const heights = months.map((item, index) => getMonthRef(index).current.getHeight());
        const heightSum = heights.reduce((a, b) => a + b, 0);
        if (bottom > heightSum && top > 0) {
            return;
        }
        let height = 0;
        let currentMonthRef;
        for (let i = 0; i < months.length; i++) {
            const month = getMonthRef(i);
            const visible = height <= bottom && height + heights[i] >= top;
            if (visible && !currentMonthRef) {
                currentMonthRef = month;
                break;
            }
            height += heights[i];
        }
        if (currentMonthRef) {
            setCurrentMonth(currentMonthRef.current.getValue());
        }
    }
    async function scrollToDate(targetDate) {
        months.some((month, index) => {
            if (compareYearMonth(month, targetDate) === 0) {
                scrollToDateLoadingRef.current = true;
                const currentMonthRef = getMonthRef(index);
                const month = currentMonthRef.current.getValue();
                setCurrentMonth(month);
                if (getEnv() === "WEB") {
                    nextTick(() => {
                        if (scrollViewRef.current) {
                            Promise.all([
                                getRect(scrollViewRef),
                                getScrollTop(scrollViewRef),
                                currentMonthRef.current?.getRectTop(),
                            ]).then(([{ top: scrollViewRectTop }, currentScrollTop, currentMonthRectTop]) => {
                                const newBodyScrollTop = currentMonthRectTop - scrollViewRectTop + currentScrollTop;
                                scrollViewRef.current.scrollTop = newBodyScrollTop;
                                nextTick(() => {
                                    scrollToDateLoadingRef.current = false;
                                });
                            });
                        }
                    });
                }
                else {
                    setScrollIntoView(genMonthId(month));
                    nextTick(() => {
                        scrollToDateLoadingRef.current = false;
                    });
                }
                return true;
            }
            return false;
        });
    }
    async function scrollToCurrentDate(newValue) {
        if (poppable && !showPopup) {
            return;
        }
        if (newValue) {
            const targetDate = type === "single" ? newValue : newValue[0];
            if (_isDate(targetDate)) {
                scrollToDate(targetDate);
            }
        }
    }
    const reset = (date) => nextTick(() => scrollToCurrentDate(date).then());
    const init = useMemoizedFn(() => {
        if (poppable && !showPopup) {
            setScrollIntoView("");
            return;
        }
        raf(async () => {
            const bodyHeight = (await getRect(scrollViewRef)).height;
            scrollViewHeightRef.current = Math.floor(bodyHeight);
            reset(getInitialDate(value));
        });
    });
    useEffect(() => {
        if (value !== changeValueRef.current) {
            reset(getInitialDate(value));
        }
    }, [value]);
    useEffect(() => {
        reset(getInitialDate(value));
    }, [type, minValue, maxValue]);
    useEffect(() => {
        init();
    }, [showPopup]);
    const monthsRender = useMemo(() => {
        clearMonthRefs?.();
        return _map(months, (month, index) => (React.createElement(CalendarMonth, { ref: setMonthRefs(index), key: month.getTime(), value: month, showMonthTitle: index !== 0 || !showSubtitle, watermark: watermark })));
    }, [clearMonthRefs, months, setMonthRefs, watermark, showSubtitle]);
    function notifyConfirm(hasConfirm) {
        hasConfirmRef.current = hasConfirm;
    }
    function handleConfirm() {
        onConfirm?.(value);
    }
    return (React.createElement(CalendarContext.Provider, { value: {
            type,
            firstDayOfWeek: dayOffset,
            min: minValue,
            max: maxValue,
            value,
            formatter,
            onDayClick,
            notifyConfirm,
            onConfirm: handleConfirm,
        } },
        React.createElement(Wrapper, { rounded: popupRounded, placement: popupPlacement, open: showPopup, onClose: onClose, className: classNames(prefixClassname("calendar--popup")) },
            poppable && showPopup && popupCloseIcon && React.createElement(Popup.Close, null),
            React.createElement(View, { className: classNames(prefixClassname("calendar"), prefixClassname(`calendar--${type}`), className), style: style },
                React.createElement(CalendarHeader, { title: title, subtitle: subtitle, date: currentMonth, showSubtitle: showSubtitle }),
                React.createElement(ScrollView, { ref: scrollViewRef, className: prefixClassname("calendar__body"), scrollY: true, scrollIntoView: scrollIntoView, onScroll: onScroll }, monthsRender),
                renderFooter()))));
}
export default Calendar;
