import { useUncontrolled, useCascader } from "@taroify/hooks/index.js";
import { View, ScrollView } from "@tarojs/components";
import { nextTick } from "@tarojs/taro";
import classNames from "classnames";
import _size from "lodash/size";
import _isEmpty from "lodash/isEmpty";
import _isObject from "lodash/isObject";
import _slice from "lodash/slice";
import _isEqual from "lodash/isEqual";
import _map from "lodash/map";
import _get from "lodash/get";
import * as React from "react";
import { Children, isValidElement, useReducer, useMemo, useState, } from "react";
import { prefixClassname } from "../styles/index.js";
import Tabs from "../tabs/index.js";
import { useMemoizedFn } from "../hooks/index.js";
import CascaderHeader from "./cascader-header.js";
import CascaderOption from "./cascader-option.js";
import CascaderOptionBase from "./cascader-option-base.js";
import CascaderTab from "./cascader-tab.js";
import { isActiveOption, } from "./cascader.shared.js";
function getCascaderOptions(children, tabIndex) {
    const options = [];
    Children.forEach(children, (child) => {
        if (isValidElement(child)) {
            const element = child;
            const { key, props, type } = element;
            const { value, ...restProps } = props;
            if (type === CascaderOption) {
                const index = _size(options);
                options.push({
                    key: key ?? index,
                    tabIndex,
                    value: value ?? index,
                    ...restProps,
                });
            }
        }
    });
    return options;
}
function useCascaderChildren(children) {
    return useMemo(() => {
        const __children__ = {
            header: undefined,
            tabs: [],
        };
        Children.forEach(children, (child) => {
            if (isValidElement(child)) {
                const element = child;
                const { props, type } = element;
                if (type === CascaderHeader) {
                    __children__.header = element;
                }
                else if (type === CascaderTab) {
                    const { children } = props;
                    __children__.tabs.push({
                        options: getCascaderOptions(children, _size(__children__.tabs)),
                    });
                }
            }
        });
        return __children__;
    }, [children]);
}
const defaultFieldNames = {
    label: "label",
    value: "value",
    children: "children",
};
function Cascader(props) {
    const { className, defaultValue, value: valueProp, placeholder = "请选择", title, loadData, fieldNames: _fieldNames, animated = true, swipeable = false, ellipsis = true, children: childrenProp, options, onChange, onSelect, onTabClick, } = props;
    const [colRefreshKey, refreshKey] = useReducer((state) => state + 1, 0);
    const { value: values = [], setValue: setValues } = useUncontrolled({
        defaultValue,
        value: valueProp,
    });
    const fieldNames = useMemo(() => {
        if (!_isEmpty(_fieldNames) && _isObject(_fieldNames)) {
            return Object.assign({ ...defaultFieldNames }, _fieldNames);
        }
        return defaultFieldNames;
    }, [_fieldNames]);
    const { columns } = useCascader({
        options: options,
        value: values,
        fieldNames,
        refreshKey: colRefreshKey,
    });
    const { header: _header, tabs: _tab } = useCascaderChildren(childrenProp);
    const header = useMemo(() => (title ? React.createElement(CascaderHeader, null, title) : _header), [title, _header]);
    const [tabs, tabsMap] = useMemo(() => {
        let ret;
        const cache = new Map();
        if (columns.length > 0) {
            ret = columns.map((column, idx) => ({
                options: column.map((item) => ({
                    children: item[fieldNames.label],
                    key: item[fieldNames.value],
                    value: item[fieldNames.value],
                    disabled: item.disabled,
                    tabIndex: idx,
                })),
            }));
        }
        else {
            ret = _tab;
        }
        ret.forEach((r) => r.options?.forEach((rr) => cache.set(rr.value, rr)));
        return [ret, cache];
    }, [columns, _tab, fieldNames]);
    const [activeTab, setActiveTab] = useState(0);
    const renderedTabs = useMemo(() => _slice(tabs, 0, _size(values) + 1), [tabs, values]);
    const renderedOptions = useMemo(() => values.map((item) => tabsMap.get(item)), [tabsMap, values]);
    const emitChange = useMemoizedFn(async (newValues) => {
        const newActiveOptions = newValues.map((item) => tabsMap.get(item));
        onSelect?.(newValues, newActiveOptions);
        if (!_isEqual(newValues, valueProp)) {
            if (columns.length > 0) {
                let children;
                if (loadData) {
                    children = await loadData(newValues.slice(), newActiveOptions.slice());
                    const level = newValues.length - 1;
                    const selected = columns[level].find((item) => item[fieldNames.value] === newValues[level]);
                    if (selected) {
                        selected[fieldNames.children] = children;
                    }
                }
                else {
                    const last = columns[newValues.length - 1].find((item) => item[fieldNames.value] === newValues[newValues.length - 1]);
                    children = last?.[fieldNames.children];
                }
                if (!children || children.length === 0) {
                    onChange?.(newValues, newActiveOptions);
                }
                else {
                    nextTick(() => {
                        refreshKey();
                        setActiveTab((prev) => prev + 1);
                    });
                }
            }
            else {
                if (_size(tabs) === _size(newValues)) {
                    onChange?.(newValues, newActiveOptions);
                }
                else {
                    nextTick(() => {
                        setActiveTab((prev) => prev + 1);
                    });
                }
            }
        }
    });
    const handleSelect = useMemoizedFn((option) => {
        const { disabled, tabIndex, value } = option;
        if (disabled) {
            return;
        }
        const newValues = _slice(values, 0, tabIndex + 1);
        newValues[tabIndex] = value;
        setValues(newValues);
        emitChange(newValues.slice());
    });
    const panes = useMemo(() => _map(renderedTabs, (tab, index) => (React.createElement(Tabs.TabPane, { key: index, value: index, title: _get(renderedOptions, index)?.children ?? placeholder, classNames: {
            title: classNames(prefixClassname("cascader__tab"), {
                [prefixClassname("cascader__tab--inactive")]: _isEmpty(_get(renderedOptions, index)?.children),
            }),
        } },
        React.createElement(ScrollView, { scrollY: true, className: prefixClassname("cascader__options") }, _map(tab.options, (option) => {
            const { onClick, value, children, ...restProps } = option;
            return (React.createElement(CascaderOptionBase, { ...restProps, children: children ?? value, onClick: (event) => {
                    onClick?.(event);
                    handleSelect(option);
                }, active: isActiveOption(option, values) }));
        }))))), [renderedOptions, renderedTabs, handleSelect, placeholder, values]);
    return (React.createElement(View, { className: classNames(prefixClassname("cascader"), className) },
        header,
        React.createElement(Tabs, { className: prefixClassname("cascader__tabs"), value: activeTab, animated: animated, swipeable: swipeable, onChange: (value) => setActiveTab(value), onTabClick: onTabClick, children: panes, ellipsis: ellipsis })));
}
export default Cascader;
