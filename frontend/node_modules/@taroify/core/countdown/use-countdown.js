import { useCallback, useEffect, useMemo, useRef } from "react";
import { useMemoizedFn, useUpdate } from "../hooks/index.js";
import { cancelRaf, raf } from "../utils/raf.js";
import { useToRef } from "../utils/state.js";
const SECOND = 1000;
const MINUTE = 60 * SECOND;
const HOUR = 60 * MINUTE;
const DAY = 24 * HOUR;
function parseTime(time) {
    const days = Math.floor(time / DAY);
    const hours = Math.floor((time % DAY) / HOUR);
    const minutes = Math.floor((time % HOUR) / MINUTE);
    const seconds = Math.floor((time % MINUTE) / SECOND);
    const milliseconds = Math.floor(time % SECOND);
    return {
        total: time,
        days,
        hours,
        minutes,
        seconds,
        milliseconds,
    };
}
function isSameTime(time1, time2, interval) {
    return Math.floor(time1 / interval) === Math.floor(time2 / interval);
}
export default function useCountdown(options) {
    const { value: valueProp, autostart: autostartProp, interval: intervalOption = 1000, onChange, onComplete, } = options;
    const update = useUpdate();
    const intervalRef = useToRef(Math.max(intervalOption, 1));
    const valueRef = useToRef(valueProp);
    const autostartRef = useToRef(autostartProp);
    const rafIdRef = useRef();
    const statusRef = useRef();
    const endTimeRef = useRef(0);
    const remainRef = useRef(valueProp);
    const current = parseTime(remainRef.current);
    const currentRef = useToRef(current);
    const macroTick = useMemoizedFn(() => {
        rafIdRef.current = raf(() => {
            if (statusRef.current === "started") {
                const remain = Math.max(endTimeRef.current - Date.now(), 0);
                if (!isSameTime(remain, remainRef.current, intervalRef.current) || remain === 0) {
                    remainRef.current = remain;
                    update();
                    onChange?.(currentRef.current);
                    if (remain === 0) {
                        stop();
                        onComplete?.();
                    }
                }
                if (remainRef.current > 0) {
                    macroTick();
                }
            }
        });
    });
    const clearRaf = useCallback(() => {
        if (rafIdRef.current) {
            cancelRaf(rafIdRef.current);
        }
    }, []);
    const pause = useCallback(() => {
        clearRaf();
        statusRef.current = "paused";
    }, [clearRaf]);
    const stop = useCallback(() => {
        clearRaf();
        statusRef.current = "stopped";
    }, [clearRaf]);
    const start = useCallback(() => {
        if (statusRef.current !== "started") {
            endTimeRef.current =
                Date.now() + (statusRef.current === "paused" ? remainRef.current : valueRef.current);
            statusRef.current = "started";
            macroTick();
        }
    }, []);
    const autostart = useCallback(() => {
        if (autostartRef.current) {
            start();
        }
    }, []);
    const reset = useCallback(() => {
        stop();
        autostart();
    }, []);
    const restart = useCallback(() => {
        stop();
        start();
    }, []);
    useEffect(() => {
        autostart();
        return () => {
            stop();
        };
    }, []);
    useEffect(() => restart(), [valueProp]);
    return useMemo(() => ({
        current,
        start,
        reset,
        restart,
        pause,
        stop,
    }), [current, pause, reset, restart, start, stop]);
}
