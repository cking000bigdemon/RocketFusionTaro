import _isUndefined from "lodash/isUndefined";
import _clamp from "lodash/clamp";
import _slice from "lodash/slice";
import _isEmpty from "lodash/isEmpty";
import _concat from "lodash/concat";
import _map from "lodash/map";
import { useMemo } from "react";
const CURRENT_YEAR = new Date().getFullYear();
export const MIN_DATE = new Date(CURRENT_YEAR - 10, 0, 1, 0, 0, 0);
export const MAX_DATE = new Date(CURRENT_YEAR + 10, 11, 31, 59, 59, 59);
export function getEndDayOfMonth(year, month) {
    return 32 - new Date(year, month - 1, 32).getDate();
}
export function clampDate(value, minDate, maxDate) {
    if (_isUndefined(value)) {
        return minDate ?? maxDate;
    }
    const timestamp = _clamp(value.getTime(), minDate.getTime(), maxDate.getTime());
    return new Date(timestamp);
}
export function getDatetime(date) {
    return [
        date.getFullYear(),
        date.getMonth() + 1,
        date.getDate(),
        date.getHours(),
        date.getMinutes(),
        date.getSeconds(),
    ];
}
function getBoundaryDatetime(type, boundary, current) {
    const year = boundary.getFullYear();
    let month = 1;
    let day = 1;
    let hour = 0;
    let minute = 0;
    let second = 0;
    if (type === "max") {
        month = 12;
        day = getEndDayOfMonth(current.getFullYear(), current.getMonth() + 1);
        hour = 23;
        minute = 59;
        second = 59;
    }
    if (current.getFullYear() === year) {
        month = boundary.getMonth() + 1;
        if (current.getMonth() + 1 === month) {
            day = boundary.getDate();
            if (current.getDate() === day) {
                hour = boundary.getHours();
                if (current.getHours() === hour) {
                    minute = boundary.getMinutes();
                    if (current.getMinutes() === minute) {
                        second = boundary.getSeconds();
                    }
                }
            }
        }
    }
    return [year, month, day, hour, minute, second];
}
function getMinDatetime(boundary, current) {
    return getBoundaryDatetime("min", boundary, current);
}
function getMaxDatetime(boundary, current) {
    return getBoundaryDatetime("max", boundary, current);
}
function useAllDatetimeRanges(date, minDate, maxDate) {
    const [minYear, minMonth, minDay, minHour, minMinute, minSecond] = getMinDatetime(minDate, date ?? minDate);
    const [maxYear, maxMonth, maxDay, maxHour, maxMinute, maxSecond] = getMaxDatetime(maxDate, date ?? minDate);
    return useMemo(() => [
        {
            type: "year",
            range: [minYear, maxYear],
        },
        {
            type: "month",
            range: [minMonth, maxMonth],
        },
        {
            type: "day",
            range: [minDay, maxDay],
        },
        {
            type: "hour",
            range: [minHour, maxHour],
        },
        {
            type: "minute",
            range: [minMinute, maxMinute],
        },
        {
            type: "second",
            range: [minSecond, maxSecond],
        },
    ], [
        maxDay,
        maxHour,
        maxMinute,
        maxMonth,
        maxSecond,
        maxYear,
        minDay,
        minHour,
        minMinute,
        minMonth,
        minSecond,
        minYear,
    ]);
}
function useSpecifiedDatetimeRanges(ranges, type) {
    return useMemo(() => {
        switch (type) {
            case "date":
                return _slice(ranges, 0, 3);
            case "time":
                return _slice(ranges, 3, 6);
            case "year-month":
                return _slice(ranges, 0, 2);
            case "month-day":
                return _slice(ranges, 1, 3);
            case "date-hour":
                return _slice(ranges, 0, 4);
            case "date-minute":
                return _slice(ranges, 0, 5);
            case "hour-minute":
                return _slice(ranges, 3, 5);
        }
        return ranges;
    }, [ranges, type]);
}
function useOrderedDatetimeRanges(ranges, fields) {
    return useMemo(() => {
        if (_isEmpty(fields)) {
            return ranges;
        }
        const fieldsOrder = _concat(fields, _map(ranges, ({ type }) => type));
        return ranges.sort((a, b) => fieldsOrder.indexOf(a.type) - fieldsOrder.indexOf(b.type));
    }, [fields, ranges]);
}
export function useDatetimeRanges(date, minDate, maxDate, type, fields) {
    const allRanges = useAllDatetimeRanges(date, minDate, maxDate);
    const specifiedRanges = useSpecifiedDatetimeRanges(allRanges, type);
    return useOrderedDatetimeRanges(specifiedRanges, fields);
}
