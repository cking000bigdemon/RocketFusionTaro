import _map from "lodash/map";
import _times from "lodash/times";
import _padStart from "lodash/padStart";
import _forEach from "lodash/forEach";
import _size from "lodash/size";
import _toNumber from "lodash/toNumber";
import _isUndefined from "lodash/isUndefined";
import _toString from "lodash/toString";
import { useMemo } from "react";
import { clampDate, getDatetime, getEndDayOfMonth, MAX_DATE, MIN_DATE, useDatetimeRanges, } from "./datetime-picker.shared.js";
const defaultFormatter = (type, value) => value;
export function useDatetimePicker(options = {}) {
    const { defaultValue = undefined, value = undefined, min: minDate = MIN_DATE, max: maxDate = MAX_DATE, type = "datetime", fields = [], filter, formatter = defaultFormatter, } = options;
    const clampDefaultValue = clampDate(defaultValue, minDate, maxDate);
    const clampValue = clampDate(value ?? defaultValue, minDate, maxDate);
    const ranges = useDatetimeRanges(clampValue, minDate, maxDate, type, fields);
    const columns = useMemo(() => _map(ranges, ({ type, range }) => {
        let values = _times(range[1] - range[0] + 1, (index) => _padStart(`${range[0] + index}`, 2, "0"));
        if (filter) {
            values = filter(type, values);
        }
        const children = _map(values, (value) => ({
            value,
            children: formatter(type, value),
        }));
        return {
            type,
            value: type,
            children,
        };
    }), [filter, formatter, ranges]);
    function toDate(datetimeValue) {
        const date = new Date(minDate.getTime());
        _forEach(columns, ({ type }, index) => {
            switch (type) {
                case "year":
                    if (_size(datetimeValue) > index) {
                        date.setFullYear(_toNumber(datetimeValue[index]));
                    }
                    break;
                case "month":
                    date.setDate(1);
                    if (_size(datetimeValue) > index) {
                        date.setMonth(_toNumber(datetimeValue[index]) - 1);
                    }
                    break;
                case "day":
                    if (_size(datetimeValue) > index) {
                        const endDayOfMonth = getEndDayOfMonth(date.getFullYear(), date.getMonth() + 1);
                        const day = _toNumber(datetimeValue[index]);
                        date.setDate(day > endDayOfMonth ? endDayOfMonth : day);
                    }
                    break;
                case "hour":
                    if (_size(datetimeValue) > index) {
                        date.setHours(_toNumber(datetimeValue[index]));
                    }
                    break;
                case "minute":
                    if (_size(datetimeValue) > index) {
                        date.setMinutes(_toNumber(datetimeValue[index]));
                    }
                    break;
                case "second":
                    if (_size(datetimeValue) > index) {
                        date.setSeconds(_toNumber(datetimeValue[index]));
                    }
                    break;
            }
        });
        return clampDate(date, minDate, maxDate);
    }
    function toValue(date) {
        if (_isUndefined(date)) {
            return date;
        }
        const [year, month, day, hour, minute, second] = getDatetime(date);
        return _map(columns, (column) => {
            switch (column.type) {
                case "year":
                    return _toString(year);
                case "month":
                    return _padStart(_toString(month), 2, "0");
                case "day":
                    return _padStart(_toString(day), 2, "0");
                case "hour":
                    return _padStart(_toString(hour), 2, "0");
                case "minute":
                    return _padStart(_toString(minute), 2, "0");
                case "second":
                    return _padStart(_toString(second), 2, "0");
                default:
                    return "";
            }
        });
    }
    return {
        toDate,
        defaultValue: toValue(_isUndefined(defaultValue) ? defaultValue : clampDefaultValue),
        value: toValue(_isUndefined(value) ? value : clampValue),
        columns,
    };
}
export default useDatetimePicker;
