import { useUncontrolled } from "@taroify/hooks/index.js";
import classNames from "classnames";
import * as React from "react";
import { Children, cloneElement, isValidElement, useCallback, useContext, useEffect, useMemo, useState, } from "react";
import Backdrop from "../backdrop/index.js";
import { createButton } from "../button/index.js";
import ButtonContext from "../button/button.context.js";
import Popup, { usePopupBackdrop } from "../popup/index.js";
import { prefixClassname } from "../styles/index.js";
import { getElementSelector, matchSelector, prependPageSelector, usePrependPageSelector, } from "../utils/dom/element.js";
import { useObject, useToRef } from "../utils/state.js";
import { isElementOf } from "../utils/validate/index.js";
import { useMemoizedFn } from "../hooks/index.js";
import DialogActions from "./dialog-actions.js";
import DialogContent from "./dialog-content.js";
import DialogHeader from "./dialog-header.js";
import { dialogEvents, dialogSelectorSet, } from "./dialog.shared.js";
export function useDialogOpen(cb) {
    useEffect(() => {
        dialogEvents.on("open", cb);
        return () => {
            dialogEvents.off("open", cb);
        };
    }, []);
}
export function useDialogCancel(cb) {
    useEffect(() => {
        dialogEvents.on("cancel", cb);
        return () => {
            dialogEvents.off("cancel", cb);
        };
    }, []);
}
function useDialogChildren(nodes) {
    return useMemo(() => {
        const __children__ = {
            header: undefined,
            content: undefined,
            actions: undefined,
        };
        if (nodes === undefined) {
            return __children__;
        }
        Children.forEach(nodes, (node) => {
            if (!isValidElement(node)) {
                return;
            }
            const { header, content, actions } = __children__;
            if (header !== undefined && content !== undefined && actions !== undefined) {
                return;
            }
            const element = node;
            if (isElementOf(element, Backdrop)) {
                __children__.backdrop = element;
            }
            else if (element.type === DialogHeader) {
                __children__.header = element;
            }
            else if (element.type === DialogContent) {
                __children__.content = element;
            }
            else if (element.type === DialogActions) {
                __children__.actions = element;
            }
        });
        return __children__;
    }, [nodes]);
}
function renderDialogHeader(header, props) {
    if (!isValidElement(header)) {
        return header;
    }
    return cloneElement(header, props);
}
function renderDialogContent(content, props) {
    if (!isValidElement(content)) {
        return content;
    }
    return cloneElement(content, props);
}
function renderHeader(title, key) {
    if (title === undefined) {
        return null;
    }
    return React.createElement(DialogHeader, { key: key, children: title });
}
function renderContent(message, messageAlign, key) {
    return React.createElement(DialogContent, { key: key, align: messageAlign, children: message });
}
function renderActions(confirm, cancel, variant, confirmLoading, cancelLoading, key) {
    if (cancel === undefined && confirm === undefined) {
        return null;
    }
    const actions = [];
    if (cancel) {
        actions.push(createButton(cancel, { key: 1, loading: cancelLoading }));
    }
    if (confirm) {
        actions.push(createButton(confirm, { key: 0, loading: confirmLoading }));
    }
    return React.createElement(DialogActions, { key: key, children: actions, variant: variant });
}
const transactionTimeout = {
    enter: 100,
    exit: 300,
    appear: 100,
};
function Dialog(props) {
    const { object: { id, className, defaultOpen, open: openProp, children, backdrop: backdropOptions = { closeable: false }, title: titleProp, message: messageProp, messageAlign: messageAlignProp, theme: themeProp, confirm: confirmProp, cancel: cancelProp, onBeforeClose: onBeforeCloseProp, onClose, onConfirm: onConfirmProp, onCancel: onCancelProp, ...restProps }, setObject, } = useObject(props);
    const rootSelectorRef = useToRef(usePrependPageSelector(getElementSelector(id)));
    const { value: open = false, setValue: setOpen } = useUncontrolled({
        defaultValue: defaultOpen,
        value: openProp,
    });
    const [confirmLoading, setConfirmLoading] = useState(false);
    const [cancelLoading, setCancelLoading] = useState(false);
    const { onClick } = useContext(ButtonContext);
    const { backdrop: backdropElement, header: headerChildren, content: contentChildren, actions: actionsChildren, } = useDialogChildren(children);
    const backdrop = usePopupBackdrop(backdropElement, backdropOptions);
    const header = useMemo(() => headerChildren ?? renderHeader(titleProp), [headerChildren, titleProp]);
    const content = useMemo(() => contentChildren ?? renderContent(messageProp, messageAlignProp), [contentChildren, messageProp, messageAlignProp]);
    const actions = useMemo(() => actionsChildren ??
        renderActions(confirmProp, cancelProp, themeProp, confirmLoading, cancelLoading), [actionsChildren, confirmProp, cancelProp, themeProp, confirmLoading, cancelLoading]);
    const onConfirm = useMemoizedFn(async () => {
        try {
            let boolean = true;
            if (onBeforeCloseProp) {
                setConfirmLoading(true);
                boolean = await onBeforeCloseProp("confirm");
                setConfirmLoading(false);
            }
            if (boolean) {
                onConfirmProp?.();
                setOpen(false);
            }
        }
        catch (err) {
            console.error(err);
        }
    });
    const onCancel = useMemoizedFn(async () => {
        try {
            let boolean = true;
            if (onBeforeCloseProp) {
                setCancelLoading(true);
                boolean = await onBeforeCloseProp("cancel");
                setCancelLoading(false);
            }
            if (boolean) {
                onCancelProp?.();
                setOpen(false);
            }
        }
        catch (err) {
            console.error(err);
        }
    });
    const hasHeader = header !== undefined;
    const hasContent = content !== undefined;
    const handleClick = (event, btnProps) => {
        onClick?.(event, btnProps);
        const { className } = btnProps;
        if (className?.includes(prefixClassname("dialog__confirm"))) {
            onConfirm();
        }
        else if (className?.includes(prefixClassname("dialog__cancel"))) {
            onCancel();
        }
        else {
            setOpen(false);
        }
    };
    const handleClose = useCallback((opened) => {
        onClose?.(opened);
        setOpen(false);
    }, [onClose, setOpen]);
    const { selector } = useMemo(() => {
        return {
            selector: props?.id
                ? prependPageSelector(getElementSelector(props?.id))
                : prependPageSelector(`${getElementSelector(id)}`),
        };
    }, [id, props?.id]);
    useEffect(() => {
        if (selector) {
            dialogSelectorSet.add(selector);
            return () => {
                dialogSelectorSet.delete(selector);
            };
        }
        return undefined;
    }, [selector]);
    useDialogOpen(({ selector, title, message, messageAlign, confirm, cancel, theme, ...restOptions }) => {
        if (matchSelector(prependPageSelector(selector), rootSelectorRef.current)) {
            const children = [];
            if (title) {
                children.push(renderHeader(title, 0));
            }
            if (message) {
                children.push(renderContent(message, messageAlign, 1));
            }
            children.push(renderActions(confirm, cancel, theme, false, false, 2));
            setObject({
                children,
                ...restOptions,
            });
            setOpen(true);
        }
    });
    useDialogCancel((selector) => {
        if (matchSelector(prependPageSelector(selector), rootSelectorRef.current)) {
            onCancel();
            setOpen(false);
        }
    });
    return (React.createElement(ButtonContext.Provider, { value: {
            onClick: handleClick,
        } },
        React.createElement(Popup, { id: id, open: open, className: classNames(prefixClassname("dialog"), className), transaction: prefixClassname("dialog-bounce"), transactionTimeout: transactionTimeout, onClose: handleClose, ...restProps },
            backdrop,
            renderDialogHeader(header, {
                isolated: hasHeader && !hasContent,
            }),
            renderDialogContent(content, {
                isolated: !hasHeader && hasContent,
            }),
            actions)));
}
export default Dialog;
