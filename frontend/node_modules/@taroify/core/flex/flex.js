import { View } from "@tarojs/components";
import classNames from "classnames";
import _isNumber from "lodash/isNumber";
import _isString from "lodash/isString";
import _toNumber from "lodash/toNumber";
import _isArray from "lodash/isArray";
import * as React from "react";
import { Children, cloneElement, useMemo, forwardRef, isValidElement, } from "react";
import { prefixClassname } from "../styles/index.js";
import { addUnitPx } from "../utils/format/unit.js";
import FlexContext from "./flex.context.js";
function useFlexGutter(gutter) {
    return useMemo(() => {
        if (gutter === undefined) {
            return [undefined, undefined];
        }
        if (_isNumber(gutter)) {
            return [gutter, gutter];
        }
        if (_isString(gutter)) {
            const gutterNumber = _toNumber(gutter);
            return [gutterNumber, gutterNumber];
        }
        if (_isArray(gutter)) {
            const [horizontalGutter, verticalGutter] = gutter;
            return [_toNumber(horizontalGutter), _toNumber(verticalGutter)];
        }
        return [0, 0];
    }, [gutter]);
}
const Flex = forwardRef((props, ref) => {
    const { className, style, gutter: gutterProp, direction = "row", wrap = "nowrap", justify = "start", align = "start", children: childrenProp, ...restProps } = props;
    const gutter = useFlexGutter(gutterProp);
    const [horizontalGutter] = gutter;
    const gutterStyle = useMemo(() => {
        const gutterStyle = {};
        if (horizontalGutter) {
            const averagePadding = _toNumber(horizontalGutter) / 2;
            gutterStyle.marginLeft = addUnitPx(-averagePadding);
            gutterStyle.marginRight = addUnitPx(-averagePadding);
        }
        return {};
    }, [horizontalGutter]);
    const rowStyle = useMemo(() => {
        const rowStyle = {};
        if (horizontalGutter) {
            const averageMargin = _toNumber(horizontalGutter) / 2;
            rowStyle.marginLeft = addUnitPx(-averageMargin);
            rowStyle.marginRight = addUnitPx(-averageMargin);
        }
        return rowStyle;
    }, [horizontalGutter]);
    const children = useMemo(() => Children.map(childrenProp, (item, index) => {
        return isValidElement(item)
            ? cloneElement(item, {
                __dataIndex__: index,
            })
            : item;
    }), [childrenProp]);
    return (React.createElement(View, { ref: ref, className: classNames(prefixClassname("flex"), {
            [prefixClassname("flex--row")]: direction === "row",
            [prefixClassname("flex--row-reverse")]: direction === "row-reverse",
            [prefixClassname("flex--column")]: direction === "column",
            [prefixClassname("flex--column-reverse")]: direction === "column-reverse",
            [prefixClassname("flex--nowrap")]: wrap === "nowrap",
            [prefixClassname("flex--wrap")]: wrap === "wrap",
            [prefixClassname("flex--wrap-reverse")]: wrap === "wrap-reverse",
            [prefixClassname("flex--justify-start")]: justify === "start",
            [prefixClassname("flex--justify-center")]: justify === "center",
            [prefixClassname("flex--justify-end")]: justify === "end",
            [prefixClassname("flex--justify-space-around")]: justify === "space-around",
            [prefixClassname("flex--justify-space-between")]: justify === "space-between",
            [prefixClassname("flex--align-start")]: align === "start",
            [prefixClassname("flex--align-center")]: align === "center",
            [prefixClassname("flex--align-end")]: align === "end",
            [prefixClassname("flex--align-baseline")]: align === "baseline",
            [prefixClassname("flex--align-stretch")]: align === "stretch",
        }, className), style: {
            ...style,
            ...gutterStyle,
            ...rowStyle,
        }, ...restProps },
        React.createElement(FlexContext.Provider, { value: {
                gutter,
            }, children: children })));
});
export default Flex;
