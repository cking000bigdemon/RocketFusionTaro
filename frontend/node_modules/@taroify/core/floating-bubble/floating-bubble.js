import * as React from "react";
import { useMemo, useRef, useState, useEffect, } from "react";
import { getWindowInfo, nextTick } from "@tarojs/taro";
import { View } from "@tarojs/components";
import { cloneIconElement, isIconElement } from "@taroify/icons/utils/index.js";
import classNames from "classnames";
import { addUnitPx } from "../utils/format/unit.js";
import { getRect } from "../utils/dom/rect.js";
import { preventDefault } from "../utils/dom/event.js";
import { useTouch } from "../utils/touch.js";
import { closest } from "../utils/closest.js";
import { prefixClassname } from "../styles/index.js";
const FloatingBubble = (props) => {
    const { className, style: styleProp, icon, gap = 24, axis = "y", magnetic, offset = { x: -1, y: -1 }, onClick: onClickProp, onOffsetChange, } = props;
    const touch = useTouch();
    const contentRef = useRef();
    const [stateVal, setStateVal] = useState({ x: 0, y: 0, width: 0, height: 0 });
    const [dragging, setDragging] = useState(false);
    const initialized = useRef(false);
    const prevX = useRef(0);
    const prevY = useRef(0);
    const windowHeight = useMemo(() => getWindowInfo().windowHeight, []);
    const windowWidth = useMemo(() => getWindowInfo().windowWidth, []);
    const boundary = useMemo(() => {
        return {
            top: gap,
            right: windowWidth - stateVal.width - gap,
            bottom: windowHeight - stateVal.height - gap,
            left: gap,
        };
    }, [gap, stateVal.height, stateVal.width, windowHeight, windowWidth]);
    const rootStyle = useMemo(() => {
        const style = {};
        const x = addUnitPx(stateVal.x);
        const y = addUnitPx(stateVal.y);
        style.transform = `translate3d(${x}, ${y}, 0)`;
        if (dragging || !initialized) {
            style.transition = "none";
        }
        return style;
    }, [dragging, stateVal.x, stateVal.y]);
    const updateState = async () => {
        const { width, height } = await getRect(contentRef.current);
        setStateVal({
            x: offset.x > -1 ? offset.x : windowWidth - width - gap,
            y: offset.y > -1 ? offset.y : windowHeight - height - gap,
            width,
            height,
        });
    };
    const onTouchStart = (event) => {
        touch.start(event);
        setDragging(true);
        prevX.current = stateVal.x;
        prevY.current = stateVal.y;
    };
    const onTouchMove = (event) => {
        preventDefault(event, true);
        touch.move(event);
        if (axis === "lock")
            return;
        if (!touch.isTap) {
            if (axis === "x") {
                let nextX = prevX.current + touch.deltaX;
                if (nextX < boundary.left)
                    nextX = boundary.left;
                if (nextX > boundary.right)
                    nextX = boundary.right;
                setStateVal({
                    ...stateVal,
                    x: nextX,
                });
            }
            if (axis === "y") {
                let nextY = prevY.current + touch.deltaY;
                if (nextY < boundary.top)
                    nextY = boundary.top;
                if (nextY > boundary.bottom)
                    nextY = boundary.bottom;
                setStateVal({
                    ...stateVal,
                    y: nextY,
                });
            }
            if (axis === "xy") {
                let nextX = prevX.current + touch.deltaX;
                if (nextX < boundary.left)
                    nextX = boundary.left;
                if (nextX > boundary.right)
                    nextX = boundary.right;
                let nextY = prevY.current + touch.deltaY;
                if (nextY < boundary.top)
                    nextY = boundary.top;
                if (nextY > boundary.bottom)
                    nextY = boundary.bottom;
                setStateVal({
                    ...stateVal,
                    x: nextX,
                    y: nextY,
                });
            }
        }
    };
    const onTouchEnd = () => {
        setDragging(false);
        nextTick(() => {
            if (magnetic === "x") {
                const nextX = closest([boundary.left, boundary.right], stateVal.x);
                setStateVal({
                    ...stateVal,
                    x: nextX,
                });
            }
            if (magnetic === "y") {
                const nextY = closest([boundary.top, boundary.bottom], stateVal.y);
                setStateVal({
                    ...stateVal,
                    y: nextY,
                });
            }
            if (!touch.isTap) {
                if (prevX.current !== stateVal.x || prevY.current !== stateVal.y) {
                    onOffsetChange?.(stateVal.x, stateVal.y);
                }
            }
        });
    };
    const onClick = (event) => {
        if (touch.isTap)
            onClickProp?.(event);
        else
            preventDefault(event, true);
    };
    useEffect(() => {
        updateState();
        nextTick(() => {
            initialized.current = true;
        });
    }, []);
    useEffect(() => {
        updateState();
    }, [windowWidth, windowHeight, gap, offset.y, offset.x]);
    return (React.createElement(View, { className: classNames(prefixClassname("floating-bubble"), className), ref: contentRef, style: {
            ...rootStyle,
            ...styleProp,
        }, onTouchStart: onTouchStart, onTouchMove: onTouchMove, onTouchEnd: onTouchEnd, onTouchCancel: onTouchEnd, onClick: onClick }, icon && isIconElement(icon)
        ? cloneIconElement(icon, { className: prefixClassname("floating-bubble__icon") })
        : icon));
};
export default FloatingBubble;
