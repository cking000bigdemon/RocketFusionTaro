import { cloneIconElement } from "@taroify/icons/utils/index.js";
import { View } from "@tarojs/components";
import classNames from "classnames";
import _isFunction from "lodash/isFunction";
import _isEmpty from "lodash/isEmpty";
import _map from "lodash/map";
import * as React from "react";
import { Children, cloneElement, isValidElement, forwardRef, useCallback, useContext, useImperativeHandle, useMemo, } from "react";
import { CellBase, CellValue } from "../cell/index.js";
import { iconMap } from "../cell/cell-base.js";
import Form, { useFormField, useFormValue } from "../form/index.js";
import FormContext from "../form/form.context.js";
import { prefixClassname } from "../styles/index.js";
import { fulfillPromise } from "../utils/promisify.js";
import { useToRef } from "../utils/state.js";
import { isElementOf } from "../utils/validate/index.js";
import FormFeedback from "./form-feedback.js";
import FormItemContext from "./form-item.context.js";
import { validateRules } from "./form.rule.js";
import useFormError from "./use-form-error.js";
import useFormFieldValueEffect from "./use-form-field-value-effect.js";
import { useDependenciesChange, useShouldUpdateSignal } from "./use-form-item.js";
function useFormItemChildren(childrenProps, shouldUpdateSignal, noStyle) {
    return useMemo(() => {
        if (noStyle) {
            if (_isFunction(childrenProps)) {
                const children = childrenProps();
                return {
                    children: isValidElement(children) ? children : undefined,
                };
            }
            else {
                console.warn('[Taroify] FormItem(noStyle): "children" should be function');
                return {};
            }
        }
        const __children__ = {
            feedbacks: [],
        };
        const children = _isFunction(childrenProps) ? childrenProps() : childrenProps;
        Children.forEach(children, (child) => {
            if (!isValidElement(child)) {
                return;
            }
            if (isElementOf(child, Form.Label)) {
                __children__.label = child;
            }
            else if (isElementOf(child, Form.Control)) {
                __children__.control = child;
            }
            else if (isElementOf(child, Form.Feedback)) {
                __children__.feedbacks?.push(child);
            }
        });
        return __children__;
    }, [childrenProps, shouldUpdateSignal, noStyle]);
}
const FormItem = forwardRef((props, ref) => {
    const { className, style, name, defaultValue, align, bordered, icon, rightIcon: rightIconProp, size, isLink = false, arrowDirection = "right", clickable, required, children: childrenProp, rules: rulesProp, dependencies, shouldUpdate, noStyle, disabled: disabledProp, validateFirst = false, onClick, } = props;
    const shouldUpdateSignal = useShouldUpdateSignal(shouldUpdate);
    const { label, control, feedbacks, children } = useFormItemChildren(childrenProp, shouldUpdateSignal, noStyle);
    const rightIcon = useMemo(() => {
        if (rightIconProp) {
            return cloneIconElement(rightIconProp, {
                className: prefixClassname("form-item__right-icon"),
            });
        }
        else if (isLink && iconMap[arrowDirection]) {
            const Icon = iconMap[arrowDirection];
            return React.createElement(Icon, { className: prefixClassname("form-item__right-icon") });
        }
        return null;
    }, [rightIconProp, isLink, arrowDirection]);
    const rulesRef = useToRef(rulesProp);
    const { validateTrigger, disabled: disabledContext } = useContext(FormContext);
    const disabled = disabledProp ?? disabledContext;
    const { validateStatus, error, setError, resetError } = useFormError(name);
    const { value, getValue, setValue } = useFormValue(name, { defaultValue });
    const validate = useCallback((rules = rulesRef.current) => {
        return new Promise((resolve, reject) => {
            if (rules) {
                resetError();
                validateRules(getValue(), rules, validateFirst)
                    .then((errors) => {
                    if (_isEmpty(errors)) {
                        resetError();
                        resolve();
                    }
                    else {
                        setError({ errors });
                        reject({
                            name,
                            errors,
                        });
                    }
                });
            }
            else {
                resolve();
            }
        });
    }, [getValue, name, resetError, rulesRef, setError]);
    const validateWithTrigger = useCallback((trigger) => {
        if (validateTrigger && rulesProp) {
            const defaultTrigger = validateTrigger === trigger;
            const rules = rulesProp.filter((rule) => {
                if (rule.trigger) {
                    return rule.trigger === trigger;
                }
                return defaultTrigger;
            });
            if (rules.length) {
                fulfillPromise(validate(rules));
            }
            else if (defaultTrigger) {
                resetError();
            }
        }
    }, [resetError, rulesProp, validate, validateTrigger]);
    const instance = useMemo(() => ({
        name,
        validate,
        getValue,
        setValue,
    }), [getValue, name, setValue, validate]);
    useImperativeHandle(ref, () => instance, [instance]);
    useFormField(name, instance);
    useFormFieldValueEffect(() => validateWithTrigger("onChange"), [value]);
    useDependenciesChange(dependencies, () => fulfillPromise(validate()));
    const explain = useMemo(() => !_isEmpty(feedbacks) || !_isEmpty(error?.errors), [error?.errors, feedbacks]);
    const Control = useMemo(() => control &&
        cloneElement(control, {
            name,
            value,
            disabled,
            onBlur: () => validateWithTrigger("onBlur"),
            onChange: setValue,
        }), [control, name, setValue, validateWithTrigger, value, disabled]);
    if (noStyle) {
        return (React.createElement(FormItemContext.Provider, { value: {
                validateStatus,
            } }, children));
    }
    return (React.createElement(FormItemContext.Provider, { value: {
            validateStatus,
        } },
        React.createElement(CellBase, { className: classNames(prefixClassname("form-item"), className), style: style, bordered: bordered, align: align, clickable: clickable, size: size, icon: cloneIconElement(icon, { className: prefixClassname("form-item__icon") }), rightIcon: rightIcon, required: required, ...(onClick && { onClick }) },
            label,
            React.createElement(CellValue, { alone: false },
                Control,
                explain && (React.createElement(View, { className: classNames(prefixClassname("form__feedbacks")) },
                    feedbacks,
                    _map(error?.errors, (message, messageKey) => (React.createElement(FormFeedback, { key: messageKey, status: "invalid", children: message })))))))));
});
export default FormItem;
