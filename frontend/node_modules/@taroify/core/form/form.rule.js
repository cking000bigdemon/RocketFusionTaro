import _isFunction from "lodash/isFunction";
import _isBoolean from "lodash/isBoolean";
import _isError from "lodash/isError";
import _isString from "lodash/isString";
import { isPromise } from "../utils/promisify.js";
function isEmptyValue(value) {
    if (Array.isArray(value)) {
        return !value.length;
    }
    if (value === 0) {
        return false;
    }
    return !value;
}
function getRuleMessage(value, rule) {
    const { message } = rule;
    if (_isFunction(message)) {
        return message(value, rule);
    }
    return message;
}
function getSyncRule(value, rule) {
    if (rule.required && isEmptyValue(value)) {
        return Promise.resolve(getRuleMessage(value, rule));
    }
    if (rule.pattern && !rule.pattern.test(String(value))) {
        return Promise.resolve(getRuleMessage(value, rule));
    }
}
function getValidatorRule(value, rule) {
    function obtainInvalidMessage(error) {
        if (_isBoolean(error) && !error) {
            return getRuleMessage(value, rule);
        }
        if (_isError(error)) {
            return error.message;
        }
        return error;
    }
    return new Promise((resolve) => {
        const promise = rule.validator?.(value, rule);
        if (isPromise(promise)) {
            promise.then(obtainInvalidMessage).catch(obtainInvalidMessage).then(resolve);
        }
        else {
            resolve(obtainInvalidMessage(promise));
        }
    });
}
function validateRule(value, rule) {
    return getSyncRule(value, rule) ?? getValidatorRule(value, rule);
}
export function validateRules(value, rules, validateFirst) {
    return rules.reduce((promise, rule) => promise.then((errors) => {
        if (validateFirst && errors.length > 0) {
            return errors;
        }
        let formattedValue = value;
        if (rule.formatter) {
            formattedValue = rule.formatter(value, rule);
        }
        return validateRule(formattedValue, rule).then((error) => {
            if (_isString(error)) {
                errors.push(error);
            }
            return errors;
        });
    }), Promise.resolve([]));
}
