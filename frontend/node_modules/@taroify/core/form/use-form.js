import { Events } from "@tarojs/taro";
import _filter from "lodash/filter";
import _isUndefined from "lodash/isUndefined";
import _isArray from "lodash/isArray";
import _isEmpty from "lodash/isEmpty";
import _reduce from "lodash/reduce";
import _get from "lodash/get";
import _forEach from "lodash/forEach";
import _isEqual from "lodash/isEqual";
import _set from "lodash/set";
import _cloneDeep from "lodash/cloneDeep";
import _includes from "lodash/includes";
import _toArray from "lodash/toArray";
import _isPlainObject from "lodash/isPlainObject";
import { useEffect, useMemo, useState } from "react";
import { getLogger } from "../utils/logger.js";
import { useToRef } from "../utils/state.js";
import { validateAll } from "./form.validate.js";
const { warn } = getLogger("useForm");
const containerForms = new Map();
const containerFormRefs = new Map();
function toMapValueArray(map) {
    const array = [];
    map?.forEach((value) => array.push(value));
    return array;
}
function getAttributiveForm(formName) {
    return containerForms.get(formName);
}
class FormAttributes {
    #fields = new Map();
    #inFormListFields = new Map();
    #defaultValues = {};
    #values = {};
    #errors = {};
    #events = new Events();
    get fields() {
        return this.#fields;
    }
    get inFormListFields() {
        return this.#inFormListFields;
    }
    get defaultValues() {
        return this.#defaultValues;
    }
    set defaultValues(defaultValues) {
        this.#defaultValues = defaultValues;
    }
    get values() {
        return this.#values;
    }
    set values(value) {
        this.#values = value;
    }
    get errors() {
        return this.#errors;
    }
    set errors(errors) {
        this.#errors = errors;
    }
    addEventListener(event, listener) {
        this.#events?.on(event, listener);
    }
    removeEventListener(event, listener) {
        this.#events?.off(event, listener);
    }
    emitEvent(event, ...args) {
        this.#events.trigger(event, ...args);
    }
    findFields(predicate) {
        const fields = toMapValueArray(this.fields);
        const inFormListFields = toMapValueArray(this.#inFormListFields);
        return _filter(fields.concat(inFormListFields), predicate);
    }
    addField(name, field, inFormList) {
        if (inFormList) {
            this.#inFormListFields.set(name, field);
        }
        else {
            this.#fields.set(name, field);
        }
    }
    removeField(name, inFormList) {
        if (inFormList) {
            this.#inFormListFields.delete(name);
        }
        else {
            this.#fields.delete(name);
        }
    }
    hasField(name) {
        return this.#fields.has(name);
    }
    getErrors(nameNames) {
        const names = _isUndefined(nameNames) ? [] : _isArray(nameNames) ? nameNames : [nameNames];
        const { errors } = this;
        if (_isEmpty(names)) {
            return errors;
        }
        return _reduce(names, (nameErrors, name) => {
            const error = _get(errors, name);
            if (error) {
                nameErrors[name] = error;
            }
            return nameErrors;
        }, {});
    }
    setErrors(newErrors, emitChange = true) {
        const { errors } = this;
        _forEach(newErrors, (error) => {
            const { name } = error;
            if (name) {
                const oldError = _get(errors, name);
                if (!_isEqual(oldError?.errors, error?.errors)) {
                    _set(errors, name, error);
                    if (emitChange) {
                        this.emitEvent(`fields.${name}.error.change`, errors);
                    }
                }
            }
        });
    }
    resetErrors(errors = {}) {
        this.errors = errors;
    }
    getValues(nameNames) {
        const names = _isUndefined(nameNames) ? [] : _isArray(nameNames) ? nameNames : [nameNames];
        const values = {};
        if (_isEmpty(names)) {
            for (const field of this.fields.values()) {
                if (field.name) {
                    values[field.name] = _get(this.values, field.name);
                }
            }
            return values;
        }
        for (const attr of names) {
            _set(values, attr, _get(this.values, attr));
        }
        return values;
    }
    setValues(newValues, emitChange = true) {
        let changed = false;
        const { values } = this;
        let prevValues;
        _forEach(newValues, (value, name) => {
            const oldValue = _get(values, name);
            if (oldValue !== value) {
                if (!changed) {
                    changed = true;
                    prevValues = _cloneDeep(values);
                }
                const copyValue = _cloneDeep(value);
                _set(values, name, copyValue);
                if (emitChange) {
                    this.emitEvent(`fields.${name}.value.change`, copyValue);
                }
            }
        });
        if (changed) {
            this.emitEvent("shouldUpdate", prevValues, values);
            this.emitEvent("change", newValues, values);
        }
    }
    resetValues(newValues = {}) {
        this.values = newValues;
    }
    release() {
        this.#events?.off();
    }
}
function validateForm(formName, name) {
    return new Promise((resolve, reject) => {
        const form = getAttributiveForm(formName);
        Promise.resolve(_isUndefined(name) ? [] : _isArray(name) ? name : [name])
            .then((names) => form?.findFields((field) => _isEmpty(names) || _includes(names, field.name)))
            .then((items) => items && validateAll(items))
            .then(() => form?.getValues(name))
            .then(resolve)
            .catch((errors) => {
            form?.resetErrors();
            form?.setErrors(errors);
            reject(errors);
        });
    });
}
function defineForm(formName) {
    return class DelegatingForm {
        get name() {
            return formName;
        }
        addEventListener(event, listener) {
            getAttributiveForm(formName)?.addEventListener(event, listener);
        }
        removeEventListener(event, listener) {
            getAttributiveForm(formName)?.removeEventListener(event, listener);
        }
        linkField(name, field, inFormList) {
            if (name && field) {
                getAttributiveForm(formName)?.addField(name, field, inFormList);
            }
        }
        hasField(name) {
            return !!(name && getAttributiveForm(formName)?.hasField(name));
        }
        unlinkField(name, inFormList) {
            if (name) {
                getAttributiveForm(formName)?.removeField(name, inFormList);
            }
        }
        getFields() {
            return toMapValueArray(getAttributiveForm(formName)?.fields);
        }
        findFields(predicate) {
            return getAttributiveForm(formName)?.findFields(predicate);
        }
        setErrors(errors) {
            getAttributiveForm(formName)?.setErrors(errors);
        }
        resetErrors() {
            getAttributiveForm(formName)?.resetErrors();
        }
        getErrors(name) {
            const form = getAttributiveForm(formName);
            return _reduce(form?.getErrors(name), (errors, error) => {
                errors.push(error);
                return errors;
            }, []);
        }
        setDefaultValues(defaultValues, inFormList) {
            const form = getAttributiveForm(formName);
            if (form) {
                const newValues = {};
                _forEach(defaultValues, (value, name) => {
                    if (!inFormList) {
                        _set(form.defaultValues, name, value);
                    }
                    newValues[name] = _get(form.values, name) || value;
                });
                form?.setValues(newValues);
            }
        }
        setValues(newValues, emitChange) {
            getAttributiveForm(formName)?.setValues(newValues, emitChange);
        }
        resetValues(values) { }
        getValues(name) {
            return getAttributiveForm(formName)?.getValues(name);
        }
        validate(name) {
            return validateForm(formName, name);
        }
        reset() {
            const form = getAttributiveForm(formName);
            const newValues = _cloneDeep(form?.defaultValues);
            form?.resetValues(newValues);
            form?.resetErrors();
            form?.emitEvent("change", newValues, newValues);
            form?.emitEvent("reset");
        }
        setFieldsValue(newValues, emitChange) {
            warn("Please use setValues instead of setFieldsValue");
            getAttributiveForm(formName)?.setValues(newValues);
        }
        getFieldsValue(name) {
            warn("Please use getValues instead of getFieldsValue");
            return getAttributiveForm(formName)?.getValues(name);
        }
        validateFields(name) {
            warn("Please use validate instead of validateFields");
            return validateForm(formName, name);
        }
        getAttributiveForm() {
            return getAttributiveForm(this.name);
        }
    };
}
class FormContainer {
    static increaseFormRef(name) {
        const count = containerFormRefs.get(name);
        containerFormRefs.set(name, (count ?? 0) + 1);
    }
    static decreaseFormRef(name) {
        const count = containerFormRefs.get(name);
        containerFormRefs.set(name, (count ?? 0) - 1);
    }
    static hasFormRef(name) {
        const count = containerFormRefs.get(name);
        return !_isUndefined(count) && count > 0;
    }
    getForms() {
        return _toArray(containerForms.values());
    }
    getForm(name) {
        if (!containerForms.has(name)) {
            return undefined;
        }
        FormContainer.increaseFormRef(name);
        const DelegatingForm = defineForm(name);
        return new DelegatingForm();
    }
    hasForm(name) {
        return name && containerForms.has(name);
    }
    newForm(name) {
        if (_isEmpty(name)) {
            return;
        }
        containerForms.set(name, new FormAttributes());
    }
    releaseForm(name) {
        if (_isEmpty(name)) {
            return;
        }
        FormContainer.decreaseFormRef(name);
        if (!FormContainer.hasFormRef(name)) {
            containerForms.get(name)?.release();
            containerForms.delete(name);
        }
    }
}
const formContainer = new FormContainer();
function useConstant(value) {
    const [constant] = useState(value);
    return constant;
}
export default function useForm(name = "", options = {}) {
    const { defaultValues, values } = options;
    const hasForm = formContainer.hasForm(name);
    const immutableHasForm = useConstant(hasForm);
    const nameRef = useToRef(name);
    if (!hasForm && !_isEmpty(name)) {
        formContainer.newForm(name);
    }
    useEffect(() => {
        if (!immutableHasForm && _isPlainObject(defaultValues)) {
            formContainer.getForm(nameRef.current)?.setDefaultValues(defaultValues);
        }
    }, []);
    useEffect(() => {
        if (!immutableHasForm && _isPlainObject(values)) {
            formContainer.getForm(nameRef.current)?.setValues(values);
        }
    }, [nameRef, values]);
    useEffect(() => () => formContainer.releaseForm(name), [name]);
    return useMemo(() => formContainer.getForm(name), [name]);
}
