import { ScrollView, View } from "@tarojs/components";
import { usePageScroll, getEnv } from "@tarojs/taro";
import classNames from "classnames";
import _isNumber from "lodash/isNumber";
import _size from "lodash/size";
import _map from "lodash/map";
import * as React from "react";
import { Children, cloneElement, createRef, isValidElement, useCallback, useMemo, useRef, useState, useEffect, forwardRef, useImperativeHandle, } from "react";
import { isFragment } from "react-is";
import { prefixClassname } from "../styles/index.js";
import { getClientCoordinates, preventDefault } from "../utils/dom/event.js";
import { getRect, getRects, makeRect } from "../utils/dom/rect.js";
import IndexListAnchor from "./index-list-anchor.js";
import IndexListIndex from "./index-list-index.js";
import IndexListSidebar from "./index-list-sidebar.js";
import IndexListContext from "./index-list.context.js";
function childrenIndexBar(children, __children__, parentIndex) {
    Children.forEach(children, (child, index) => {
        if (!isValidElement(child)) {
            return;
        }
        const element = child;
        const elementType = element.type;
        const { key, props } = element;
        const { children: childrenProp } = props;
        if (isFragment(element)) {
            childrenIndexBar(childrenProp, __children__, key ?? index);
            return;
        }
        if (elementType === IndexListAnchor) {
            const { index: indexProp } = props;
            const anchorRef = createRef();
            const { length: arrayedIndex } = __children__.anchorRefs;
            __children__.anchorRefs.push(anchorRef);
            __children__.anchorProps.push(props);
            __children__.children?.push(cloneElement(element, {
                arrayedIndex,
                key: indexProp,
                ref: anchorRef,
            }));
        }
        else {
            __children__.children?.push(cloneElement(element, {
                key: key ?? `${parentIndex}-${index}`,
            }));
        }
    });
}
function useIndexBarChildren(children) {
    return useMemo(() => {
        const __children__ = {
            children: [],
            anchorRefs: [],
            anchorProps: [],
        };
        childrenIndexBar(children, __children__);
        return __children__;
    }, [children]);
}
const IndexList = forwardRef((props, ref) => {
    const { className, sticky = true, stickyOffsetTop = 0, inner = false, delay: delayProp, showSidebar = true, children: childrenProp, onChange, ...restProps } = props;
    const delay = inner ? (_isNumber(delayProp) ? delayProp : 300) : 0;
    const TagElement = inner ? ScrollView : View;
    const { anchorProps, anchorRefs, children } = useIndexBarChildren(childrenProp);
    const scrollTopRef = useRef(0);
    const listRef = useRef();
    const sidebarRef = useRef();
    const listRectRef = useRef(makeRect(0, 0));
    const sidebarRectRef = useRef(makeRect(0, 0));
    const anchorRectsRef = useRef([]);
    const anchorRectsCacheRef = useRef([]);
    const firstAnchorTop = useRef(0);
    const scrolling = useRef(false);
    const [activeAnchor, setActiveAnchor] = useState({});
    const [scrollTop, setScrollTop] = useState();
    const getListRect = useCallback(() => getRect(listRef).then((rect) => ({
        ...rect,
        top: rect.top + scrollTopRef.current,
    })), []);
    const getSidebarRect = useCallback(() => getRect(sidebarRef), []);
    const getAnchorRects = useCallback(() => getRects(listRef, ` .${prefixClassname("index-list__anchor-wrapper")}`), []);
    const scrollToAnchorIndexRef = useRef();
    const getActiveAnchor = useCallback(() => {
        const { current: anchorRects } = anchorRectsRef;
        for (let i = anchorRefs.length - 1; i >= 0; i--) {
            const prevHeight = i > 0 ? anchorRects[i - 1].height : 0;
            const reachTop = sticky ? prevHeight : 0;
            if (reachTop + firstAnchorTop.current >= anchorRects[i].top) {
                return i;
            }
        }
        return -1;
    }, [anchorRefs.length, sticky]);
    const onScroll = useCallback(async () => {
        const arrayedIndex = getActiveAnchor();
        if (arrayedIndex >= 0) {
            setActiveAnchor({
                arrayedIndex,
                index: anchorProps[arrayedIndex].index,
            });
            if (scrollToAnchorIndexRef.current !== arrayedIndex) {
                scrollToAnchorIndexRef.current = arrayedIndex;
                onChange?.(arrayedIndex, anchorProps[arrayedIndex].index);
            }
        }
        else {
            setActiveAnchor({});
        }
    }, [anchorProps, getActiveAnchor]);
    const scrollToAnchor = useCallback((anchorArrayedIndex) => {
        if (anchorArrayedIndex < 0 || scrollToAnchorIndexRef.current === anchorArrayedIndex) {
            return;
        }
        if (inner) {
            setScrollTop(anchorRectsCacheRef.current[anchorArrayedIndex].top - firstAnchorTop.current);
            return;
        }
        scrollToAnchorIndexRef.current = anchorArrayedIndex;
        const { current: matchInstance } = anchorRefs[anchorArrayedIndex];
        matchInstance?.scrollIntoView(scrollTopRef.current);
    }, [anchorRefs]);
    const getAnchorArrayedIndex = useCallback((event) => {
        const { current: sidebarRect } = sidebarRectRef;
        const touch = getClientCoordinates(event);
        const sidebarLength = _size(anchorRefs);
        const itemHeight = sidebarRect.height / sidebarLength;
        let index = Math.floor((touch.clientY - sidebarRect.top) / itemHeight);
        if (index < 0) {
            index = 0;
        }
        else if (index > sidebarLength - 1) {
            index = sidebarLength - 1;
        }
        return index;
    }, [anchorRefs]);
    const scrollToEvent = useCallback((event) => {
        const arrayedIndex = getAnchorArrayedIndex(event);
        scrollToAnchor(arrayedIndex);
    }, [getAnchorArrayedIndex, scrollToAnchor]);
    const onSidebarClick = useCallback((event) => scrollToEvent(event), [scrollToEvent]);
    const onTouchStart = useCallback(() => {
        scrolling.current = true;
    }, [scrolling]);
    const onTouchMove = useCallback((event) => {
        preventDefault(event);
        scrollToEvent(event);
    }, [scrollToEvent]);
    const onTouchStop = useCallback(() => (scrollToAnchorIndexRef.current = undefined), []);
    const getRectAll = (init) => {
        setTimeout(() => {
            Promise.all([getListRect(), getSidebarRect(), getAnchorRects()])
                .then((rects) => {
                const [listRect, sidebarRect, anchorRects] = rects;
                listRectRef.current = listRect;
                sidebarRectRef.current = sidebarRect;
                anchorRectsRef.current = anchorRects;
                if (init && inner) {
                    anchorRectsCacheRef.current = anchorRects;
                    firstAnchorTop.current = anchorRects[0]?.top || 0;
                }
            })
                .then(onScroll);
        }, _isNumber(delay) ? delay + 1 : 0);
    };
    useEffect(() => {
        getRectAll(true);
    }, []);
    usePageScroll(({ scrollTop }) => {
        if (inner) {
            return;
        }
        scrollTopRef.current = scrollTop;
        getRectAll();
    });
    const onPageScroll = (e) => {
        const { scrollTop } = e.detail;
        scrollTopRef.current = scrollTop;
        getRectAll();
        if (scrolling.current) {
            return;
        }
        getEnv() === "WEB" && setScrollTop(scrollTop);
    };
    const sidebarIndexes = useMemo(() => _map(anchorProps, (anchorProp) => (React.createElement(IndexListIndex, { key: anchorProp.index, index: anchorProp.index }))), [anchorProps]);
    useImperativeHandle(ref, () => {
        return {
            scrollTo(index) {
                scrollToAnchor(index);
            },
        };
    });
    return (React.createElement(IndexListContext.Provider, { value: {
            sticky,
            stickyOffsetTop,
            inner,
            activeIndex: activeAnchor?.index ?? -1,
            activeArrayedIndex: activeAnchor?.arrayedIndex ?? -1,
            getListRect: () => listRectRef.current,
            getAnchorRects: () => anchorRectsRef.current,
            getFirstAnchorTop: () => firstAnchorTop.current,
        } },
        React.createElement(View, { className: classNames(prefixClassname("index-list"), {
                inner: inner,
            }, className) },
            showSidebar && (React.createElement(IndexListSidebar, { ref: sidebarRef, inner: inner, onClick: onSidebarClick, onTouchStart: onTouchStart, onTouchMove: onTouchMove, onTouchCancel: onTouchStop, onTouchEnd: onTouchStop }, sidebarIndexes)),
            React.createElement(TagElement, { scrollY: true, ref: listRef, className: classNames({
                    [prefixClassname("index-list_scroll")]: inner,
                }), scrollTop: scrollTop, scrollWithAnimation: true, scrollAnchoring: true, onScroll: onPageScroll, onTouchStart: () => {
                    scrolling.current = false;
                }, ...restProps }, children))));
});
export default IndexList;
