import { useUncontrolled } from "@taroify/hooks/index.js";
import { View } from "@tarojs/components";
import classNames from "classnames";
import _isArray from "lodash/isArray";
import _isEmpty from "lodash/isEmpty";
import _isObject from "lodash/isObject";
import _map from "lodash/map";
import * as React from "react";
import { Children, useCallback, useRef, useMemo } from "react";
import Loading from "../loading/index.js";
import { prefixClassname } from "../styles/index.js";
import { useRefs, useToRef } from "../utils/state.js";
import { isElementOf } from "../utils/validate/index.js";
import { unitToPx } from "../utils/format/unit.js";
import PickerColumns from "./picker-columns.js";
import PickerToolbar from "./picker-toolbar.js";
import PickerTitle from "./picker-title.js";
import PickerButton from "./picker-button.js";
import { PickerColumn } from "./picker.composition.js";
import PickerContext from "./picker.context.js";
import PickerOption from "./picker-option.js";
import { DEFAULT_OPTION_HEIGHT, DEFAULT_SIBLING_COUNT, validPickerColumn, } from "./picker.shared.js";
function usePickerValues(value) {
    return _isArray(value) ? value : [value];
}
const defaultFieldNames = {
    label: "label",
    value: "value",
};
function Picker(props) {
    const { defaultValue, value: valueProp, className, loading, readonly, title, confirmText = "确认", cancelText = "取消", columns: columnsProp, columnsFieldNames: columnsFieldNamesProp, siblingCount = DEFAULT_SIBLING_COUNT, optionHeight: optionHeightProp, children: childrenProp, onChange, onCancel, onConfirm, ...restProps } = props;
    const { getRefs: getColumnRefs, setRefs: setColumnRefs, clearRefs: clearColumnRefs, } = useRefs();
    const { value, setValue } = useUncontrolled({ value: valueProp, defaultValue });
    const multiValueRef = useToRef(_isArray(value));
    const values = usePickerValues(value);
    const fieldNames = useMemo(() => {
        if (!_isEmpty(columnsFieldNamesProp) && _isObject(columnsFieldNamesProp)) {
            return Object.assign({ ...defaultFieldNames }, columnsFieldNamesProp);
        }
        return defaultFieldNames;
    }, [columnsFieldNamesProp]);
    const children = useMemo(() => {
        let toolbar = null;
        const __children__ = [];
        const columns = [];
        Children.toArray(childrenProp).forEach((child) => {
            if (isElementOf(child, PickerColumn)) {
                const element = child;
                columns.push(element);
            }
            else if (isElementOf(child, PickerColumns)) {
                const element = child;
                columns.push(...element.props.children);
            }
            else if (isElementOf(child, PickerToolbar)) {
                toolbar = child;
            }
            else {
                __children__.push(child);
            }
        });
        if (!toolbar && (title || confirmText || cancelText)) {
            toolbar = (React.createElement(PickerToolbar, { key: "-2" },
                React.createElement(PickerButton, { type: "cancel" }, cancelText),
                React.createElement(PickerTitle, null, title),
                React.createElement(PickerButton, { type: "confirm" }, confirmText)));
        }
        if (_isEmpty(columns) && columnsProp && columnsProp.length > 0) {
            ;
            (Array.isArray(columnsProp[0]) ? columnsProp : [columnsProp]).forEach((col, i) => {
                columns.push(React.createElement(PickerColumn, { key: i }, col.map((data, ii) => (React.createElement(PickerOption, { key: ii, label: data[fieldNames.label], value: data[fieldNames.value], disabled: data.disabled })))));
            });
        }
        __children__.unshift(React.createElement(PickerColumns, { key: "-1", children: columns }));
        __children__.unshift(toolbar);
        return __children__;
    }, [childrenProp, title, confirmText, cancelText, columnsProp, fieldNames]);
    const valueOptionsRef = useRef([]);
    const optionHeight = useMemo(() => (optionHeightProp ? unitToPx(optionHeightProp) : DEFAULT_OPTION_HEIGHT), [optionHeightProp]);
    const setValueOptions = useCallback((option, unverifiedColumn) => {
        const column = validPickerColumn(unverifiedColumn);
        if (option && column) {
            const { index: columnIndex } = column;
            valueOptionsRef.current[columnIndex] = option;
        }
    }, []);
    const handleChange = useCallback((values, option, column) => {
        setValue(values);
        onChange?.(values, option, column);
    }, [onChange, setValue]);
    const stopMomentum = useCallback(() => getColumnRefs()
        .filter((columnRef) => columnRef.current)
        .forEach((columnRef) => columnRef.current.stopMomentum()), [getColumnRefs]);
    const handleAction = (action) => () => {
        stopMomentum();
        action?.(_map(valueOptionsRef.current, ({ value }) => value), _map(valueOptionsRef.current, (valueOption) => ({ ...valueOption })));
    };
    const getValueOptions = useCallback(() => valueOptionsRef.current, []);
    const isMultiValue = useCallback(() => multiValueRef.current, [multiValueRef]);
    return (React.createElement(PickerContext.Provider, { value: {
            readonly,
            siblingCount,
            optionHeight,
            values,
            getValueOptions,
            isMultiValue,
            setValueOptions,
            clearColumnRefs,
            setColumnRefs,
            onChange: handleChange,
            onConfirm: handleAction(onConfirm),
            onCancel: handleAction(onCancel),
        } },
        React.createElement(View, { className: classNames(prefixClassname("picker"), className), ...restProps },
            loading && React.createElement(Loading, { className: prefixClassname("picker__loading") }),
            children)));
}
export default Picker;
