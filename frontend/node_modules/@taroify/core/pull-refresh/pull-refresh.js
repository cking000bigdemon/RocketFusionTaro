import { View } from "@tarojs/components";
import { nextTick } from "@tarojs/taro";
import classNames from "classnames";
import * as React from "react";
import { Children, isValidElement, useCallback, useEffect, useMemo, useRef, useState, } from "react";
import Loading from "../loading/index.js";
import { prefixClassname } from "../styles/index.js";
import { preventDefault } from "../utils/dom/event.js";
import { addUnitPx } from "../utils/format/unit.js";
import { usePreviousRef, useToRef } from "../utils/state.js";
import { useTouch } from "../utils/touch.js";
import { throttle } from "../utils/lodash-polyfill.js";
import { PullRefreshCompleted, PullRefreshLoading, PullRefreshLoosing, PullRefreshPulling, } from "./pull-refresh-children.js";
import PullRefreshContext from "./pull-refresh.context.js";
var PullRefreshStatus;
(function (PullRefreshStatus) {
    PullRefreshStatus["Awaiting"] = "awaiting";
    PullRefreshStatus["Pulling"] = "pulling";
    PullRefreshStatus["Loosing"] = "loosing";
    PullRefreshStatus["Loading"] = "loading";
    PullRefreshStatus["Completed"] = "completed";
})(PullRefreshStatus || (PullRefreshStatus = {}));
const TEXT_STATUS = ["pulling", "loosing", "success"];
function usePullRefreshChildren(children) {
    return useMemo(() => {
        const __children__ = {
            content: [],
        };
        Children.forEach(children, (child) => {
            if (isValidElement(child)) {
                const element = child;
                const elementType = element.type;
                if (elementType === PullRefreshPulling) {
                    __children__.pulling = element;
                }
                else if (elementType === PullRefreshLoosing) {
                    __children__.loosing = element;
                }
                else if (elementType === PullRefreshLoading) {
                    __children__.loading = element;
                }
                else if (elementType === PullRefreshCompleted) {
                    __children__.completed = element;
                }
                else {
                    __children__.content?.push(child);
                }
            }
            else {
                __children__.content?.push(child);
            }
        });
        return __children__;
    }, [children]);
}
function getCompletedProps(node) {
    if (isValidElement(node)) {
        const element = node;
        return element.props;
    }
    return {};
}
function PullRefresh(props) {
    const { className, loading, disabled = false, headHeight = 50, reachTop: reachTopProp = true, pullDistance: pullDistanceProp, duration: durationProp = 300, children: childrenProp, onRefresh, ...restProps } = props;
    const children = usePullRefreshChildren(childrenProp);
    const { completed: completedElement, content } = children;
    const { duration: completedDuration = 500 } = getCompletedProps(completedElement);
    const statusRef = useRef(PullRefreshStatus.Awaiting);
    const [distance, setDistance] = useState(0);
    const reachTopPreviousRef = usePreviousRef(reachTopProp);
    const reachTopRef = useToRef(reachTopProp);
    const durationRef = useRef(0);
    const touch = useTouch();
    function resetDuration() {
        durationRef.current = 0;
    }
    const isTouchable = useCallback(() => PullRefreshStatus.Loading !== statusRef.current &&
        PullRefreshStatus.Completed !== statusRef.current &&
        !disabled, [disabled]);
    const easeDistance = useCallback((distance) => {
        const pullDistance = +(pullDistanceProp || headHeight);
        let easedDistance = distance;
        if (easedDistance > pullDistance) {
            if (easedDistance < pullDistance * 2) {
                easedDistance = pullDistance + (easedDistance - pullDistance) / 2;
            }
            else {
                easedDistance = pullDistance * 1.5 + (easedDistance - pullDistance * 2) / 4;
            }
        }
        return Math.round(easedDistance);
    }, [headHeight, pullDistanceProp]);
    const checkPosition = useCallback((event) => {
        if (reachTopRef.current) {
            resetDuration();
            touch.start(event);
        }
    }, [reachTopRef, touch]);
    const onTouchStart = useCallback((event) => {
        if (isTouchable()) {
            checkPosition(event);
        }
    }, [checkPosition, isTouchable]);
    const updateStatus = useCallback((distance, isLoading) => {
        const pullDistance = +(pullDistanceProp || headHeight);
        if (isLoading) {
            statusRef.current = PullRefreshStatus.Loading;
        }
        else if (distance === 0) {
            statusRef.current = PullRefreshStatus.Awaiting;
        }
        else if (distance < pullDistance) {
            statusRef.current = PullRefreshStatus.Pulling;
        }
        else {
            statusRef.current = PullRefreshStatus.Loosing;
        }
        setDistance(distance);
    }, [headHeight, pullDistanceProp]);
    const onTouchMove = useMemo(() => throttle((event) => {
        if (isTouchable()) {
            if (!reachTopPreviousRef.current) {
                checkPosition(event);
            }
            const { deltaY } = touch;
            touch.move(event);
            if (reachTopRef.current && deltaY >= 0 && touch.isVertical()) {
                preventDefault(event);
                updateStatus(easeDistance(deltaY));
            }
        }
    }, 16.7), [
        checkPosition,
        easeDistance,
        isTouchable,
        reachTopPreviousRef,
        reachTopRef,
        touch,
        updateStatus,
    ]);
    const onTouchEnd = useCallback(() => {
        if (reachTopRef.current && isTouchable()) {
            durationRef.current = durationProp;
            if (statusRef.current === PullRefreshStatus.Loosing) {
                updateStatus(headHeight, true);
                onRefresh?.();
            }
            else {
                updateStatus(0);
            }
        }
    }, [durationProp, headHeight, isTouchable, onRefresh, reachTopRef, updateStatus]);
    const showCompleted = useCallback(() => {
        statusRef.current = PullRefreshStatus.Completed;
        resetDuration();
        setTimeout(() => nextTick(() => updateStatus(0)), +completedDuration);
    }, [completedDuration, updateStatus]);
    const contextValue = useMemo(() => ({ distance, onTouchStart, onTouchMove, onTouchEnd }), [distance, onTouchStart, onTouchMove, onTouchEnd]);
    useEffect(() => {
        if (loading) {
            updateStatus(headHeight, true);
        }
    }, [headHeight, loading, updateStatus]);
    useEffect(() => {
        if (!loading && !isTouchable() && !completedElement) {
            durationRef.current = durationProp;
            updateStatus(0, false);
        }
    }, [completedElement, durationProp, isTouchable, loading, updateStatus]);
    useEffect(() => {
        if (!loading && completedElement) {
            showCompleted();
        }
    }, [completedElement, loading, showCompleted]);
    const getStatusText = useCallback(() => {
        if (statusRef.current === PullRefreshStatus.Pulling) {
            return "下拉即可刷新...";
        }
        if (statusRef.current === PullRefreshStatus.Loosing) {
            return "释放即可刷新...";
        }
        if (statusRef.current === PullRefreshStatus.Loading) {
            return "加载中...";
        }
        return "";
    }, []);
    const renderStatus = useCallback(() => {
        const statusSlot = children[statusRef.current];
        if (statusSlot) {
            return statusSlot;
        }
        const nodes = [];
        if (TEXT_STATUS.includes(statusRef.current)) {
            nodes.push(React.createElement(View, { key: "text", className: prefixClassname("pull-refresh__text"), children: getStatusText() }));
        }
        if (statusRef.current === PullRefreshStatus.Loading) {
            nodes.push(React.createElement(Loading, { key: "loading", className: prefixClassname("pull-refresh__loading"), children: getStatusText() }));
        }
        return nodes;
    }, [children, getStatusText]);
    const trackStyle = {
        transitionDuration: `${durationRef.current}ms`,
        transform: distance ? `translate3d(0,${addUnitPx(distance)}, 0)` : "",
    };
    const headStyle = useMemo(() => {
        if (headHeight !== 50) {
            return {
                height: addUnitPx(headHeight),
            };
        }
    }, [headHeight]);
    return (React.createElement(PullRefreshContext.Provider, { value: contextValue },
        React.createElement(View, { className: classNames(prefixClassname("pull-refresh"), className), ...restProps },
            React.createElement(View, { className: prefixClassname("pull-refresh__track"), style: trackStyle, onTouchStart: onTouchStart, onTouchMove: onTouchMove, onTouchEnd: onTouchEnd, onTouchCancel: onTouchEnd },
                React.createElement(View, { className: prefixClassname("pull-refresh__head"), style: headStyle, children: renderStatus() }),
                content))));
}
export default PullRefresh;
