import { useRef, useMemo, forwardRef, useImperativeHandle } from "react";
import * as React from "react";
import { getEnv } from "@tarojs/taro";
import { View, Canvas } from "@tarojs/components";
import cls from "classnames";
import { prefixClassname } from "../styles/index.js";
import { getRect } from "../utils/dom/rect.js";
import { preventDefault } from "../utils/dom/event.js";
import { useCanvas } from "../hooks/index.js";
let _canvasIdx = 0;
const Signature = forwardRef(function Signature(props, ref) {
    const { type = "png", lineWidth = 3, penColor = "#000", backgroundColor, className, canvasId: canvasIdProp, onStart, onSigning, onEnd, ...rest } = props;
    const wrapRef = useRef(null);
    const canvasRectRef = useRef();
    const canvasId = useMemo(() => (canvasIdProp ? canvasIdProp : `taroify-canvas${_canvasIdx++}`), []);
    const [canvas, ctx] = useCanvas(canvasId, wrapRef, {
        async onLoaded(_, _ctx) {
            canvasRectRef.current = await getRect(wrapRef);
            setCanvasBgColor(_ctx);
        },
    });
    const emptyRef = useRef(true);
    const touchStartHandler = async () => {
        if (ctx) {
            ctx.beginPath();
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = penColor;
            canvasRectRef.current = await getRect(wrapRef);
            onStart?.();
        }
    };
    const touchMoveHandler = (event) => {
        if (ctx) {
            preventDefault(event);
            emptyRef.current = false;
            const touch = event.touches[0];
            const env = getEnv();
            let mouseX = touch.x;
            let mouseY = touch.y;
            if (env === "WEB") {
                mouseX = touch.clientX - (canvasRectRef.current?.left || 0);
                mouseY = touch.clientY - (canvasRectRef.current?.top || 0);
            }
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.lineTo(mouseX, mouseY);
            ctx.stroke();
            onSigning?.();
        }
    };
    const touchEndHandler = (event) => {
        if (ctx) {
            event.preventDefault();
            onEnd?.();
        }
    };
    const setCanvasBgColor = (ctxParam) => {
        if (ctxParam) {
            ctxParam.clearRect(0, 0, canvasRectRef.current?.width, canvasRectRef.current?.height);
            if (backgroundColor) {
                ctxParam.fillStyle = backgroundColor;
                ctxParam.fillRect(0, 0, canvasRectRef.current?.width, canvasRectRef.current?.height);
            }
        }
    };
    const getImage = () => {
        if (canvas) {
            return {
                image: emptyRef.current
                    ? ""
                    : {
                        jpg: () => canvas.toDataURL("image/jpeg", 0.8),
                        jpeg: () => canvas.toDataURL("image/jpeg", 0.8),
                    }[type]?.() || canvas.toDataURL(`image/${type}`),
                canvas,
            };
        }
        return {
            image: "",
            canvas: null,
        };
    };
    const clearHandler = () => {
        if (ctx) {
            emptyRef.current = true;
            setCanvasBgColor(ctx);
        }
    };
    useImperativeHandle(ref, () => {
        return {
            getImage,
            clear: clearHandler,
        };
    });
    return (React.createElement(View, { className: cls(prefixClassname("signature"), className), ...rest },
        React.createElement(View, { className: prefixClassname("signature__content") },
            React.createElement(Canvas, { id: canvasId, canvasId: canvasId, ref: wrapRef, disableScroll: true, type: "2d", onTouchStart: touchStartHandler, onTouchMove: touchMoveHandler, onTouchEnd: touchEndHandler }))));
});
export default Signature;
