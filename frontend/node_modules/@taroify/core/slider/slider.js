import { useUncontrolled } from "@taroify/hooks/index.js";
import { View } from "@tarojs/components";
import classNames from "classnames";
import _clamp from "lodash/clamp";
import * as React from "react";
import { Children, cloneElement, isValidElement, useCallback, useMemo, useRef, } from "react";
import { prefixClassname } from "../styles/index.js";
import { getClientCoordinates, preventDefault, stopPropagation } from "../utils/dom/event.js";
import { getRect } from "../utils/dom/rect.js";
import { addNumber } from "../utils/format/number.js";
import { addUnitPx } from "../utils/format/unit.js";
import { useTouch } from "../utils/touch.js";
import SliderThumb from "./slider-thumb.js";
import SliderContext from "./slider.context.js";
var SliderDragStatus;
(function (SliderDragStatus) {
    SliderDragStatus["Start"] = "start";
    SliderDragStatus["Dragging"] = "dragging";
    SliderDragStatus["End"] = "end";
})(SliderDragStatus || (SliderDragStatus = {}));
function useSliderChildren(children, range) {
    return useMemo(() => {
        const __children__ = {
            thumb1: undefined,
            thumb2: undefined,
        };
        Children.forEach(children, (child) => {
            if (!isValidElement(child)) {
                return;
            }
            const element = child;
            if (__children__.thumb1 === undefined) {
                __children__.thumb1 = element;
            }
            else if (__children__.thumb2 === undefined) {
                __children__.thumb2 = element;
            }
        });
        __children__.thumb1 = __children__.thumb1 ?? React.createElement(SliderThumb, null);
        if (range) {
            __children__.thumb1 = cloneElement(__children__.thumb1, {
                key: 0,
                index: 0,
            });
            __children__.thumb2 = __children__.thumb2 ?? React.createElement(SliderThumb, null);
            __children__.thumb2 = cloneElement(__children__.thumb2, {
                key: 1,
                index: 1,
            });
        }
        else {
            __children__.thumb1 = cloneElement(__children__.thumb1, {
                index: undefined,
            });
        }
        return __children__;
    }, [children, range]);
}
function Slider(props) {
    const { className, style = {}, defaultValue, value: valueProp = undefined, min = 0, max = 100, step = 1, range = false, size, orientation = "horizontal", disabled = false, children, onClick, onChange: onChangeProp, ...restProps } = props;
    const { value = 0, setValue } = useUncontrolled({
        defaultValue,
        value: valueProp,
        onChange: onChangeProp,
    });
    const { thumb1, thumb2 } = useSliderChildren(children, range);
    const vertical = orientation === "vertical";
    const rootRef = useRef();
    const dragStatusRef = useRef();
    const startValueRef = useRef(0);
    const currentValueRef = useRef(0);
    const buttonIndexRef = useRef();
    const touch = useTouch();
    const scope = useMemo(() => Number(max) - Number(min), [max, min]);
    const isRange = useCallback((val) => range && Array.isArray(val), [range]);
    const calcMainAxis = useCallback(() => {
        if (isRange(value)) {
            return `${((value[1] - value[0]) * 100) / scope}%`;
        }
        return `${((value - Number(min)) * 100) / scope}%`;
    }, [isRange, min, scope, value]);
    const calcOffset = useCallback(() => {
        if (isRange(value)) {
            return `${((value[0] - Number(min)) * 100) / scope}%`;
        }
        return "0%";
    }, [isRange, min, scope, value]);
    const wrapperStyle = useMemo(() => {
        const crossAxis = vertical ? "width" : "height";
        return {
            ...style,
            [crossAxis]: addUnitPx(size) ?? "",
        };
    }, [size, style, vertical]);
    const trackStyle = useMemo(() => {
        const mainAxis = vertical ? "height" : "width";
        return {
            [mainAxis]: calcMainAxis(),
            left: vertical ? "" : calcOffset(),
            top: vertical ? calcOffset() : "",
            transition: dragStatusRef.current ? "none" : "",
        };
    }, [calcMainAxis, calcOffset, vertical]);
    const formatValue = (value) => {
        const valueCache = _clamp(value, min, max);
        const diff = Math.round((valueCache - min) / step) * step;
        return addNumber(min, diff);
    };
    const isSameValue = (newValue, oldValue) => JSON.stringify(newValue) === JSON.stringify(oldValue);
    const handleOverlap = (value) => {
        if (value[0] > value[1]) {
            return value.slice(0).reverse();
        }
        return value;
    };
    const updateValue = (newValue) => {
        let newValueCache = newValue;
        if (isRange(newValueCache)) {
            newValueCache = handleOverlap(newValueCache).map(formatValue);
        }
        else {
            newValueCache = formatValue(newValueCache);
        }
        if (!isSameValue(newValueCache, value)) {
            setValue(newValueCache);
        }
    };
    const handleClick = (event) => {
        onClick?.(event);
        stopPropagation(event);
        if (disabled) {
            return;
        }
        getRect(rootRef).then((rect) => {
            const { clientX, clientY } = getClientCoordinates(event);
            const delta = vertical ? clientY - rect.top : clientX - rect.left;
            const total = vertical ? rect.height : rect.width;
            const newValue = Number(min) + (delta / total) * scope;
            if (isRange(value)) {
                const [left, right] = value;
                const middle = (left + right) / 2;
                if (newValue <= middle) {
                    updateValue([newValue, right]);
                }
                else {
                    updateValue([left, newValue]);
                }
            }
            else {
                updateValue(newValue);
            }
        });
    };
    const onTouchStart = (event, index) => {
        if (typeof index === "number") {
            buttonIndexRef.current = index;
        }
        if (disabled) {
            return;
        }
        touch.start(event);
        currentValueRef.current = value;
        if (isRange(currentValueRef.current)) {
            startValueRef.current = currentValueRef.current.map(formatValue);
        }
        else {
            startValueRef.current = formatValue(currentValueRef.current);
        }
        dragStatusRef.current = SliderDragStatus.Start;
    };
    const onTouchMove = (event) => {
        if (disabled) {
            return;
        }
        preventDefault(event, true);
        touch.move(event);
        dragStatusRef.current = SliderDragStatus.Dragging;
        getRect(rootRef).then((rect) => {
            const delta = vertical ? touch.deltaY : touch.deltaX;
            const total = vertical ? rect.height : rect.width;
            const diff = (delta / total) * scope;
            if (isRange(startValueRef.current)) {
                ;
                currentValueRef.current[buttonIndexRef.current] =
                    startValueRef.current[buttonIndexRef.current] + diff;
            }
            else {
                currentValueRef.current = startValueRef.current + diff;
            }
            updateValue(currentValueRef.current);
        });
    };
    const onTouchEnd = () => {
        if (disabled) {
            return;
        }
        if (dragStatusRef.current === SliderDragStatus.Dragging) {
            updateValue(currentValueRef.current);
        }
        dragStatusRef.current = SliderDragStatus.End;
    };
    return (React.createElement(View, { ref: rootRef, className: classNames(classNames(prefixClassname("slider"), {
            [prefixClassname("slider--vertical")]: vertical,
            [prefixClassname("slider--disabled")]: disabled,
        }), className), style: wrapperStyle, onClick: handleClick, ...restProps },
        React.createElement(SliderContext.Provider, { value: {
                onTouchStart,
                onTouchMove,
                onTouchEnd,
            } },
            React.createElement(View, { className: prefixClassname("slider__track"), style: trackStyle }, range ? [thumb1, thumb2] : thumb1))));
}
export default Slider;
