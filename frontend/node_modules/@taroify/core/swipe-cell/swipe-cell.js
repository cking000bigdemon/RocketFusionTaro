import { useUncontrolled } from "@taroify/hooks/index.js";
import { View } from "@tarojs/components";
import classNames from "classnames";
import _clamp from "lodash/clamp";
import * as React from "react";
import { Children, cloneElement, isValidElement, useCallback, useMemo, useRef, useState, } from "react";
import { useFunctionInterceptor, useRenderedEffect } from "../hooks/index.js";
import { prefixClassname } from "../styles/index.js";
import { inBrowser } from "../utils/base.js";
import { preventDefault } from "../utils/dom/event.js";
import { getRect } from "../utils/dom/rect.js";
import { addUnitPx } from "../utils/format/unit.js";
import { fulfillPromise } from "../utils/promisify.js";
import { useTouch } from "../utils/touch.js";
import SwipeCellActions from "./swipe-cell-actions.js";
function useSwipeCellChildren(children, leftRef, rightRef, createClickHandler) {
    return useMemo(() => {
        const __children__ = {
            left: undefined,
            content: [],
            right: undefined,
        };
        Children.forEach(children, (child) => {
            if (isValidElement(child)) {
                const element = child;
                const elementType = element.type;
                if (elementType === SwipeCellActions) {
                    const { props } = element;
                    const { side, onClick } = props;
                    if (side === "left") {
                        __children__.left = cloneElement(element, {
                            ...props,
                            ref: leftRef,
                            onClick: (event) => {
                                onClick?.(event);
                                createClickHandler?.("left", true)(event);
                            },
                        });
                    }
                    else if (side === "right") {
                        __children__.right = cloneElement(element, {
                            ...props,
                            ref: rightRef,
                            onClick: (event) => {
                                onClick?.(event);
                                createClickHandler?.("right", true)(event);
                            },
                        });
                    }
                }
                else {
                    __children__.content?.push(element);
                }
            }
            else {
                __children__.content?.push(child);
            }
        });
        return __children__;
    }, [children, createClickHandler, leftRef, rightRef]);
}
function SwipeCell(props) {
    const { className, defaultOpen, open: openProp, disabled, stopPropagation, beforeClose: beforeCloseProp, onOpen, onClose, onClick: onClickProp, onTouchStart, onTouchMove, onTouchEnd, onTouchCancel, children: childrenProp, catchMove, ...restProps } = props;
    const beforeClose = useFunctionInterceptor(beforeCloseProp);
    const { value } = useUncontrolled({
        defaultValue: defaultOpen,
        value: openProp,
    });
    const openedRef = useRef(false);
    const lockClickRef = useRef(false);
    const startOffsetRef = useRef(0);
    const rootRef = useRef();
    const leftRef = useRef();
    const rightRef = useRef();
    const leftWidthRef = useRef(0);
    const rightWidthRef = useRef(0);
    const positionRef = useRef("outside");
    const draggingRef = useRef(false);
    const [offset, setOffset] = useState(0);
    const touch = useTouch();
    const updateLeftWidth = () => getRect(leftRef)
        .then(({ width }) => width ?? 0)
        .then((leftWidth) => (leftWidthRef.current = leftWidth));
    const updateRightWidth = () => getRect(rightRef)
        .then(({ width }) => width ?? 0)
        .then((rightWidth) => (rightWidthRef.current = rightWidth));
    const open = useCallback((side, emitOpen = true) => {
        openedRef.current = true;
        setOffset(side === "left" ? leftWidthRef.current : -rightWidthRef.current);
        if (emitOpen) {
            onOpen?.(side);
        }
    }, [onOpen]);
    const close = useCallback((position, emitClose = true) => {
        openedRef.current = false;
        setOffset(0);
        if (emitClose) {
            onClose?.(position);
        }
    }, [onClose]);
    const toggle = useCallback((side) => {
        const THRESHOLD = 0.15;
        const threshold = openedRef.current ? 1 - THRESHOLD : THRESHOLD;
        const width = side === "left" ? leftWidthRef.current : rightWidthRef.current;
        const offsetAbs = Math.abs(offset);
        if (width && offsetAbs > width * threshold) {
            open(side);
        }
        else {
            close(side);
        }
    }, [close, offset, open]);
    const handleTouchStart = (event) => {
        if (disabled) {
            return;
        }
        fulfillPromise(Promise.all([updateLeftWidth(), updateRightWidth()]));
        startOffsetRef.current = offset;
        touch.start(event);
    };
    const handleTouchMove = useCallback(async (event) => {
        if (disabled) {
            return;
        }
        const { deltaX } = touch;
        touch.move(event);
        if (touch.isHorizontal()) {
            const offset = _clamp(deltaX + startOffsetRef.current, -rightWidthRef.current, leftWidthRef.current);
            if (!draggingRef.current) {
                draggingRef.current = true;
            }
            lockClickRef.current = true;
            const isEdge = !openedRef.current || deltaX * startOffsetRef.current < 0;
            if (isEdge) {
                preventDefault(event, stopPropagation);
            }
            positionRef.current = offset > 0 ? "left" : "right";
            setOffset(offset);
        }
    }, [disabled, stopPropagation, touch]);
    const handleTouchEnd = () => {
        if (disabled) {
            return;
        }
        draggingRef.current = false;
        toggle(positionRef.current);
        setTimeout(() => {
            lockClickRef.current = false;
        }, 0);
    };
    const onClick = useCallback((position = "outside") => {
        if (openedRef.current && !lockClickRef.current) {
            beforeClose(position).then(() => close(position));
        }
    }, [beforeClose, close]);
    const createClickHandler = useCallback((position, stop) => (event) => {
        if (stop) {
            event.stopPropagation();
        }
        onClick(position);
    }, [onClick]);
    const { left, content, right } = useSwipeCellChildren(childrenProp, leftRef, rightRef, createClickHandler);
    const valueChange = (side) => {
        if (side === "left" || side === "right") {
            new Promise((resolve) => {
                if (inBrowser) {
                    setTimeout(() => {
                        if (side === "left") {
                            updateLeftWidth().then(resolve);
                        }
                        else {
                            updateRightWidth().then(resolve);
                        }
                    }, 150);
                }
                else {
                    resolve(true);
                }
            }).then(() => {
                draggingRef.current = false;
                open(side, false);
            });
        }
        else {
            close("outside", false);
        }
    };
    useRenderedEffect(() => {
        if (!inBrowser) {
            fulfillPromise(updateLeftWidth());
        }
    }, [left]);
    useRenderedEffect(() => {
        if (!inBrowser) {
            fulfillPromise(updateRightWidth());
        }
    }, [right]);
    useRenderedEffect(() => valueChange(value), [value]);
    return (React.createElement(View, { catchMove: catchMove, ref: rootRef, className: classNames(prefixClassname("swipe-cell"), className), onTouchStart: (event) => {
            onTouchStart?.(event);
            handleTouchStart(event);
        }, onTouchMove: (event) => {
            onTouchMove?.(event);
            handleTouchMove?.(event);
        }, onTouchEnd: (event) => {
            onTouchEnd?.(event);
            handleTouchEnd();
        }, onTouchCancel: (event) => {
            onTouchCancel?.(event);
            handleTouchEnd();
        }, onClick: (event) => {
            onClickProp?.(event);
            createClickHandler("cell")(event);
        }, ...restProps },
        React.createElement(View, { className: prefixClassname("swipe-cell__wrapper"), style: {
                transform: `translate3d(${addUnitPx(offset)}, 0, 0)`,
                ...(inBrowser ? { transitionDuration: draggingRef.current ? "0s" : ".3s" } : {}),
            } },
            left,
            content,
            right)));
}
export default SwipeCell;
