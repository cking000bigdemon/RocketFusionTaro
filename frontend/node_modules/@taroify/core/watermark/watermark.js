import * as React from "react";
import { useMemo, useRef, useState, useEffect } from "react";
import { Canvas, View } from "@tarojs/components";
import { getEnv, getWindowInfo } from "@tarojs/taro";
import cls from "classnames";
import { useCanvas } from "../hooks/index.js";
import { prefixClassname } from "../styles/index.js";
let _canvasIdx = 0;
function Watermark(props) {
    const { gapX = 20, gapY = 20, image: imageProp = "", width: widthProp = 80, height: heightProp = 80, rotate = -11, zIndex, opacity = 1, fullPage = false, content = "", textSize = 20, textColor = "#dcdee0", } = props;
    const width = useMemo(() => widthProp + gapX, [widthProp, gapX]);
    const height = useMemo(() => heightProp + gapY, [heightProp, gapY]);
    const canvasId = useMemo(() => `taroify-watermark${_canvasIdx++}`, []);
    const canvasRef = useRef(null);
    const [watermarkUrl, setWatermarkUrl] = useState("");
    const [canvas, ctx, loaded] = useCanvas(canvasId, canvasRef);
    useEffect(() => {
        if (canvas && ctx && loaded) {
            if (imageProp) {
                const image = getEnv() === "WEB" ? new Image() : canvas.createImage();
                image.crossOrigin = "anonymous";
                image.referrerPolicy = "no-referrer";
                image.onload = () => {
                    canvas.width = image.width + gapX;
                    canvas.height = image.height + gapY;
                    ctx.globalAlpha = opacity;
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate((rotate * Math.PI) / 180);
                    ctx.translate(-canvas.width / 2, -canvas.height / 2);
                    ctx?.drawImage(image, gapX, gapY);
                    setWatermarkUrl(canvas.toDataURL());
                };
                image.src = imageProp;
            }
            else {
                const ratio = getWindowInfo().pixelRatio || 1;
                canvas.width = width * ratio;
                canvas.height = height * ratio;
                ctx.scale(ratio, ratio);
                ctx.globalAlpha = opacity;
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.rotate((rotate * Math.PI) / 180);
                ctx.translate(-canvas.width / 2, -canvas.height / 2);
                ctx.textAlign = "left";
                ctx.font = `${textSize}px sans-serif`;
                ctx.fillStyle = textColor;
                ctx.textBaseline = "top";
                ctx.fillText(content, gapX, gapY);
                setWatermarkUrl(canvas.toDataURL());
            }
        }
    }, [gapX, gapY, imageProp, width, height, rotate, opacity, content, textSize, textColor, loaded]);
    const style = useMemo(() => ({
        zIndex,
        backgroundImage: `url(${watermarkUrl})`,
        backgroundSize: `${width}px ${height}px`,
    }), [zIndex, watermarkUrl]);
    return (React.createElement(View, { className: cls({
            [prefixClassname("watermark")]: true,
            [prefixClassname("watermark--full")]: fullPage,
        }), style: style },
        React.createElement(View, { className: prefixClassname("watermark__wrapper") },
            React.createElement(Canvas, { type: "2d", id: canvasId, canvasId: canvasId, ref: canvasRef }))));
}
export default Watermark;
