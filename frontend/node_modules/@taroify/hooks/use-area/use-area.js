import _map from "lodash/map";
import _padEnd from "lodash/padEnd";
import _forEach from "lodash/forEach";
import _startsWith from "lodash/startsWith";
import _first from "lodash/first";
import _get from "lodash/get";
import _find from "lodash/find";
import _isArray from "lodash/isArray";
import _isEqual from "lodash/isEqual";
import { useCallback, useEffect, useMemo, useRef } from "react";
import useForceUpdate from "../use-force-update/index.js";
import useToRef from "../use-to-ref/index.js";
import { getAreaData } from "./area.shared.js";
const DEFAULT_AREA_DATA = {
    province_list: {},
    city_list: {},
    county_list: {},
};
function defaultFormatter(list) {
    let index = 0;
    return _map(list, (label, value) => ({ index: index++, value, label, children: label }));
}
function padAreaPrefixToValue(prefix) {
    return _padEnd(prefix, 6, "0");
}
function filterAreaList(list, prefix) {
    const newRecord = {};
    _forEach(list, (name, code) => {
        if (_startsWith(code, prefix)) {
            newRecord[code] = name;
        }
    });
    return newRecord;
}
function getAreaPrefix(value, depth) {
    return value?.substring(0, depth * 2);
}
function getFirstDivisionPrefix(divisions, depth) {
    return getAreaPrefix(_first(divisions)?.value, depth);
}
function getAreaPrefixDivision(prefixes, divisions, values, index) {
    const value = _get(values, index);
    const depth = index + 1;
    const valuePrefix = getAreaPrefix(value, depth);
    if (index === 0) {
        prefixes[index] = valuePrefix ?? getFirstDivisionPrefix(divisions, depth);
    }
    else {
        const valueSuperiorPrefix = value?.substring(0, index * 2);
        const superiorPrefix = prefixes[index - 1];
        if (superiorPrefix !== valueSuperiorPrefix) {
            prefixes[index] = getFirstDivisionPrefix(divisions, depth);
        }
        else {
            prefixes[index] = valuePrefix;
        }
    }
    const valuePad = padAreaPrefixToValue(prefixes[index]);
    return _find(divisions, (division) => division.value === valuePad);
}
function doAreaSelect(options) {
    const { unverifiedValues, data: dataPrimitive, depth, formatter } = options;
    const data = getAreaData(dataPrimitive, depth);
    const prefixes = [];
    const columns = [];
    const nextValueOptions = [];
    const nextValues = [];
    _forEach(data, (record, index) => {
        let divisions;
        if (index === 0) {
            divisions = formatter?.(record);
        }
        else {
            divisions = formatter?.(filterAreaList(record, prefixes[index - 1]));
        }
        const division = getAreaPrefixDivision(prefixes, divisions, unverifiedValues, index);
        nextValueOptions[index] = division;
        nextValues[index] = division.value;
        columns[index] = {
            index,
            children: divisions,
        };
    });
    return {
        columns,
        values: nextValues,
        valueOptions: nextValueOptions,
    };
}
function useAreaSelect(options) {
    const { unverifiedValues, data, depth, formatter } = options;
    return useMemo(() => doAreaSelect({
        unverifiedValues,
        data,
        depth,
        formatter,
    }), [data, depth, formatter, unverifiedValues]);
}
function useAreaValues(value) {
    return useMemo(() => (_isArray(value) ? value : [value]), [value]);
}
export default function useArea(unverifiedValue = [], options = {}) {
    const { data = DEFAULT_AREA_DATA, depth = 3, formatter = defaultFormatter } = options;
    const unverifiedValueRef = useRef(unverifiedValue);
    const forceUpdate = useForceUpdate();
    const unverifiedValues = useAreaValues(unverifiedValueRef.current);
    const { columns, values, valueOptions } = useAreaSelect({
        unverifiedValues,
        data,
        depth,
        formatter,
    });
    const valuesRef = useToRef(values);
    const valueOptionsRef = useToRef(valueOptions);
    const getValues = useCallback(() => valuesRef.current, [valuesRef]);
    const getValueOptions = useCallback(() => valueOptionsRef.current, [valueOptionsRef]);
    const setValues = useCallback((newValues) => {
        unverifiedValueRef.current = newValues;
        forceUpdate();
    }, [forceUpdate]);
    useEffect(() => {
        if (!_isEqual(valuesRef.current, unverifiedValue)) {
            setValues(unverifiedValue);
        }
    }, [setValues, unverifiedValue, valuesRef]);
    return useMemo(() => ({
        columns,
        values,
        valueOptions,
        getValues,
        getValueOptions,
        setValues,
    }), [columns, getValueOptions, getValues, setValues, valueOptions, values]);
}
